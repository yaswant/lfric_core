!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief     Tests for mesh_tools/source/support/gen_planar_mod.F90
!
!> @details   [1]  Constructor can be called with program default args.
!>            [2]  Constructor fails with invalid args.
!>            [3]  Type generates mesh with appropriate dimensions for args.
!>            [4]  Mesh contains correct values at fixed points for fixed args.
!>            [5]  Mesh connectivity has correct dimensions.
!>            [6]  Mesh connectivity has correct values at fixed points.
!>            [7]  Mesh coords have correct values at fixed points.
!>
module gen_planar_mod_test_spherical

  use constants_mod,                  only: i_def, r_def, &
                                            str_def, str_longlong, str_short
  use gen_planar_mod,                 only: gen_planar_type
  use global_mesh_map_collection_mod, only: global_mesh_map_collection_type
  use global_mesh_map_mod,            only: global_mesh_map_type

  use funit

  use reference_element_mod,          only: reference_cube_type, &
                                            W, S, E, N

  use mesh_config_mod, only: coord_sys_ll,       &
                             geometry_spherical, &
                             topology_non_periodic

  implicit none

  private
  public :: gen_planar_test_constructor, &
            getParameters,               &
            test_gen

  integer(i_def), parameter :: mdi = -9999

  @testParameter
  type, public, extends(AbstractTestParameter) :: config_type
    integer,     public :: x_size
    logical,     public :: x_periodic
    integer,     public :: y_size
    logical,     public :: y_periodic

    real(r_def), public :: domain_size(2)
    real(r_def), public :: domain_centre(2)

    logical, public :: rotate_mesh
    real(r_def), public :: target_north_pole(2)
    real(r_def), public :: target_null_island(2)

    integer, public :: topology
    integer, public :: coord_sys

    character(:), public, allocatable :: topology_string
    character(:), public, allocatable :: coord_sys_string

    integer, public :: nodes
    integer, public :: edges
    integer, public :: faces

    integer, public, allocatable :: nodes_on_face(:, :)
    integer, public, allocatable :: faces_on_face(:, :)
    integer, public, allocatable :: edges_on_face(:, :)
    integer, public, allocatable :: nodes_on_edge(:, :)

    real, public, allocatable :: coords(:, :)
    real, public, allocatable :: face_coords(:, :)

    integer, public :: number_of_maps

  contains
    procedure, public :: toString
  end type config_type

  @TestCase(testParameters={getParameters()}, constructor=gen_planar_test_constructor)
  type, extends(ParameterizedTestCase), public :: gen_planar_test_type
    private
    integer     :: x_size
    logical     :: x_periodic
    integer     :: y_size
    logical     :: y_periodic

    real(r_def) :: domain_size(2)
    real(r_def) :: domain_centre(2)

    logical, public :: rotate_mesh
    real(r_def), public :: target_north_pole(2)
    real(r_def), public :: target_null_island(2)

    integer, public :: topology
    integer, public :: coord_sys

    character(:), public, allocatable :: topology_string
    character(:), public, allocatable :: coord_sys_string

    integer, public :: nodes
    integer, public :: edges
    integer, public :: faces

    integer, public, allocatable :: nodes_on_face(:, :)
    integer, public, allocatable :: faces_on_face(:, :)
    integer, public, allocatable :: edges_on_face(:, :)
    integer, public, allocatable :: nodes_on_edge(:, :)

    real, public, allocatable :: coords(:, :)
    real, public, allocatable :: face_coords(:, :)

    integer, public :: number_of_maps

  contains

  end type gen_planar_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'

  character(str_def), parameter :: target_mesh_names(1) = ['unit_test_target']

  real(r_def),        parameter :: eps = 1E-09_r_def

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function toString( this ) result(string)
    implicit none
    class(config_type), intent(in) :: this
    character(:), allocatable :: string
    character(str_def) :: buffer
    write(                                                        &
      buffer,                                                     &
      '(I0, "x", I0, " ", L1, "x", L1, " ", L1)'                  &
    ) this%x_size, this%y_size, this%x_periodic, this%y_periodic, &
      this%rotate_mesh
    string = trim(buffer)
  end function toString

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function gen_planar_test_constructor( testParameter ) result(gen_planar_test)

    implicit none

    type(config_type), intent(in) :: testParameter
    type(gen_planar_test_type) :: gen_planar_test

    gen_planar_test%x_size     = testParameter%x_size
    gen_planar_test%x_periodic = testParameter%x_periodic
    gen_planar_test%y_size     = testParameter%y_size
    gen_planar_test%y_periodic = testParameter%y_periodic

    gen_planar_test%domain_size   = testParameter%domain_size
    gen_planar_test%domain_centre = testParameter%domain_centre

    gen_planar_test%rotate_mesh = testParameter%rotate_mesh
    gen_planar_test%target_north_pole = testParameter%target_north_pole
    gen_planar_test%target_null_island = testParameter%target_null_island

    gen_planar_test%topology = testParameter%topology
    gen_planar_test%coord_sys = testParameter%coord_sys

    gen_planar_test%topology_string = testParameter%topology_string
    gen_planar_test%coord_sys_string = testParameter%coord_sys_string

    gen_planar_test%nodes = testParameter%nodes
    gen_planar_test%edges = testParameter%edges
    gen_planar_test%faces = testParameter%faces

    gen_planar_test%nodes_on_face = testParameter%nodes_on_face
    gen_planar_test%faces_on_face = testParameter%faces_on_face
    gen_planar_test%edges_on_face = testParameter%edges_on_face
    gen_planar_test%nodes_on_edge = testParameter%nodes_on_edge

    gen_planar_test%coords = testParameter%coords
    gen_planar_test%face_coords = testParameter%face_coords

    gen_planar_test%number_of_maps = testParameter%number_of_maps

  end function gen_planar_test_constructor

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function getParameters() result(parameters)
    implicit none
    type(config_type) :: parameters(3)
    parameters = [                                                 &
      ! 1x1
      config_type(                                                 &
        x_size=1, x_periodic=.false.,                              &
        y_size=1, y_periodic=.false.,                              &
        domain_size=(/50.0_r_def, 10.0_r_def/),                    &
        domain_centre=(/0.0_r_def, 0.0_r_def/),                    &
        rotate_mesh=.false.,                                       &
        target_north_pole=(/0.0_r_def, 0.0_r_def/),                &
        target_null_island=(/0.0_r_def, 0.0_r_def/),               &
        topology=topology_non_periodic, coord_sys=coord_sys_ll,    &
        topology_string='non_periodic', coord_sys_string='ll',     &
        nodes=4, edges=4, faces=1,                                 &
        nodes_on_face=reshape( (/1, 2, 3, 4/), (/4, 1/) ),         &
        faces_on_face=reshape( (/mdi, mdi, mdi, mdi/), (/4, 1/) ), &
        edges_on_face=reshape( (/1, 2, 3, 4/), (/4, 1/) ),         &
        nodes_on_edge=reshape( (/4, 1,   1, 2,                     &
                                 3, 2,   4, 3/), (/2, 4/) ),       &
        coords=reshape(      (/-25.0_r_def, -5.0_r_def,                 &
                                25.0_r_def, -5.0_r_def,                 &
                                25.0_r_def,  5.0_r_def,                 &
                               -25.0_r_def,  5.0_r_def/), (/2, 4/) ),   &
        face_coords=reshape( (/  0.0_r_def,  0.0_r_def/), (/2, 1/) ),   &
        number_of_maps=0                                                &
      ),                                                                &
      ! 1x1 rotated south
      config_type(                                                 &
        x_size=1, x_periodic=.false.,                              &
        y_size=1, y_periodic=.false.,                              &
        domain_size=(/180.0_r_def, 10.0_r_def/),                   &
        domain_centre=(/90.0_r_def, 0.0_r_def/),                   &
        rotate_mesh=.true.,                                        &
        target_north_pole=(/0.0_r_def, 85.0_r_def/),               &
        target_null_island=(/180.0_r_def, 5.0_r_def/),             &
        topology=topology_non_periodic, coord_sys=coord_sys_ll,    &
        topology_string='non_periodic', coord_sys_string='ll',     &
        nodes=4, edges=4, faces=1,                                 &
        nodes_on_face=reshape( (/1, 2, 3, 4/), (/4, 1/) ),         &
        faces_on_face=reshape( (/mdi, mdi, mdi, mdi/), (/4, 1/) ), &
        edges_on_face=reshape( (/1, 2, 3, 4/), (/4, 1/) ),         &
        nodes_on_edge=reshape( (/4, 1,   1, 2,                     &
                                 3, 2,   4, 3/), (/2, 4/) ),       &
        coords=reshape(      (/  0.0_r_def, -10.0_r_def,           &
                              180.0_r_def,   0.0_r_def,            &
                              180.0_r_def,  10.0_r_def,            &
                              0.0_r_def,   0.0_r_def/), (/2, 4/) ),&
        face_coords=reshape((/90.0_r_def,0.0_r_def/), (/2, 1/) ),  &
        number_of_maps=0                                           &
      ),                                                           &
      ! 1x1 rotated north
      config_type(                                                 &
        x_size=1, x_periodic=.false.,                              &
        y_size=1, y_periodic=.false.,                              &
        domain_size=(/180.0_r_def, 10.0_r_def/),                   &
        domain_centre=(/90.0_r_def, 0.0_r_def/),                   &
        rotate_mesh=.true.,                                        &
        target_north_pole=(/180.0_r_def, 85.0_r_def/),             &
        target_null_island=(/0.0_r_def, 5.0_r_def/),               &
        topology=topology_non_periodic, coord_sys=coord_sys_ll,    &
        topology_string='non_periodic', coord_sys_string='ll',     &
        nodes=4, edges=4, faces=1,                                 &
        nodes_on_face=reshape( (/1, 2, 3, 4/), (/4, 1/) ),         &
        faces_on_face=reshape( (/mdi, mdi, mdi, mdi/), (/4, 1/) ), &
        edges_on_face=reshape( (/1, 2, 3, 4/), (/4, 1/) ),         &
        nodes_on_edge=reshape( (/4, 1,   1, 2,                     &
                                 3, 2,   4, 3/), (/2, 4/) ),       &
        coords=reshape( (/  0.0_r_def,   0.0_r_def,                &
                          180.0_r_def, -10.0_r_def,                &
                          180.0_r_def,   0.0_r_def,                &
                            0.0_r_def,  10.0_r_def/), (/2, 4/) ),  &
        face_coords=reshape( (/90.0_r_def, 0.0_r_def/), (/2, 1/) ),&
        number_of_maps=0                                           &
      )                                                            &
    ]
  end function getParameters

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_gen( context )

    implicit none

    class(gen_planar_test_type), intent(inout) :: context

    integer(i_def), parameter :: npanels = 1

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    integer(i_def), pointer  :: edge_cell_ids(:) => null()

    integer(i_def) :: faces_on_face(4, context%x_size * context%y_size)
    integer(i_def) :: nodes_on_face(4, context%x_size * context%y_size)
    integer(i_def) :: edges_on_face(4, context%x_size * context%y_size)
    integer(i_def) :: nodes_on_edge(2, context%edges)

    real(r_def) :: face_coords(2, context%x_size * context%y_size)
    real(r_def) :: coords(2, context%nodes)
    real(r_def) :: domain_extents(2,4)

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str
    character(str_longlong) :: expected_test_str
    character(str_def)      :: domain_size_str
    character(str_def)      :: domain_centre_str
    character(str_def)      :: north_pole_str, null_island_str
    character(str_short)    :: x_str, y_str

    character(str_def) :: test_coord_units_x
    character(str_def) :: test_coord_units_y

    integer(i_def) :: test_npanels
    integer(i_def) :: test_edge_cells_x, test_edge_cells_y
    integer(i_def) :: test_nmaps
    integer(i_def) :: target_edge_cells_x, target_edge_cells_y

    character(str_def), allocatable :: test_target_mesh_names(:)

    integer(i_def), allocatable :: test_maps_edge_cells_x(:)
    integer(i_def), allocatable :: test_maps_edge_cells_y(:)

    type(global_mesh_map_collection_type), pointer :: global_mesh_maps => null()
    type(global_mesh_map_type),            pointer :: global_mesh_map  => null()

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element,              &
                                mesh_name=mesh_name,                         &
                                geometry=geometry_spherical,                 &
                                topology=context%topology,                   &
                                coord_sys=context%coord_sys,                 &
                                edge_cells_x=context%x_size,                 &
                                edge_cells_y=context%y_size,                 &
                                fine_mesh_edge_cells_x=context%x_size,       &
                                fine_mesh_edge_cells_y=context%y_size,       &
                                periodic_x=context%x_periodic,               &
                                periodic_y=context%y_periodic,               &
                                domain_size=context%domain_size,             &
                                domain_centre=context%domain_centre,         &
                                rotate_mesh=context%rotate_mesh,             &
                                target_north_pole=context%target_north_pole, &
                                target_null_island=context%target_null_island )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1),            &
                                geometry           = test_str(2),            &
                                topology           = test_str(3),            &
                                coord_sys          = test_str(4),            &
                                constructor_inputs = big_test_str,           &
                                edge_cells_x       = test_edge_cells_x,      &
                                edge_cells_y       = test_edge_cells_y,      &
                                nmaps              = test_nmaps,             &
                                target_mesh_names  = test_target_mesh_names, &
                                maps_edge_cells_x  = test_maps_edge_cells_x, &
                                maps_edge_cells_y  = test_maps_edge_cells_y )

    @assertEqual( mesh_name,             trim(test_str(1)) )
    @assertEqual( 'spherical',           trim(test_str(2)) )
    @assertEqual( context%topology_string,  trim(test_str(3)) )
    @assertEqual( context%coord_sys_string, trim(test_str(4)) )

    @assertEqual( context%x_size, test_edge_cells_x )
    @assertEqual( context%y_size, test_edge_cells_y )
    @assertEqual( context%number_of_maps, test_nmaps )


    write(x_str, '(F10.2)') context%domain_size(1)
    write(y_str, '(F10.2)') context%domain_size(2)
    write(domain_size_str, '(A)') ';domain_size=['//          &
                                  trim(adjustl(x_str))//','// &
                                  trim(adjustl(y_str))//']'

    write(x_str, '(F10.2)') context%domain_centre(1)
    write(y_str, '(F10.2)') context%domain_centre(2)
    write(domain_centre_str, '(A)') ';domain_centre=['//        &
                                    trim(adjustl(x_str))//','// &
                                    trim(adjustl(y_str))//']'

    if (context%rotate_mesh) then
      write(x_str, '(F10.2)') context%target_north_pole(1)
      write(y_str, '(F10.2)') context%target_north_pole(2)
      write(north_pole_str, '(A)') ';north_pole=['//            &
                                    trim(adjustl(x_str))//','// &
                                    trim(adjustl(y_str))//']'

      write(x_str, '(F10.2)') context%target_null_island(1)
      write(y_str, '(F10.2)') context%target_null_island(2)
      write(null_island_str, '(A)') ';null_island=['//           &
                                     trim(adjustl(x_str))//','// &
                                     trim(adjustl(y_str))//']'

      write( expected_test_str, '( 2(A,I0), 2(A,L1), 2A, (A,L1), 2A)' ) &
          "geometry=spherical;topology="//context%topology_string//     &
          ";coord_sys="//context%coord_sys_string//                     &
          ";edge_cells_x=", context%x_size,                             &
          ";edge_cells_y=", context%y_size,                             &
          ";periodic_x=", context%x_periodic,                           &
          ";periodic_y=", context%y_periodic,                           &
          trim(domain_size_str), trim(domain_centre_str),               &
          ";rotate_mesh=", context%rotate_mesh,                         &
          trim(north_pole_str), trim(null_island_str)

    else

      write( expected_test_str, '( 2(A,I0), 2(A,L1), 2A, (A,L1) )' ) &
          "geometry=spherical;topology="//context%topology_string//  &
          ";coord_sys="//context%coord_sys_string//                  &
          ";edge_cells_x=", context%x_size,                          &
          ";edge_cells_y=", context%y_size,                          &
          ";periodic_x=", context%x_periodic,                        &
          ";periodic_y=", context%y_periodic,                        &
          trim(domain_size_str), trim(domain_centre_str),            &
          ";rotate_mesh=", context%rotate_mesh

    end if

    @assertEqual( trim(expected_test_str), trim(big_test_str) )

    test_npanels = mesh_gen%get_number_of_panels()
    @assertEqual( npanels, test_npanels )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, &
                                  nodes_per_face,      &
                                  edges_per_face,      &
                                  nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(context%nodes, nodes, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(context%edges, edges, "Incorrect number of edges for mesh dimensions")
    @assertEqual(context%faces, faces, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(4, edges_per_face, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(2, nodes_per_edge, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(4, max_faces_per_node, "Max number of faces around a node does not correspond to quad mesh")

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( nodes_on_face, edges_on_face, &
                                    faces_on_face, nodes_on_edge )

    @assertEqual(context%nodes_on_face, nodes_on_face, "Incorrect vertex sequence on faces.")
    @assertEqual(context%faces_on_face, faces_on_face, "Incorrect faces_on_face connectivity.")
    @assertEqual(context%edges_on_face, edges_on_face, "Incorrect edges_on_face connectivity.")
    @assertEqual(context%nodes_on_edge, nodes_on_edge, "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( coords,             &
                                   face_coords,        &
                                   domain_extents,     &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    @assertEqual( context%coords, coords, 0.005_r_def, "Incorrect mesh coordinates." )
    @assertEqual( context%face_coords, face_coords, 0.005_r_def, "Incorrect cell coordinates." )
    @assertEqual( 'degrees_east', trim(test_coord_units_x) )
    @assertEqual( 'degrees_north', trim(test_coord_units_y) )

    ! I don't think these are ever used.
    !
    if (context%number_of_maps > 0) then
      @assertEqual( context%number_of_maps, size(test_target_mesh_names) )
      @assertEqual( trim(target_mesh_names(1)), trim(test_target_mesh_names(1)) )
      @assertEqual( context%number_of_maps, size(test_maps_edge_cells_x ) )
      @assertEqual( context%number_of_maps, size(test_maps_edge_cells_y ) )
      @assertEqual( target_edge_cells_x, test_maps_edge_cells_x )
      @assertEqual( target_edge_cells_y, test_maps_edge_cells_y )

      ! Retrieve global mesh maps
      nullify(global_mesh_maps)
      global_mesh_maps => mesh_gen%get_global_mesh_maps()
      @assertAssociated(global_mesh_maps)

      ! Although no actual global mesh maps have written to file maps have been
      ! created for global meshes in the order they are virtually listed,
      ! i.e. mesh "unit_test", id=1
      !      mesh "unit_test_target", id=2
      nullify(global_mesh_map)
      global_mesh_map  => global_mesh_maps%get_global_mesh_map(1,2)

      @assertAssociated( global_mesh_map )
      @assertEqual( 20, global_mesh_map%get_nsource_cells() )
      @assertEqual( 6,  global_mesh_map%get_ntarget_cells_per_source_cell() )
      @assertEqual( 1,  global_mesh_map%get_source_id() )
      @assertEqual( 2,  global_mesh_map%get_target_id() )
      @assertEqual( 2,  global_mesh_map%get_ntarget_cells_per_source_x() )
      @assertEqual( 3,  global_mesh_map%get_ntarget_cells_per_source_y() )
    end if

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_gen

end module gen_planar_mod_test_spherical
