!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief     Tests for src/dynamo/ugrid/genbiperiodic_mod.F90
!>
!> @details   [1]  Constructor can be called with program default args.
!>            [2]  Constructor fails with invalid args.
!>            [3]  Type generates mesh with appropriate dimensions for args.
!>            [4]  Mesh contains correct values at fixed points for fixed args.
!>            [5]  Mesh connectivity has correct dimensions.
!>            [6]  Mesh connectivity has correct values at fixed points.
!>            [7]  Mesh coords have correct values at fixed points.
!>
module genbiperiodic_mod_test

  use constants_mod,                  only: i_def, r_def, str_def, str_long
  use genbiperiodic_mod,              only: genbiperiodic_type
  use global_mesh_map_collection_mod, only: global_mesh_map_collection_type
  use global_mesh_map_mod,            only: global_mesh_map_type

  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: genbiperiodic_test_type
    private
    integer(i_def), allocatable :: faces_on_face(:,:)
    integer(i_def), allocatable :: nodes_on_face(:,:)
    integer(i_def), allocatable :: edges_on_face(:,:)
    integer(i_def), allocatable :: nodes_on_edge(:,:)
    real(r_def),    allocatable :: coords(:,:)
    real(r_def),    allocatable :: face_coords(:,:)
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type genbiperiodic_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'
  integer(i_def),     parameter :: edge_cells_x = 5
  integer(i_def),     parameter :: edge_cells_y = 4
  real(r_def),        parameter :: domain_x = 30000.0
  real(r_def),        parameter :: domain_y = 8000.0
  integer(i_def),     parameter :: npanels = 1
  integer(i_def),     parameter :: nmaps = 1
  integer(i_def),     parameter :: ncells = 20

  character(str_def), parameter :: target_mesh_names(nmaps) = ['unit_test_target']
  integer(i_def),     parameter :: target_edge_cells_x(nmaps) = [10]
  integer(i_def),     parameter :: target_edge_cells_y(nmaps) = [12]

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(genbiperiodic_test_type), intent(inout) :: this

    allocate( this%faces_on_face(4, edge_cells_x*edge_cells_y) )
    allocate( this%nodes_on_face(4, edge_cells_x*edge_cells_y) )
    allocate( this%edges_on_face(4, edge_cells_x*edge_cells_y) )
    allocate( this%nodes_on_edge(2, 2*edge_cells_x*edge_cells_y) )
    allocate( this%coords(2, edge_cells_x*edge_cells_y) )
    allocate( this%face_coords(2, edge_cells_x*edge_cells_y) )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(genbiperiodic_test_type), intent(inout) :: this

    deallocate( this%faces_on_face )
    deallocate( this%nodes_on_face )
    deallocate( this%edges_on_face )
    deallocate( this%nodes_on_edge )
    deallocate( this%coords )
    deallocate( this%face_coords )

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all( this )

    implicit none

    class(genbiperiodic_test_type), intent(inout) :: this

    type(genbiperiodic_type) :: bpgen
    integer(i_def)           :: nodes, edges, faces
    integer(i_def)           :: nodes_per_face, edges_per_face
    integer(i_def)           :: nodes_per_edge, max_faces_per_node

    character(str_def)  :: test_mesh_name
    character(str_def)  :: test_mesh_class
    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    character(str_long) :: test_constructor_inputs
    integer(i_def)      :: test_npanels
    integer(i_def)      :: test_edge_cells_x
    integer(i_def)      :: test_edge_cells_y
    integer(i_def)      :: test_nmaps

    character(str_def), allocatable :: test_maps_mesh_names(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_x(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_y(:)

    type(global_mesh_map_collection_type), pointer :: global_mesh_maps => null()
    type(global_mesh_map_type),            pointer :: global_mesh_map  => null()

    bpgen = genbiperiodic_type( mesh_name,                  &
                                edge_cells_x, edge_cells_y, &
                                domain_x, domain_y,         &
                                target_mesh_names,          &
                                target_edge_cells_x,        &
                                target_edge_cells_y )

    ! Test metadata retrieval
    call bpgen%get_metadata( mesh_name           = test_mesh_name,          &
                             mesh_class          = test_mesh_class,         &
                             constructor_inputs  = test_constructor_inputs, &
                             npanels             = test_npanels,            &
                             edge_cells_x        = test_edge_cells_x,       &
                             edge_cells_y        = test_edge_cells_y,       &
                             nmaps               = test_nmaps,              &
                             maps_mesh_names     = test_maps_mesh_names,    &
                             maps_edge_cells_x   = test_maps_edge_cells_x,  &
                             maps_edge_cells_y   = test_maps_edge_cells_y )

    @assertEqual( mesh_name, trim(test_mesh_name) )
    @assertEqual( 'plane',   trim(test_mesh_class) )
    @assertEqual( "edge_cells_x=5;edge_cells_y=4;domain_x=30000.00;domain_y=8000.00;target_mesh_names=['unit_test_target'];target_edge_cells_x=[10];target_edge_cells_y=[12]", trim(test_constructor_inputs) )
    @assertEqual( npanels, test_npanels )
    @assertEqual( edge_cells_x, test_edge_cells_x )
    @assertEqual( edge_cells_y, test_edge_cells_y )
    @assertEqual( nmaps, test_nmaps )
    @assertEqual( trim(target_mesh_names(1)), trim(test_maps_mesh_names(1)) )
    @assertEqual( target_edge_cells_x, test_maps_edge_cells_x )
    @assertEqual( target_edge_cells_y, test_maps_edge_cells_y )
    @assertEqual( nmaps, size(test_maps_mesh_names   ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_x ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_y ) )

    ! Generate the mesh and connectivity
    call bpgen%generate()

    ! Retrieve calculated dimensions
    call bpgen%get_dimensions(nodes, edges, faces, nodes_per_face, &
                              edges_per_face, nodes_per_edge)

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, edge_cells_x*edge_cells_y, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 2*edge_cells_x*edge_cells_y, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, edge_cells_x*edge_cells_y, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")

    ! Retrieve mesh connectivity
    call bpgen%get_connectivity(this%nodes_on_face, this%nodes_on_edge, &
                                this%edges_on_face, this%faces_on_face)

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1),  (/  1, 2,  3,  4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,20), (/ 10, 4, 16, 20 /), "Incorrect vertex sequence on faces.")

    ! Mesh connectivity is complete
    @assertTrue(minval(this%faces_on_face, 2) /= 0, "Incomplete faces_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1),  (/  5,  6,  2, 16 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,11), (/ 15, 16, 12,  6 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1),  (/  1,  2,  3,  4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,20), (/ 40, 15, 36, 35 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1),  (/  4,  1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,40), (/ 20, 10 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call bpgen%get_coordinates( this%coords,        &
                                this%face_coords,   &
                                test_coord_units_x, &
                                test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1)  == (/ -12000.0_r_def,  2000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,20) == (/  12000.0_r_def, -2000.0_r_def /), "Incorrect mesh coordinates.")

    ! Cell coordinates have expected values at certain points
    @assertTrue(this%face_coords(:,1)  == (/  -9000.0_r_def,  3000.0_r_def /), "Incorrect cell coordinates.")
    @assertTrue(this%face_coords(:,20) == (/  15000.0_r_def, -3000.0_r_def /), "Incorrect cell coordinates.")

    @assertTrue( trim(test_coord_units_x) == 'm')
    @assertTrue( trim(test_coord_units_y) == 'm')

    ! Retrieve global mesh maps
    nullify(global_mesh_maps)
    global_mesh_maps => bpgen%get_global_mesh_maps()
    @assertAssociated(global_mesh_maps)

    ! Although no actual global mesh maps have written to file maps have been created
    ! for global meshes in the order they are virtually listed,
    ! i.e. mesh "unit_test", id=1
    !      mesh "unit_test_target", id=2
    nullify(global_mesh_map)
    global_mesh_map  => global_mesh_maps%get_global_mesh_map(1,2)

    @assertAssociated( global_mesh_map )
    @assertEqual( ncells, global_mesh_map%get_nsource_cells() )
    @assertEqual( 6,  global_mesh_map%get_ntarget_cells_per_source_cell() )
    @assertEqual( 1,  global_mesh_map%get_source_id() )
    @assertEqual( 2,  global_mesh_map%get_target_id() )

  end subroutine test_all

end module genbiperiodic_mod_test
