!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
module gencube_ps_mod_test

  use constants_mod,                  only: i_def, r_def, str_def, str_long
  use gencube_ps_mod,                 only: gencube_ps_type
  use global_mesh_map_collection_mod, only: global_mesh_map_collection_type
  use global_mesh_map_mod,            only: global_mesh_map_type

  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: gencube_ps_test_type
    private
    integer(i_def), allocatable :: faces_on_face(:,:)
    integer(i_def), allocatable :: nodes_on_face(:,:)
    integer(i_def), allocatable :: edges_on_face(:,:)
    integer(i_def), allocatable :: nodes_on_edge(:,:)
    real(r_def),    allocatable :: coords(:,:)
    real(r_def),    allocatable :: face_coords(:,:)
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type gencube_ps_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'

  integer(i_def),     parameter :: edge_cells = 3
  integer(i_def),     parameter :: nsmooth = 1
  integer(i_def),     parameter :: npanels = 6
  integer(i_def),     parameter :: nmaps = 1
  integer(i_def),     parameter :: ncells = 54

  character(str_def), parameter :: target_mesh_names(nmaps) = ['unit_test_target']
  integer(i_def),     parameter :: target_edge_cells(nmaps) = [6]

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

    allocate( this%faces_on_face(4, 6*edge_cells*edge_cells) )
    allocate( this%nodes_on_face(4, 6*edge_cells*edge_cells) )
    allocate( this%edges_on_face(4, 6*edge_cells*edge_cells) )
    allocate( this%nodes_on_edge(2, 2*6*edge_cells*edge_cells) )
    allocate( this%coords(2, 6*edge_cells*edge_cells+2) )
    allocate( this%face_coords(2, 6*edge_cells*edge_cells) )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

    deallocate( this%faces_on_face )
    deallocate( this%nodes_on_face )
    deallocate( this%edges_on_face )
    deallocate( this%nodes_on_edge )
    deallocate( this%coords )
    deallocate( this%face_coords )

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

    type(gencube_ps_type)  :: csgen
    integer(i_def)         :: nodes, edges, faces
    integer(i_def)         :: nodes_per_face, edges_per_face
    integer(i_def)         :: nodes_per_edge, max_faces_per_node

    character(str_def)  :: test_mesh_name
    character(str_def)  :: test_mesh_class
    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    character(str_long) :: test_constructor_inputs
    integer(i_def)      :: test_npanels
    integer(i_def)      :: test_edge_cells_x
    integer(i_def)      :: test_edge_cells_y
    integer(i_def)      :: test_nmaps

    character(str_def), allocatable :: test_maps_mesh_names(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_x(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_y(:)

    type(global_mesh_map_collection_type), pointer :: global_mesh_maps => null()
    type(global_mesh_map_type),            pointer :: global_mesh_map  => null()

    real(r_def), parameter :: eps = 1E-09_r_def


    csgen = gencube_ps_type( mesh_name, edge_cells, nsmooth,      &
                             target_mesh_names=target_mesh_names, &
                             target_edge_cells=target_edge_cells )


    ! Test metadata retrieval
    call csgen%get_metadata( mesh_name          = test_mesh_name,          &
                             mesh_class         = test_mesh_class,         &
                             constructor_inputs = test_constructor_inputs, &
                             npanels            = test_npanels,            &
                             edge_cells_x       = test_edge_cells_x,       &
                             edge_cells_y       = test_edge_cells_y,       &
                             nmaps              = test_nmaps,              &
                             maps_mesh_names    = test_maps_mesh_names,    &
                             maps_edge_cells_x  = test_maps_edge_cells_x,  &
                             maps_edge_cells_y  = test_maps_edge_cells_y )


    @assertEqual( mesh_name, trim(test_mesh_name) )
    @assertEqual( 'sphere', trim(test_mesh_class) )
    @assertEqual( "edge_cells=3;smooth_passes=1;target_mesh_names=['unit_test_target'];target_edge_cells=[6]", trim(test_constructor_inputs) )
    @assertEqual( npanels, test_npanels )
    @assertEqual( edge_cells, test_edge_cells_x )
    @assertEqual( edge_cells, test_edge_cells_y )
    @assertEqual( nmaps, test_nmaps )
    @assertEqual( trim(target_mesh_names(1)), trim(test_maps_mesh_names(1)) )
    @assertEqual( target_edge_cells, test_maps_edge_cells_x )
    @assertEqual( target_edge_cells, test_maps_edge_cells_y )
    @assertEqual( nmaps, size(test_maps_mesh_names   ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_x ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_y ) )

    ! Generate the mesh and connectivity
    call csgen%generate()
    ! Retrieve calculated dimensions
    call csgen%get_dimensions(nodes, edges, faces, nodes_per_face, &
                              edges_per_face, nodes_per_edge)

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6*edge_cells*edge_cells+2, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 2*6*edge_cells*edge_cells, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 6*edge_cells*edge_cells, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")

    ! Retrieve mesh connectivity
    call csgen%get_connectivity(this%nodes_on_face, this%nodes_on_edge, &
                                this%edges_on_face, this%faces_on_face)

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/ 4,5,2,1 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,20), (/ 24,21,20,23 /), "Incorrect vertex sequence on faces.")

    ! Mesh connectivity is complete
    @assertTrue(minval(this%faces_on_face, 2) /= 0, "Incomplete faces_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/ 30,4,2,37 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,11), (/ 10,14,12,44 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1), (/ 2,3,5,1 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,20), (/ 48,50,46,47 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1),  (/  1,  2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,40), (/ 43, 42 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call csgen%get_coordinates( this%coords,        &
                                this%face_coords,   &
                                test_coord_units_x, &
                                test_coord_units_y )

    ! Node coordinates have expected values at specified points
    @assertTrue(abs(this%coords(1,1)  - 315.0000000000001137_r_def) < eps, "Incorrect x-coord, node 1.")
    @assertTrue(abs(this%coords(2,1)  -  35.2643896827546399_r_def) < eps, "Incorrect y-coord, node 1.")
    @assertTrue(abs(this%coords(1,20) - 160.7237414026762394_r_def) < eps, "Incorrect x-coord, node 20.")
    @assertTrue(abs(this%coords(2,20) -  43.3480768096655993_r_def) < eps, "Incorrect y-coord, node 20.")

    ! Check face co-ordinates for cells 1 and 20
    @assertTrue(abs(this%face_coords(1,1)  - 328.6231683398669929375_r_def) < eps, "Incorrect x-coord, face 1.")
    @assertTrue(abs(this%face_coords(2,1)  -  27.5043902958763375466_r_def) < eps, "Incorrect y-coord, face 1.")
    @assertTrue(abs(this%face_coords(1,20) - 179.9999999999999715783_r_def) < eps, "Incorrect x-coord, face 20.")
    @assertTrue(abs(this%face_coords(2,20) -  30.1569744318065886546_r_def) < eps, "Incorrect y-coord, face 20.")

    @assertTrue( trim(test_coord_units_x) == 'degrees_east')
    @assertTrue( trim(test_coord_units_y) == 'degrees_north')

    ! Retrieve global mesh maps
    nullify(global_mesh_maps)
    global_mesh_maps => csgen%get_global_mesh_maps()
    @assertAssociated( global_mesh_maps )

    ! Although no actual global mesh maps have written to file maps have been created
    ! for global meshes in the order they are virtually listed,
    ! i.e. mesh "unit_test", id=1
    !      mesh "unit_test_target", id=2
    nullify(global_mesh_map)
    global_mesh_map  => global_mesh_maps%get_global_mesh_map(1,2)

    @assertAssociated( global_mesh_map )
    @assertEqual( ncells, global_mesh_map%get_nsource_cells() )
    @assertEqual( 4,  global_mesh_map%get_ntarget_cells_per_source_cell() )
    @assertEqual( 1,  global_mesh_map%get_source_id() )
    @assertEqual( 2,  global_mesh_map%get_target_id() )

  end subroutine test_all

end module gencube_ps_mod_test
