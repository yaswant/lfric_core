#!/usr/bin/env python3
# pylint: disable=invalid-name
##############################################################################
# Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
# For further details please refer to the file LICENCE which you
# should have received as part of this distribution.
##############################################################################
"""
Generate a make file snippet holding dependency information about a Fortran
program.

This snippet may then be "include"ed into other make files.
"""

import argparse
import logging
import os
from pathlib import Path
import sys
import traceback
from time import time
from typing import List

from dependerator import database, process, __version__

###############################################################################
# Entry point

if __name__ == '__main__':
    parser = argparse.ArgumentParser(add_help=False,
                                     description=__doc__)
    parser.add_argument('-help', '-h', '--help', action='help',
                        help='Show this help message and exit')
    parser.add_argument('-version', action='version',
                        version=f'%(prog)s {__version__}')
    parser.add_argument('-verbose', action='store_true',
                        help='Provide a running commentary')
    parser.add_argument('-debug', action='store_true',
                        help='Provide a really detailed running commentary')
    parser.add_argument('-database', metavar='database-file', type=Path,
                        help='Database file to use')
    parser.add_argument('-moduledir', metavar='module-directory', type=Path,
                        help='Fortran module files are here.'
                             + 'Defaults to the output directory.')
    parser.add_argument('-objectdir', metavar='object-directory', type=Path,
                        help='Object files are here. '
                             + 'Defaults to the output directory.')
    parser.add_argument('-moduleobjects', action='store_true',
                        help='The compiler puts module information in object '
                             'files.')
    parser.add_argument('output', metavar='output-file',
                        type=Path,
                        help='Dependency details are put here')
    args = parser.parse_args()

    logger = logging.getLogger('dependerator')
    logger.addHandler(logging.StreamHandler())
    if args.debug:
        logger.setLevel(logging.DEBUG)
    elif args.verbose:
        logger.setLevel(logging.INFO)
    else:
        logger.setLevel(logging.WARNING)

    if os.path.exists(args.output):
        os.unlink(args.output)

    outputDirectory = os.path.dirname(args.output)
    if outputDirectory and not os.path.exists(outputDirectory):
        os.makedirs(outputDirectory)

    if not args.database:
        args.database = os.path.join(outputDirectory, 'dependencies.db')
    if not args.moduledir:
        args.moduledir = outputDirectory
    if not args.objectdir:
        args.objectdir = outputDirectory

    backend = database.SQLiteDatabase(args.database)
    fortranStore = database.FortranDependencies(backend)
    processor = process.FortranProcessor(fortranStore,
                                         args.objectdir, args.moduledir)

    fileStore = database.FileDependencies(backend)
    processor.determine_compile_file_dependencies(fileStore,
                                                  args.moduleobjects)

    start_time = time()
    try:
        with args.output.open('wt') as listFile:
            print('# Object dependencies', file=listFile)

            for filename, prerequisites in fileStore.get_dependencies():
                if filename.suffix == '.mod':
                    filename = f'$(MOD_DIR)/{filename.name}'
                prereq_strings: List[str] = []
                for prereq in prerequisites:
                    if prereq.suffix == '.mod':
                        prereq_strings.append(f'$(MOD_DIR)/{prereq.name}')
                    else:  # prereq.suffix != '.mod'
                        prereq_strings.append(str(prereq))
                print(f'{filename} : {" ".join(prereq_strings)}',
                      file=listFile)
    except Exception:  # pylint: disable=broad-except
        os.unlink(args.output)
        traceback.print_exc(file=sys.stdout)
        sys.exit(1)
    finally:
        message = f"Time to write out dependencies: {time() - start_time}"
        logger.debug(message)
