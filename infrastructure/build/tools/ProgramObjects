#!/usr/bin/env python3
# pylint: disable=invalid-name
##############################################################################
# Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
# For further details please refer to the file LICENCE which you
# should have received as part of this distribution.
##############################################################################
"""
Generate a make file snippet holding build information about a Fortran
program.

This snippet consists of a list of objects required to link an program.

This snippet may then be "include"ed into other make files.
"""
from argparse import ArgumentParser
import logging
from pathlib import Path
from sys import exit as sys_exit, stdout
import traceback
from time import time

from dependerator import database, process, __version__


def program_objects_fragment(database_path: Path,
                             objects_path: Path,
                             output_path: Path) -> int:
    """
    Generates make fragment listing all objects needed to link programs.
    """
    dependency_backend = database.SQLiteDatabase(database_path)
    dependency_store = database.FortranDependencies(dependency_backend)
    processor = process.FortranProcessor(dependency_store,
                                         objects_path,
                                         None)

    start_time = time()
    try:
        with output_path.open('wt') as make_file:
            print('# Program objects', file=make_file)
            programs = []
            for program, _, objects in processor.determine_link_dependencies():
                programs.append(program.with_suffix('.o'))
                print(f'{program.name.upper()}_OBJS = '
                      + ' '.join([str(path) for path in objects]),
                      file=make_file)
                print(file=make_file)

            print('PROG_OBJS = '
                  + ' '.join([str(path) for path in programs]),
                  file=make_file)
    except Exception:  # pylint: disable=broad-except
        output_path.unlink()
        traceback.print_exc(file=stdout)
        return 1
    finally:
        message = f"Time to write out program objects: {time() - start_time}"
        logger.debug(message)
    return 0


###############################################################################
# Entry point

if __name__ == '__main__':
    parser = ArgumentParser(add_help=False,
                            description=__doc__)
    parser.add_argument('-help', '-h', '--help', action='help',
                        help='Show this help message and exit')
    parser.add_argument('-version', action='version',
                        version=f'%(prog)s {__version__}')
    parser.add_argument('-verbose', action='store_true',
                        help='Provide a running commentary')
    parser.add_argument('-debug', action='store_true',
                        help='Illucidate the minutia of execution')
    parser.add_argument('-database', metavar='database-file',
                        type=Path,
                        help='Database file to use')
    parser.add_argument('-objectdir', metavar='object-directory',
                        type=Path,
                        help='Object files are here. '
                             + 'Defaults to the output directory.')
    parser.add_argument('output', metavar='output-file',
                        type=Path,
                        help='Dependency details are put here')
    arguments = parser.parse_args()

    logger = logging.getLogger('dependerator')
    logger.addHandler(logging.StreamHandler())
    if arguments.debug:
        logger.setLevel(logging.DEBUG)
    elif arguments.verbose:
        logger.setLevel(logging.INFO)
    else:
        logger.setLevel(logging.WARNING)

    if arguments.output.exists and arguments.output.is_file():
        arguments.output.unlink()

    outputDirectory = arguments.output.parent
    if outputDirectory and not outputDirectory.exists():
        outputDirectory.mkdir()

    if not arguments.database:
        arguments.database = outputDirectory / 'dependencies.db'
    if not arguments.objectdir:
        arguments.objectdir = outputDirectory

    sys_exit(program_objects_fragment(arguments.database,
                                      arguments.objectdir,
                                      arguments.output))
