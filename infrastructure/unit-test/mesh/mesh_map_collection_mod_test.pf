!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> @brief pFunit tests for the mesh map collection
!>
module mesh_map_collection_mod_test

  use constants_mod,              only: r_def, i_def, IMDI, &
                                        str_max_filename, str_def
  use global_mesh_map_collection_mod, &
                                  only: global_mesh_map_collection_type
  use global_mesh_collection_mod, only: global_mesh_collection_type, &
                                        global_mesh_collection
  use global_mesh_mod,            only: global_mesh_type
  use global_mesh_map_mod,        only: global_mesh_map_type

  use partition_mod,              only: partition_type, partitioner_interface, &
                                        partitioner_cubedsphere_serial
  use mesh_mod,                   only: mesh_type
  use mesh_map_mod,               only: mesh_map_type
  use mesh_map_collection_mod,    only: mesh_map_collection_type
  use mesh_collection_mod,        only: mesh_collection_type, mesh_collection
  use yaxt,                       only : xt_initialize, xt_finalize
  use mpi_mod,                    only : store_comm, clear_comm
  use ugrid_mesh_data_mod,        only : ugrid_mesh_data_type

  use pFUnit_Mod


  implicit none

  private
  public :: mesh_map_collection_test_type, test_mesh_map_collection

  @testCase
  type, extends( MPITestCase ) :: mesh_map_collection_test_type
    private

    type(global_mesh_map_type), pointer :: CoarseToFine_global_mesh_map => null()
    type(mesh_type), pointer    :: coarse_mesh => null()
    type(mesh_type), pointer    :: fine_mesh   => null()

    integer(i_def), allocatable :: coarse_lid_gid_map(:)
    integer(i_def), allocatable :: fine_lid_gid_map(:)

  contains
    procedure :: setUp
    procedure :: tearDown
    procedure :: test_mesh_map_collection
  end type mesh_map_collection_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'
  character(str_max_filename), parameter ::                      &
                               coarse_ugrid = 'data/mesh_C4.nc', &! 4x4 panel
                               fine_ugrid   = 'data/mesh_C8.nc'   ! 8x8 panel

  character(str_max_filename), parameter :: filename = &
                                     'data/mesh_C32_MG.nc'
  character(str_max_filename), parameter :: mesh_names(2) = &
                                    [ 'C4',  &! 4x4 panel
                                      'C8']   ! 8x8 panel

  integer(i_def), parameter :: local_rank  = 0_i_def
  integer(i_def), parameter :: total_ranks = 1_i_def
  integer(i_def), parameter :: max_stencil_depth = 0_i_def
  integer(i_def), parameter :: xproc       = 1_i_def
  integer(i_def), parameter :: yproc       = 1_i_def
  integer(i_def), parameter :: nlayers     = 5_i_def
  real(r_def),    parameter :: domain_top  = 10000.0_r_def

  real(r_def),    parameter :: gravity  = 10.0_r_def
  real(r_def),    parameter :: radius   = 6371229.0_r_def
  real(r_def),    parameter :: omega    = 8.0E-5_r_def
  real(r_def),    parameter :: p_zero   = 100000.0_r_def
  real(r_def),    parameter :: rd       = 300.0_r_def
  real(r_def),    parameter :: cp       = 1000.0_r_def
  real(r_def),    parameter :: scaling  = 125.0_r_def

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use extrusion_mod, only: uniform_extrusion_type
    use ncdf_quad_mod, only: ncdf_quad_type

    implicit none

    class( mesh_map_collection_test_type ), intent( inout ) :: this

    type(ugrid_mesh_data_type)      :: ugrid_mesh_data
    type(global_mesh_type), pointer :: coarse_global_mesh_ptr => null()
    type(global_mesh_type), pointer :: fine_global_mesh_ptr   => null()
    type(global_mesh_type), pointer :: global_mesh_ptr => null()
    type(global_mesh_type), pointer :: target_mesh_ptr => null()
    type(partition_type)            :: coarse_partition
    type(partition_type)            :: fine_partition
    type(uniform_extrusion_type)    :: extrusion

    type(global_mesh_type) :: global_mesh
    type(mesh_type)        :: local_mesh

    integer(i_def)         :: coarse_global_mesh_id
    integer(i_def)         :: fine_global_mesh_id
    integer(i_def)         :: coarse_mesh_id
    integer(i_def)         :: fine_mesh_id

    character(str_def)     :: name

    character(str_def), allocatable :: target_mesh_names(:)
    integer(i_def),     allocatable :: cell_map(:,:)

    integer(i_def)         :: ncells
    integer(i_def)         :: i, j
    integer(i_def)         :: npanels

    integer(i_def)         :: global_mesh_id

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()

    type(ncdf_quad_type) :: file_handler

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    !Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    global_mesh_collection = global_mesh_collection_type()
    mesh_collection        = mesh_collection_type()

    partitioner_ptr => partitioner_cubedsphere_serial


    npanels = 6

    ! Read in global meshes
    do i=1, size(mesh_names)

      call ugrid_mesh_data%read_from_file(trim(filename), mesh_names(i))
      global_mesh = global_mesh_type( ugrid_mesh_data, npanels)
      call ugrid_mesh_data%clear()
      call global_mesh_collection%add_new_global_mesh( global_mesh )

    end do

    ! Read in global mesh maps
    call file_handler%file_open(trim(filename))
    do i=1, size(mesh_names)
      global_mesh_ptr => global_mesh_collection%get_global_mesh (mesh_names(i) )
      call global_mesh_ptr%get_target_mesh_names(target_mesh_names)
      do j=1, size(target_mesh_names)
        if (global_mesh_collection%check_for(target_mesh_names(j))) then
          call file_handler%read_map( mesh_names(i),        &
                                      target_mesh_names(j), &
                                      cell_map )
          target_mesh_ptr => global_mesh_collection%get_global_mesh( target_mesh_names(j) )
          call global_mesh_ptr%add_global_mesh_map(target_mesh_ptr, cell_map)
        end if
      end do
    end do
    call file_handler%file_close()


    name = 'C4'
    coarse_global_mesh_ptr => global_mesh_collection%get_global_mesh( name )
    coarse_global_mesh_id  = coarse_global_mesh_ptr%get_id()

    name = 'C8'
    fine_global_mesh_ptr => global_mesh_collection%get_global_mesh( name )
    fine_global_mesh_id  =  fine_global_mesh_ptr%get_id()

    this%CoarseToFine_global_mesh_map => &
         coarse_global_mesh_ptr%get_global_mesh_map( fine_global_mesh_id )

    coarse_partition = partition_type( coarse_global_mesh_ptr, &
                                       partitioner_ptr,        &
                                       xproc, yproc,           &
                                       max_stencil_depth,      &
                                       local_rank, total_ranks )

    ncells = coarse_partition%get_num_cells_in_layer()

    fine_partition   = partition_type( fine_global_mesh_ptr,   &
                                       partitioner_ptr,        &
                                       xproc, yproc,           &
                                       max_stencil_depth,      &
                                       local_rank, total_ranks )

    extrusion = uniform_extrusion_type( radius, domain_top, nlayers )

    local_mesh = mesh_type( coarse_global_mesh_ptr, &
                            coarse_partition,       &
                            extrusion )
    coarse_mesh_id   = mesh_collection%add_new_mesh( local_mesh )


    local_mesh = mesh_type( fine_global_mesh_ptr, &
                            fine_partition,       &
                            extrusion )
    fine_mesh_id     = mesh_collection%add_new_mesh( local_mesh )

    this%coarse_mesh => mesh_collection%get_mesh( coarse_mesh_id )
    this%fine_mesh   => mesh_collection%get_mesh( fine_mesh_id   )


    ncells = coarse_partition%get_num_cells_in_layer()
    allocate(this%coarse_lid_gid_map(ncells))
    do i=1, ncells
      this%coarse_lid_gid_map(i) = coarse_partition%get_gid_from_lid(i)
    end do


    ncells = fine_partition%get_num_cells_in_layer()
    allocate(this%fine_lid_gid_map(ncells))
    do i=1, ncells
      this%fine_lid_gid_map(i) = fine_partition%get_gid_from_lid(i)
    end do

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod, only: final_configuration

    implicit none

    class( mesh_map_collection_test_type ), intent( inout ) :: this

    deallocate(this%coarse_lid_gid_map)
    deallocate(this%fine_lid_gid_map)

    call global_mesh_collection%clear()
    call mesh_collection%clear()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_mesh_map_collection( this )

    implicit none

    class( mesh_map_collection_test_type ), intent( inout ) :: this

    type (mesh_map_collection_type) :: mesh_maps

    type (mesh_map_type),  pointer :: mesh_map  => null()
    type (mesh_map_type),  pointer :: mesh_map2 => null()
    type (partition_type), pointer :: partition => null()

    integer(i_def) :: i
    integer(i_def) :: ncells_2d
    integer(i_def) :: ntarget_cells_per_source_cell, nsource_cells

    integer(i_def), allocatable :: map(:,:)

    integer(i_def), allocatable :: mesh_lid_gid_map(:)


    partition => this%coarse_mesh % get_partition()
    ncells_2d = partition%get_num_cells_in_layer()

    allocate(mesh_lid_gid_map(ncells_2d))
    do i=1, ncells_2d
      mesh_lid_gid_map(i) = partition%get_gid_from_lid(i)
    end do

    mesh_maps = mesh_map_collection_type()

    ntarget_cells_per_source_cell = &
        this%CoarseTofine_global_mesh_map%get_ntarget_cells_per_source_cell()
    nsource_cells                 = &
        this%CoarseTofine_global_mesh_map%get_nsource_cells()
    allocate(map(ntarget_cells_per_source_cell,nsource_cells))

    ! For this test we don't care what's in the map
    map(:,:) = IMDI

    call mesh_maps % add_mesh_map( this%coarse_mesh%get_id(), &
                                   this%fine_mesh%get_id(),   &
                                   map )

    mesh_map => mesh_maps % get_mesh_map( this%coarse_mesh%get_id(), &
                                          this%fine_mesh%get_id()    )
    @assertAssociated ( mesh_map )


    call mesh_maps % add_mesh_map( this%coarse_mesh%get_id(), &
                                   this%fine_mesh%get_id(),   &
                                   map )


    mesh_map2 => mesh_maps % get_mesh_map( this%coarse_mesh%get_id(), &
                                           this%fine_mesh%get_id() )

    @assertAssociated ( mesh_map2 )

    @assertEqual ( associated(mesh_map, mesh_map2), .true. )

    deallocate(mesh_lid_gid_map)
    deallocate(map)

    call mesh_maps % clear()

    return
  end subroutine test_mesh_map_collection

end module mesh_map_collection_mod_test


