!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the scalar object
!>
!-------------------------------------------------------------------------------
module scalar_real32_mod_test

  use, intrinsic :: iso_fortran_env, only : real32
  use constants_mod, only: i_def
  use mpi_mod, only : global_mpi
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(MPITestCase), public :: scalar_real32_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type scalar_real32_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(scalar_real32_test_type), intent(inout) :: this

    !Store the MPI communicator for later use
    call global_mpi%initialise(this%getMpiCommunicator())

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(scalar_real32_test_type), intent(inout) :: this

    ! Clear the stored MPI communicator
    call global_mpi%finalise()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[2] )
  subroutine test_all( this )

    use scalar_real32_mod, only: scalar_real32_type

    implicit none

    class(scalar_real32_test_type), intent(inout) :: this

    type(scalar_real32_type) :: s1, s2

    real(real32) :: s1_val, s2_val
    real(real32) :: sum_val, min_val, max_val

    integer(i_def) :: local_rank

    local_rank  = global_mpi%get_comm_rank()

    s1_val = 10.0_real32 + real(local_rank, kind=real32)

    s1%value = s1_val

    ! Check the scalar type has been correctly constructed and that
    ! we have access to the data
    @assertEqual( s1_val, s1%value, 1.0e-2_real32 )

    ! Test the global reductions
    ! - a bit trivial until we have parallel tests
    sum_val = s1%get_sum()
    @assertEqual( 21.0_real32, sum_val, 1.0e-2_real32 )

    min_val = s1%get_min()
    @assertEqual( 10.0_real32, min_val, 1.0e-2_real32 )

    max_val = s1%get_max()
    @assertEqual( 11.0_real32, max_val, 1.0e-2_real32 )

    ! Test alternative way to create a scalar - by calling the initialiser
    s2_val = 20.0_real32 + real(local_rank, kind=real32)
    call s2%initialise(s2_val, global_mpi)
    ! Make sure we can call one of the reductions on this scalar
    sum_val = s2%get_sum()
    @assertEqual( 41.0_real32, sum_val, 1.0e-2_real32 )

  end subroutine test_all

end module scalar_real32_mod_test
