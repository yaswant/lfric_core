!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the subroutines in coord_transform_mod
!>
module coord_transform_mod_test

    use, intrinsic :: iso_fortran_env, only : real32, real64

  use pFUnit_Mod
  use constants_mod, only: i_def, r_def, pi

  implicit none

contains

  !> Test transformation from (X,Y,Z) coordinates to (alpha,beta,r)
  !>
  @test
  subroutine test_xyz2alphabetarpanel( )

    use coord_transform_mod, only : xyz2alphabetarpanel

    implicit none

    real(kind=r_def)    :: tol
    real(kind=r_def)    :: XYZ(3), abr(3)
    real(kind=r_def)    :: abr_answer(3)
    integer(kind=i_def) :: i, panel_id, panel_answer

    ! Check that some obvious coordinates are returned correctly
#if (RDEF_PRECISION == 64)
    tol = 1.0e-7_real64
#elif (RDEF_PRECISION == 32)
    tol = 2.0e-7_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Panel 1: tan(alpha) = Y/X, tan(beta) = Z/X
    XYZ(:) = (/ 1.0_r_def, 0.0_r_def, 0.0_r_def /)
    abr_answer(:) = (/ 0.0_r_def, 0.0_r_def, 1.0_r_def /)
    panel_answer = 1_i_def

    call xyz2alphabetarpanel(XYZ(1), XYZ(2), XYZ(3), &
                             abr(1), abr(2), abr(3), &
                             panel_id)

    do i = 1, 3
      @assertEqual(abr(i), abr_answer(i), tol)
    end do

    @assertEqual(panel_id, panel_answer)

    ! Panel 4: tan(alpha) = Z/-Y, tan(beta) = -X/-Y
    ! Use that tan(pi/6) = sqrt(3) / 3
    ! radius found from sqrt(3)**2 + 3**2 = 12
    XYZ(:) = (/ sqrt(3.0_r_def), -3.0_r_def, 0.0_r_def /)
    abr_answer(:) = (/ 0.0_r_def, -pi / 6.0_r_def, sqrt(12.0_r_def) /)
    panel_answer = 4_i_def

    call xyz2alphabetarpanel(XYZ(1), XYZ(2), XYZ(3), &
                             abr(1), abr(2), abr(3), &
                             panel_id)

    do i = 1, 3
      @assertEqual(abr(i), abr_answer(i), tol)
    end do

    @assertEqual(panel_id, panel_answer)

    ! Panel 5: tan(alpha) = Y/Z, tan(beta) = -X/Z
    ! Use that tan(pi/12) = 2 - sqrt(3)
    ! Use that tan(pi/6) = sqrt(3) / 3
    ! radius found from 1**2 + (sqrt(3)/3)**2 + (2-sqrt(3))**3 = 25/3-4*sqrt(3)
    XYZ(:) = (/ 2.0_r_def - sqrt(3.0_r_def), sqrt(3.0_r_def)/3.0_r_def, 1.0_r_def /)
    abr_answer(:) = (/ pi/6.0_r_def,                                           &
                       -pi/12.0_r_def,                                         &
                       sqrt(25.0_r_def/3.0_r_def - 4.0_r_def*sqrt(3.0_r_def)) /)
    panel_answer = 5_i_def

    call xyz2alphabetarpanel(XYZ(1), XYZ(2), XYZ(3), &
                             abr(1), abr(2), abr(3), &
                             panel_id)

    do i = 1, 3
      @assertEqual(abr(i), abr_answer(i), tol)
    end do

    @assertEqual(panel_id, panel_answer)

  end subroutine test_xyz2alphabetarpanel


  !> Test transformation from (alpha,beta,r) coordinates to (X,Y,Z)
  !>
  @test
  subroutine test_alphabetar2xyz( )
    use coord_transform_mod, only : alphabetar2xyz
    implicit none

    real(kind=r_def)    :: tol
    real(kind=r_def)    :: XYZ(3), abr(3)
    real(kind=r_def)    :: XYZ_answer(3)
    integer(kind=i_def) :: i, panel_id

    ! Check that some obvious coordinates are returned correctly
#if (RDEF_PRECISION == 64)
    tol = 1.0e-7_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.5e-7_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Panel 2: tan(alpha) = -X/Y, tan(beta) = Z/Y
    abr(:) = (/ 0.0_r_def, 0.0_r_def, 1.0_r_def /)
    XYZ_answer(:) = (/ 0.0_r_def, 1.0_r_def, 0.0_r_def /)
    panel_id = 2_i_def

    call alphabetar2xyz(abr(1), abr(2), abr(3), panel_id, &
                        XYZ(1), XYZ(2), XYZ(3))

    do i = 1, 3
      @assertEqual(XYZ(i), XYZ_answer(i), tol)
    end do

    ! Panel 3: tan(alpha) = Z/-X, tan(beta) = Y/-X
    ! Use that tan(pi/6) = sqrt(3) / 3
    ! radius found from sqrt(3)**2 + 3**2 = 12
    XYZ_answer(:) = (/ -3.0_r_def, sqrt(3.0_r_def), 0.0_r_def /)
    abr(:) = (/ 0.0_r_def, pi / 6.0_r_def, sqrt(12.0_r_def) /)
    panel_id = 3_i_def

    call alphabetar2xyz(abr(1), abr(2), abr(3), panel_id, &
                        XYZ(1), XYZ(2), XYZ(3))

    do i = 1, 3
      @assertEqual(XYZ(i), XYZ_answer(i), tol)
    end do

    ! Panel 6: tan(alpha) = -X/-Z, tan(beta) = Y/-Z
    ! Use that tan(pi/12) = 2 - sqrt(3)
    ! Use that tan(pi/6) = sqrt(3) / 3
    ! radius found from 1**2 + (sqrt(3)/3)**2 + (2-sqrt(3))**3 = 25/3-4*sqrt(3)
    XYZ_answer(:) = (/ -sqrt(3.0_r_def)/3.0_r_def,         &
                       -2.0_r_def + sqrt(3.0_r_def), &
                      -1.0_r_def                    /)
    abr(:) = (/ pi/6.0_r_def,                                           &
                -pi/12.0_r_def,                                         &
                sqrt(25.0_r_def/3.0_r_def - 4.0_r_def*sqrt(3.0_r_def)) /)
    panel_id = 6_i_def

    call alphabetar2xyz(abr(1), abr(2), abr(3), panel_id, &
                        XYZ(1), XYZ(2), XYZ(3))

    do i = 1, 3
      @assertEqual(XYZ(i), XYZ_answer(i), tol)
    end do

  end subroutine test_alphabetar2xyz


  !> Test transformation from (X,Y,Z) components of a vector
  !> to (alpha,beta,r) components
  !>
  @test
  subroutine test_xyz2alphabetar_vector( )
    use coord_transform_mod, only : xyz2alphabetar_vector
    implicit none

    real(kind=r_def)    :: tol
    real(kind=r_def)    :: XYZ(3), XYZ_vec(3)
    real(kind=r_def)    :: abr_vec_answer(3), abr_vec(3)
    integer(kind=i_def) :: i

    ! Check that some obvious coordinates are returned correctly
#if (RDEF_PRECISION == 64)
    tol = 1.0e-7_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.0e-7_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Panel 1: tan(alpha) = Y/X, tan(beta) = Z/X
    XYZ(:) = (/ 10.0_r_def, 0.0_r_def, 0.0_r_def /)
    XYZ_vec(:) = (/ 2.0_r_def, 3.0_r_def, 5.0_r_def /)

    abr_vec_answer(:) = (/ 3.0_r_def, 5.0_r_def, 2.0_r_def /)

    abr_vec(:) = xyz2alphabetar_vector(XYZ_vec, XYZ)

    do i = 1, 3
      @assertEqual(abr_vec(i), abr_vec_answer(i), tol)
    end do

    ! Panel 4: tan(alpha) = Z/-Y, tan(beta) = -X/-Y
    XYZ(:) = (/ 0.0_r_def, -0.1_r_def, 0.0_r_def /)
    XYZ_vec(:) = (/ 2.0_r_def, 3.0_r_def, 5.0_r_def /)

    abr_vec_answer(:) = (/ 5.0_r_def, -2.0_r_def, -3.0_r_def /)

    abr_vec(:) = xyz2alphabetar_vector(XYZ_vec, XYZ)

    do i = 1, 3
      @assertEqual(abr_vec(i), abr_vec_answer(i), tol)
    end do

  end subroutine test_xyz2alphabetar_vector


  !> Test transformation from (alpha,beta,r) components of a vector
  !> to (X,Y,Z) components
  !>
  @test
  subroutine test_alphabetar2xyz_vector( )
    use coord_transform_mod, only : alphabetar2xyz_vector
    implicit none

    real(kind=r_def)    :: tol
    real(kind=r_def)    :: XYZ_vec_answer(3), XYZ_vec(3)
    real(kind=r_def)    :: abr(3), abr_vec(3)
    integer(kind=i_def) :: i, panel_id

    ! Check that some obvious coordinates are returned correctly
#if (RDEF_PRECISION == 64)
    tol = 1.0e-7_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.0e-7_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Panel 2: tan(alpha) = -X/Y, tan(beta) = Z/Y
    panel_id = 2_i_def
    abr(:) = (/ 0.0_r_def, 0.0_r_def, 0.1_r_def /)
    abr_vec(:) = (/ 2.0_r_def, 3.0_r_def, 5.0_r_def /)

    XYZ_vec_answer(:) = (/ -2.0_r_def, 5.0_r_def, 3.0_r_def /)

    xyz_vec(:) = alphabetar2xyz_vector(abr_vec, abr, panel_id)

    do i = 1, 3
      @assertEqual(XYZ_vec(i), XYZ_vec_answer(i), tol)
    end do

    ! Panel 6: tan(alpha) = -X/-Z, tan(beta) = Y/-Z
    panel_id = 6_i_def
    abr(:) = (/ 0.0_r_def, 0.0_r_def, 19.0_r_def /)
    abr_vec(:) = (/ 2.0_r_def, 3.0_r_def, 5.0_r_def /)

    XYZ_vec_answer(:) = (/ -2.0_r_def, 3.0_r_def, -5.0_r_def /)

    xyz_vec(:) = alphabetar2xyz_vector(abr_vec, abr, panel_id)

    do i = 1, 3
      @assertEqual(XYZ_vec(i), XYZ_vec_answer(i), tol)
    end do

  end subroutine test_alphabetar2xyz_vector


  !> Test re-basing of the longitude to -180< lon <=180
  !>
  @test
  subroutine test_rebase_longitude_range( )
    use coord_transform_mod, only : rebase_longitude_range
    implicit none

    real(kind=r_def),parameter :: LON_BASE = -180.0_r_def
    real(kind=r_def)           :: tol
    real(kind=r_def)           :: lon

#if (RDEF_PRECISION == 64)
    tol = 1.0e-5_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.0e-5_real32
#else
    @assertFail("Unsupported default precision")
#endif

    lon = 180.0_r_def
    @assertEqual( -180.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = -180.0_r_def
    @assertEqual( -180.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = 360.0_r_def
    @assertEqual( 0.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = 45.0_r_def
    @assertEqual( 45.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = -45.0_r_def
    @assertEqual( -45.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = 360_r_def - 45.0_r_def
    @assertEqual( -45.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = 360_r_def + 45.0_r_def
    @assertEqual( 45.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = -45.0_r_def - 360_r_def
    @assertEqual( -45.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = 45.0_r_def - 360_r_def
    @assertEqual( 45.0_r_def, rebase_longitude_range(lon, LON_BASE) )

    lon = 360_r_def + 45.0_r_def
    @assertEqual( 45.0_r_def, rebase_longitude_range(lon, 0.0_r_def) )

    lon = 360_r_def + 45.0_r_def
    @assertEqual( 45.0_r_def, rebase_longitude_range(lon, -90.0_r_def) )


  end subroutine test_rebase_longitude_range

  !> Test the computation of the rotation matrix
  @test
  subroutine test_mesh_rotation_matrix()
    use coord_transform_mod, only: mesh_rotation_matrix
    implicit none

    real(kind=r_def)    :: target_north_pole(2)
    real(kind=r_def)    :: computed_matrix(3,3)
    real(kind=r_def)    :: true_matrix(3,3)
    real(kind=r_def)    :: tol

    tol = 1.0e-8_r_def

    ! Rotate North pole to equator ---------------------------------------------
    target_north_pole(1) = 0.0_r_def
    target_north_pole(2) = 0.0_r_def

    true_matrix(:,:) = 0.0_r_def
    true_matrix(1,3) = 1.0_r_def
    true_matrix(2,2) = 1.0_r_def
    true_matrix(3,1) = -1.0_r_def

    computed_matrix = mesh_rotation_matrix(target_north_pole)

    @assertEqual(computed_matrix, true_matrix, tol)

  end subroutine test_mesh_rotation_matrix


  !> Test the Cartesian Schmidt transform
  @test
  subroutine test_schmidt_transform_xyz()
    use coord_transform_mod, only: schmidt_transform_xyz
    implicit none

    real(kind=r_def) :: stretch, tol, radius
    real(kind=r_def) :: native_xyz(3), physical_xyz(3), true_physical_xyz(3)

    radius = 190.19_r_def    ! Arbitrary radius
    stretch = 1.0_r_def/sqrt(3.0_r_def)

#if (RDEF_PRECISION == 64)
    tol = 1.0e-8_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.0e-5_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Check that North pole stays the same -------------------------------------
    native_xyz(1) = 0.0_r_def
    native_xyz(2) = 0.0_r_def
    native_xyz(3) = radius
    true_physical_xyz(1) = 0.0_r_def
    true_physical_xyz(2) = 0.0_r_def
    true_physical_xyz(3) = radius

    physical_xyz = schmidt_transform_xyz(native_xyz, stretch)

    @assertEqual(physical_xyz, true_physical_xyz, tol)

    ! Check that South pole stays the same -------------------------------------
    native_xyz(1) = 0.0_r_def
    native_xyz(2) = 0.0_r_def
    native_xyz(3) = -radius
    true_physical_xyz(1) = 0.0_r_def
    true_physical_xyz(2) = 0.0_r_def
    true_physical_xyz(3) = -radius

    physical_xyz = schmidt_transform_xyz(native_xyz, stretch)

    @assertEqual(physical_xyz, true_physical_xyz, tol)

    ! Check that equator moves appropriately -----------------------------------
    native_xyz(1) = radius
    native_xyz(2) = 0.0_r_def
    native_xyz(3) = 0.0_r_def
    true_physical_xyz(1) = sqrt(3.0_r_def)*radius*0.5_r_def
    true_physical_xyz(2) = 0.0_r_def
    true_physical_xyz(3) = radius*0.5_r_def

    physical_xyz = schmidt_transform_xyz(native_xyz, stretch)

    @assertEqual(physical_xyz, true_physical_xyz, tol)

  end subroutine test_schmidt_transform_xyz


  !> Test the inverse Cartesian Schmidt transform
  @test
  subroutine test_inverse_schmidt_transform_xyz()
    use coord_transform_mod, only: inverse_schmidt_transform_xyz
    implicit none

    real(kind=r_def) :: stretch, tol, radius
    real(kind=r_def) :: native_xyz(3), physical_xyz(3), true_native_xyz(3)

    radius = 6131.19_r_def    ! Arbitrary radius
    stretch = 1.0_r_def/sqrt(3.0_r_def)

#if (RDEF_PRECISION == 64)
    tol = 1.0e-8_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.0e-5_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Check that North pole stays the same -------------------------------------
    physical_xyz(1) = 0.0_r_def
    physical_xyz(2) = 0.0_r_def
    physical_xyz(3) = radius
    true_native_xyz(1) = 0.0_r_def
    true_native_xyz(2) = 0.0_r_def
    true_native_xyz(3) = radius

    native_xyz = inverse_schmidt_transform_xyz(physical_xyz, stretch)

    @assertEqual(native_xyz, true_native_xyz, tol)

    ! Check that South pole stays the same -------------------------------------
    physical_xyz(1) = 0.0_r_def
    physical_xyz(2) = 0.0_r_def
    physical_xyz(3) = -radius
    true_native_xyz(1) = 0.0_r_def
    true_native_xyz(2) = 0.0_r_def
    true_native_xyz(3) = -radius

    native_xyz = inverse_schmidt_transform_xyz(physical_xyz, stretch)

    @assertEqual(native_xyz, true_native_xyz, tol)

    ! Check that equator moves appropriately -----------------------------------
    physical_xyz(1) = sqrt(3.0_r_def)*radius*0.5_r_def
    physical_xyz(2) = 0.0_r_def
    physical_xyz(3) = radius*0.5_r_def
    true_native_xyz(1) = radius
    true_native_xyz(2) = 0.0_r_def
    true_native_xyz(3) = 0.0_r_def

    native_xyz = inverse_schmidt_transform_xyz(physical_xyz, stretch)

    ! Checking zeros so can have a slacker tolerance
#if (RDEF_PRECISION == 64)
    tol = 1.0e-8_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.0e-3_real32
#else
    @assertFail("Unsupported default precision")
#endif

    @assertEqual(native_xyz, true_native_xyz, tol)

  end subroutine test_inverse_schmidt_transform_xyz

  !> Test the latitude Schmidt transform
  @test
  subroutine test_schmidt_transform_lat()
    use coord_transform_mod, only: schmidt_transform_lat
    implicit none

    real(kind=r_def) :: stretch, tol
    real(kind=r_def) :: native_lat, physical_lat, true_physical_lat

    stretch = 1.0_r_def/sqrt(3.0_r_def)

#if (RDEF_PRECISION == 64)
    tol = 1.0e-8_real64
#elif (RDEF_PRECISION == 32)
    tol = 2.0e-7_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Check that equator moves appropriately -----------------------------------
    native_lat = 0.0_r_def
    true_physical_lat = PI/6.0_r_def

    physical_lat = schmidt_transform_lat(native_lat, stretch)

    @assertEqual(physical_lat, true_physical_lat, tol)

  end subroutine test_schmidt_transform_lat

end module coord_transform_mod_test
