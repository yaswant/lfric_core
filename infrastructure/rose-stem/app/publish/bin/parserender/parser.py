#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
##############################################################################
# Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
# For further details please refer to the file LICENCE.original which you
# should have received as part of this distribution.
##############################################################################
'''
Parse the log files generated by Cylc of various stages in the test suite.
'''
from __future__ import print_function

from abc import ABCMeta, abstractmethod
import copy
import hashlib
import re

##############################################################################
class Event(object):
    '''
    An "event" gleened from parsing the output of various processes.
    '''

    filenamePattern = re.compile( r'/.+?/dynamo/(.+)' )

    def __init__( self ):
        self.occurrences = 1
        self.filename   = None
        self.lineNumber = None
        self.level      = None
        self.eventCode  = None
        self.message    = None
        self.source     = None
        self.highlightStart = None
        self.highlightEnd   = None
        self.highlightRange = ':'

    def setFilename( self, filename ):
        '''
        The file in which the event occurred.
        '''
        match = Event.filenamePattern.match( filename )
        if match:
            self.filename = match.group(1)
        else:
            self.filename = filename

    def setLineNumber( self, lineNumber ):
        '''
        The line of the file in which the event occurred.
        '''
        self.lineNumber = lineNumber

    def setLevel( self, level ):
        '''
        Severity of the event.
        '''
        self.level   = level

    def setEventCode( self, code ):
        '''
        A code for the event.
        '''
        self.eventCode = code

    def setMessage( self, message ):
        '''
        The description of the event.
        '''
        # Strip sexed single quotes
        message = message.replace(u'\u2018', "'")
        message = message.replace(u'\u2019', "'")
        self.message = message

    def extendMessage( self, extension ):
        '''
        Append additional text to the message.
        '''
        self.setMessage( self.message + ' ' + extension )

    def setSource( self, source ):
        '''
        The line of source the event refers to.
        '''
        self.source = source

    def setHighlight( self, start, end ):
        '''
        The first and last characters within the source line to highlight.
        '''
        self.highlightStart = start
        self.highlightEnd   = end
        self.highlightRange = str(start) + ':' + str(end)

    def getHash( self ):
        '''
        Calculates a hash for the event.
        '''
        hasher = hashlib.sha1()
        if self.filename:       hasher.update( self.filename )
        if self.lineNumber:     hasher.update( str(self.lineNumber) )
        if self.highlightStart: hasher.update( str(self.highlightStart) )
        if self.highlightEnd:   hasher.update( str(self.highlightEnd) )
        if self.level:          hasher.update( self.level )
        if self.eventCode:      hasher.update( self.eventCode )
        if self.message:        hasher.update( self.message )
        return hasher.digest()

    def bump( self ):
        '''
        Increments the occurence counter for this event.
        '''
        self.occurrences = self.occurrences + 1

##############################################################################
class Parser(object):
    '''
    The root parser class, all parsers inherit from this.
    '''
    __MetaClass__ = ABCMeta

    def __init__( self, errfile ):
        '''
        Initialises a Parser object from the filename of a Cylc error log file.

        In their initialiser children should set up any state their parser
        needs, the call "super(<ChildClass>, self).__init__( errfile )". They
        will then have their "acceptLine" method called for each line in the
        log file.
        '''
        self._events = {}

        for line in errfile:
            if not line.strip(): # Ignore blank lines
                continue

            line = line.decode('utf-8')
            while line:
                line, event = self.acceptLine( line )
                if event:
                    signature = event.getHash()
                    if signature in self._events:
                        self._events[signature].bump()
                    else:
                        self._events[signature] = event
        # Force the last line through the parser. I don't like this duplication
        # but people are waiting.
        line = 'EOF'
        while line:
            line, event = self.acceptLine( line )
            if event:
                signature = event.getHash()
                if signature in self._events:
                    self._events[signature].bump()
                else:
                    self._events[signature] = event

    @abstractmethod
    def acceptLine( self, line ):
        '''
        Examine one line of the input file.

        Called repeatedly by the parsing process, this method is passed the
        new line to examine.

        It should return any of the input line not yet parsed (or None if it
        is all parsed) and any event which may have become available through
        the processing of the line.
        '''
        pass

    def processEvents( self, processor ):
        '''
        Passes each event, in turn, to the processor for potential
        modification.

        The processor is a function which accepts an event and returns an
        event.
        '''
        newEvents = {}
        for event in self._events.itervalues():
            newEvent = processor( event )
            newEvents[newEvent.getHash()] = newEvent
        self._events = newEvents

    def getEvents( self, ignoreCodes=[], groupBy=None ):
        '''
        Gets the events collected by parsing the file.

        Returns a dictionary keyed on the attribute specified in groupBy.

        If groupBy is not specigied then returns the events as a list.
        '''
        if groupBy:
            groups = {}
            for event in self._events.itervalues():
                if event.eventCode in ignoreCodes:
                    continue

                groupingValue = getattr(event, groupBy)

                if groupingValue not in groups:
                    groups[groupingValue] = []

                groups[groupingValue].append( copy.deepcopy( event ) )

            return groups
        else:
            return [copy.deepcopy(event) \
                    for event in self._events.itervalues() \
                    if event.eventCode not in ignoreCodes]

##############################################################################
class CylcParser(Parser):
    '''
    Parse the status file from a Cylc task.

    This picks up the start and completion timestamps.
    '''
    startTimePattern = re.compile( r'CYLC_JOB_INIT_TIME=(\S+)' )
    endTimePattern = re.compile( r'CYLC_JOB_EXIT_TIME=(\S+)' )

    def __init__( self, statusfile, compiler=None ):
        self.started   = None
        self.completed = None
        self.compiler  = compiler
        super(CylcParser, self).__init__( statusfile )

    def acceptLine( self, line ):
            match = BuildParser.startTimePattern.match( line )
            if match:
              self.started = match.group( 1 )
              return None, None

            match = BuildParser.endTimePattern.match( line )
            if match:
              self.completed = match.group( 1 )
              return None, None

            return None, None

##############################################################################
class BuildParser(CylcParser):
    '''
    Parse the standard output from the Dynamo build system.

    This is done in order to determine which compiler was in use.
    '''
    fortranPattern = re.compile( r'\*\* Chosen (\S+) Fortran compiler' )

    def __init__(self, outfile ):
        self.compiler = None
        super(BuildParser, self).__init__( outfile )

    def acceptLine( self, line ):
        super(BuildParser, self).acceptLine( line )

        match = BuildParser.fortranPattern.match( line )
        if match:
            self.compiler = match.group( 1 )

        return None, None

##############################################################################
class DoxygenParser(Parser):
    '''
    Parse the error stream from the Doxygen tasks.
    '''
    eventPattern        = re.compile( r'([^:]+):(\d+): ([^:]+): (.+)' )
    continuationPattern = re.compile( r'  (.+)' )

    def __init__( self, errfile ):
        self._state = 'lookingForEvent'
        self._currentEvent = None
        super(DoxygenParser, self).__init__( errfile )

    def acceptLine( self, line ):
        if self._state == 'lookingForEvent':
            match = DoxygenParser.eventPattern.match( line )
            if match:
                self._currentEvent = Event( )
                self._currentEvent.setFilename( match.group( 1 ) )
                self._currentEvent.setLineNumber( int(match.group( 2 )) )
                self._currentEvent.setLevel( match.group( 3 ) )
                self._currentEvent.setMessage( match.group( 4 ).strip() )

                self._state = 'lookingForContinuation'
                return None, None

        if self._state == 'lookingForContinuation':
            match = DoxygenParser.continuationPattern.match( line )
            if match:
                self._currentEvent.extendMessage( match.group( 1 ).strip() )
                return None, None
            else:
                self._state = 'lookingForEvent'
                return line, self._currentEvent

        return None, None

##############################################################################
class CompileParser(Parser):
    '''
    All parsers of compiler output inherit this class.
    '''
    __MetaClass__ = ABCMeta

    def __init__( self, compiler, errfile ):
        super(CompileParser, self).__init__( errfile )
        self.compiler = compiler

    @abstractmethod
    def acceptLine( self, line ):
        pass

##############################################################################
class CrayCompileParser(CompileParser):
    '''
    Parse the error stream from the Cray compiler.
    '''
    eventPattern = re.compile( r'ftn-(\d+) crayftn: (\S+) (\S+), File = ([^,]+), Line = (\d+)(?:, Column = (\d+))?' )
    junkPattern  = re.compile( r'Cray Fortran : .+' )

    _levelMap = {'comment': 'comment', \
                 'note'   : 'comment', \
                 'caution': 'beware',  \
                 'warning': 'warning', \
                 'error':   'error'}

    def __init__( self, errfile ):
        self._state = 'lookingForEvent'
        self._currentEvent = None
        self._backlog = []
        super(CrayCompileParser, self).__init__( "Cray Fortran", errfile )

    def acceptLine( self, line ):
        if self._state == 'lookingForEvent':
            match = CrayCompileParser.junkPattern.match( line )
            if match:
                return None, None

            match = CrayCompileParser.eventPattern.match( line )
            if match:
                self._currentEvent = Event()
                self._currentEvent.setEventCode( match.group(1) )
                self._currentEvent.setLevel( CrayCompileParser._levelMap[match.group(2).lower()] )
                self._currentEvent.setFilename( match.group(4) )
                self._currentEvent.setLineNumber( int(match.group( 5 )) )
                if match.group(6) is not None:
                    self._currentEvent.setHighlight( int(match.group( 6 )), \
                                                     None )
                    if len(self._backlog) > 0 \
                       and self._backlog[-1].strip() == '^':
                        self._backlog.pop()

                if len(self._backlog) > 0:
                    self._currentEvent.setSource( self._backlog.pop().rstrip() )
                    self._backlog = []

                self._state = 'lookingForMessage'
                return None, None

            self._backlog.append( line )
            return None, None

        if self._state == 'lookingForMessage':
            self._currentEvent.setMessage( line.strip() )
            self._state = 'lookingForEvent'
            return None, self._currentEvent

        raise Exception( 'Unknown state: {}'.format( self._state ) )

##############################################################################
class GnuCompileParser(CompileParser):
    '''
    Parse the error stream from the GNU compiler.
    '''
    eventPattern   = re.compile( r'([^:]+):(\d+):(\d+):' )
    messagePattern = re.compile( r'([^:]+): (.+)\[-W(.+)\]' )

    _levelMap = {'warning': 'warning', \
                 'error':   'error'}

    def __init__( self, errfile ):
        self._state = 'lookingForEvent'
        self._currentEvent = None
        super(GnuCompileParser, self).__init__( "GNU Fortran", errfile )

    def levelMap( self, level ):
        return self._levelMap[level]

    def acceptLine( self, line ):
        if self._state == 'lookingForEvent':
            match = GnuCompileParser.eventPattern.match( line )
            if match:
                self._currentEvent = Event()
                self._currentEvent.setFilename( match.group(1) )
                self._currentEvent.setLineNumber( int(match.group( 2 )) )
                self._currentEvent.setHighlight( None, \
                                                 int(match.group( 3 )) + 1 )

                self._state = 'lookingForSource'

            return None, None

        if self._state == 'lookingForSource':
            self._currentEvent.setSource( line.rstrip() )
            self._state = 'lookingForMessage'
            return None, None

        if self._state == 'lookingForMessage':
            match = GnuCompileParser.messagePattern.match( line.strip() )
            if match:
                level    = match.group( 1 ).lower()
                message  = match.group( 2 ).rstrip()
                category = match.group( 3 )

                self._currentEvent.setLevel( GnuCompileParser._levelMap[level] )
                self._currentEvent.setMessage( message )
                self._currentEvent.setEventCode( category.lower() )

                self._state = 'lookingForEvent'
                return None, self._currentEvent

            return None, None

        raise Exception( 'Unknown state: {}'.format( self._state ) )

##############################################################################
class IntelCompileParser(CompileParser):
    '''
    Parse the error stream from the Intel compiler.
    '''
    compileMessagePattern = re.compile( r'([^(]+)\((\d+)\): (\S+) #(\d+): (.+)' )
    runMessagePattern     = re.compile ( r'forrtl: (\S+) \((\d+)\): ([^:]+): \((\d+)\): (.+)' )

    _levelMap = {'remark':  'comment', \
                 'warning': 'warning', \
                 'error':   'error'}

    def __init__( self, errfile ):
        self._state = 'lookingForEvent'
        self._currentEvent = None
        super(IntelCompileParser, self).__init__( "Intel Fortran", errfile )

    def levelMap( self, level ):
        return self._levelMap[level]

    def acceptLine( self, line ):
        if self._state == 'lookingForEvent':
            match = IntelCompileParser.compileMessagePattern.match( line )
            if match:
                self._currentEvent = Event()
                self._currentEvent.setFilename( match.group( 1 ) )
                self._currentEvent.setLineNumber( match.group( 2 ) )
                self._currentEvent.setLevel( IntelCompileParser._levelMap[match.group(3).lower()] )
                self._currentEvent.setEventCode( match.group( 4 ) )
                self._currentEvent.setMessage( match.group( 5 ).strip() )

                self._state = 'lookingForSource'

            return None, None

        if self._state == 'lookingForSource':
            self._currentEvent.setSource( line.rstrip() )
            self._state = 'lookingForStart'
            return None, None

        if self._state == 'lookingForStart':
            self._currentEvent.setHighlight( line.count( '-' ), None )
            self._state = 'lookingForEvent'
            return None, self._currentEvent

        raise Exception( 'Unrecognised state: {}'.format( self._state ) )

##############################################################################
class PortlandCompileParser(CompileParser):
    '''
    Parse the error stream from the Portland compiler.
    '''
    compileMessagePattern = re.compile( r'PGF90-([^-]+)-(\d+)-([^(]+) \(([^:)]+)(?:: (\d+))?\)' )

    _levelMap = {'W': 'warning'}

    def __init__( self, errfile ):
        self._state = 'lookingForEvent'
        super(PortlandCompileParser, self).__init__( "Portland Fortran", \
                                                     errfile )

    def acceptLine( self, line ):
        if self._state == 'lookingForEvent':
            match = PortlandCompileParser.compileMessagePattern.match( line )
            if match:
                event = Event()
                event.setLevel( PortlandCompileParser._levelMap[match.group(1)] )
                event.setEventCode( match.group( 2 ) )
                event.setMessage( match.group( 3 ) )
                event.setFilename( match.group( 4 ) )
                if match.group( 5 ) : event.setLineNumber( match.group( 5 ) )

                return None, event

            return None, None

        raise Exception( 'Unrecognised state: {}'.format( self._state ) )

##############################################################################
class RuntimeParser(Parser):
    '''
    All parsers of run-time library checking output inherit this class.
    '''
    __MetaClass__ = ABCMeta

    def __init__( self, compiler, errfile ):
        super(RuntimeParser, self).__init__( errfile )
        self.compiler = compiler

    @abstractmethod
    def acceptLine( self, line ):
        pass

##############################################################################
class GnuRunParser(RuntimeParser):
    '''
    Parse the error stream from the GNU run-time.
    '''
    runContextPattern = re.compile( r'At line (\d+) of file (.+)' )
    runMessagePattern = re.compile( r'Fortran runtime ([^:]+): (.+)' )

    def __init__( self, errfile ):
        self._state = 'lookingForEvent'
        self._currentEvent = None
        super(GnuRunParser, self).__init__( 'GNU Fortran', errfile )

    def acceptLine( self, line ):
        if self._state == 'lookingForEvent':
            match = GnuRunParser.runContextPattern.match( line )
            if match:
                self._currentEvent = Event()
                self._currentEvent.setLineNumber( match.group( 1 ) )
                self._currentEvent.setFilename( match.group( 2 ) )

                self._state = 'lookingForMessage'

            return None, None

        if self._state == 'lookingForMessage':
            match = GnuRunParser.runMessagePattern.match( line )
            if match:
                self._currentEvent.setLevel( match.group( 1 ) )
                self._currentEvent.setMessage( match.group( 2 ) )

                self._state = 'lookingForEvent'
                return None, self._currentEvent

            return None, None

        raise Exception( 'Unknown state: {}'.format( self._state ) )

##############################################################################
class IntelRunParser(RuntimeParser):
    '''
    Parse the error stream from the Intel run-time.
    '''
    runMessagePattern = re.compile( r'forrtl: (\S+) \((\d+)\): ([^:]+): \((\d+)\): (.+)' )

    def __init__( self, errfile ):
        super(IntelRunParser, self).__init__( 'Intel Fortran', errfile )

    def acceptLine( self, line ):
        print(line)
        match = IntelRunParser.runMessagePattern.match( line )
        if match:
            level      = match.group( 1 )
            message    = match.group( 5 )

            event = Event()
            event.setLevel( level )
            event.setEventCode( match.group(2) )
            event.setMessage( message )

            return None, event

        return None, None

##############################################################################
class PortlandRunParser(RuntimeParser):
    '''
    Parse the error stream from the Portland run-time.
    '''
    def __init__( self, errfile ):
        super(PortlandRunParser, self).__init__( 'Portland Fortran', errfile )

    def acceptLine( self, line ):
        raise NotImplementedError()
