
!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief   This module handles calculation of fields sent to the coupler
!> @details Here, we set up fields, essentailly as diagnostics, which are
!           to be passed to external models via an external coupler which
!           deals with any regridding, interpolation, etc.

module coupler_diagnostics_mod
  use field_mod,                     only: field_type
  use field_collection_mod,          only: field_collection_type
  use clock_mod,                     only: clock_type
  use constants_mod,                 only: str_def, l_def, i_def, r_def, imdi, &
                                           rmdi, i_timestep
  use log_mod,                       only: log_event,       &
                                           LOG_LEVEL_INFO,  &
                                           LOG_LEVEL_DEBUG, &
                                           LOG_LEVEL_ERROR, &
                                           log_scratch_space
  use io_config_mod,                 only: checkpoint_read
#if defined(UM_PHYSICS)
  use cv_run_mod,                    only: l_param_conv
  use jules_control_init_mod,        only: n_sea_tile, first_sea_tile,   &
                                           first_sea_ice_tile,           &
                                           n_sea_ice_tile
  use driver_water_constants_mod,    only: latent_heat_h2o_condensation, &
                                           latent_heat_h2o_fusion
#endif

  use convert_to_celsius_kernel_mod, only: convert_to_celsius_kernel_type
  use convert_to_marine_fraction_mod, only: convert_to_marine_fraction_type

  implicit none

  private
  ! workspace used for coupling field calculation
  type( field_type )                 :: cpl_field1, cpl_field2, cpl_field3,    &
                                        cpl_field4, cpl_field5
  type( field_type )                 :: cpl_field1_si, cpl_field2_si,          &
                                        cpl_field3_si

  ! Sea ice fractions used in the previous timestep
  ! (i.e. not updated by the coupling)
  ! These ice fractions are stored as a fraction of
  ! the marine portion of the grid box
  type( field_type )                 :: sea_ice_frac_previous
  type( field_type )                 :: sea_frac_previous


  ! Flag to indicate that pre-dump preparation is required for coupling fields
  logical :: ldump_prep

  ! Accumulated timestep count over which coupling fields have been accumulated
  ! used for time meaning of coupling fields
  real(r_def) :: acc_step


#if !defined(UM_PHYSICS)
  !
  ! Dummy variables required when NOT running with UM_PHYSICS
  !
  logical ::  l_param_conv = .false.
  ! index of the sea tile set here to prevent using jules_control_init_mod
  ! when UM physics is not used
  integer(i_def),parameter              :: n_sea_tile = imdi
  ! index of the first sea and tile
  integer(i_def), parameter             :: first_sea_tile = imdi
  ! other indices for sea ice
  integer(i_def), parameter             :: first_sea_ice_tile = imdi
  integer(i_def), parameter             :: n_sea_ice_tile = imdi
  ! latent heat of condensation
  real(r_def), parameter                :: latent_heat_h2o_condensation = rmdi
#endif

  public cpl_diagnostics, cpl_reset_field, initialise_extra_coupling_fields
  public save_sea_ice_frac_previous, acc_step, ldump_prep, ice_sheet_mass
  contains

  !> @brief assignes data to coupling fields
  !> @param[in, out] fld coupling field
  !> @param[in] depository field collection - all fields
  !> @param[in] clock
  subroutine cpl_diagnostics(fld, depository, clock)

   use multi_extract_kernel_mod,    only: multi_extract_kernel_type
   use value_based_mask_kernel_mod, only: value_based_mask_kernel_type
   use mesh_mod,                    only: mesh_type
   use geometric_constants_mod,     only: get_latitude
   use field_minmax_alg_mod,        only: log_field_minmax

   implicit none
   type( field_type ), intent(inout)            :: fld
   type( field_collection_type ), intent(in)    :: depository
   class(clock_type), intent(in)                :: clock
   ! Local variables
   logical(l_def)                               :: lfail    ! failure flag
   !local pointers
   type( field_type ), pointer                  :: fld_ptr1 => null()
   type( field_type ), pointer                  :: fld_ptr2 => null()
   type( field_type ), pointer                  :: fld_ptr3 => null()
   type( field_type ), pointer                  :: fld_ptr4 => null()
   type( field_type ), pointer                  :: latitude => null()
   type(mesh_type), pointer                     :: mesh => null()

   ! Reciprocal of number of accumulated time steps
   real(r_def)                                  :: r_acc_step

   lfail = .false.

   ! We need to detect if this is the first step after a start/restart.
   ! If it is then we can either load coupling fields from a
   ! checkpoint file, if one exists, or we can simply initialise all
   ! coupling fields to zero if there are no initial values to work with.
   if (clock%get_step() ==  clock%get_first_step() ) then

      if (checkpoint_read) then
         ! Take fields from restart dump.
         ! There should actually be nothing to do here since all relevant fields
         ! should be naturally populated from from the dump read process, so
         ! we merely output a message to that effect.
         call log_field_minmax( LOG_LEVEL_DEBUG, 'cpl_diagnostics: from restart', fld )
      else
         ! Initialise coupling fields to zero in the absence of an initial dump.
         call cpl_reset_field(fld)
         write(log_scratch_space, '(2A)' ) "cpl_diagnostics: variable ",          &
                                   trim(fld%get_name())//": set to 0"
         call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      endif

      if (fld%get_name() == "lf_greenland") then
          !Make a mask of the Northern Hemisphere
          ! Get the mesh
          mesh => fld%get_mesh()
          ! Get the latitude field
          latitude => get_latitude(mesh%get_id())
          call invoke(value_based_mask_kernel_type(fld, latitude, &
                                                0.0_r_def, 2.0_r_def))
      endif
      if (fld%get_name() == "lf_antarctic") then
          !Make a mask of the Southern Hemisphere
          ! Get the mesh
          mesh => fld%get_mesh()
          ! Get the latitude field
          latitude => get_latitude(mesh%get_id())
          call invoke(value_based_mask_kernel_type(fld, latitude, &
                                                -2.0_r_def, 0.0_r_def))
      endif
   else
      ! We just accumulate coupling field contributions.

      select case(fld%get_name())
         case ("lf_taux")
            call depository%get_field("taux_ssi", fld_ptr1)
            call invoke(inc_X_plus_Y( fld, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_tauy")
            call depository%get_field("tauy_ssi", fld_ptr1)
            call invoke(inc_X_plus_Y( fld, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_solar")
            call depository%get_field("sw_up_tile", fld_ptr1)
            call depository%get_field("sw_down_surf", fld_ptr2)
            call invoke(                                                       &

                  ! Extract SW up (SW_up = cpl_field1)
                  multi_extract_kernel_type(cpl_field1, fld_ptr1,              &
                                      first_sea_tile, n_sea_tile),             &

                  ! Use SW down (SW_down = fld_ptr2)

                  ! Now we need to combine the above fluxes
                  ! net_SW_down = SW_down - SW_up
                  ! (net_SW_down = cpl_field5)
                  X_minus_Y(cpl_field5, fld_ptr2, cpl_field1),                 &

                  ! Scale by sea area fraction so that this flux is an
                  ! average over the whole marine portion of the grid box
                  ! (net_SW_scaled = cpl_field2)
                  X_times_Y( cpl_field2, cpl_field5, sea_frac_previous ),      &

                  ! Multiply by the length of the timestep as part of the
                  ! time averaging process
                  inc_X_plus_Y( fld, cpl_field2 ))

            fld_ptr1 => null()
            fld_ptr2 => null()
         case ("lf_heatflux")
            call depository%get_field("lw_up_tile", fld_ptr1)
            call depository%get_field("lw_down_surf", fld_ptr2)
            call depository%get_field("tile_heat_flux", fld_ptr3)
            call depository%get_field("tile_moisture_flux", fld_ptr4)

            ! Concoct our heatflux value from various contributing fields.
            call invoke(                                                       &

                  ! Extract LW up (LW_up = cpl_field1)
                  multi_extract_kernel_type(cpl_field1, fld_ptr1,              &
                                     first_sea_tile, n_sea_tile),              &

                  ! Use LW down (LW_down = fld_ptr2)

                  ! Extract heat flux (heat_flux = cpl_field3)
                  multi_extract_kernel_type(cpl_field3, fld_ptr3,              &
                                     first_sea_tile, n_sea_tile),              &

                  ! Extract evaporative mass flux
                  ! (evap_mass = cpl_field2)
                  multi_extract_kernel_type(cpl_field2, fld_ptr4,              &
                                     first_sea_tile, n_sea_tile),              &

                  ! Convert evaporative mass flux to energy flux
                  ! (evap_energy = cpl_field4)
                  a_times_X(cpl_field4, latent_heat_h2o_condensation,          &
                                     cpl_field2),                              &

                  ! Now we need to combine the above fluxes
                  ! net_heat_down = LW_down - LW_up - heat_flux - evap_energy
                  ! (net_heat_down = cpl_field5)
                  X_minus_Y(cpl_field5, fld_ptr2, cpl_field1),                 &
                  inc_X_minus_Y(cpl_field5, cpl_field3),                       &
                  inc_X_minus_Y(cpl_field5, cpl_field4),                       &

                  ! Scale by sea area fraction so that this flux is an
                  ! average over the whole marine portion of the grid box
                  ! (net_heat_scaled = cpl_field2)
                  X_times_Y( cpl_field2, cpl_field5, sea_frac_previous ),      &

                  ! Multiply by the length of the timestep as part of the
                  ! time averaging process
                  inc_X_plus_Y( fld, cpl_field2 ))


            fld_ptr1 => null()
            fld_ptr2 => null()
            fld_ptr3 => null()
            fld_ptr4 => null()
         case ("lf_train")
            !large scale rain
            call depository%get_field("ls_rain", fld_ptr1)

            if(l_param_conv) then
               !convective rain
               call depository%get_field("conv_rain", fld_ptr2)
               !total
               call invoke(X_plus_Y( cpl_field1, fld_ptr1, fld_ptr2),          &
                           inc_X_plus_Y( fld, cpl_field1 ))
               fld_ptr2 => null()
            else
               call invoke(inc_X_plus_Y( fld, fld_ptr1 ))
            endif

            fld_ptr1 => null()
         case ("lf_tsnow")
            !large scale snow
            call depository%get_field("ls_snow", fld_ptr1)

            if(l_param_conv) then
               !convective snow
               call depository%get_field("conv_snow", fld_ptr2)
               !total
               call invoke(X_plus_Y( cpl_field1, fld_ptr1, fld_ptr2),          &
                           inc_X_plus_Y( fld, cpl_field1 ))
               fld_ptr2 => null()
            else
               call invoke(inc_X_plus_Y( fld, fld_ptr1 ))
            endif

            fld_ptr1 => null()
         case ("lf_w10")
            !10m wind
            call depository%get_field("wspd10m", fld_ptr1)
            call invoke(inc_X_plus_Y( fld, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_evap")
            call depository%get_field("tile_moisture_flux", fld_ptr1)

            ! Extract the oceanic evaporation from the ocean tile
            call invoke( multi_extract_kernel_type(cpl_field1, fld_ptr1,       &
                                             first_sea_tile, n_sea_tile ),     &

               ! Convert oceanic evaporation to be as a fraction of the marine
               ! portion of the grid box
               ! evaporation_marine_fraction(cpl_field2) =
               ! evaporation(cpl_field1) * sea_fraction_of_marine(sea_frac_previous)
               X_times_Y( cpl_field2, cpl_field1, sea_frac_previous ),         &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_Y( fld, cpl_field2 ))
            fld_ptr1 => null()
         case ("lf_topmelt")
            call depository%get_field("snowice_melt", fld_ptr1)

            ! Extract the sea ice top melt from the snowice_melt which is on
            ! all tiles
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert top melt into an equivalent energy flux
               ! (i.e. from kg m-2 s-1 to W m-2)
               ! top_melt_flux(cpl_field2_si) =
               !                latent_heat_h2o_fusion * top_melt(cpl_field1_si)
               a_times_X( cpl_field2_si, latent_heat_h2o_fusion,               &
                                               cpl_field1_si ),                &

               ! Convert top melt to be as a fraction of the marine portion
               ! of the grid box
               ! top_melt_marine_fraction(cpl_field3_si) =
               !               top_melt_flux(cpl_field2_si) *
               !               sea_ice_fraction_of_marine(sea_ice_frac_previous)
               X_times_Y( cpl_field3_si, cpl_field2_si,                        &
                                                      sea_ice_frac_previous ), &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_Y( fld, cpl_field3_si ))
            fld_ptr1 => null()
         case ("lf_iceheatflux")
            call depository%get_field("surf_ht_flux", fld_ptr1)

            ! Extract the sea ice surface to sub-surface heat flux from the
            ! surf_ht_flux which is on all tiles
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert surface heat flux to be as a fraction of the marine
               ! portion of the grid box.
               ! surf_heat_marine_fraction(cpl_field2_si) =
               !               surf_ht_flux(cpl_field1_si) *
               !               sea_ice_fraction_of_marine(sea_ice_frac_previous)
               X_times_Y( cpl_field2_si, cpl_field1_si,                        &
                                                      sea_ice_frac_previous ), &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_Y( fld, cpl_field2_si ))
            fld_ptr1 => null()
         case ("lf_sublimation")
            call depository%get_field("snowice_sublimation", fld_ptr1)

            ! Extract the sea ice sublimation from the snowice_sublimation
            ! which is on all tiles
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert sublimation to be as a fraction of the marine
               ! portion of the grid box
               ! sublimation_marine_fraction(cpl_field2_si) =
               !               sublimation(cpl_field1_si) *
               !               sea_ice_fraction_of_marine(sea_ice_frac_previous)
               X_times_Y( cpl_field2_si, cpl_field1_si,                        &
                                                      sea_ice_frac_previous ), &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_Y( fld, cpl_field2_si ))
            fld_ptr1 => null()
         case ("lf_iceskint")
            call depository%get_field("tile_temperature", fld_ptr1)

            ! Extract the sea ice skin temperature from the tile temperature
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert from Kelvin to Celsius
               ! (NEMO is expecting the data in Celsius)
               convert_to_celsius_kernel_type(cpl_field2_si, cpl_field1_si,    &
                                              n_sea_ice_tile),                 &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_Y( fld, cpl_field2_si ))
            fld_ptr1 => null()
         case ("lf_pensolar")
            call depository%get_field('sea_ice_pensolar', fld_ptr1)

            ! Convert penetrating solar to be as a fraction of the marine
            ! portion of the grid box
            ! penetrating_solar_marine_fraction(cpl_field2_si) =
            !               sea_ice_penetrating_solar(fld_ptr1) *
            !               sea_ice_fraction_of_marine(sea_ice_frac_previous)
            call invoke( X_times_Y( cpl_field2_si, fld_ptr1,                   &
                                                      sea_ice_frac_previous ), &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_Y( fld, cpl_field2_si ))
            fld_ptr1 => null()
         case ("lf_rsurf")
            !surface river runoff
            call depository%get_field("surface_runoff", fld_ptr1)
            call invoke(inc_X_plus_Y( fld, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_rsub")
            !sub-surface river runoff
            call depository%get_field("sub_surface_runoff", fld_ptr1)
            call invoke(inc_X_plus_Y( fld, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_greenland")
            !Special case as this is an instantaneous field (not incremented)
         case ("lf_antarctic")
            !Special case as this is an instantaneous field (not incremented)
         case default
            lfail = .true.
            write(log_scratch_space, '(3A)' )                                  &
                                         "PROBLEM cpl_diagnostics variable ",  &
                                trim(fld%get_name()), ": can not assign value"
            call log_event( log_scratch_space, LOG_LEVEL_INFO )
      end select

      ! If this is the last accumulation before the end of the run, then
      ! there will be no coupling exchange with these values. They must be
      ! preserved in the restart dump in the exact form in which they will be
      ! used on the first coupling exchange of any future cycle or new run which starts
      ! from that dump. We can NOT simply allow the accumulated values to
      ! be stored because:
      ! a) any subsequent run using the dump would have to be clairvoyant
      !    enough to know the coupling frequency and timestep used in the
      !    run which generated a given dump
      ! b) any run wishing to use the dump would be constrained to use
      !    the same timestep and coupling frequency as the run which generated the dump
      ! c) it would be impossible to alter timestep or coupling frequencies when starting
      !    from an existing dump without wrecking the values used for coupling.
      if (ldump_prep) then

        ! Calculate reciprocal of acc_step
        r_acc_step = 1.0/acc_step
        call invoke(inc_a_times_X( r_acc_step, fld ))
      endif

   endif

   if(lfail) then
      write(log_scratch_space, * ) "ERRORS in cpl_diagnostics"
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
   endif

  end subroutine cpl_diagnostics

  !> @brief sets value of fld to 0
  !> @param[in, out] fld coupling field
  subroutine cpl_reset_field(fld)
   implicit none
   type( field_type ), intent(inout) :: fld

   call invoke(setval_c(fld, 0.0_r_def))

  end subroutine cpl_reset_field

  subroutine initialise_extra_coupling_fields(fld_cpld_fs, sice_space)
  !> @brief initialises temporary coupling work fields
  !> @param[in] fld_cpld_fs: 2D function space
  !> @param[in] sice_space : sea ice function space

    use function_space_mod,             only: function_space_type

    implicit none

    type(function_space_type), intent(in), pointer :: fld_cpld_fs
    type(function_space_type), intent(in), pointer :: sice_space

    ! initialize 2D scratch variables
    call cpl_field1%initialise( vector_space=fld_cpld_fs, name="cpl_field1_W3" )
    call cpl_field2%initialise( vector_space=fld_cpld_fs, name="cpl_field2_W3" )
    call cpl_field3%initialise( vector_space=fld_cpld_fs, name="cpl_field3_W3" )
    call cpl_field4%initialise( vector_space=fld_cpld_fs, name="cpl_field4_W3" )
    call cpl_field5%initialise( vector_space=fld_cpld_fs, name="cpl_field5_W3" )

    ! initialise sea ice scratch variables
    call cpl_field1_si%initialise( vector_space = sice_space,             &
                                        name="cpl_field1_sea_ice_W3" )
    call cpl_field2_si%initialise( vector_space = sice_space,             &
                                        name="cpl_field2_sea_ice_W3" )
    call cpl_field3_si%initialise( vector_space = sice_space,             &
                                        name="cpl_field3_sea_ice_W3" )

    ! Initialise other fields used in coupling
    call sea_ice_frac_previous%initialise( vector_space = sice_space,        &
                                        name="sea_ice_frac_previous" )
    call sea_frac_previous%initialise( vector_space = fld_cpld_fs,           &
                                        name="sea_frac_previous" )

  end subroutine initialise_extra_coupling_fields

  subroutine save_sea_ice_frac_previous(depository)
  !> @brief Save the sea and sea ice fractions from the previous timestep prior
  !> @brief to recieving a new sea ice fraction from the coupler.
  !> @brief These are saved as a marine fraction
  !> @brief             (rather than whole grid box fraction)

    implicit none
    type( field_collection_type ), intent(in)    :: depository

    !local variables
    type( field_type ), pointer :: tile_fraction_ptr       => null()

    call depository%get_field('tile_fraction', tile_fraction_ptr)
    call invoke(convert_to_marine_fraction_type(sea_ice_frac_previous, &
                                           sea_frac_previous,          &
                                           tile_fraction_ptr,          &
                                           first_sea_ice_tile,         &
                                           n_sea_ice_tile,             &
                                           first_sea_tile))

  end subroutine save_sea_ice_frac_previous

  !> @brief Calculate the volume of snow on ice tile in region defined by mask
  !> @param[in] mask_field - the coupling field (contains the region mask)
  !> @param[in] snow_mass_on_tiles Pointer to the snow mass on tiles field
  !> @param[in] tile_fraction Pointer to the tile fraction field
  !> @param[out] imass Total snow mass as scalar
  subroutine ice_sheet_mass(mask_field, snow_mass_on_tiles, tile_fraction, imass)

    use geometric_constants_mod,    only: get_da_at_w2
    use jules_surface_types_mod,    only: ice
    use mesh_mod,                   only: mesh_type
    use multi_extract_kernel_mod,   only: multi_extract_kernel_type
    use physical_op_constants_mod,  only: get_da_msl_proj

    implicit none

    type( field_type ),          intent(in) :: mask_field
    type( field_type ), pointer, intent(in) :: snow_mass_on_tiles
    type( field_type ), pointer, intent(in) :: tile_fraction
    real(r_def),                 intent(out):: imass

    !local variables
    type( field_type ), pointer        :: dA => null()
    type(mesh_type), pointer           :: mesh => null()


    ! Get the mesh
    mesh => snow_mass_on_tiles%get_mesh()

    ! Calculate the grid cell areas (dA)
    dA => get_dA_msl_proj( mesh%get_id() )

    call invoke(                                                             &
                ! Extract snow mass on ice tile into cpl_field1
                multi_extract_kernel_type(cpl_field1,                        &
                                          snow_mass_on_tiles, ice, 1),       &

                !Extract tile_fraction on ice tile only
                multi_extract_kernel_type(cpl_field2, tile_fraction,         &
                                          ice, 1),                           &

                !Multiply fld (latitude mask) by tile fraction
                X_times_Y(cpl_field5, mask_field, cpl_field2),               &

                ! Multiply by cell area
                inc_X_times_Y(cpl_field5, dA),                               &

                !Multiply snow mass by masked area and sum
                X_innerproduct_Y(imass, cpl_field1, cpl_field5)              &
                )

  end subroutine ice_sheet_mass

end module coupler_diagnostics_mod
