!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Write checksums to file for input fields
module sci_checksum_alg_mod

  implicit none

  private
  public :: checksum_alg

contains
  !> @brief Computes the checksum of fields as the inner product:
  !>        for field X, checksum = sum(X.X)
  !>        Writes the checksums to a filename generated from the model name
  !> @param[in] model_name Name of the model to checksum
  !> @param[in] field1 Optional first field to checksum
  !> @param[in] name1 Optional name of the first field to checksum
  !> @param[in] field2 Optional second field to checksum
  !> @param[in] name2 Optional name of the second field to checksum
  !> @param[in] field3 Optional third field to checksum
  !> @param[in] name3 Optional name of the third field to checksum
  !> @param[in] field4 Optional fourth field to checksum
  !> @param[in] name4 Optional name of the fourth field to checksum
  !> @param[in] field_bundle Optional array of fields to checksum
  !> @param[in] name4 Optional name of the array of fields to checksum
  !> @param[in] field_collection Optional collection of fields to checksum
  subroutine checksum_alg(model_name,                   &
                          field1, name1, field2, name2, &
                          field3, name3, field4, name4, &
                          field_bundle, bundle_name,    &
                          field_collection)

    use constants_mod,        only: i_def, r_def, str_max_filename
    use field_mod,            only: field_type
    use field_parent_mod,     only: field_parent_type
    use field_collection_iterator_mod, &
                              only: field_collection_iterator_type
    use field_collection_mod, only: field_collection_type
    use io_utility_mod,       only: claim_io_unit, release_io_unit
    use lfric_mpi_mod,        only: global_mpi
    use log_mod,              only: log_event, &
                                    LOG_LEVEL_ERROR


    implicit none

    character(len=*), intent(in)           :: model_name
    type(field_type), intent(in), optional :: field1, field2, field3, field4
    character(len=*), intent(in), optional :: name1, name2, name3, name4
    type(field_type), intent(in), optional :: field_bundle(:)
    character(len=*), intent(in), optional :: bundle_name
    type(field_collection_type), &
                      intent(in), optional :: field_collection

    integer(i_def)                  :: stat
    real(r_def)                     :: chksum1, chksum2, chksum3, chksum4
    real(r_def), allocatable        :: chksum_bundle(:)
    character(len=str_max_filename) :: fname
    integer(i_def)                  :: bundle_size
    integer(i_def)                  :: ibundle
    integer(i_def)                  :: unit
    character(len=23), parameter    :: kgo_str = 'Inner product checksum '

    type(field_collection_iterator_type) :: iter
    real(r_def), allocatable             :: chksum_collection(:)
    integer(i_def)                       :: iter_index
    class(field_parent_type), pointer    :: fld
    type(field_type), pointer            :: fld_actual

    ! Calculate checksums (on all ranks)
    if ( present(field1) ) call invoke( X_innerproduct_X(chksum1, field1) )
    if ( present(field2) ) call invoke( X_innerproduct_X(chksum2, field2) )
    if ( present(field3) ) call invoke( X_innerproduct_X(chksum3, field3) )
    if ( present(field4) ) call invoke( X_innerproduct_X(chksum4, field4) )

    if (present(field_bundle)) then
      bundle_size=size(field_bundle)
      allocate(chksum_bundle(bundle_size))
      do ibundle=1,bundle_size
        call invoke( &
              X_innerproduct_X(chksum_bundle(ibundle), field_bundle(ibundle)) )
      end do
    end if

    if (present(field_collection)) then
      allocate( chksum_collection( field_collection%get_length() ) )
      ! Loop through fields and generate checksums
      call iter%initialise(field_collection)
      iter_index = 0
      do
        if ( .not.iter%has_next() ) exit
        fld => iter%next()
        iter_index = iter_index + 1
        select type(fld)
          type is (field_type)
            ! PSyclone needs to know the actual rather than abstract type
            fld_actual => fld
            call invoke( &
              X_innerproduct_X(chksum_collection(iter_index), fld_actual) )
        end select
      end do
    end if

    ! Write checksums to file (only on rank 0)
    if ( global_mpi%get_comm_rank() == 0 ) then
      unit = claim_io_unit()
      write(fname,'(A,A)') trim(model_name),'-checksums.txt'
      open( unit, file=fname, status="replace", iostat=stat)
      if (stat /= 0) then
        call log_event( "Unable to open checksum file", LOG_LEVEL_ERROR )
      end if
      if ( present(field1) .and. present(name1) ) &
        write(unit, '(A,A,A,Z16)' ) kgo_str,trim(name1),' = ',chksum1
      if ( present(field2) .and. present(name2) ) &
        write(unit, '(A,A,A,Z16)' ) kgo_str,trim(name2),' = ',chksum2
      if ( present(field3) .and. present(name3) ) &
        write(unit, '(A,A,A,Z16)' ) kgo_str,trim(name3),' = ',chksum3
      if ( present(field4) .and. present(name4) ) &
        write(unit, '(A,A,A,Z16)' ) kgo_str,trim(name4),' = ',chksum4
      if ( present(field_bundle) .and. present(bundle_name) ) then
        do ibundle=1,bundle_size
          write(unit, '(A,A,I1,A,Z16)' ) &
            kgo_str,trim(bundle_name),ibundle,' = ', chksum_bundle(ibundle)
        end do
        deallocate(chksum_bundle)
      end if
      if (present(field_collection)) then
        ! Loop through fields and write checksums to file
        call iter%initialise(field_collection)
        iter_index = 0
        do
          if ( .not.iter%has_next() ) exit
          fld => iter%next()
          iter_index = iter_index + 1
          select type(fld)
            type is (field_type)
              write( unit, '(A,A,A,Z16)' ) &
                kgo_str,trim(fld%get_name()),' = ',chksum_collection(iter_index)
          end select
        end do
        deallocate(chksum_collection)
      end if
      close( unit )
      call release_io_unit(unit)
    end if

  end subroutine checksum_alg
end module sci_checksum_alg_mod
