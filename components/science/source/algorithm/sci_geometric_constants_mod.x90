!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
!> @brief Pre-computes and stores various geometric objects.
!>
!> @details This module controls the set up of various objects relating to
!>          the geometry of the mesh that do not change during a run. These
!>          objects are accessed from this module through appropriate 'get'
!>          functions.
!-------------------------------------------------------------------------------

module sci_geometric_constants_mod

  ! Infrastructure
  use constants_mod,                      only: i_def, r_def, l_def, str_def
  use extrusion_mod,                      only: TWOD, PRIME_EXTRUSION
  use field_mod,                          only: field_type
  use fs_continuity_mod,                  only: W1, W2, W2H, W3, Wtheta
  use function_space_collection_mod,      only: function_space_collection
  use function_space_mod,                 only: function_space_type
  use integer_field_mod,                  only: integer_field_type
  use inventory_by_mesh_mod,              only: inventory_by_mesh_type
  use inventory_by_local_mesh_mod,        only: inventory_by_local_mesh_type
  use io_config_mod,                      only: subroutine_timers
  use local_mesh_mod,                     only: local_mesh_type
  use log_mod,                            only: log_event, LOG_LEVEL_ERROR
  use mesh_collection_mod,                only: mesh_collection
  use mesh_mod,                           only: mesh_type
  use timer_mod,                          only: timer

  ! Configuration
  use finite_element_config_mod,          only: element_order_h, &
                                                element_order_v

  implicit none

  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them

  ! ========================================================================== !
  ! Inventories for use in the rest of the model
  ! ========================================================================== !
  ! Finite element representations of coordinates
  type(inventory_by_mesh_type),       target :: chi_inventory
  type(inventory_by_mesh_type),       target :: panel_id_inventory
  type(inventory_by_mesh_type)               :: extended_chi_inventory

  ! Basic geometric entities
  type(inventory_by_mesh_type)               :: dA_at_w2_inventory
  type(inventory_by_mesh_type)               :: dz_w3_inventory
  type(inventory_by_mesh_type)               :: detj_at_w3_inventory
  type(inventory_by_mesh_type)               :: detj_at_w2_inventory
  type(inventory_by_mesh_type)               :: delta_at_wtheta_inventory
  type(inventory_by_mesh_type)               :: dx_at_w2_inventory
  type(inventory_by_mesh_type)               :: dz_at_wtheta_inventory
  type(inventory_by_local_mesh_type)         :: dA_msl_proj_inventory

  ! 2D Longitude/latitude fields
  type(inventory_by_local_mesh_type), target :: lat_w3_inventory
  type(inventory_by_local_mesh_type), target :: lat_w2_inventory
  type(inventory_by_local_mesh_type), target :: lat_w2h_inventory
  type(inventory_by_local_mesh_type), target :: long_w3_inventory
  type(inventory_by_local_mesh_type), target :: long_w2_inventory
  type(inventory_by_local_mesh_type), target :: long_w2h_inventory

  ! Heights of DoFs
  type(inventory_by_mesh_type),       target :: height_w1_inventory
  type(inventory_by_mesh_type),       target :: height_w2_inventory
  type(inventory_by_mesh_type),       target :: height_w2h_inventory
  type(inventory_by_mesh_type),       target :: height_w3_inventory
  type(inventory_by_mesh_type),       target :: height_wth_inventory

  ! Face selectors, used to avoid doubly-iterating over horizontal faces
  type(inventory_by_local_mesh_type)         :: face_selector_ew_inventory
  type(inventory_by_local_mesh_type)         :: face_selector_ns_inventory

  ! ========================================================================== !
  ! Public functions for accessing the module contents
  ! ========================================================================== !

  public :: final_geometric_constants
  public :: get_panel_id
  public :: get_coordinates
  public :: get_extended_coordinates
  public :: get_dA_at_w2
  public :: get_detj_at_w3
  public :: get_detj_at_w2
  public :: get_dz_w3
  public :: get_delta_at_wtheta
  public :: get_dx_at_w2
  public :: get_dz_at_wtheta
  public :: get_dA_msl_proj
  public :: get_height
  public :: get_latitude
  public :: get_longitude
  public :: get_face_selector_ew
  public :: get_face_selector_ns
  public :: get_chi_inventory
  public :: get_panel_id_inventory

  ! Private routines for creating constants
  private :: compute_latlon
  private :: compute_face_selectors

contains

  ! ========================================================================== !
  ! Private routines for creating some particular constants
  ! ========================================================================== !

  !> @brief Private routine for computing longitude and latitude fields
  !> @param[in,out] long_inventory   Inventory containing longitude fields
  !> @param[in,out] lat_inventory    Inventory containing latitude fields
  !> @param[in]     mesh             Mesh used to determine local mesh for
  !!                                 computing the fields for
  !> @param[in]     fs_id            Identifier for function space to compute
  !!                                 longitude and latitude fields for
  subroutine compute_latlon(long_inventory, lat_inventory, mesh, fs_id)

    use base_mesh_config_mod,               only: f_lat, geometry, &
                                                  geometry_spherical
    use idealised_config_mod,               only: f_lon
    use sci_compute_latlon_kernel_mod,      only: compute_latlon_kernel_type

    implicit none

    type(inventory_by_local_mesh_type), intent(inout) :: long_inventory
    type(inventory_by_local_mesh_type), intent(inout) :: lat_inventory
    type(mesh_type),                       intent(in) :: mesh
    integer(kind=i_def),                   intent(in) :: fs_id

    ! Internal variables
    type(mesh_type),           pointer :: twod_mesh
    type(local_mesh_type),     pointer :: local_mesh
    type(field_type),          pointer :: lat
    type(field_type),          pointer :: long
    type(field_type),          pointer :: chi(:)
    type(field_type),          pointer :: panel_id
    type(function_space_type), pointer :: twod_fs

    if ( subroutine_timers ) call timer('runtime_constants.geometric')

    twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
    local_mesh => mesh%get_local_mesh()
    twod_fs => function_space_collection%get_fs(twod_mesh, element_order_h, &
                                                element_order_v, fs_id)
    call lat_inventory%add_field(lat, twod_fs, local_mesh)
    call long_inventory%add_field(long, twod_fs, local_mesh)

    if ( geometry == geometry_spherical ) then
      chi => get_coordinates(mesh%get_id())
      panel_id => get_panel_id(mesh%get_id())
      call invoke( compute_latlon_kernel_type(lat, long, chi, panel_id) )
    else
      call invoke( setval_c(lat, f_lat),                                       &
                   setval_c(long, f_lon) )
    end if

    if ( subroutine_timers ) call timer('runtime_constants.geometric')

  end subroutine compute_latlon

  !> @brief Private routine for computing face selectors fields
  !> @param[in,out] ew_inventory     Inventory containing East-West selectors
  !> @param[in,out] ns_inventory     Inventory containing North-South selectors
  !> @param[in]     mesh             Mesh used to determine local mesh for
  !!                                 computing the fields for
  subroutine compute_face_selectors(mesh)

    use reference_element_mod,              only: S, W
    use sci_set_any_int_dof_kernel_mod,     only: set_any_int_dof_kernel_type
    use sci_face_selector_kernel_mod,       only: face_selector_kernel_type

    implicit none

    type(mesh_type),                       intent(in) :: mesh

    ! Internal variables
    type(mesh_type),           pointer :: twod_mesh
    type(local_mesh_type),     pointer :: local_mesh
    type(integer_field_type),  pointer :: face_selector_ew
    type(integer_field_type),  pointer :: face_selector_ns
    type(integer_field_type)           :: face_counter
    type(function_space_type), pointer :: w2h_2d_fs
    type(function_space_type), pointer :: w3_2d_fs

    if ( subroutine_timers ) call timer('runtime_constants.geometric')

    twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
    local_mesh => mesh%get_local_mesh()
    w2h_2d_fs => function_space_collection%get_fs(twod_mesh, 0, 0, W2H)
    w3_2d_fs => function_space_collection%get_fs(twod_mesh, 0, 0, W3)

    ! Temporary W2H field, tracking the count for each face
    call face_counter%initialise( w2h_2d_fs )

    call face_selector_ew_inventory%add_field(                                 &
            face_selector_ew, w3_2d_fs, local_mesh                             &
    )
    call face_selector_ns_inventory%add_field(                                 &
            face_selector_ns, w3_2d_fs, local_mesh                             &
    )

    call invoke( int_setval_c(face_counter, 0),                                &
                 ! Do West and South faces for every cell
                 int_setval_c(face_selector_ew, 1),                            &
                 int_setval_c(face_selector_ns, 1),                            &
                 set_any_int_dof_kernel_type(face_counter, W, 1),              &
                 set_any_int_dof_kernel_type(face_counter, S, 1),              &
                 ! Determine where North and East faces are needed
                 face_selector_kernel_type(face_selector_ew,                   &
                                           face_selector_ns,                   &
                                           face_counter ) )

    if ( subroutine_timers ) call timer('runtime_constants.geometric')

  end subroutine compute_face_selectors

  ! ========================================================================== !
  ! GETTERS FOR FINITE ELEMENT COORDINATE FIELDS
  ! ========================================================================== !
  !> @brief Function to return a pointer to the panel_id
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The coordinate field array
  function get_panel_id(mesh_id) result(panel_id_ptr)

    implicit none

    integer(kind=i_def), intent(in) :: mesh_id
    type(mesh_type),        pointer :: mesh
    type(mesh_type),        pointer :: prime_extrusion_mesh
    type(field_type),       pointer :: panel_id_ptr

    mesh => mesh_collection%get_mesh(mesh_id)
    if (mesh%get_extrusion_id() == TWOD) then
      prime_extrusion_mesh => mesh_collection%get_mesh(mesh, PRIME_EXTRUSION)
      call panel_id_inventory%get_field(prime_extrusion_mesh, panel_id_ptr)
    else
      call panel_id_inventory%get_field(mesh, panel_id_ptr)
    end if

  end function get_panel_id

  !> @brief Returns a pointer to the coordinate field array
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The coordinate field array
  function get_coordinates(mesh_id) result(coords_ptr)

    implicit none

    integer(kind=i_def), intent(in) :: mesh_id
    type(mesh_type),        pointer :: mesh
    type(mesh_type),        pointer :: prime_extrusion_mesh
    type(field_type),       pointer :: coords_ptr(:)

    mesh => mesh_collection%get_mesh(mesh_id)
    if (mesh%get_extrusion_id() == TWOD) then
      prime_extrusion_mesh => mesh_collection%get_mesh(mesh, PRIME_EXTRUSION)
      call chi_inventory%get_field_array(prime_extrusion_mesh, coords_ptr)
    else
      call chi_inventory%get_field_array(mesh, coords_ptr)
    end if

  end function get_coordinates

  !> @brief Returns a pointer to the extended coordinate field array
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The coordinate field array
  function get_extended_coordinates(mesh_id) result(extended_chi)

    use sci_extend_chi_field_kernel_mod,    only: extend_chi_field

    implicit none

    integer(kind=i_def),    intent(in) :: mesh_id
    type(mesh_type),           pointer :: mesh
    type(field_type),          pointer :: extended_chi(:)
    logical(kind=l_def)                :: constant_exists
    type(field_type),          pointer :: chi(:)
    type(field_type),          pointer :: panel_id
    type(function_space_type), pointer :: wchi_fs

    ! Initialise inventory if this is the first time getting this constant
    if (.not. extended_chi_inventory%is_initialised()) then
      call extended_chi_inventory%initialise(name="extended_chi")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = extended_chi_inventory%paired_object_exists(mesh_id)

    if (.not. constant_exists) then
      ! If this constant doesn't exist, create it
      chi => get_coordinates(mesh_id)
      panel_id => get_panel_id(mesh_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      wchi_fs => chi(1)%get_function_space()
      call extended_chi_inventory%add_field_array(                             &
              extended_chi, wchi_fs, 3, mesh, halo_depth=mesh%get_halo_depth() &
      )
      call extend_chi_field(extended_chi, chi, panel_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    else
      ! Otherwise, return existing constant
      call extended_chi_inventory%get_field_array(mesh, extended_chi)
    end if

  end function get_extended_coordinates

  ! ========================================================================== !
  ! GETTERS FOR BASIC GEOMETRIC ENTITIES
  ! ========================================================================== !
  !> @brief Returns the areas of cell faces at W2 DoF locations
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The dA field
  function get_dA_at_w2(mesh_id) result(dA_at_w2)

    use sci_calc_da_at_w2_kernel_mod,       only: calc_dA_at_w2_kernel_type

    implicit none

    integer(kind=i_def),    intent(in) :: mesh_id
    type(mesh_type),           pointer :: mesh
    type(field_type),          pointer :: dA_at_w2
    logical(kind=l_def)                :: constant_exists
    type(field_type),          pointer :: chi(:)
    type(field_type),          pointer :: panel_id
    type(function_space_type), pointer :: w2_k0_fs

    ! Initialise inventory if this is the first time getting this constant
    if (.not. dA_at_w2_inventory%is_initialised()) then
      call dA_at_w2_inventory%initialise(name="dA_at_w2")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = dA_at_w2_inventory%paired_object_exists(mesh_id)

    if (.not. constant_exists) then
      ! If this constant doesn't exist, create it
      chi => get_coordinates(mesh_id)
      panel_id => get_panel_id(mesh_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      w2_k0_fs => function_space_collection%get_fs(mesh, 0, 0, W2)
      call dA_at_w2_inventory%add_field(dA_at_w2, w2_k0_fs, mesh)

      call invoke( setval_c(dA_at_w2, 0.0_r_def),                              &
                   calc_dA_at_w2_kernel_type(dA_at_w2, chi, panel_id) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    else
      ! Otherwise, return existing constant
      call dA_at_w2_inventory%get_field(mesh, dA_at_w2)
    end if

  end function get_dA_at_w2

  !> @brief Returns the Det(J) values at W3 dof locations
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The Det(J) field
  function get_detj_at_w3(mesh_id) result(detj_at_w3)

    ! @TODO #4487: update these imports
    ! use sci_calc_detj_at_w3_kernel_mod, only: calc_detj_at_w3_kernel_type
    use sci_compute_mass_matrix_kernel_w_scalar_mod, &
                                      only: compute_mass_matrix_kernel_w_scalar_type
    use sci_mm_diagonal_kernel_mod,   only: mm_diagonal_kernel_type
    use finite_element_config_mod,    only: nqp_exact
    use operator_mod,                 only: operator_type
    use quadrature_xyoz_mod,          only: quadrature_xyoz_type
    use quadrature_rule_gaussian_mod, only: quadrature_rule_gaussian_type

    implicit none

    integer(kind=i_def),       intent(in) :: mesh_id
    type(mesh_type),              pointer :: mesh
    logical(kind=l_def)                   :: constant_exists
    type(field_type),             pointer :: detj_at_w3
    type(field_type),             pointer :: chi(:)
    type(field_type),             pointer :: panel_id
    type(function_space_type),    pointer :: w3_fs
    ! @TODO #4487: arguments for calculating detj in old way
    type(operator_type)                   :: mm_w3
    type(quadrature_xyoz_type)            :: qr
    logical(kind=l_def)                   :: extended_mesh
    type(quadrature_rule_gaussian_type)   :: quadrature_rule

    ! Check inventory is initialised
    if (.not. detj_at_w3_inventory%is_initialised()) then
      ! Initialise all inventories together
      call detj_at_w3_inventory%initialise(name='detj_at_w3')
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = detj_at_w3_inventory%paired_object_exists(mesh_id)

    if (.not. constant_exists) then
      chi => get_coordinates(mesh_id)
      panel_id => get_panel_id(mesh_id)

      ! Create the object as it doesn't exist yet
      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      w3_fs => function_space_collection%get_fs(mesh, element_order_h, &
                                                element_order_v, W3)
      call detj_at_w3_inventory%add_field(detj_at_w3, w3_fs, mesh)

      ! @TODO #4487: it is inefficient to calculate this via mass matrices
      ! The proper method is preserved in the comment here
      ! call invoke( calc_detj_at_w3_kernel_type(detj_at_w3, chi, panel_id) )
      call mm_w3%initialise( w3_fs, w3_fs )
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)
      extended_mesh = .false.
      call invoke( compute_mass_matrix_kernel_w_scalar_type(mm_w3,             &
                                                            chi,               &
                                                            panel_id,          &
                                                            extended_mesh,     &
                                                            qr),               &
                   setval_c(detj_at_w3, 0.0_r_def),                            &
                   mm_diagonal_kernel_type(detj_at_w3, mm_w3) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    end if

    ! Get existing constant
    call detj_at_w3_inventory%get_field(mesh, detj_at_w3)

  end function get_detj_at_w3

  !> @brief Returns the Det(J) values at W2 dof locations
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The Det(J) field
  function get_detj_at_w2(mesh_id) result(detj_at_w2)

    use sci_calc_detj_at_w2_kernel_mod, only: calc_detj_at_w2_kernel_type
    use sci_multiplicity_kernel_mod,    only: multiplicity_kernel_type

    implicit none

    integer(kind=i_def),       intent(in) :: mesh_id
    type(mesh_type),              pointer :: mesh
    logical(kind=l_def)                   :: constant_exists
    type(field_type),             pointer :: detj_at_w2
    type(field_type),             pointer :: chi(:)
    type(field_type),             pointer :: panel_id
    type(field_type)                      :: multiplicity_w2
    type(function_space_type),    pointer :: w2_fs

    ! Check inventory is initialised
    if (.not. detj_at_w2_inventory%is_initialised()) then
      ! Initialise all inventories together
      call detj_at_w2_inventory%initialise(name='detj_at_w2')
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = detj_at_w2_inventory%paired_object_exists(mesh_id)

    if (.not. constant_exists) then
      chi => get_coordinates(mesh_id)
      panel_id => get_panel_id(mesh_id)

      ! Create the object as it doesn't exist yet
      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      w2_fs => function_space_collection%get_fs(mesh, element_order_h, &
                                                element_order_v, W2)
      call multiplicity_w2%initialise( w2_fs )
      call detj_at_w2_inventory%add_field(detj_at_w2, w2_fs, mesh)

      ! @TODO #4487: a small optimisation here is to multiply by rmultiplicity,
      ! rather than computing and dividing by mulitplicity
      call invoke( setval_c(detj_at_w2, 0.0_r_def),                            &
                   calc_detj_at_w2_kernel_type(detj_at_w2, chi, panel_id),     &
                   setval_c(multiplicity_w2, 0.0_r_def),                       &
                   multiplicity_kernel_type(multiplicity_w2),                  &
                   inc_X_divideby_Y(detj_at_w2, multiplicity_w2) )
      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    end if

    ! Get existing constant
    call detj_at_w2_inventory%get_field(mesh, detj_at_w2)

  end function get_detj_at_w2

  !> @brief Returns a pointer to the vertical grid spacing, located at W3 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The physical height difference of layers, at W3
  function get_dz_w3(mesh_id) result(dz_w3)

    use sci_get_dz_w3_kernel_mod,           only: get_dz_w3_kernel_type

    implicit none

    integer(kind=i_def),    intent(in) :: mesh_id
    type(mesh_type),           pointer :: mesh
    type(field_type),          pointer :: dz_w3
    logical(kind=l_def)                :: constant_exists
    type(field_type),          pointer :: height_w2
    type(function_space_type), pointer :: w3_fs

    ! Initialise inventory if this is the first time getting this constant
    if (.not. dz_w3_inventory%is_initialised()) then
      call dz_w3_inventory%initialise(name="dz_w3")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = dz_w3_inventory%paired_object_exists(mesh_id)

    if (.not. constant_exists) then
      ! If this constant doesn't exist, create it
      ! Get height first to avoid potentially timing twice
      height_w2 => get_height(W2, mesh_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      w3_fs => function_space_collection%get_fs(mesh, 0, 0, W3)
      call dz_w3_inventory%add_field(dz_w3, w3_fs, mesh)

      call invoke( get_dz_w3_kernel_type(dz_w3, height_w2) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    else
      ! Otherwise, return existing constant
      call dz_w3_inventory%get_field(mesh, dz_w3)
    end if

  end function get_dz_w3

  !> @brief Returns the delta_at_wtheta values at Wtheta DoF locations
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The delta_at_wtheta field
  function get_delta_at_wtheta(mesh_id) result(delta_at_wtheta)

    use sci_calc_delta_at_wtheta_kernel_mod, &
                                       only: calc_delta_at_wtheta_kernel_type

    implicit none

    integer(kind=i_def),       intent(in) :: mesh_id
    type(mesh_type),              pointer :: mesh
    logical(kind=l_def)                   :: constant_exists
    type(field_type),             pointer :: dx_at_w2
    type(field_type),             pointer :: delta_at_wtheta
    type(function_space_type),    pointer :: wt_k0_fs

    ! Initialise inventory if it hasn't been done so already
    if (.not. delta_at_wtheta_inventory%is_initialised()) then
      call delta_at_wtheta_inventory%initialise(name="delta_at_wtheta")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = delta_at_wtheta_inventory%paired_object_exists(mesh_id)

    ! Create constant if it doesn't already exist
    if (.not. constant_exists) then
      wt_k0_fs => function_space_collection%get_fs(mesh, 0, 0, Wtheta)
      dx_at_w2 => get_dx_at_w2(mesh_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      call delta_at_wtheta_inventory%add_field(delta_at_wtheta, wt_k0_fs, mesh)

      call invoke( calc_delta_at_wtheta_kernel_type(delta_at_wtheta, dx_at_w2) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    end if

    ! Return constant
    call delta_at_wtheta_inventory%get_field(mesh, delta_at_wtheta)

  end function get_delta_at_wtheta

  !> @brief Returns the dx_at_w2 values at W2 DoF locations
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The dx_at_w2 field
  function get_dx_at_w2(mesh_id) result(dx_at_w2)

    implicit none

    integer(kind=i_def),       intent(in) :: mesh_id
    type(mesh_type),              pointer :: mesh
    logical(kind=l_def)                   :: constant_exists
    type(field_type),             pointer :: dx_at_w2
    type(field_type),             pointer :: detj_at_w2
    type(field_type),             pointer :: dA_at_w2
    type(function_space_type),    pointer :: w2_fs

    ! Initialise inventory if it hasn't been done so already
    if (.not. dx_at_w2_inventory%is_initialised()) then
      call dx_at_w2_inventory%initialise(name="dx_at_w2")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = dx_at_w2_inventory%paired_object_exists(mesh_id)

    ! Create constant if it doesn't already exist
    if (.not. constant_exists) then
      w2_fs => function_space_collection%get_fs(mesh, 0, 0, W2)
      detj_at_w2 => get_detj_at_w2(mesh_id)
      dA_at_w2 => get_dA_at_w2(mesh_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      call dx_at_w2_inventory%add_field(dx_at_w2, w2_fs, mesh)
      call invoke( X_divideby_Y(dx_at_w2, detj_at_w2, dA_at_w2) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    end if

    ! Return constant
    call dx_at_w2_inventory%get_field(mesh, dx_at_w2)

  end function get_dx_at_w2


  !> @brief Returns the 1/dz values at lowest-order Wtheta DoF locations
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The dz_at_wtheta field
  function get_dz_at_wtheta(mesh_id) result(dz_at_wtheta)

    use sci_calc_dz_face_kernel_mod, only: calc_dz_face_kernel_type

    implicit none

    integer(kind=i_def),      intent(in) :: mesh_id
    type(mesh_type),             pointer :: mesh
    type(field_type),            pointer :: dz_at_wtheta
    type(function_space_type),   pointer :: wtheta_k0_fs
    type(field_type),            pointer :: height_w3
    type(field_type),            pointer :: height_wth
    logical(kind=l_def)                  :: constant_exists

    ! Parameters of the cells
    integer(i_def), parameter :: n_centres = 1_i_def
    logical(l_def), parameter :: ign_surf = .false.

    ! Initialise inventory if it hasn't been done so already
    if (.not. dz_at_wtheta_inventory%is_initialised()) then
      call dz_at_wtheta_inventory%initialise(name="dz_at_wtheta")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = dz_at_wtheta_inventory%paired_object_exists(mesh_id)

    ! Create constant if it doesn't already exist
    if (.not. constant_exists) then
      ! NB: this assumes heights are in the lowest-order space
      height_w3 => get_height(W3, mesh_id)
      height_wth => get_height(Wtheta, mesh_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      wtheta_k0_fs => function_space_collection%get_fs(mesh, 0, 0, Wtheta)

      call dz_at_wtheta_inventory%add_field(dz_at_wtheta, wtheta_k0_fs, mesh)

      call invoke( calc_dz_face_kernel_type(dz_at_wtheta, height_w3,           &
                                            height_wth, n_centres, ign_surf) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    end if

    ! Return constant
    call dz_at_wtheta_inventory%get_field(mesh, dz_at_wtheta)

  end function get_dz_at_wtheta

  !> @brief Returns the surface area of a cell projected to mean sea level
  !>        i.e. ignoring the orographic effect on the area
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The dA_msl_proj field
  function get_dA_msl_proj(mesh_id) result(dA_msl_proj)

    use base_mesh_config_mod,            only: geometry, geometry_spherical
    use extrusion_config_mod,            only: planet_radius, domain_height
    use sci_calc_da_msl_proj_kernel_mod, only: calc_da_msl_proj_kernel_type

    implicit none

    integer(kind=i_def),       intent(in) :: mesh_id
    integer(kind=i_def)                   :: local_mesh_id
    type(mesh_type),              pointer :: mesh
    type(mesh_type),              pointer :: prime_mesh
    type(mesh_type),              pointer :: twod_mesh
    type(local_mesh_type),        pointer :: local_mesh
    logical(kind=l_def)                   :: constant_exists
    type(field_type),             pointer :: dA_msl_proj
    type(field_type),             pointer :: dA_at_w2
    type(function_space_type),    pointer :: fs

    ! Initialise inventory if it hasn't been done so already
    if (.not. dA_msl_proj_inventory%is_initialised()) then
      call dA_msl_proj_inventory%initialise(name="dA_msl_proj")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    local_mesh => mesh%get_local_mesh()
    local_mesh_id = local_mesh%get_id()
    constant_exists = dA_msl_proj_inventory%paired_object_exists(local_mesh_id)

    ! Create constant if it doesn't already exist
    if (.not. constant_exists) then
      prime_mesh => mesh_collection%get_mesh(mesh, PRIME_EXTRUSION)
      twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
      fs => function_space_collection%get_fs(twod_mesh, 0, 0, W3)
      dA_at_w2 => get_dA_at_w2(prime_mesh%get_id())

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      call dA_msl_proj_inventory%add_field(dA_msl_proj, fs, local_mesh)
      call invoke( calc_da_msl_proj_kernel_type(dA_at_w2, dA_msl_proj,         &
                                                planet_radius, domain_height,  &
                                                geometry, geometry_spherical) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    end if

    ! Return constant
    call dA_msl_proj_inventory%get_field(local_mesh, dA_msl_proj)

  end function get_dA_msl_proj

  ! ========================================================================== !
  ! PHYSICAL COORDINATES OF DOFs
  ! ========================================================================== !

  !> @brief Returns a pointer to the longitude of DoFs
  !> @param[in] space_id   The space for which to get the longitude of DoFs for
  !> @param[in] mesh_id    The ID of the mesh to get the object for
  !> @return The longitude field
  function get_longitude(space_id, mesh_id) result(long_ptr)

    implicit none

    integer(kind=i_def),             intent(in) :: space_id
    integer(kind=i_def),             intent(in) :: mesh_id
    type(mesh_type),                    pointer :: mesh
    type(local_mesh_type),              pointer :: local_mesh
    type(inventory_by_local_mesh_type), pointer :: long_inventory
    type(inventory_by_local_mesh_type), pointer :: lat_inventory
    type(field_type),                   pointer :: long_ptr
    logical(kind=l_def)                         :: constant_exists
    character(len=str_def)                      :: inventory_name

    ! NB: Longitude and latitude fields are computed simultaneously
    ! Determine inventory based on space
    select case (space_id)
    case (W2)
      long_inventory => long_w2_inventory
      lat_inventory => lat_w2_inventory
      inventory_name = "_w2"
    case (W2H)
      long_inventory => long_w2h_inventory
      lat_inventory => lat_w2h_inventory
      inventory_name = "_w2h"
    case (W3)
      long_inventory => long_w3_inventory
      lat_inventory => lat_w3_inventory
      inventory_name = "_w3"
    case default
      long_ptr => null()
      call log_event("Longitude not available on requested space", LOG_LEVEL_ERROR)
    end select

    ! Initialise inventory if this is the first time getting this constant
    if (.not. long_inventory%is_initialised()) then
      call long_inventory%initialise(name='longitude_'//trim(inventory_name))
      call lat_inventory%initialise(name='latitude_'//trim(inventory_name))
    end if

    ! Create constant
    mesh => mesh_collection%get_mesh(mesh_id)
    local_mesh => mesh%get_local_mesh()
    constant_exists = long_inventory%paired_object_exists(local_mesh%get_id())

    if (.not. constant_exists) then
      call compute_latlon(long_inventory, lat_inventory, mesh, space_id)
    end if

    call long_inventory%get_field(local_mesh, long_ptr)

  end function get_longitude

  !> @brief Returns a pointer to the latitude of DoFs
  !> @param[in] space_id   The space for which to get the latitude of DoFs for
  !> @param[in] mesh_id    The ID of the mesh to get the object for
  !> @return The latitude field
  function get_latitude(space_id, mesh_id) result(lat_ptr)

    implicit none

    integer(kind=i_def),             intent(in) :: space_id
    integer(kind=i_def),             intent(in) :: mesh_id
    type(mesh_type),                    pointer :: mesh
    type(local_mesh_type),              pointer :: local_mesh
    type(inventory_by_local_mesh_type), pointer :: long_inventory
    type(inventory_by_local_mesh_type), pointer :: lat_inventory
    type(field_type),                   pointer :: lat_ptr
    logical(kind=l_def)                         :: constant_exists
    character(len=str_def)                      :: inventory_name

    ! NB: Longitude and latitude fields are computed simultaneously
    ! Determine inventory based on space
    select case (space_id)
    case (W2)
      long_inventory => long_w2_inventory
      lat_inventory => lat_w2_inventory
      inventory_name = "_w2"
    case (W2H)
      long_inventory => long_w2h_inventory
      lat_inventory => lat_w2h_inventory
      inventory_name = "_w2h"
    case (W3)
      long_inventory => long_w3_inventory
      lat_inventory => lat_w3_inventory
      inventory_name = "_w3"
    case default
      lat_ptr => null()
      call log_event("Latitude not available on requested space", LOG_LEVEL_ERROR)
    end select

    ! Initialise inventory if this is the first time getting this constant
    if (.not. lat_inventory%is_initialised()) then
      call long_inventory%initialise(name='longitude_'//trim(inventory_name))
      call lat_inventory%initialise(name='latitude_'//trim(inventory_name))
    end if

    ! Create constant
    mesh => mesh_collection%get_mesh(mesh_id)
    local_mesh => mesh%get_local_mesh()
    constant_exists = lat_inventory%paired_object_exists(local_mesh%get_id())

    if (.not. constant_exists) then
      call compute_latlon(long_inventory, lat_inventory, mesh, space_id)
    end if

    call lat_inventory%get_field(local_mesh, lat_ptr)

  end function get_latitude

  !> @brief Returns a pointer to a height field
  !> @param[in] space   The space of the desired height field
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return A height field
  function get_height(space_id, mesh_id) result(height)

    use sci_get_height_kernel_mod,          only: get_height_kernel_type
    use planet_config_mod,                  only: scaled_radius

    implicit none

    integer(kind=i_def),       intent(in) :: space_id
    integer(kind=i_def),       intent(in) :: mesh_id
    type(mesh_type),              pointer :: mesh
    type(inventory_by_mesh_type), pointer :: inventory
    logical(kind=l_def)                   :: constant_exists
    type(function_space_type),    pointer :: space
    type(field_type),             pointer :: chi(:)
    type(field_type),             pointer :: height
    character(len=str_def)                :: inventory_name

    ! Determine inventory based on space
    select case (space_id)
    case (W1)
      inventory => height_w1_inventory
      inventory_name = "height_w1"
    case (W2)
      inventory => height_w2_inventory
      inventory_name = "height_w2"
    case (W2H)
      inventory => height_w2h_inventory
      inventory_name = "height_w2"
    case (W3)
      inventory => height_w3_inventory
      inventory_name = "height_w3"
    case (Wtheta)
      inventory => height_wth_inventory
      inventory_name = "height_wtheta"
    case default
      height => null()
      call log_event("Height not available on requested space", LOG_LEVEL_ERROR)
    end select

    ! Initialise inventory if this is the first time getting this constant
    if (.not. inventory%is_initialised()) then
      call inventory%initialise(name=inventory_name)
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    constant_exists = inventory%paired_object_exists(mesh_id)

    if (.not. constant_exists) then
      ! If this constant doesn't exist, create it
      chi => get_coordinates(mesh_id)

      if ( subroutine_timers ) call timer('runtime_constants.geometric')

      space => function_space_collection%get_fs(mesh, element_order_h, &
                                                element_order_v, space_id)
      call inventory%add_field(height, space, mesh)

      call invoke( get_height_kernel_type(height, chi, scaled_radius) )

      if ( subroutine_timers ) call timer('runtime_constants.geometric')
    else
      call inventory%get_field(mesh, height)
    end if

  end function get_height

  ! ========================================================================== !
  ! FACE SELECTORS
  ! ========================================================================== !

  !> @brief Returns a pointer to the east-west face selector
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The east-west face selector
  function get_face_selector_ew(mesh_id) result(selector)

    implicit none

    integer(kind=i_def),   intent(in) :: mesh_id
    type(mesh_type),          pointer :: mesh => null()
    type(local_mesh_type),    pointer :: local_mesh => null()
    type(integer_field_type), pointer :: selector
    logical(kind=l_def)               :: constant_exists

    ! Initialise inventory if this is the first time getting this constant
    if (.not. face_selector_ew_inventory%is_initialised()) then
      call face_selector_ew_inventory%initialise(name="face_selector_ew")
      call face_selector_ns_inventory%initialise(name="face_selector_ns")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    local_mesh => mesh%get_local_mesh()
    constant_exists =                                                          &
        face_selector_ew_inventory%paired_object_exists(local_mesh%get_id())

    if (.not. constant_exists) call compute_face_selectors(mesh)

    call face_selector_ew_inventory%get_field(local_mesh, selector)

  end function get_face_selector_ew

  !> @brief Returns a pointer to the north-south face selector
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The north-south face selector
  function get_face_selector_ns(mesh_id) result(selector)

    implicit none

    integer(kind=i_def),   intent(in) :: mesh_id
    type(mesh_type),          pointer :: mesh => null()
    type(local_mesh_type),    pointer :: local_mesh => null()
    type(integer_field_type), pointer :: selector
    logical(kind=l_def)               :: constant_exists

    ! Initialise inventory if this is the first time getting this constant
    if (.not. face_selector_ew_inventory%is_initialised()) then
      call face_selector_ew_inventory%initialise(name="face_selector_ew")
      call face_selector_ns_inventory%initialise(name="face_selector_ns")
    end if

    mesh => mesh_collection%get_mesh(mesh_id)
    local_mesh => mesh%get_local_mesh()
    constant_exists =                                                          &
        face_selector_ns_inventory%paired_object_exists(local_mesh%get_id())

    if (.not. constant_exists) call compute_face_selectors(mesh)

    call face_selector_ns_inventory%get_field(local_mesh, selector)

  end function get_face_selector_ns

  ! ========================================================================== !
  ! GETTERS FOR INVENTORIES
  ! ========================================================================== !
  ! These are two special inventories, which are set up in the driver

  !> @brief Returns a pointer to the chi inventory
  function get_chi_inventory() result(inventory_ptr)
    implicit none
    type(inventory_by_mesh_type), pointer :: inventory_ptr

    inventory_ptr => chi_inventory

  end function get_chi_inventory

  !> @brief Returns a pointer to the panel_id inventory
  function get_panel_id_inventory() result(inventory_ptr)
    implicit none
    type(inventory_by_mesh_type), pointer :: inventory_ptr

    inventory_ptr => panel_id_inventory

  end function get_panel_id_inventory

  ! ========================================================================== !
  ! FINALISE
  ! ========================================================================== !
  !> @brief Explicitly reclaim memory from module scope variables
  subroutine final_geometric_constants()

    implicit none

    call lat_w2_inventory%clear()
    call lat_w3_inventory%clear()
    call lat_w2h_inventory%clear()
    call long_w2_inventory%clear()
    call long_w3_inventory%clear()
    call long_w2h_inventory%clear()
    call dA_at_w2_inventory%clear()
    call height_wth_inventory%clear()
    call height_w3_inventory%clear()
    call height_w2_inventory%clear()
    call height_w2h_inventory%clear()
    call height_w1_inventory%clear()
    call dz_w3_inventory%clear()
    call panel_id_inventory%clear()
    call chi_inventory%clear()
    call extended_chi_inventory%clear()
    call detj_at_w3_inventory%clear()
    call detj_at_w2_inventory%clear()
    call delta_at_wtheta_inventory%clear()
    call dx_at_w2_inventory%clear()
    call dz_at_wtheta_inventory%clear()
    call dA_msl_proj_inventory%clear()

  end subroutine final_geometric_constants

end module sci_geometric_constants_mod
