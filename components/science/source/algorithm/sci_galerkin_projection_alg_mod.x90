!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> Computes the galerkin projection of fields.
!>
!> As a first step fields are projected into a continuous space.
!>
module sci_galerkin_projection_alg_mod

  use constants_mod,                 only: r_def, i_def
  use function_space_collection_mod, only: function_space_collection
  use field_mod,                     only: field_type
  use finite_element_config_mod,     only: element_order_h, &
                                           element_order_v
  use fs_continuity_mod,             only: W2, W3
  use sci_gp_rhs_kernel_mod,         only: gp_rhs_kernel_type
  use sci_gp_vector_rhs_kernel_mod,  only: gp_vector_rhs_kernel_type
  use log_mod,                       only: log_event, log_scratch_space, &
                                           log_level_debug, log_level_error
  use operator_mod,                  only: operator_type
  use quadrature_xyoz_mod,           only: quadrature_xyoz_type
  use sci_mass_matrix_solver_alg_mod, &
                                     only: mass_matrix_solver_alg

  implicit none

  private
  public :: galerkin_projection_algorithm

contains

  !> @brief Computes the galerkin projection of a field into another.
  !>
  !> @details Computes the Galerkin projection of a field <code>f_in</code>
  !>          into the space of field <code>f_out</code>.
  !>
  !>          Solves \f$M * f_{out} = rhs\f$ where
  !>          \f$rhs = \lfloor\gamma * f_{in}\rfloor\f$ and \f$\gamma\f$ is a test
  !>          function from the same space as \f$f_{out}\f$ and \f$M\f$ is
  !>          the mass matrix for the space of \f$f_{out}\f$.
  !>
  !>          If <code>f_in</code> is in a vector space then it is decomposed
  !>          into orthogonal components and the galerkin projection of each
  !>          component is computed.
  !>
  !> @param[out] f_out     Field to project onto.
  !> @param[in]  f_in      Field to project.
  !> @param[in]  chi       Field entity co-ordinates.
  !> @param[in]  panel_id  Cell orientation.
  !> @param[in]  qr        Quadrature rule to perform integrations.
  !>
  !> @todo Ideally this function would not take chi and panel_id, these would
  !>       be available through the input field. That is some way off though.
  !>
  subroutine galerkin_projection_algorithm( f_out,    &
                                            f_in,     &
                                            chi,      &
                                            panel_id, &
                                            qr)

    implicit none

    ! Field to output
    type(field_type),           intent(inout) :: f_out(:)

    ! Field to input
    type(field_type),           intent(in)    :: f_in

    ! Coordinate fields
    type(field_type),           intent(in)    :: chi(:)
    type(field_type),           intent(in)    :: panel_id

    type(quadrature_xyoz_type), intent(in)    :: qr

    type(field_type) :: rhs(size(f_out))
    type(field_type) :: w2_field
    integer(i_def)   :: out_fs
    integer(i_def)   :: idx

    ! Create continuous fields to project data into
    out_fs = f_out(1)%which_function_space()
    do idx = 1, size(f_out)
      ! A Galerkin projection doesn't make sense between meshes.
      ! This check could usefully be an assertion if Fortran gains support
      ! for them.
      !
      if (.not. associated(f_in%get_mesh(), f_out(idx)%get_mesh())) then
        call log_event( "Galerkin cannot project between meshes", &
                        log_level_error )
      end if

      call rhs(idx)%initialise( vector_space = f_out(1)%get_function_space() )
      call invoke( setval_c(rhs(idx), 0.0_r_def) )
    end do

    ! Project field into continuous space
    write( log_scratch_space, '(A)' ) 'Computing Galerkin projection...'
    call log_event( log_scratch_space, log_level_debug )
    if ( f_in%which_function_space() == out_fs ) then
      write( log_scratch_space, '(A)' ) '   function spaces match, no projection needed'
      call log_event( log_scratch_space, log_level_debug )
      call invoke( setval_X(f_out(1), f_in) )
    else
      if ( size(f_out) == 1 ) then
        write( log_scratch_space, '(A)' ) '    scalar field ... '
        call log_event( log_scratch_space, log_level_debug )
        call invoke( gp_rhs_kernel_type(rhs(1), f_in, chi, panel_id, qr) )
      else
        write( log_scratch_space, '(A)' ) '    vector field ... '
        call log_event( log_scratch_space, log_level_debug )

        ! Create dummy W2 field for kernel to perform check again
        call w2_field%initialise(                          &
          vector_space = function_space_collection%get_fs( &
            f_in%get_mesh(), element_order_h,              &
            element_order_v, W2                            &
          )                                                &
        )

        call invoke( &
          gp_vector_rhs_kernel_type( &
            rhs, f_in, chi, panel_id, w2_field, qr &
          ) &
        )
      end if
      do idx = 1, size(f_out)
        call mass_matrix_solver_alg( f_out(idx), rhs(idx) )
      end do
    end if

  end subroutine galerkin_projection_algorithm

end module sci_galerkin_projection_alg_mod
