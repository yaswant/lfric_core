!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
module coordinate_jacobian_stretched_mod_test

  use pFUnit_Mod
  use constants_mod, only : r_def, i_def, PI
  use, intrinsic :: iso_fortran_env, only : real32, real64

  implicit none

  public :: jacobian_stretched_test_type, test_all

  @TestCase
  type, extends(TestCase) :: jacobian_stretched_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type jacobian_stretched_test_type

  real(r_def), parameter :: radius   = 270_r_def
  real(r_def), parameter :: scaling  = 1.0_r_def

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use base_mesh_config_mod,      only : geometry_spherical, &
                                          topology_non_periodic
    use finite_element_config_mod, only : cellshape_quadrilateral, &
                                          coord_system_native
    use feign_config_mod,          only : feign_finite_element_config, &
                                          feign_planet_config,         &
                                          feign_base_mesh_config

    implicit none

    class(jacobian_stretched_test_type), intent(inout) :: this

    call feign_base_mesh_config( file_prefix='foo',                &
                                 prime_mesh_name='unit_test',      &
                                 geometry=geometry_spherical,      &
                                 prepartitioned=.false.,           &
                                 topology=topology_non_periodic, &
                                 fplane=.false., f_lat_deg=0.0_r_def )

    call feign_finite_element_config(           &
             cellshape=cellshape_quadrilateral, &
             coord_order=0_i_def,               &
             coord_system=coord_system_native,  &
             element_order=0_i_def,             &
             rehabilitate=.true. )

    call feign_planet_config( radius=radius, scaling_factor=scaling )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(jacobian_stretched_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use sci_coordinate_jacobian_mod, only : jacobian_stretched

    implicit none

    class(jacobian_stretched_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: radius = 29.1295_r_def

    real(kind=r_def) :: native_lon, native_lat
    real(kind=r_def) :: stretch, psi
    real(kind=r_def) :: jac(3,3), jac_answer(3,3)
    real(kind=r_def) :: tol = 1.0e-7_r_def

#if (RDEF_PRECISION == 64)
    tol = 1.0e-7_real64
#elif (RDEF_PRECISION == 32)
    tol = 1.0e-6_real32
#else
    @assertFail("Unsupported default precision")
#endif

    ! Stretching factor of 1/sqrt(3) takes equator to 30 degrees
    ! Consider lon = 0 and lat = 0, which yields some nice analytic values
    stretch = 1.0_r_def / sqrt(3.0_r_def)

    ! Our strategy is to calculate the Jacobian for performing the stretching
    ! from native to physical space, at the equator in native space
    native_lon = 0.0_r_def
    native_lat = 0.0_r_def
    jac = jacobian_stretched(native_lon, native_lat, radius, stretch)

    ! Then we check this Jacobian is valid by comparing with analytic values
    psi = sqrt(3.0_r_def) / 2.0_r_def
    jac_answer(:,:) = 0.0_r_def
    jac_answer(1,1) = sqrt(3.0_r_def) / 2.0_r_def
    jac_answer(1,3) = -psi / 2.0_r_def
    jac_answer(2,2) = sqrt(3.0_r_def) / 2.0_r_def
    jac_answer(3,1) = 0.5_r_def
    jac_answer(3,3) = psi * sqrt(3.0_r_def) / 2.0_r_def

    @assertEqual(jac, jac_answer, tol)

  end subroutine test_all

end module coordinate_jacobian_stretched_mod_test
