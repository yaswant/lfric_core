!-------------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------
!> @brief Interface to the UM diagnostic and prognostic cloud schemes

module cld_alg_mod

  use constants_mod,                 only: i_def
  use field_mod,                     only: field_type
  use field_collection_mod,          only: field_collection_type
  use mr_indices_mod,                only: nummr, imr_v, imr_cl, imr_ci
  use io_config_mod,                 only: subroutine_timers,             &
                                           write_conservation_diag
  use timer_mod,                     only: timer
  use cloud_config_mod,              only: scheme,                        &
                                           scheme_smith,                  &
                                           scheme_bimodal,                &
                                           scheme_pc2
  use pc2_initiation_alg_mod,        only: pc2_initiation_alg
  use pc2_pressure_forcing_alg_mod,  only: pc2_pressure_forcing_alg
  use physics_mappings_alg_mod,      only: map_physics_scalars
  use moisture_conservation_alg_mod, only: moisture_conservation_alg
  use log_mod,                       only: log_event, LOG_LEVEL_INFO

  use geometric_constants_mod,       only: get_height
  use fs_continuity_mod,             only: Wtheta

  implicit none

  private
  public cld_alg

contains

  !>@brief Run the UM Large-scale diagnostic or (parts of) prognostic cloud scheme
  !>@details The UM Diagnostic cloud scheme:
  !>         generates liquid and ice cloud fraction and water content,
  !>         and adjust vapour and temperature, as described in UMDP29
  !>         (for liquid only for now).
  !>         Parts of PC2 scheme are also done here.
  !>@param[in,out] theta_inc         (in,out) Potential temperature increment
  !>@param[in,out] mr                (in,out) Mixing ratios, in theta space
  !>@param[in]     theta             (in)     theta in its native space
  !>@param[in]     exner             (in)     Exner Pressure in w3 space
  !>@param[in]     rho               (in)     Density in w3 space
  !>@param[in]     derived_fields    (in)     Group of derived fields
  !>@param[in]     turbulence_fields (in)     Fields for turbulence scheme
  !>@param[in]     cloud_fields      (in,out) Fields for cloud scheme
  !>@param[in]     theta_n           (in)     theta at start of timestep
  !>@param[in]     mr_n              (in)     mixing ratios at start of timestep
  !>@param[in]     step              (in)     Timestep
  subroutine cld_alg(theta_inc, mr, theta, exner, rho,         &
                     derived_fields, turbulence_fields,        &
                     cloud_fields,                             &
                     theta_n, mr_n, step)

    use smith_kernel_mod, only: smith_kernel_type
    use bm_kernel_mod,  only: bm_kernel_type

    implicit none

    type( field_collection_type ), intent(in) :: derived_fields
    type( field_collection_type ), intent(in) :: turbulence_fields
    type( field_collection_type ), intent(in) :: cloud_fields

    type( field_type ), intent( inout ) :: theta_inc, mr(nummr)

    ! Convention for variables below is to omit their function space
    ! in their name if they are in native space. However, variable name
    ! states when in timestep variable is valid.
    type( field_type ), intent( in )    :: theta            ! Current value wth
    type( field_type ), intent( in )    :: exner            ! Current value w3
    type( field_type ), intent( in )    :: rho              ! Current value w3
    type( field_type ), intent( in )    :: theta_n          ! Start of TS wth
    type( field_type ), intent( in )    :: mr_n(nummr)      ! Start of TS

    integer( i_def ),   intent( in )    :: step

    ! Variable below is for remapping from w3 to wth.
    type( field_type ) :: exner_wth                         ! Current value
    type( field_type ) :: dtheta_pc2_inc_pres
    type( field_type ) :: theta_updated

    type( field_type ), pointer :: cf_area  => null()
    type( field_type ), pointer :: cf_ice  => null()
    type( field_type ), pointer :: cf_liq  => null()
    type( field_type ), pointer :: cf_bulk  => null()
    type( field_type ), pointer :: ntml => null()
    type( field_type ), pointer :: cumulus => null()
    type( field_type ), pointer :: rh_crit => null()

    type( field_type ), pointer :: dsldzm     => null()
    type( field_type ), pointer :: wvar       => null()
    type( field_type ), pointer :: tau_dec_bm => null()
    type( field_type ), pointer :: tau_hom_bm => null()
    type( field_type ), pointer :: tau_mph_bm => null()

    type( field_type ), pointer :: sskew_bm   => null()
    type( field_type ), pointer :: svar_bm    => null()
    type( field_type ), pointer :: svar_tb    => null()

    type( field_type ), pointer :: height_wth => null()

    integer(i_def) :: mesh_id

    if ( subroutine_timers ) call timer('cld_alg')

    call log_event( 'End-of-timestep cloud update', LOG_LEVEL_INFO )

    mesh_id = theta%get_mesh_id()

    ! Map updated pressure into wtheta space
    call theta%copy_field_properties(exner_wth)
    call map_physics_scalars(exner_wth, exner)

    if (scheme == scheme_smith) then

      cf_area => cloud_fields%get_field('area_fraction')
      cf_ice => cloud_fields%get_field('ice_fraction')
      cf_liq => cloud_fields%get_field('liquid_fraction')
      cf_bulk => cloud_fields%get_field('bulk_fraction')
      rh_crit => cloud_fields%get_field('rh_crit')

      ntml => turbulence_fields%get_field('ntml')
      cumulus => turbulence_fields%get_field('cumulus')

      call invoke( smith_kernel_type( theta, exner , exner_wth, rh_crit,         &
                                    ntml, cumulus, mr(imr_v), mr(imr_cl),      &
                                    mr(imr_ci), cf_area, cf_ice, cf_liq,       &
                                    cf_bulk, theta_inc)   )

    else if (scheme == scheme_bimodal) then

      cf_area    => cloud_fields%get_field('area_fraction')
      cf_ice     => cloud_fields%get_field('ice_fraction')
      cf_liq     => cloud_fields%get_field('liquid_fraction')
      cf_bulk    => cloud_fields%get_field('bulk_fraction')

      dsldzm     => turbulence_fields%get_field('dsldzm')
      wvar       => turbulence_fields%get_field('wvar')
      tau_dec_bm => cloud_fields%get_field('tau_dec_bm')
      tau_hom_bm => cloud_fields%get_field('tau_hom_bm')
      tau_mph_bm => cloud_fields%get_field('tau_mph_bm')

      sskew_bm   => cloud_fields%get_field('sskew_bm')
      svar_bm    => cloud_fields%get_field('svar_bm')
      svar_tb    => cloud_fields%get_field('svar_tb')

      height_wth => get_height(Wtheta, mesh_id)

      call invoke( bm_kernel_type(  theta, exner , exner_wth, dsldzm,          &
                                    wvar, tau_dec_bm, tau_hom_bm,              &
                                    tau_mph_bm, height_wth,                    &
                                    mr(imr_v), mr(imr_cl),                     &
                                    mr(imr_ci), cf_area, cf_ice, cf_liq,       &
                                    cf_bulk, theta_inc,                        &
                                    sskew_bm, svar_bm, svar_tb)   )

    else if (scheme == scheme_pc2) then

      ! Do PC2 Pressure forcing
      call pc2_pressure_forcing_alg( mr,                      & ! IN
                                     theta,                   & ! IN
                                     exner_wth,               & ! IN wth
                                     cloud_fields,            & ! INOUT
                                     dtheta_pc2_inc_pres )      ! OUT

      ! Temporary value of theta to be updated with increment from
      ! pressure forcing for use as input for initiation.
      call theta%copy_field(theta_updated)
      call invoke( inc_X_plus_Y(theta_updated, dtheta_pc2_inc_pres) )

      ! Now do PC2 initiation (and checks)
      call pc2_initiation_alg( mr,                  & ! INOUT Current
                               theta_updated,       & ! IN    Updated
                               exner,               & ! IN    Current exner w3
                               exner_wth,           & ! IN    Current exner wth
                               mr_n,                & ! IN    Start of timestep
                               theta_n,             & ! IN    Start of timestep
                               derived_fields,      & ! IN
                               turbulence_fields,   &
                               cloud_fields,        & ! INOUT
                               theta_inc )            ! OUT

      call invoke( inc_X_plus_Y(theta_inc,    dtheta_pc2_inc_pres) )

    end if

    if (write_conservation_diag) &
      call moisture_conservation_alg( step, rho, mr, 'After cloud' )

    if ( subroutine_timers ) call timer('cld_alg')

  end subroutine cld_alg

end module cld_alg_mod
