!----------------------------------------------------------------------------
! (c) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!----------------------------------------------------------------------------
!> @brief Initialisation of things needed by UM physics schemes

module um_init_mod

  use blayer_config_mod,    only : flux_bc_opt_in => flux_bc_opt
  use constants_mod,        only : i_def, i_um, r_def, r_um
  use section_choice_config_mod, only : cloud,      &
                                        cloud_um,   &
                                        convection, &
                                        convection_um
  use cloud_config_mod,      only : scheme,       &
                                    scheme_smith, &
                                    rh_crit
  use extrusion_config_mod,  only : domain_top
  use field_collection_mod,  only : field_collection_type
  use log_mod,               only : log_event,         &
                                    log_scratch_space, &
                                    LOG_LEVEL_ERROR
  use convection_config_mod, only : cv_scheme,                         &
                                    cv_scheme_gregory_rowntree,        &
                                    cv_scheme_lambert_lewis,           &
                                    number_of_convection_substeps

  use mixing_config_mod,     only : smagorinsky,                   &
                                    mixing_method => method,       &
                                    method_3d_smag,         &
                                    method_2d_smag,         &
                                    method_blending,        &
                                    mix_factor_in => mix_factor
  use spectral_gwd_config_mod, only:                    &
          	ussp_launch_factor_in => ussp_launch_factor,&
           	wavelstar_in => wavelstar,                  &
           	add_cgw_in => add_cgw,                      &
           	cgw_scale_factor_in => cgw_scale_factor

  implicit none

contains

  !>@brief Initialize the UM physics schemes
  !>@param[in]    theta_in_wth Theta in its native space
  subroutine um_init(theta_in_wth)

    ! UM modules containing things that need setting
    use allocate_jules_arrays_mod, only: allocate_jules_arrays
    use ancil_info, only: ssi_pts, sea_pts, sice_pts,                      &
         sice_pts_ncat, ssi_index, sea_index, sice_index,                  &
         sice_index_ncat, fssi_ij, sea_frac, sice_frac, sice_frac_ncat
    use atm_fields_bounds_mod, only: atm_fields_bounds_init
    use atm_step_local, only: rhc_row_length, rhc_rows
    use bl_option_mod, only: i_bl_vn, sbl_op, ritrans,                     &
         cbl_op, lambda_min_nml, l_bl_mix_qcf, local_fa, keep_ri_fa,       &
         sg_orog_mixing, fric_heating, idyndiag,                           &
         zhloc_depth_fac, flux_grad, entr_smooth_dec,                      &
         relax_sc_over_cu, bl_res_inv, blending_option,                    &
         a_ent_shr_nml, alpha_cd, puns, pstb, nl_bl_levels, kprof_cu,      &
         non_local_bl, flux_bc_opt, i_bl_vn_9c, sharp_sea_mes_land,        &
         lem_conven, to_sharp_across_1km, off, on, DynDiag_Ribased,        &
         grey_zone_cu
    use cloud_inputs_mod, only: i_cld_vn, forced_cu, i_rhcpt, i_cld_area,  &
         rhcrit, ice_fraction_method,falliceshear_method, cff_spread_rate, &
         l_subgrid_qv, ice_width, smith_orig, i_eacf
    use cv_run_mod, only: icvdiag, cvdiag_inv, cvdiag_sh_wtest,            &
         limit_pert_opt, tv1_sd_opt, iconv_congestus, iconv_deep,          &
         ent_fac_dp, cldbase_opt_dp, cldbase_opt_sh, w_cape_limit,         &
         l_param_conv, i_convection_vn, l_ccrad, l_mom, adapt, amdet_fac,  &
         bl_cnv_mix, anvil_factor, ccw_for_precip_opt, cldbase_opt_md,     &
         cnv_wat_load_opt,dd_opt, deep_cmt_opt, eff_dcff, eff_dcfl,        &
         ent_dp_power, ent_fac_md, ent_opt_dp, ent_opt_md, fac_qsat,       &
         ent_fac_md, iconv_deep, iconv_mid, iconv_shallow,l_3d_cca,        &
         l_anvil, l_cmt_heating, l_cv_conserve_check, l_safe_conv,         &
         mdet_opt_dp, mid_cnv_pmin, mparwtr, qlmin, n_conv_calls,          &
         qstice, r_det, sh_pert_opt,t_melt_snow, termconv, tice,           &
         tower_factor,ud_factor, fdet_opt, anv_opt, cape_timescale,        &
         cca2d_dp_opt,cca2d_md_opt,cca2d_sh_opt,                           &
         cca_dp_knob,cca_md_knob,cca_sh_knob,                              &
         ccw_dp_knob,ccw_md_knob,ccw_sh_knob,                              &
         cnv_cold_pools,dil_plume_water_load,l_cloud_deep, mid_cmt_opt,    &
         plume_water_load, rad_cloud_decay_opt, cape_bottom, cape_top,     &
         cape_min, i_convection_vn_6a, i_cv_llcs
    use cv_stash_flg_mod, only: set_convection_output_flags
    use cv_set_dependent_switches_mod, only: cv_set_dependent_switches

    use cderived_mod, only: delta_lambda, delta_phi
    use dyn_coriolis_mod, only: f3_at_u
    use dynamics_input_mod, only: numcycles
    use fsd_parameters_mod, only: fsd_eff_lam, fsd_eff_phi
    use gen_phys_inputs_mod, only: l_mr_physics
    use jules_sea_seaice_mod, only: nice_use, iseasurfalg, emis_sea,       &
         seasalinityfactor, charnock, nice, ip_ss_surf_div
    use jules_soil_mod, only: dzsoil, dzsoil_io
    use jules_surface_mod, only: l_epot_corr, cor_mo_iter, iscrntdiag,     &
         isrfexcnvgust, Limit_ObukhovL, ip_scrndecpl2, IP_SrfExWithCnv
    use jules_surface_types_mod, only: nnpft, npft, nnvg, ntype, brd_leaf, &
        ndl_leaf, c3_grass, c4_grass, shrub, urban, lake, soil, ice
    use jules_radiation_mod, only: i_sea_alb_method, l_albedo_obs,         &
        l_dolr_land_black, l_embedded_snow, l_mask_snow_orog,              &
        l_sea_alb_var_chl, l_snow_albedo, l_spec_alb_bs, l_spec_albedo,    &
        l_spec_sea_alb
    use init_jules_alg_mod, only: n_land_tile, n_sea_ice_tile
    use nvegparm, only:                                                    &
        albsnc_nvg, albsnf_nvgu, albsnf_nvg, albsnf_nvgl, emis_nvg, vf_nvg
    use pftparm, only:                                                     &
        albsnc_max, albsnc_min, albsnf_maxu, albsnf_maxl,                  &
        alniru, alnir, alnirl, alparu, alpar, alparl, emis_pft
    use g_wave_input_mod, only: ussp_launch_factor,                        &
    	                          wavelstar, l_add_cgw, cgw_scale_factor

    use level_heights_mod, only: r_theta_levels, r_rho_levels, eta_theta_levels
    use lsm_switch_mod, only: init_lsm_um
    use model_domain_mod, only: model_type, mt_single_column
    use mphys_bypass_mod, only: mphys_mod_top
    use mphys_inputs_mod, only: ai, ar, bi, c_r_correl, ci_input, cic_input, &
        di_input, dic_input, i_mcr_iter, l_diff_icevt,                       &
        l_mcr_qrain, l_psd, l_rain, l_warm_new, timestep_mp_in, x1r, x2r,    &
        l_mcr_qcf2, sediment_loc, i_mcr_iter_tstep, all_sed_start
    use nlsizes_namelist_mod, only: model_levels, bl_levels, row_length,   &
         rows, land_field, ntiles, sm_levels, tr_vars, cloud_levels,       &
         n_cca_lev
    use pc2_constants_mod, only: i_cld_smith, i_cld_off, rhcpt_off, acf_off, &
         real_shear
    use rad_input_mod, only: two_d_fsd_factor
    use timestep_mod, only: timestep
    use trignometric_mod, only: cos_theta_latitude
    use tuning_segments_mod, only: bl_segment_size, precip_segment_size, &
                                   ussp_seg_size
    use turb_diff_ctl_mod, only: visc_m, visc_h, max_diff, delta_smag, rneutml_sq
    use turb_diff_mod, only: l_subfilter_horiz, l_subfilter_vert,        &
         mix_factor, turb_startlev_vert, turb_endlev_vert

    ! LFRic modules with information we need
    use conversions_mod, only: pi_over_180
    use field_mod, only : field_type, field_proxy_type
    use timestepping_config_mod, only: dt, outer_iterations

    implicit none

    type( field_type ), intent( in ) :: theta_in_wth
    type( field_proxy_type )  :: theta_in_wth_proxy

    integer(kind=i_def) :: nlayers

    ! Loop counters
    integer(kind=i_def) :: i,j,l

    theta_in_wth_proxy = theta_in_wth%get_proxy()

    ! Set up physics dimensions as a single column sea point
    ! This may need changing if we pass multiple columns to physics kernels
    nlayers      = theta_in_wth_proxy%vspace%get_nlayers()
    model_levels = nlayers
    cloud_levels = nlayers
    n_cca_lev    = nlayers
    bl_levels    = nlayers-1
    row_length   = 1
    rows         = 1
    land_field   = 1
    ntiles       = n_land_tile
    sm_levels    = 4
    nice         = n_sea_ice_tile
    nice_use     = n_sea_ice_tile
    tr_vars      = 0

    ! Set up array sizes for a single column model
    model_type = mt_single_column
    call atm_fields_bounds_init( 0_i_um, 0_i_um, 0_i_um, &
                                 0_i_um, row_length, rows,rows,  &
                                 nlayers, bl_levels, nlayers )

    ! Arrays that need to be allocated at startup
    allocate(f3_at_u(row_length,rows))
    allocate(r_theta_levels(row_length,rows,0:nlayers))
    allocate(r_rho_levels(row_length,rows,nlayers))
    allocate(eta_theta_levels(0:nlayers))

    ! Set up surface and allocate Jules arrays
    nnpft = 5
    npft  = 5
    nnvg  = 4
    ntype = 9
    brd_leaf = 1
    ndl_leaf = 2
    c3_grass = 3
    c4_grass = 4
    shrub = 5
    urban = 6
    lake  = 7
    soil  = 8
    ice   = 9
    call init_lsm_um()
    call allocate_jules_arrays(land_field,ntiles,sm_levels,nice_use,nice_use)
    dzsoil => dzsoil_io(1:sm_levels)

    ! Set up JULES radiation values (GL7 config: jules_radiation)
    i_sea_alb_method=3
    l_albedo_obs=.false.
    l_dolr_land_black=.false.
    l_embedded_snow=.true.
    l_mask_snow_orog=.true.
    l_sea_alb_var_chl=.false.
    l_snow_albedo=.false.
    l_spec_alb_bs=.true.
    l_spec_albedo=.true.
    l_spec_sea_alb=.true.

    ! Set up JULES nvegparm values (GL7 config: jules_nvegparm)
    albsnc_nvg=(/ 0.4,0.8,0.8,0.8 /)
    albsnf_nvg=(/ 0.18,0.12,-1.00,0.75 /)
    albsnf_nvgl=(/ 0.05,0.06,0.03,0.75 /)
    albsnf_nvgu=(/ 0.20,0.15,0.80,0.75 /)
    emis_nvg=(/ 0.970,0.985,0.900,0.990 /)
    vf_nvg=(/ 1.0,1.0,0.0,0.0 /)

    ! Set up JULES pftparm values (GL7 config: jules_pftparm) 
    albsnc_max=(/ 2.50000e-1,2.50000e-1,6.00000e-1,6.00000e-1,4.00000e-1 /)
    albsnc_min=(/ 3.00000e-1,3.00000e-1,8.00000e-1,8.00000e-1,8.00000e-1 /)
    albsnf_maxl=(/ 0.095,0.059,0.128,0.106,0.077 /)
    albsnf_maxu=(/ 0.215,0.132,0.288,0.239,0.173 /)
    alnir=(/ 0.45,0.35,0.58,0.58,0.58 /)
    alnirl=(/ 0.30,0.23,0.39,0.39,0.39 /)
    alniru=(/ 0.75,0.65,0.95,0.95,0.87 /)
    alpar=(/ 0.10,0.07,0.10,0.10,0.10 /)
    alparl=(/ 0.06,0.04,0.06,0.06,0.06 /)
    alparu=(/ 0.15,0.11,0.25,0.25,0.25 /)
    emis_pft=(/ 0.98,0.99,0.98,0.98,0.98 /)

    ! Set physics timestep from Gungho timestep
    timestep=dt

    ! Set the number of dynamics outer loops
    numcycles=outer_iterations

    ! Set mixing ratios to always be true
    l_mr_physics=.true.

    ! BL namelist options - should be moved to namelist in future
    i_bl_vn          = i_bl_vn_9c
    sbl_op           = sharp_sea_mes_land
    ritrans          = 0.1_r_um
    cbl_op           = lem_conven
    lambda_min_nml   = 40.0_r_um
    l_bl_mix_qcf     = .true.
    local_fa         = to_sharp_across_1km
    keep_ri_fa       = on
    sg_orog_mixing   = off
    fric_heating     = on
    idyndiag         = DynDiag_Ribased
    zhloc_depth_fac  = 0.3_r_um
    flux_grad        = off
    entr_smooth_dec  = off
    relax_sc_over_cu = off
    kprof_cu         = off
    bl_res_inv       = off
    a_ent_shr_nml    = 5.0_r_um
    allocate(alpha_cd(bl_levels))
    alpha_cd         = 1.5_r_um
    alpha_cd(1)      = 2.0_r_um
    puns             = 0.5_r_um
    pstb             = 2.0_r_um
    nl_bl_levels     = bl_levels
    flux_bc_opt      = flux_bc_opt_in

    ! Convection namelist options - should be moved to namelist in future
    if (convection == convection_um) l_param_conv = .true.
    ! need by conv_diag even if Gregory-Rowntree scheme not called
    icvdiag         = 1
    cvdiag_inv      = 0
    cvdiag_sh_wtest = 0.02_r_um
    limit_pert_opt  = 2
    tv1_sd_opt      = 2
    iconv_congestus = 0
    iconv_deep      = 1
    ent_fac_dp      = 1.13_r_um
    cldbase_opt_sh  = 0
    cldbase_opt_dp  = 8
    w_cape_limit    = 0.4_r_um
    cape_bottom     = 5
    cape_top        = 50

    if ( l_param_conv ) then

      ! Convection scheme
      select case (cv_scheme)
        case(cv_scheme_gregory_rowntree) 
          i_convection_vn = i_convection_vn_6a
          ! set for testing GA7 like 6A convection
          adapt   = 7
          amdet_fac = 3.0_r_um
          anv_opt = 0
          anvil_factor = 1.0000_r_um
          bl_cnv_mix = 1
          cape_min   = 0.5_r_um
          cape_timescale = 3600
          cca2d_dp_opt = 1
          cca2d_md_opt = 1
          cca2d_sh_opt = 2
          cca_dp_knob = 0.10_r_um 
          cca_md_knob = 0.10_r_um
          cca_sh_knob = 0.20_r_um
          ccw_dp_knob = 1.00_r_um
          ccw_for_precip_opt = 4
          ccw_md_knob = 1.00_r_um
          ccw_sh_knob = 1.00_r_um
          cldbase_opt_md   = 7
          cnv_cold_pools   = 0
          cnv_wat_load_opt = 0
          dd_opt = 1
          deep_cmt_opt = 5
          dil_plume_water_load = 0
          eff_dcff = 1.0_r_um
          eff_dcfl = 1.0_r_um
          ent_dp_power = 1.00_r_um
          ent_fac_md   = 0.90_r_um
          ent_opt_dp = 3
          ent_opt_md = 0
          fac_qsat = 0.500_r_um
          fdet_opt      = 0
          iconv_mid     = 1
          iconv_shallow = 1

          l_cloud_deep  = .true.
          l_3d_cca = .true.
          l_anvil  = .true.
          l_ccrad  = .true.

          l_cmt_heating       = .true.
          l_cv_conserve_check = .true.
          l_mom               = .true.
          l_safe_conv         = .true.

          mdet_opt_dp = 1
          mid_cmt_opt = 0
          mid_cnv_pmin = 10000.00_r_um
          mparwtr      = 1.5000e-3_r_um
          n_conv_calls = int( number_of_convection_substeps,i_um)
          plume_water_load = 0
          qlmin  = 3.0000e-4_r_um
          qstice = 3.5000e-3_r_um
          r_det  = 0.8000_r_um
          rad_cloud_decay_opt = 0
          sh_pert_opt = 1
          t_melt_snow  = 274.15_r_um
          termconv    = 1
          tice         = 263.1500_r_um
          tower_factor = 1.0000_r_um
          ud_factor    = 1.0000_r_um

          ! Need to set switches based on above UM convection namelist info
          call cv_set_dependent_switches( )
          ! Flags set to calculate all diagnostics i.e. as a SCM
          call set_convection_output_flags( )
        case(cv_scheme_lambert_lewis) 
          i_convection_vn = i_cv_llcs
          non_local_bl    = off            ! Only valid for this option
        case default
          write( log_scratch_space, '(A,I5)' )  &
          'Invalid convection scheme option, stopping', cv_scheme 
          call log_event( log_scratch_space, LOG_LEVEL_ERROR )
      end select
    else
      ! No call to convection but using 6A convective diagnosis scheme
      i_convection_vn = i_convection_vn_6a
    end if 

    ! Cloud namelist options - should be moved to namelist in future
    if ( cloud == cloud_um ) then
      select case (scheme)
        case(scheme_smith)
          i_cld_vn = i_cld_smith
        case default
          write( log_scratch_space, '(A,I3)' )  &
            'Invalid cloud scheme option, stopping', scheme
          call log_event( log_scratch_space, LOG_LEVEL_ERROR )
      end select
    else
      i_cld_vn = i_cld_off
    end if

    i_rhcpt               = rhcpt_off
    forced_cu             = off
    i_cld_area            = acf_off
    i_eacf                = off
    ice_fraction_method   = smith_orig
    falliceshear_method   = real_shear
    cff_spread_rate       = 1.0e-3_r_um
    l_subgrid_qv          = .true.
    ice_width             = 0.02_r_um

    ! Set rhcrit to the profile provided in the physics namelist.
    ! rhcrit is used throughout the UM and its value needs setting
    ! here.
    if ( cloud == cloud_um .and. &
         scheme == scheme_smith ) then
      rhcrit = real(rh_crit, r_um)
    end if
    rhc_row_length = 1
    rhc_rows = 1

    ! Microphysics namelist options - should be moved to namelist in future
    ai             = 2.5700e-2_r_um
    ar             = 1.00_r_um
    bi             = 2.00_r_um
    c_r_correl     = 0.9_r_um
    ci_input       = 14.3_r_um
    cic_input      = 1024.0_r_um
    di_input       = 0.416_r_um
    dic_input      = 1.0_r_um
    i_mcr_iter     = i_mcr_iter_tstep
    l_diff_icevt   = .true.
    l_mcr_qrain    = .true.
    l_psd          = .true.
    l_rain         = .true.
    l_warm_new     = .true.
    sediment_loc   = all_sed_start
    timestep_mp_in = 120
    x1r            = 2.2000e-1_r_um
    x2r            = 2.2000_r_um

    ! Radiation option needed by microphysics
    two_d_fsd_factor = 1.414_r_um

    ! Things required by mphys.
    ! These should all be reviewed and removed or
    ! set to more sensible values based on LFRic mesh
    ! However the code will not work if they are left unset.

    ! This is used in the calculation of grid-box size. Since they are
    ! nearly square, we set it to a value of 1 for now
    allocate(cos_theta_latitude(row_length,rows), source=1.0_r_um)
    mphys_mod_top       = domain_top
    delta_lambda        = 1.875_r_um*pi_over_180
    delta_phi           = 1.875_r_um*pi_over_180
    fsd_eff_lam         = delta_lambda
    fsd_eff_phi         = delta_phi

    ! Jules namelist options - should be moved to namelist in future
    charnock          = 0.018_r_um
    emis_sea          = 0.985_r_um
    iseasurfalg       = ip_ss_surf_div
    seasalinityfactor = 0.98_r_um
    cor_mo_iter       = Limit_ObukhovL
    iscrntdiag        = ip_scrndecpl2
    isrfexcnvgust     = IP_SrfExWithCnv
    l_epot_corr       = .true.

    ! Tuning segment sizes used in the physics code
    bl_segment_size     = 1
    precip_segment_size = 1
    ussp_seg_size       = 1

    ! Spectral gravity wave drag namelist options

    ussp_launch_factor = real(ussp_launch_factor_in, r_um)
    wavelstar = real(wavelstar_in, r_um)
    l_add_cgw = add_cgw_in
    cgw_scale_factor = real(cgw_scale_factor_in, r_um)

    !-----------------------------------------------------------------------
    ! Set up index for sea and sea-ice
    !
    ! This code is copied from atmos_physics1 and has been adapted
    ! for a sea-point only - no land or sea-ice
    !
    ! It will need re-writing!
    !-----------------------------------------------------------------------
    ssi_pts = 0
    ssi_index(:)=0
    DO j=1,rows
      DO i=1,row_length
        ssi_pts=ssi_pts + 1
        ssi_index(ssi_pts) = (j-1)*row_length + i
        fssi_ij(i,j)=1.0_r_um
      END DO
    END DO

    !-----------------------------------------------------------------------
    ! Allocate space for and initialise sea and sea-ice indices.
    !-----------------------------------------------------------------------
    sea_pts = 0
    sice_pts = 0
    sea_index(:)=0
    sice_index(:)=0
    sice_frac(:)=0.0_r_um
    sea_frac(:)=0.0_r_um
    DO l=1,ssi_pts
      j=(ssi_index(l)-1)/row_length + 1
      i = ssi_index(l) - (j-1)*row_length
      IF (ssi_index(l) > 0) THEN
        sea_pts=sea_pts+1
        sea_index(sea_pts)=l
        sea_frac(l)=1.0_r_um - sice_frac(l)
      END IF
    END DO

    ! NOTE these settings use NICE_USE not NICE so are suitable for use here and
    ! in the explicit part of the surface exchange code.  They are then updated
    ! using NICE before the call to the implicit part of the surface exchange
    ! code
    sice_pts_ncat(:)=0
    sice_index_ncat(:,:)=0
    sice_frac_ncat(:,:)=0.0_r_um
    !-----------------------------------------------------------------------
    ! Code to prepare for Smagorinsky turbulence scheme
    !-----------------------------------------------------------------------

    if ( smagorinsky ) then

      allocate ( visc_h(row_length, rows, nlayers) )
      allocate ( visc_m(row_length, rows, nlayers) )
      allocate ( rneutml_sq(row_length, rows, nlayers) )
      allocate ( max_diff  (row_length, rows) )
      allocate ( delta_smag(row_length, rows) )

      select case ( mixing_method )
        case( method_3d_smag ) 
          l_subfilter_horiz = .true. 
          l_subfilter_vert  = .true. 
          blending_option   = off
        case( method_2d_smag ) 
          l_subfilter_horiz = .true. 
          l_subfilter_vert  = .false. 
          blending_option   = off
        case( method_blending ) 
          l_subfilter_horiz = .true. 
          l_subfilter_vert  = .true. 
          blending_option   = grey_zone_cu
      end select

      mix_factor = real(mix_factor_in, r_um)
      turb_startlev_vert  = 1
      turb_endlev_vert    = bl_levels

    else

      allocate ( visc_h(1,1,1) )
      allocate ( visc_m(1,1,1) )
      allocate ( rneutml_sq(1,1,1) )
      allocate ( max_diff(1,1) )
      allocate ( delta_smag(1,1) )

      blending_option   = off
      l_subfilter_horiz = .false. 
      l_subfilter_vert  = .false. 

    end if

    !-----------------------------------------------------------------------
    ! Final error checking
    !-----------------------------------------------------------------------
    if (l_mcr_qcf2) then
         call log_event( &
        'mphys_kernel_mod: Second ice prognostic is retired in LFRic.', &
         LOG_LEVEL_ERROR )
    end if

  end subroutine um_init

end module um_init_mod
