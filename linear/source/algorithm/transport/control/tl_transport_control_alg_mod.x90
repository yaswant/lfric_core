!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module controlling the tangent linear transport.

module tl_transport_control_alg_mod

  use constants_mod,                     only: i_def, r_def, l_def
  use field_mod,                         only: field_type
  use formulation_config_mod,            only: moisture_formulation,    &
                                               moisture_formulation_dry
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_INFO
  use model_clock_mod,                   only: model_clock_type
  use tl_transport_runtime_collection_mod, &
                                         only: tl_transport_runtime
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_runtime_alg_mod,         only: transport_runtime_type
  use transport_runtime_collection_mod,  only: set_transport_runtime
  use transport_metadata_collection_mod, only: transport_metadata_collection

  implicit none

  private

  ! Set number of mixing ratio species to transport
  ! Only transport first four species of moisture (and not graupel or snow)
  integer(kind=i_def), parameter :: nummr_to_transport = 4

  ! Contained suroutines
  public :: tl_transport_control_alg

contains

  !=============================================================================
  !> @brief Advection of prognostic variables for the tangent linear model.
  !> @param[in,out] advection_inc      ACTIVE Advection increment of the dynamics
  !!                                   prognostics [u, rho, theta, exner]
  !> @param[in]     advected_fields    ACTIVE Fields to advect: [u, rho, theta, exner]
  !> @param[in]     wind_np1           ACTIVE End of timestep wind field
  !> @param[in]     wind_n             ACTIVE Start of timestep wind field
  !> @param[in,out] mr_out             ACTIVE Moisture fields after transport
  !> @param[in]     mr_in              ACTIVE Moisture fields before transport
  !> @param[in]     ls_advected_fields PASSIVE Fields to advect: [u, rho, theta, exner]
  !> @param[in]     ls_wind_np1        PASSIVE End of timestep wind field
  !> @param[in]     ls_wind_n          PASSIVE Start of timestep wind field
  !> @param[in]     ls_mr_in           PASSIVE Moisture fields before transport
  !> @param[in]     model_clock        Time within the model
  !>
  subroutine tl_transport_control_alg(advection_inc, advected_fields,   &
                                      wind_np1, wind_n, mr_out, mr_in,  &
                                      ls_advected_fields,               &
                                      ls_wind_np1, ls_wind_n, ls_mr_in, &
                                      model_clock )

    use check_configuration_mod,         only: check_any_shifted
    use derived_config_mod,              only: bundle_size
    use extrusion_mod,                   only: SHIFTED
    use fem_constants_mod,               only: get_mass_matrix
    use field_bundle_mod,                only: clone_bundle, set_bundle_scalar
    use field_indices_mod,               only: igh_u, igh_t, igh_d, igh_p
    use fs_continuity_mod,               only: Wtheta
    use dg_inc_matrix_vector_kernel_mod, only: dg_inc_matrix_vector_kernel_type
    use mesh_mod,                        only: mesh_type
    use mesh_collection_mod,             only: mesh_collection
    use mr_indices_mod,                  only: nummr
    use operator_mod,                    only: operator_type
    use timestepping_config_mod,         only: time_method => method, &
                                               method_semi_implicit
    use tl_moist_mr_transport_alg_mod,   only: tl_moist_mr_transport_alg
    use tl_transport_field_mod,          only: tl_transport_field
    use tl_wind_transport_alg_mod,       only: tl_wind_transport_alg
    use io_config_mod,                   only: subroutine_timers
    use timer_mod,                       only: timer

    implicit none

    ! Arguments
    type(field_type),            intent(inout) :: advection_inc(bundle_size)
    type(field_type),            intent(in)    :: advected_fields(bundle_size)
    type(field_type),            intent(in)    :: wind_np1
    type(field_type),            intent(in)    :: wind_n
    type(field_type),            intent(in)    :: ls_wind_np1
    type(field_type),            intent(in)    :: ls_wind_n
    type(field_type),            intent(inout) :: mr_out(nummr)
    type(field_type),            intent(in)    :: mr_in(nummr)
    type(field_type),            intent(in)    :: ls_advected_fields(bundle_size)
    type(field_type),            intent(in)    :: ls_mr_in(nummr)
    class(model_clock_type),     intent(in)    :: model_clock

    ! Internal variables
    type(field_type)    :: temp_inc
    type(field_type)    :: fields_np1(bundle_size)
    logical(kind=l_def) :: any_shifted
    real(r_def)         :: cast_dt
    type(operator_type), pointer :: mm_wt => null()
    type(mesh_type),     pointer :: primary_mesh => null()
    type(mesh_type),     pointer :: shifted_mesh => null()
    type(transport_runtime_type) :: transport_runtime

    type(transport_metadata_type), pointer :: transport_metadata => null()

    if ( subroutine_timers ) call timer('tl_transport_control')

    ! ------------------------------------------------------------------------ !
    ! Pre-transport initialisation tasks
    ! ------------------------------------------------------------------------ !

    ! Check if any horizontal method is ffsl
    any_shifted = check_any_shifted()

    ! Create transport_runtime object (advecting wind etc)
    if ( any_shifted ) then
      primary_mesh => ls_wind_n%get_mesh()
      shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)

      transport_runtime = transport_runtime_type( ls_wind_n, ls_wind_np1, &
                                                  model_clock, shifted_mesh )
      tl_transport_runtime = transport_runtime_type( wind_n, wind_np1, &
                                                     model_clock, shifted_mesh )

      nullify(primary_mesh, shifted_mesh)
    else
      transport_runtime = transport_runtime_type( ls_wind_n, ls_wind_np1, &
                                                  model_clock )
      tl_transport_runtime = transport_runtime_type( wind_n, wind_np1, &
                                                     model_clock )
    end if
    call set_transport_runtime(transport_runtime)

    ! Initialise fields
    call clone_bundle(advected_fields, fields_np1, bundle_size)
    call set_bundle_scalar(0.0_r_def, fields_np1, bundle_size)

    ! ------------------------------------------------------------------------ !
    ! Transport of prognostic variables
    ! ------------------------------------------------------------------------ !

    cast_dt = real( model_clock%get_seconds_per_step(), r_def )

    ! ------------------------------------------------------------------------ !
    ! Transport dry density
    call log_event( "Transporting density...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('density')
    call tl_transport_field( fields_np1(igh_d), advected_fields(igh_d), &
                             ls_advected_fields(igh_d), cast_dt,        &
                             transport_metadata )
    call invoke( X_minus_Y( advection_inc(igh_d), fields_np1(igh_d), &
                            advected_fields(igh_d) ) )

    ! ------------------------------------------------------------------------ !
    ! Transport potential temperature
    call log_event( "Transporting potential temperature...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('potential_temperature')
    call tl_transport_field( fields_np1(igh_t), advected_fields(igh_t), &
                             ls_advected_fields(igh_t), cast_dt,        &
                             transport_metadata )
    call invoke( X_minus_Y( advection_inc(igh_t), fields_np1(igh_t), &
                            advected_fields(igh_t) ) )
    ! The increment is now pointwise. Depending upon the temporal discretisation
    ! this may need converting into weak form by multiplying by the mass matrix
    if ( time_method == method_semi_implicit ) then
      mm_wt => get_mass_matrix(Wtheta, advected_fields(igh_t)%get_mesh_id())
      call temp_inc%initialise( vector_space = &
                                fields_np1(igh_t)%get_function_space() )

      call invoke( setval_X(temp_inc, advection_inc(igh_t)),              &
                   setval_c(advection_inc(igh_t), 0.0_r_def),             &
                   dg_inc_matrix_vector_kernel_type(advection_inc(igh_t), &
                                                    temp_inc, mm_wt) )
      nullify( mm_wt )
    end if

    ! ------------------------------------------------------------------------ !
    ! Transport wind field
    call log_event( "Transporting wind...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('wind')
    call tl_wind_transport_alg( advection_inc(igh_u), advected_fields(igh_u), &
                                ls_advected_fields(igh_u), cast_dt,           &
                                transport_metadata )
    ! We don't change advection_inc(igh_u) as tl_wind_transport_alg
    ! already returns weak increment

    ! ------------------------------------------------------------------------ !
    ! Don't transport Exner pressure
    call invoke( setval_c(advection_inc(igh_p), 0.0_r_def) )

    ! ------------------------------------------------------------------------ !
    ! Transport moisture mixing ratio fields
    if ( moisture_formulation /= moisture_formulation_dry ) then

      call log_event("Transporting moisture mixing ratio fields...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('moisture')
      call tl_moist_mr_transport_alg( mr_out, mr_in, ls_mr_in,      &
                                      nummr_to_transport, cast_dt, &
                                      transport_metadata )

    end if

    if ( subroutine_timers ) call timer('tl_transport_control')

  end subroutine tl_transport_control_alg

end module tl_transport_control_alg_mod
