!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief  Additional code to initialise the linearisation state.
module linear_data_algorithm_mod

  use constants_mod,                  only: i_def, r_def, str_def
  use field_array_mod,                only: field_array_type
  use field_bundle_builtins_mod,      only: set_bundle_scalar
  use field_mod,                      only: field_type
  use field_collection_mod,           only: field_collection_type
  use geometric_constants_mod,        only: get_coordinates, &
                                            get_panel_id
  use gungho_modeldb_mod,             only: modeldb_type
  use linked_list_mod,                only: linked_list_type
  use lfric_xios_read_mod,            only: read_state
  use mr_indices_mod,                 only: nummr, mr_names
  use model_clock_mod,                only: model_clock_type
  use moist_dyn_mod,                  only: num_moist_factors
  use moist_dyn_factors_alg_mod,      only: moist_dyn_factors_alg
  use variable_fields_mod,            only: init_variable_fields,  &
                                            update_variable_fields
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO,    &
                                            LOG_LEVEL_DEBUG
  use mesh_mod,                       only: mesh_type
  use field_minmax_alg_mod,           only: log_field_minmax

  implicit none

  private
  public init_ls_file_alg,            &
         update_ls_file_alg,          &
         combine_ls_winds,            &
         linear_copy_model_to_ls,     &
         linear_init_pert_random,     &
         linear_init_pert_analytical, &
         linear_init_reference_ls,    &
         linear_init_pert_zero

  contains

  !> @brief   Read the time-varying linearisation state from a file.
  !> @details Initialise the lin state, that is read in and updated using
  !!          a time-axis.
  !> @param[in,out] ls_times_list  The Lin state time axis list
  !> @param[in]     model_clock    Time within the model.
  !> @param[in,out] ls_fields      The Lin state field collection
  !> @param[in,out] ls_mr          The Lin state mixing ratios
  !> @param[in,out] ls_moist_dyn   The Lin state moist dynamical factors
  subroutine init_ls_file_alg( ls_times_list, &
                               model_clock,   &
                               ls_fields,     &
                               ls_mr,         &
                               ls_moist_dyn )

    implicit none

    type( field_collection_type ), intent(inout) :: ls_fields
    type( field_type ),            intent(inout) :: ls_mr(nummr)
    type( field_type ),            intent(inout) :: ls_moist_dyn(num_moist_factors)
    type(linked_list_type),        intent(in)    :: ls_times_list
    class(model_clock_type),       intent(in)    :: model_clock

    type( field_type ),            pointer       :: ls_field => null()
    integer(i_def)                               :: imr
    character(str_def) :: name

    call read_state( ls_fields )
    call init_variable_fields( ls_times_list, &
                               model_clock, ls_fields )

    ! When the moisture fields are read in from file, they are read into
    ! fields in ls_fields. Here, the moisture fields are copied from ls_fields
    ! to the ls_mr array. This step is required because problems were found
    ! reading the moisture fields directly into the ls_mr array.
    do imr = 1, nummr-2
      name = trim( 'ls_' // adjustl(mr_names(imr)) )

      call ls_fields%get_field(name, ls_field)
      call ls_field%copy_field_properties(ls_mr(imr))
      call invoke( setval_X(ls_mr(imr), ls_field) )

    end do

    ! Only the first 4 moisture fields are read from file, and the remaining
    ! fields ls_mr are set to zero. This is done explictly here.
    call invoke( setval_C(ls_mr(nummr-1), 0.0_r_def), &
                 setval_C(ls_mr(nummr),   0.0_r_def) )

    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )

    call combine_ls_winds( ls_fields )

    nullify( ls_field )

  end subroutine init_ls_file_alg

  !> @brief   Update the time-varying Lin state from a file.
  !> @details Update the Lin state, that is read in and updated using
  !!          a time-axis.
  !> @param[in]     ls_times_list  The Lin state time axis list
  !> @param[in]     model_clock    Time within the model.
  !> @param[in,out] ls_fields      The Lin state field collection
  !> @param[in,out] ls_mr          The Lin state mixing ratios
  !> @param[in,out] ls_moist_dyn   The Lin state moist dynamical factors
  subroutine update_ls_file_alg( ls_times_list, &
                                 model_clock,   &
                                 ls_fields,     &
                                 ls_mr,         &
                                 ls_moist_dyn )

    implicit none

    type( field_collection_type ), intent(inout) :: ls_fields
    type( field_type ),            intent(inout) :: ls_mr(nummr)
    type( field_type ),            intent(inout) :: ls_moist_dyn(num_moist_factors)
    type(linked_list_type),        intent(in)    :: ls_times_list
    class(model_clock_type),       intent(in)    :: model_clock

    type( field_type ), pointer                  :: ls_field => null()
    integer(i_def)                               :: imr
    character(str_def) :: name

    call update_variable_fields( ls_times_list,    &
                                 model_clock, ls_fields )

    ! When the moisture fields are read in from file, they are read into
    ! fields in ls_fields. Here, the moisture fields are copied from ls_fields
    ! to the ls_mr array. This step is required because problems were found
    ! reading the moisture fields directly into the ls_mr array.
    do imr = 1, nummr-2

      name = trim( 'ls_' // adjustl(mr_names(imr)) )

      call ls_fields%get_field(name, ls_field)
      call invoke( setval_X( ls_mr(imr), ls_field) )

    end do

    ! Only the first 4 moisture fields are read from file, and the remaining
    ! fields ls_mr are set to zero. This is done explictly here.
    call invoke( setval_C(ls_mr(nummr-1), 0.0_r_def), &
                 setval_C(ls_mr(nummr),   0.0_r_def) )

    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )

    call combine_ls_winds( ls_fields )

    call ls_fields%get_field("ls_u", ls_field)
    call log_field_minmax( LOG_LEVEL_DEBUG, 'ls_u', ls_field )

    call ls_fields%get_field("ls_rho", ls_field)
    call log_field_minmax( LOG_LEVEL_DEBUG, 'ls_rho', ls_field )

    call ls_fields%get_field("ls_exner", ls_field)
    call log_field_minmax( LOG_LEVEL_DEBUG, 'ls_exner', ls_field )

    call ls_fields%get_field("ls_theta", ls_field)
    call log_field_minmax( LOG_LEVEL_DEBUG, 'ls_theta', ls_field )

    call ls_fields%get_field("ls_m_v", ls_field)
    call log_field_minmax( LOG_LEVEL_DEBUG, 'ls_m_v', ls_field )

    nullify( ls_field )

  end subroutine update_ls_file_alg

  !> @brief   Combine horizontal and vertical winds.
  !> @details The horizontal winds are read in as W2H, and the vertical
  !!          winds are read in as Wtheta. This combines them into a
  !!          single W2 field.
  !> @param[in,out] fields  The collection of ls fields
  subroutine combine_ls_winds( fields )

    use combine_w2_field_kernel_mod, only: combine_w2_field_kernel_type

    implicit none

    type( field_collection_type ), intent(inout) :: fields
    type(field_type), pointer                    :: wind => null()
    type(field_type), pointer                    :: h_wind => null()
    type(field_type), pointer                    :: v_wind => null()

    write(log_scratch_space,'(A)') "Combining winds "
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    call fields%get_field("ls_h_u", h_wind)
    call fields%get_field("ls_v_u", v_wind)
    call fields%get_field("ls_u", wind)

    call invoke( combine_w2_field_kernel_type(wind, h_wind, v_wind) )

    nullify( h_wind, v_wind, wind )

  end subroutine combine_ls_winds

  !> @brief Copy the prognostic fields to the LS and then zero the prognostics.
  !> @param[in,out] modeldb The working data set for the model run
  subroutine linear_copy_model_to_ls( modeldb )

    implicit none

    type( modeldb_type ), target, intent(inout) :: modeldb

    type( field_collection_type ), pointer :: prognostic_fields => null()
    type( field_collection_type ), pointer :: ls_fields => null()
    type( field_type ),            pointer :: ls_mr(:) => null()
    type( field_type ),            pointer :: mr(:) => null()
    type( field_type ),            pointer :: ls_moist_dyn(:) => null()
    type( field_type ),            pointer :: moist_dyn(:) => null()
    type( field_type ),            pointer :: l_field => null()
    type( field_type ),            pointer :: n_field => null()
    integer( kind=i_def )                  :: imr

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: mr_array => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()
    type(field_array_type), pointer      :: ls_mr_array => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    write(log_scratch_space,'(A)') "Copy prognostics to ls fields"
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    ls_fields => modeldb%model_data%ls_fields
    prognostic_fields => modeldb%fields%get_field_collection(&
                                          "prognostic_fields")

    call ls_fields%get_field("ls_u", l_field)
    call prognostic_fields%get_field("u", n_field)
    call invoke( setval_X( l_field, n_field), &
                 setval_C( n_field, 0.0_r_def) )

    call ls_fields%get_field("ls_exner", l_field)
    call prognostic_fields%get_field("exner", n_field)
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    call ls_fields%get_field("ls_rho", l_field)
    call prognostic_fields%get_field("rho", n_field)
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    call ls_fields%get_field("ls_theta", l_field)
    call prognostic_fields%get_field("theta", n_field)
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("mr", mr_array)
    mr => mr_array%bundle
    call moisture_fields%get_field("ls_mr",ls_mr_array)
    ls_mr => ls_mr_array%bundle
    do imr = 1, nummr
      call invoke( setval_X( ls_mr(imr), mr(imr) ) , &
                   setval_C( mr(imr), 0.0_r_def) )
    end do

    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_moist_dyn => ls_moist_dyn_array%bundle
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)
    moist_dyn => moist_dyn_array%bundle
    do imr = 1, num_moist_factors
      call invoke( setval_X( ls_moist_dyn(imr), moist_dyn(imr) ) , &
                   setval_C( moist_dyn(imr), 0.0_r_def) )
    end do

    nullify( l_field, n_field, ls_mr, mr, ls_moist_dyn, moist_dyn )

  end subroutine linear_copy_model_to_ls

  !> @brief Define the initial conditions with random data.
  !> @details The Fortran intrinsic 'random_number' is used to assign
  !!          random numbers to the initial conditions, with the size set
  !!          by specified parameters such as gamma_u and gamma_rho.
  !> @param[in,out] modeldb The working data set for the model run
  subroutine linear_init_pert_random( modeldb )

    use assign_field_random_kernel_mod, only: assign_field_random_kernel_type
    use map_fd_to_prognostics_alg_mod,  only: set_wind
    use fs_continuity_mod,              only: W3, Wtheta
    use function_space_mod,             only: function_space_type
    use function_space_collection_mod,  only: function_space_collection

    implicit none

    type( modeldb_type ), target, intent(inout) :: modeldb

    type( field_type ),          pointer :: field => null()
    type( field_type ),          pointer :: moist_dyn(:) => null()
    type( field_type ),          pointer :: mr(:) => null()
    type( mesh_type ),           pointer :: mesh => null()
    type( function_space_type ), pointer :: vspace => null()

    type( field_type )    :: u_in_w3
    type( field_type )    :: v_in_w3
    type( field_type )    :: w_in_wth

    real( kind=r_def )    :: gamma_u, gamma_rho, gamma_exner, gamma_theta
    real( kind=r_def )    :: gamma_moist_dyn, gamma_mr
    integer( kind=i_def ) :: element_order
    integer( kind=i_def ) :: i

    type(field_collection_type), pointer :: prognostic_fields => null()
    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: mr_array => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()

    gamma_theta = 1.e2
    gamma_rho = 1.e-1
    gamma_exner = 1.e-1
    gamma_moist_dyn = 1.e-1
    gamma_mr = 1.e-1
    gamma_u = 1.e2

    prognostic_fields => modeldb%fields%get_field_collection(&
                                          "prognostic_fields")
    call prognostic_fields%get_field("rho", field)
    call invoke( assign_field_random_kernel_type( field, gamma_rho ))

    call prognostic_fields%get_field("theta", field)
    call invoke( assign_field_random_kernel_type( field, gamma_theta ))

    call prognostic_fields%get_field("exner", field)
    call invoke( assign_field_random_kernel_type( field, gamma_exner ))

    ! Apply randomization to W3/Wtheta cell centre wind fields and Interpolate
    ! to prognostic W2 wind

    ! Get mesh and element order from field
    mesh=>field%get_mesh()
    element_order=field%get_element_order()

    ! Create local fields to apply randomization
    vspace => function_space_collection%get_fs(mesh, element_order, W3)
    call u_in_w3%initialise( vector_space = vspace )
    call v_in_w3%initialise( vector_space = vspace )
    vspace => function_space_collection%get_fs(mesh, element_order, Wtheta)
    call w_in_wth%initialise( vector_space = vspace )

    ! Apply randomization to cell centre winds
    call invoke( assign_field_random_kernel_type( u_in_w3, gamma_u), &
                 assign_field_random_kernel_type( v_in_w3, gamma_u), &
                 assign_field_random_kernel_type( w_in_wth, gamma_u) )

    ! Interpolate cell centred zonal/meridional winds to the W2 wind
    call prognostic_fields%get_field("u", field)
    call set_wind( field, u_in_w3, v_in_w3, w_in_wth )

    ! Apply randomization to moisture fields
    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("mr", mr_array)
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)

    moist_dyn => moist_dyn_array%bundle
    do i = 1, num_moist_factors
      call invoke( assign_field_random_kernel_type( moist_dyn(i), gamma_moist_dyn ) )
    end do

    mr => mr_array%bundle
    do i = 1, nummr
      call invoke( assign_field_random_kernel_type( mr(i), gamma_mr ) )
    end do

    nullify( field, mr, moist_dyn, mesh, vspace )
    nullify( moisture_fields, mr_array, moist_dyn_array )

  end subroutine linear_init_pert_random


  !> @brief Define the initial conditions by setting fields to zeros.
  !> @param[in,out] modeldb The working data set for the model run
  subroutine linear_init_pert_zero( modeldb )

    implicit none

    type( modeldb_type ), target, intent(inout) :: modeldb

    ! Local
    integer( kind=i_def )                :: i
    type( field_collection_type ), pointer :: prognostic_fields => null()
    type( field_type ),            pointer :: mr(:)             => null()
    type( field_type ),            pointer :: moist_dyn(:)      => null()
    type( field_type ),            pointer :: theta             => null()
    type( field_type ),            pointer :: rho               => null()
    type( field_type ),            pointer :: u                 => null()
    type( field_type ),            pointer :: exner             => null()

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: mr_array => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()


    ! Prognostic fields
    prognostic_fields => modeldb%fields%get_field_collection(&
                                          "prognostic_fields")

    call prognostic_fields%get_field('u', u)
    call prognostic_fields%get_field('theta', theta)
    call prognostic_fields%get_field('exner', exner)
    call prognostic_fields%get_field('rho', rho)

    ! Set all prognostics to zero
    call invoke( setval_c(theta, 0.0_r_def),                 &
                 setval_c(rho, 0.0_r_def),                   &
                 setval_c(u, 0.0_r_def),                     &
                 setval_c(exner, 0.0_r_def))

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("mr", mr_array)
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)

    moist_dyn => moist_dyn_array%bundle
    do i = 1, num_moist_factors
      call invoke( setval_c(moist_dyn(i), 0.0_r_def) )
    end do

    mr => mr_array%bundle
    do i = 1, nummr
      call invoke( setval_c(mr(i), 0.0_r_def) )
    end do

    nullify( prognostic_fields, mr , moist_dyn )
    nullify( theta, rho, u, exner )
    nullify( moisture_fields, mr_array, moist_dyn_array )

  end subroutine linear_init_pert_zero

  !> @brief Define the initial conditions based on an analytical function.
  !> @details The DCMIP gravity wave test case is used to define perturbation.
  !> @param[in]     mesh       The current 3D mesh
  !> @param[in]     twod_mesh  The current 2D mesh
  !> @param[in,out] modeldb    The working data set for the model run
  subroutine linear_init_pert_analytical( mesh, twod_mesh, modeldb )

    implicit none

    type( mesh_type ), intent(in), pointer :: mesh
    type( mesh_type ), intent(in), pointer :: twod_mesh
    type( modeldb_type ), target, intent(inout) :: modeldb

    type( field_type ), pointer :: u => null()
    type( field_type ), pointer :: rho => null()
    type( field_type ), pointer :: theta => null()
    type( field_type ), pointer :: exner => null()

    type( field_type ), pointer :: ls_u => null()
    type( field_type ), pointer :: ls_rho => null()
    type( field_type ), pointer :: ls_theta => null()
    type( field_type ), pointer :: ls_exner => null()

    type( field_type ), pointer :: ls_mr(:) => null()
    type( field_type ), pointer :: ls_moist_dyn(:) => null()
    type( field_type ), pointer :: mr(:) => null()
    type( field_type ), pointer :: moist_dyn(:) => null()

    type( field_collection_type ), pointer :: prognostic_fields => null()
    type( field_collection_type ), pointer :: ls_fields => null()

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: mr_array => null()
    type(field_array_type), pointer      :: moist_dyn_array => null()
    type(field_array_type), pointer      :: ls_mr_array => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    integer( kind=i_def )  :: i

    ls_fields => modeldb%model_data%ls_fields
     prognostic_fields => modeldb%fields%get_field_collection(&
                                          "prognostic_fields")

    call ls_fields%get_field('ls_theta', ls_theta)
    call ls_fields%get_field('ls_u', ls_u)
    call ls_fields%get_field('ls_rho', ls_rho)
    call ls_fields%get_field('ls_exner', ls_exner)

    call prognostic_fields%get_field('theta', theta)
    call prognostic_fields%get_field('u', u)
    call prognostic_fields%get_field('rho', rho)
    call prognostic_fields%get_field('exner', exner)

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("mr", mr_array)
    call moisture_fields%get_field("moist_dyn", moist_dyn_array)
    mr => mr_array%bundle
    moist_dyn => moist_dyn_array%bundle

    call moisture_fields%get_field("ls_mr", ls_mr_array)
    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_mr => ls_mr_array%bundle
    ls_moist_dyn => ls_moist_dyn_array%bundle

    ! Subtract reference field from perturbed field to give perturbation
    call invoke( inc_X_minus_Y( u, ls_u ) ,         &
                 inc_X_minus_Y( exner, ls_exner ) , &
                 inc_X_minus_Y( rho, ls_rho ) ,     &
                 inc_X_minus_Y( theta, ls_theta ) )

    do i = 1, num_moist_factors
      call invoke( inc_X_minus_Y( moist_dyn(i), ls_moist_dyn(i) ) )
    enddo
    do i = 1, nummr
      call invoke( inc_X_minus_Y( mr(i), ls_mr(i) ) )
    enddo

    nullify( theta, rho, u, exner, moist_dyn, mr )
    nullify( ls_theta, ls_rho, ls_u, ls_exner, ls_moist_dyn, ls_mr )

  end subroutine linear_init_pert_analytical

  !> @brief Define the analytical reference field.
  !> @param[in,out] modeldb The working data set for the model run
  subroutine linear_init_reference_ls( modeldb )

    use init_gungho_prognostics_alg_mod,  only: init_u_field,     &
                                                init_exner_field, &
                                                init_rho_field,   &
                                                init_mr_fields
    use initial_theta_ref_kernel_mod,     only: initial_theta_ref_kernel_type
    use idealised_config_mod,             only: test

    implicit none

    type( modeldb_type ), target, intent(inout) :: modeldb

    type( field_type ), pointer :: ls_u => null()
    type( field_type ), pointer :: ls_rho => null()
    type( field_type ), pointer :: ls_theta => null()
    type( field_type ), pointer :: ls_exner => null()

    type( field_type ), pointer :: ls_mr(:) => null()
    type( field_type ), pointer :: ls_moist_dyn(:) => null()

    type( field_collection_type ), pointer :: ls_fields => null()

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: ls_mr_array => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    integer( kind=i_def )       :: mesh_id
    type( field_type ), pointer :: chi(:) => null()
    type( field_type ), pointer :: panel_id => null()

    real( kind=r_def )          :: initial_time

    ls_fields => modeldb%model_data%ls_fields

    call ls_fields%get_field('ls_theta', ls_theta)
    call ls_fields%get_field('ls_u', ls_u)
    call ls_fields%get_field('ls_rho', ls_rho)
    call ls_fields%get_field('ls_exner', ls_exner)

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("ls_mr",ls_mr_array)
    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_mr => ls_mr_array%bundle
    ls_moist_dyn => ls_moist_dyn_array%bundle

    mesh_id = ls_theta%get_mesh_id()
    chi => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    ! Define reference field
    initial_time = 0.0_r_def
    call init_u_field( ls_u , initial_time )
    call set_bundle_scalar( 0.0_r_def, ls_mr, nummr )

    call invoke( initial_theta_ref_kernel_type( &
                 ls_theta, chi, panel_id, test ) )

    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )
    call init_exner_field( ls_exner, ls_theta, ls_moist_dyn, initial_time )
    call init_rho_field( ls_rho, ls_theta, ls_exner, ls_moist_dyn, initial_time )
    call init_mr_fields( ls_mr, ls_theta, ls_exner, ls_rho, ls_moist_dyn )

    nullify( ls_theta, ls_rho, ls_u, ls_exner, ls_moist_dyn, ls_mr )
    nullify( chi, panel_id )

  end subroutine linear_init_reference_ls

end module linear_data_algorithm_mod
