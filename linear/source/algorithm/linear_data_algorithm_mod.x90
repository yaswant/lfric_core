!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief  Additional code to initialise the linearisation state.
module linear_data_algorithm_mod

  use constants_mod,                  only: i_def, r_def, str_def
  use field_bundle_mod,               only: set_bundle_scalar
  use field_mod,                      only: field_type
  use field_collection_mod,           only: field_collection_type
  use geometric_constants_mod,        only: get_coordinates, &
                                            get_panel_id
  use gungho_model_data_mod,          only: model_data_type
  use linked_list_mod,                only: linked_list_type
  use lfric_xios_read_mod,            only: read_state
  use mr_indices_mod,                 only: nummr, mr_names
  use model_clock_mod,                only: model_clock_type
  use moist_dyn_mod,                  only: num_moist_factors
  use moist_dyn_factors_alg_mod,      only: moist_dyn_factors_alg
  use variable_fields_mod,            only: init_variable_fields,  &
                                            update_variable_fields
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO,    &
                                            LOG_LEVEL_DEBUG
  use mesh_mod,                       only: mesh_type

  implicit none

  private
  public init_ls_file_alg,            &
         update_ls_file_alg,          &
         combine_ls_winds,            &
         linear_copy_model_to_ls,     &
         linear_init_pert_random,     &
         linear_init_pert_analytical, &
         linear_init_reference_ls

  contains

  !> @brief   Read the time-varying linearisation state from a file.
  !> @details Initialise the lin state, that is read in and updated using
  !!          a time-axis.
  !> @param[in,out] ls_times_list  The Lin state time axis list
  !> @param[in]     model_clock    Time within the model.
  !> @param[in,out] ls_fields      The Lin state field collection
  !> @param[in,out] ls_mr          The Lin state mixing ratios
  !> @param[in,out] ls_moist_dyn   The Lin state moist dynamical factors
  subroutine init_ls_file_alg( ls_times_list, &
                               model_clock,   &
                               ls_fields,     &
                               ls_mr,         &
                               ls_moist_dyn )

    implicit none

    type( field_collection_type ), intent(inout) :: ls_fields
    type( field_type ),            intent(inout) :: ls_mr(nummr)
    type( field_type ),            intent(inout) :: ls_moist_dyn(num_moist_factors)
    type(linked_list_type),        intent(in)    :: ls_times_list
    class(model_clock_type),       intent(in)    :: model_clock

    type( field_type ),            pointer       :: ls_field => null()
    integer(i_def)                               :: imr
    character(str_def) :: name

    call read_state( ls_fields )
    call init_variable_fields( ls_times_list, &
                               model_clock, ls_fields )

    ! When the moisture fields are read in from file, they are read into
    ! fields in ls_fields. Here, the moisture fields are copied from ls_fields
    ! to the ls_mr array. This step is required because problems were found
    ! reading the moisture fields directly into the ls_mr array.
    do imr = 1, nummr-2
      name = trim( 'ls_' // adjustl(mr_names(imr)) )

      call ls_fields%get_field(name, ls_field)
      call ls_field%copy_field(ls_mr(imr))

    end do

    ! Only the first 4 moisture fields are read from file, and the remaining
    ! fields ls_mr are set to zero. This is done explictly here.
    call invoke( setval_C(ls_mr(nummr-1), 0.0_r_def), &
                 setval_C(ls_mr(nummr),   0.0_r_def) )

    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )

    call combine_ls_winds( ls_fields )

    nullify( ls_field )

  end subroutine init_ls_file_alg

  !> @brief   Update the time-varying Lin state from a file.
  !> @details Update the Lin state, that is read in and updated using
  !!          a time-axis.
  !> @param[in]     ls_times_list  The Lin state time axis list
  !> @param[in]     model_clock    Time within the model.
  !> @param[in,out] ls_fields      The Lin state field collection
  !> @param[in,out] ls_mr          The Lin state mixing ratios
  !> @param[in,out] ls_moist_dyn   The Lin state moist dynamical factors
  subroutine update_ls_file_alg( ls_times_list, &
                                 model_clock,   &
                                 ls_fields,     &
                                 ls_mr,         &
                                 ls_moist_dyn )

    implicit none

    type( field_collection_type ), intent(inout) :: ls_fields
    type( field_type ),            intent(inout) :: ls_mr(nummr)
    type( field_type ),            intent(inout) :: ls_moist_dyn(num_moist_factors)
    type(linked_list_type),        intent(in)    :: ls_times_list
    class(model_clock_type),       intent(in)    :: model_clock

    type( field_type ), pointer                  :: ls_field => null()
    integer(i_def)                               :: imr
    character(str_def) :: name

    call update_variable_fields( ls_times_list,    &
                                 model_clock, ls_fields )

    ! When the moisture fields are read in from file, they are read into
    ! fields in ls_fields. Here, the moisture fields are copied from ls_fields
    ! to the ls_mr array. This step is required because problems were found
    ! reading the moisture fields directly into the ls_mr array.
    do imr = 1, nummr-2

      name = trim( 'ls_' // adjustl(mr_names(imr)) )

      call ls_fields%get_field(name, ls_field)
      call invoke( setval_X( ls_mr(imr), ls_field) )

    end do

    ! Only the first 4 moisture fields are read from file, and the remaining
    ! fields ls_mr are set to zero. This is done explictly here.
    call invoke( setval_C(ls_mr(nummr-1), 0.0_r_def), &
                 setval_C(ls_mr(nummr),   0.0_r_def) )

    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )

    call combine_ls_winds( ls_fields )

    call ls_fields%get_field("ls_u", ls_field)
    call ls_field%log_minmax(LOG_LEVEL_DEBUG, 'ls_u')

    call ls_fields%get_field("ls_rho", ls_field)
    call ls_field%log_minmax(LOG_LEVEL_DEBUG, 'ls_rho')

    call ls_fields%get_field("ls_exner", ls_field)
    call ls_field%log_minmax(LOG_LEVEL_DEBUG, 'ls_exner')

    call ls_fields%get_field("ls_theta", ls_field)
    call ls_field%log_minmax(LOG_LEVEL_DEBUG, 'ls_theta')

    call ls_fields%get_field("ls_m_v", ls_field)
    call ls_field%log_minmax(LOG_LEVEL_DEBUG, 'ls_m_v')

    nullify( ls_field )

  end subroutine update_ls_file_alg

  !> @brief   Combine horizontal and vertical winds.
  !> @details The horizontal winds are read in as W2H, and the vertical
  !!          winds are read in as Wtheta. This combines them into a
  !!          single W2 field.
  !> @param[in,out] fields  The collection of ls fields
  subroutine combine_ls_winds( fields )

    use combine_w2_field_kernel_mod, only: combine_w2_field_kernel_type

    implicit none

    type( field_collection_type ), intent(inout) :: fields
    type(field_type), pointer                    :: wind => null()
    type(field_type), pointer                    :: h_wind => null()
    type(field_type), pointer                    :: v_wind => null()

    write(log_scratch_space,'(A)') "Combining winds "
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    call fields%get_field("ls_h_u", h_wind)
    call fields%get_field("ls_v_u", v_wind)
    call fields%get_field("ls_u", wind)

    call invoke( combine_w2_field_kernel_type(wind, h_wind, v_wind) )

    nullify( h_wind, v_wind, wind )

  end subroutine combine_ls_winds

  !> @brief Copy the prognostic fields to the LS and then zero the prognostics.
  !> @param[in,out] model_data The working data set for the model run
  subroutine linear_copy_model_to_ls( model_data )

    implicit none

    type( model_data_type ), target, intent(inout) :: model_data

    type( field_collection_type ), pointer :: prognostics => null()
    type( field_collection_type ), pointer :: ls_fields => null()
    type( field_type ),            pointer :: ls_mr(:) => null()
    type( field_type ),            pointer :: mr(:) => null()
    type( field_type ),            pointer :: ls_moist_dyn(:) => null()
    type( field_type ),            pointer :: moist_dyn(:) => null()
    type( field_type ),            pointer :: l_field => null()
    type( field_type ),            pointer :: n_field => null()
    integer( kind=i_def )                  :: imr

    write(log_scratch_space,'(A)') "Copy prognostics to ls fields"
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    ls_fields => model_data%ls_fields
    prognostics => model_data%prognostic_fields

    call ls_fields%get_field("ls_u", l_field)
    call prognostics%get_field("u", n_field)
    call invoke( setval_X( l_field, n_field), &
                 setval_C( n_field, 0.0_r_def) )

    call ls_fields%get_field("ls_exner", l_field)
    call prognostics%get_field("exner", n_field)
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    call ls_fields%get_field("ls_rho", l_field)
    call prognostics%get_field("rho", n_field)
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    call ls_fields%get_field("ls_theta", l_field)
    call prognostics%get_field("theta", n_field)
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    ls_mr => model_data%ls_mr
    mr => model_data%mr
    do imr = 1, nummr
      call invoke( setval_X( ls_mr(imr), mr(imr) ) , &
                   setval_C( mr(imr), 0.0_r_def) )
    end do

    ls_moist_dyn => model_data%ls_moist_dyn
    moist_dyn => model_data%moist_dyn
    do imr = 1, num_moist_factors
      call invoke( setval_X( ls_moist_dyn(imr), moist_dyn(imr) ) , &
                   setval_C( moist_dyn(imr), 0.0_r_def) )
    end do

    nullify( l_field, n_field, ls_mr, mr, ls_moist_dyn, moist_dyn )

  end subroutine linear_copy_model_to_ls

  !> @brief Define the initial conditions with random data.
  !> @details The Fortran intrinsic 'random_number' is used to assign
  !!          random numbers to the initial conditions, with the size set
  !!          by specified parameters such as gamma_u and gamma_rho.
  !> @param[in]     mesh       The current 3D mesh
  !> @param[in]     twod_mesh  The current 2D mesh
  !> @param[in,out] model_data The working data set for the model run
  subroutine linear_init_pert_random( mesh, twod_mesh, model_data )

    use assign_field_random_kernel_mod, only: assign_field_random_kernel_type

    implicit none

    type( mesh_type ), intent(in), pointer :: mesh
    type( mesh_type ), intent(in), pointer :: twod_mesh

    type( model_data_type ), target, intent(inout) :: model_data

    integer( kind=i_def )                          :: i
    type( field_type ), pointer                    :: field => null()
    type( field_type ), pointer                    :: moist_dyn(:) => null()
    type( field_type ), pointer                    :: mr(:) => null()
    real( kind=r_def ) :: gamma_u, gamma_rho, gamma_exner, gamma_theta
    real( kind=r_def ) :: gamma_moist_dyn, gamma_mr

    gamma_u = 1.e4
    gamma_theta = 1.e2
    gamma_rho = 1.e-1
    gamma_exner = 1.e-1
    gamma_moist_dyn = 1.e-1
    gamma_mr = 1.e-1

    call model_data%prognostic_fields%get_field("u", field)
    call invoke( assign_field_random_kernel_type( field, gamma_u))

    call model_data%prognostic_fields%get_field("rho", field)
    call invoke( assign_field_random_kernel_type( field, gamma_rho ))

    call model_data%prognostic_fields%get_field("theta", field)
    call invoke( assign_field_random_kernel_type( field, gamma_theta ))

    call  model_data%prognostic_fields%get_field("exner", field)
    call invoke( assign_field_random_kernel_type( field, gamma_exner ))

    moist_dyn => model_data%moist_dyn
    do i = 1, num_moist_factors
      call invoke( assign_field_random_kernel_type( moist_dyn(i), gamma_moist_dyn ) )
    end do

    mr => model_data%mr
    do i = 1, nummr
      call invoke( assign_field_random_kernel_type( mr(i), gamma_mr ) )
    end do

    nullify( field, mr, moist_dyn )

  end subroutine linear_init_pert_random

  !> @brief Define the initial conditions based on an analytical function.
  !> @details The DCMIP gravity wave test case is used to define perturbation.
  !> @param[in]     mesh       The current 3D mesh
  !> @param[in]     twod_mesh  The current 2D mesh
  !> @param[in,out] model_data The working data set for the model run
  subroutine linear_init_pert_analytical( mesh, twod_mesh, model_data )

    implicit none

    type( mesh_type ), intent(in), pointer :: mesh
    type( mesh_type ), intent(in), pointer :: twod_mesh
    type( model_data_type ), target, intent(inout) :: model_data

    type( field_type ), pointer :: u => null()
    type( field_type ), pointer :: rho => null()
    type( field_type ), pointer :: theta => null()
    type( field_type ), pointer :: exner => null()

    type( field_type ), pointer :: ls_u => null()
    type( field_type ), pointer :: ls_rho => null()
    type( field_type ), pointer :: ls_theta => null()
    type( field_type ), pointer :: ls_exner => null()

    type( field_type ), pointer :: ls_mr(:) => null()
    type( field_type ), pointer :: ls_moist_dyn(:) => null()
    type( field_type ), pointer :: mr(:) => null()
    type( field_type ), pointer :: moist_dyn(:) => null()

    type( field_collection_type ), pointer :: prognostic_fields => null()
    type( field_collection_type ), pointer :: ls_fields => null()

    integer( kind=i_def )  :: i

    ls_fields => model_data%ls_fields
    prognostic_fields => model_data%prognostic_fields

    call ls_fields%get_field('ls_theta', ls_theta)
    call ls_fields%get_field('ls_u', ls_u)
    call ls_fields%get_field('ls_rho', ls_rho)
    call ls_fields%get_field('ls_exner', ls_exner)

    call prognostic_fields%get_field('theta', theta)
    call prognostic_fields%get_field('u', u)
    call prognostic_fields%get_field('rho', rho)
    call prognostic_fields%get_field('exner', exner)

    moist_dyn => model_data%moist_dyn
    mr => model_data%mr
    ls_moist_dyn => model_data%ls_moist_dyn
    ls_mr => model_data%ls_mr

    ! Subtract reference field from perturbed field to give perturbation
    call invoke( inc_X_minus_Y( u, ls_u ) ,         &
                 inc_X_minus_Y( exner, ls_exner ) , &
                 inc_X_minus_Y( rho, ls_rho ) ,     &
                 inc_X_minus_Y( theta, ls_theta ) )

    do i = 1, num_moist_factors
      call invoke( inc_X_minus_Y( moist_dyn(i), ls_moist_dyn(i) ) )
    enddo
    do i = 1, nummr
      call invoke( inc_X_minus_Y( mr(i), ls_mr(i) ) )
    enddo

    nullify( theta, rho, u, exner, moist_dyn, mr )
    nullify( ls_theta, ls_rho, ls_u, ls_exner, ls_moist_dyn, ls_mr )

  end subroutine linear_init_pert_analytical

  !> @brief Define the analytical reference field.
  !> @param[in,out] model_data The working data set for the model run
  subroutine linear_init_reference_ls( model_data )

    use init_gungho_prognostics_alg_mod,  only: init_u_field,     &
                                                init_exner_field, &
                                                init_rho_field,   &
                                                init_mr_fields
    use initial_theta_ref_kernel_mod,     only: initial_theta_ref_kernel_type
    use idealised_config_mod,             only: test

    implicit none

    type( model_data_type ), target, intent(inout) :: model_data

    type( field_type ), pointer :: ls_u => null()
    type( field_type ), pointer :: ls_rho => null()
    type( field_type ), pointer :: ls_theta => null()
    type( field_type ), pointer :: ls_exner => null()

    type( field_type ), pointer :: ls_mr(:) => null()
    type( field_type ), pointer :: ls_moist_dyn(:) => null()

    type( field_collection_type ), pointer :: ls_fields => null()

    integer( kind=i_def )       :: mesh_id
    type( field_type ), pointer :: chi(:) => null()
    type( field_type ), pointer :: panel_id => null()

    real( kind=r_def )          :: initial_time

    ls_fields => model_data%ls_fields

    call ls_fields%get_field('ls_theta', ls_theta)
    call ls_fields%get_field('ls_u', ls_u)
    call ls_fields%get_field('ls_rho', ls_rho)
    call ls_fields%get_field('ls_exner', ls_exner)

    ls_moist_dyn => model_data%ls_moist_dyn
    ls_mr => model_data%ls_mr

    mesh_id = ls_theta%get_mesh_id()
    chi => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    ! Define reference field
    initial_time = 0.0_r_def
    call init_u_field( ls_u , initial_time )
    call set_bundle_scalar( 0.0_r_def, ls_mr, nummr )

    call invoke( initial_theta_ref_kernel_type( &
                 ls_theta, chi, panel_id, test ) )

    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )
    call init_exner_field( ls_exner, ls_theta, ls_moist_dyn, initial_time )
    call init_rho_field( ls_rho, ls_theta, ls_exner, ls_moist_dyn, initial_time )
    call init_mr_fields( ls_mr, ls_theta, ls_exner, ls_rho, ls_moist_dyn )

    nullify( ls_theta, ls_rho, ls_u, ls_exner, ls_moist_dyn, ls_mr )
    nullify( chi, panel_id )

  end subroutine linear_init_reference_ls

end module linear_data_algorithm_mod
