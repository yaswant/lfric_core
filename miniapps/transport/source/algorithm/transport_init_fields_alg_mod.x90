!-----------------------------------------------------------------------------
! (c) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!-----------------------------------------------------------------------------
!> @brief Initialisation of density field for the transport miniapp.
!> @details The initial density field can be generated either by sampling
!>          or by projection.
!-----------------------------------------------------------------------------

module transport_init_fields_alg_mod

  use constants_mod,                     only: r_def, i_def, radians_to_degrees
  use domain_mod,                        only: domain_type
  use divergence_alg_mod,                only: divergence_alg
  use fem_constants_mod,                 only: get_qr
  use finite_element_config_mod,         only: element_order
  use field_mod,                         only: field_type
  use field_bundle_mod,                  only: set_bundle_scalar
  use field_parent_mod,                  only: write_interface
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use fs_continuity_mod,                 only: W2, W3, Wtheta
  use geometric_constants_mod,           only: get_coordinates,     &
                                               get_panel_id
  use init_gungho_prognostics_alg_mod,   only: init_u_field
  use initial_tracer_field_sample_kernel_mod, &
                                         only: initial_tracer_field_sample_kernel_type
  use initial_pressure_config_mod,       only: method, method_sampled
  use initial_rho_sample_kernel_mod,     only: initial_rho_sample_kernel_type
  use io_config_mod,                     only: write_diag, use_xios_io
  use lfric_xios_write_mod,              only: write_field_face
  use mesh_mod,                          only: mesh_type
  use mr_indices_mod,                    only: nummr, mr_names
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use set_rho_kernel_mod,                only: set_rho_kernel_type
  use set_tracer_field_kernel_mod,       only: set_tracer_field_kernel_type

  implicit none

  private

  public :: transport_init_fields_alg

contains
!-----------------------------------------------------------------------------
!> @brief Initialisation of prognostic fields for the transport miniapp.
!> @param[in]     mesh              Mesh to initialise variables on
!> @param[in,out] wind              Transporting wind field
!> @param[in,out] density           Density field (in W3)
!> @param[in,out] theta             Theta field (in Wtheta)
!> @param[in,out] tracer_con        Conservative tracer field (in W3)
!> @param[in,out] tracer_adv        Advective tracer field (in W3)
!> @param[in,out] constant          Constant tracer field (in W3)
!> @param[in,out] mr                Moisture mixing ratio fields (in Wtheta)
!> @param[in,out] divergence        Divergence field
!-----------------------------------------------------------------------------
subroutine transport_init_fields_alg( mesh,       &
                                      wind,       &
                                      density,    &
                                      theta,      &
                                      tracer_con, &
                                      tracer_adv, &
                                      constant,   &
                                      mr,         &
                                      divergence )

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh

    type(field_type),     intent(inout) :: wind
    type(field_type),     intent(inout) :: density
    type(field_type),     intent(inout) :: theta
    type(field_type),     intent(inout) :: tracer_con
    type(field_type),     intent(inout) :: tracer_adv
    type(field_type),     intent(inout) :: constant
    type(field_type),     intent(inout) :: mr(nummr)
    type(field_type),     intent(inout) :: divergence

    ! Internal variables
    real(kind=r_def), parameter         :: initial_time = 0.0_r_def
    integer(kind=i_def)                 :: imr, const_flag, config_flag

    type(domain_type) :: domain
    real(kind=r_def)  :: domain_max_x

    type(field_type),           pointer :: chi(:) => null()
    type(field_type),           pointer :: panel_id => null()
    type(function_space_type),  pointer :: w2_fs => null()
    type(function_space_type),  pointer :: w3_fs => null()
    type(function_space_type),  pointer :: wt_fs => null()
    type(quadrature_xyoz_type), pointer :: qr => null()
    procedure(write_interface), pointer :: tmp_write_ptr => null()

    ! Set pointers
    w2_fs => function_space_collection%get_fs( mesh, element_order, W2 )
    w3_fs => function_space_collection%get_fs( mesh, element_order, W3 )
    wt_fs => function_space_collection%get_fs( mesh, element_order, Wtheta )
    chi  => get_coordinates(mesh%get_id())
    panel_id => get_panel_id(mesh%get_id())
    qr => get_qr()

    domain = mesh%get_domain()
    if ( domain%is_lonlat() ) then
      domain_max_x = domain%maximum_lonlat(axis=1) * radians_to_degrees
    else
      domain_max_x = domain%maximum_xy(axis=1)
    end if

    ! Set constants
    const_flag  = 1_i_def
    config_flag = 0_i_def

    ! Initialise field objects
    call wind%initialise( name='u', vector_space=w2_fs )
    call density%initialise( name='rho', vector_space=w3_fs )
    call theta%initialise( name='theta', vector_space=wt_fs )
    call tracer_con%initialise( name='tracer_con', vector_space=w3_fs )
    call tracer_adv%initialise( name='tracer_adv', vector_space=w3_fs )
    call constant%initialise( name='constant', vector_space=w3_fs )
    call divergence%initialise( name='divergence', vector_space=w3_fs )
    do imr = 1, nummr
      call mr(imr)%initialise( name=trim(mr_names(imr)), vector_space=wt_fs )
    end do

    ! ======================================================================== !
    ! Set up field values from analytic initial conditions
    ! ======================================================================== !

    ! Read in rho and theta first
    if ( method == method_sampled ) then
      call invoke( initial_rho_sample_kernel_type(          density,    chi, panel_id, initial_time ),              &
                   initial_tracer_field_sample_kernel_type( theta,      chi, panel_id, domain_max_x, config_flag ), &
                   initial_tracer_field_sample_kernel_type( tracer_con, chi, panel_id, domain_max_x, config_flag ), &
                   initial_tracer_field_sample_kernel_type( constant,   chi, panel_id, domain_max_x, const_flag ) )
     else
      call invoke( set_rho_kernel_type(          density,    chi, panel_id, &
                                                 initial_time, qr ),        &
                   set_tracer_field_kernel_type( theta,      chi, panel_id, &
                                                 domain_max_x,              &
                                                 config_flag, qr ),         &
                   set_tracer_field_kernel_type( tracer_con, chi, panel_id, &
                                                 domain_max_x,              &
                                                 config_flag, qr ),         &
                   set_tracer_field_kernel_type( constant,   chi, panel_id, &
                                                 domain_max_x,              &
                                                 const_flag,  qr ) )
    end if

    ! Duplicate these values for tracer_adv and mixing ratio
    ! Mixing ratios are set to zero for all but first value
    call set_bundle_scalar( 0.0_r_def, mr, nummr )
    call invoke( setval_X( tracer_adv, tracer_con ), &
                 setval_X( mr(1), theta ) )

    ! Set winds and divergence
    call init_u_field( wind, initial_time )
    call divergence_alg( divergence, wind )

    ! ======================================================================== !
    ! Set I/O behaviours for diagnostic output
    ! ======================================================================== !
    if ( write_diag .and. use_xios_io ) then
       ! Fields that are output on the XIOS face domain
       tmp_write_ptr => write_field_face
       call wind%set_write_behaviour( tmp_write_ptr )
       call density%set_write_behaviour( tmp_write_ptr )
       call theta%set_write_behaviour( tmp_write_ptr )
       call tracer_con%set_write_behaviour( tmp_write_ptr )
       call tracer_adv%set_write_behaviour( tmp_write_ptr )
       call constant%set_write_behaviour( tmp_write_ptr )
       call mr(1)%set_write_behaviour( tmp_write_ptr )
       call divergence%set_write_behaviour( tmp_write_ptr )
    end if

    nullify( w2_fs, w3_fs, wt_fs, chi, panel_id, qr, tmp_write_ptr )

  end subroutine transport_init_fields_alg

end module transport_init_fields_alg_mod
