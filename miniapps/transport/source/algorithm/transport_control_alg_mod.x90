!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Control module for the transport miniapp, where the wind is prescribed.

module transport_control_alg_mod

  use constants_mod,                     only: i_def, r_def, l_def, str_def
  use extrusion_mod,                     only: SHIFTED
  use field_mod,                         only: field_type
  use log_mod,                           only: log_event,       &
                                               LOG_LEVEL_ERROR, &
                                               LOG_LEVEL_INFO,  &
                                               log_scratch_space
  use mesh_mod,                          only: mesh_type
  use mesh_collection_mod,               only: mesh_collection
  use mr_indices_mod,                    only: nummr
  use runtime_tools_mod,                 only: find_mesh_index
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_runtime_alg_mod,         only: transport_runtime_type
  use transport_runtime_collection_mod,  only: set_transport_runtime
  use transport_metadata_collection_mod, only: transport_metadata_collection_type

  implicit none

  private

  logical(kind=l_def) :: time_varying_wind
  logical(kind=l_def) :: variables_allocated = .false.

  ! Initial fields, to be compared against at the end for measuring errors
  ! These are allocatable as there might be one for each mesh
  type(field_type), allocatable :: rho0(:)
  type(field_type), allocatable :: theta0(:)
  type(field_type), allocatable :: tracer_con0(:)
  type(field_type), allocatable :: tracer_adv0(:)
  type(field_type), allocatable :: constant0(:)
  type(field_type), allocatable :: mr0(:,:)

  type(transport_metadata_collection_type) :: transport_metadata_collection

  ! Contained suroutines
  public :: transport_prerun_setup
  public :: transport_init
  public :: transport_step
  public :: transport_final

contains

  !=============================================================================
  !> @brief Set up various entities for transport-only time stepping.
  !> @details Taking the number of meshes, this allocates arrays of true fields
  !!          and sets up whether the wind is to be updated and the metadata for
  !!          the transported variables.
  !> @param[in] number_of_meshes Number of meshes to transport on
  subroutine transport_prerun_setup( number_of_meshes )

    use transport_config_mod,    only: profile_size,         &
                                       field_names,          &
                                       equation_form,        &
                                       scheme,               &
                                       splitting,            &
                                       horizontal_method,    &
                                       vertical_method,      &
                                       log_space,            &
                                       enforce_min_value,    &
                                       min_value,            &
                                       reversible,           &
                                       horizontal_monotone,  &
                                       vertical_monotone,    &
                                       vertical_monotone_order


    use initial_wind_config_mod, only: profile,                      &
                                       profile_curl_free_reversible, &
                                       profile_div_free_reversible,  &
                                       profile_xy_NL_case_1,         &
                                       profile_yz_NL_case_1,         &
                                       profile_NL_case_1,            &
                                       profile_NL_case_2,            &
                                       profile_NL_case_3,            &
                                       profile_NL_case_4,            &
                                       profile_hadley_like_dcmip,    &
                                       profile_sbr_with_vertical,    &
                                       profile_dcmip_101,            &
                                       profile_vertical_deformation

    implicit none

    integer(kind=i_def), intent(in) :: number_of_meshes
    integer(kind=i_def)             :: config
    type(transport_metadata_type)   :: transport_metadata
    logical(kind=l_def), parameter  :: use_divergence_factor = .false.

    ! ------------------------------------------------------------------------ !
    ! Allocate arrays for initial/true fields
    ! ------------------------------------------------------------------------ !
    if (.not. variables_allocated) then
      if (.not. allocated(rho0))        allocate(rho0(number_of_meshes))
      if (.not. allocated(theta0))      allocate(theta0(number_of_meshes))
      if (.not. allocated(tracer_con0)) allocate(tracer_con0(number_of_meshes))
      if (.not. allocated(tracer_adv0)) allocate(tracer_adv0(number_of_meshes))
      if (.not. allocated(constant0))   allocate(constant0(number_of_meshes))
      if (.not. allocated(mr0))         allocate(mr0(nummr, number_of_meshes))
      variables_allocated = .true.
    else
      call log_event('Variables have already been allocated for ' // &
                     'transport_control', LOG_LEVEL_ERROR)
    end if

    ! ------------------------------------------------------------------------ !
    ! Determine if wind is time-varying or not
    ! ------------------------------------------------------------------------ !
    if ((profile == profile_xy_NL_case_1)         .or. &
        (profile == profile_yz_NL_case_1)         .or. &
        (profile == profile_NL_case_1)            .or. &
        (profile == profile_NL_case_2)            .or. &
        (profile == profile_NL_case_3)            .or. &
        (profile == profile_NL_case_4)            .or. &
        (profile == profile_hadley_like_dcmip)    .or. &
        (profile == profile_div_free_reversible)  .or. &
        (profile == profile_curl_free_reversible) .or. &
        (profile == profile_sbr_with_vertical)    .or. &
        (profile == profile_dcmip_101)            .or. &
        (profile == profile_vertical_deformation))then
      time_varying_wind = .true.
    else
      time_varying_wind = .false.
    end if

    ! ------------------------------------------------------------------------ !
    ! Set up metadata for variables
    ! ------------------------------------------------------------------------ !
    ! Set up linked list of metadatas
    transport_metadata_collection = transport_metadata_collection_type()

    ! Set up configs using namelist entries
    do config = 1, profile_size

      write(log_scratch_space,'(3A)') 'Setting up ',trim(field_names(config)),' transport metadata'
      call log_event(log_scratch_space, LOG_LEVEL_INFO)

      transport_metadata = transport_metadata_type( field_names(config),             &
                                                    equation_form(config),           &
                                                    splitting(config),               &
                                                    scheme(config),                  &
                                                    horizontal_method(config),       &
                                                    vertical_method(config),         &
                                                    horizontal_monotone(config),     &
                                                    vertical_monotone(config),       &
                                                    vertical_monotone_order(config), &
                                                    enforce_min_value(config),       &
                                                    min_value(config),               &
                                                    log_space(config),               &
                                                    use_divergence_factor,           &
                                                    reversible(config) )

      call transport_metadata_collection%set_transport_metadata(transport_metadata)

    end do

  end subroutine transport_prerun_setup


  !=============================================================================
  !> @brief Stores the initial values of the fields to be transported.
  !> @details This copies the initial fields to be transported into variables
  !!          to be held in this algorithm. At the end of the simulation, this
  !!          allows us to compare the final states of the field with their
  !!          initial values, so that the errors incurred by the transport can
  !!          be measured.
  !> @param[in] rho         Dry density field (in W3)
  !> @param[in] theta       Potential temperature field (in Wtheta)
  !> @param[in] tracer_con  Tracer field obeying conservative equation (in W3)
  !> @param[in] tracer_adv  Tracer field obeying advective equation (in W3)
  !> @param[in] constant    Constant tracer field obeying conservative equation (in W3)
  !> @param[in] mr          Bundle of mixing ratio fields (in Wtheta)
  subroutine transport_init( rho, theta, tracer_con, tracer_adv, constant, mr )

    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_init
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_init

    implicit none

    ! Prognostic fields
    type(field_type), intent(in) :: rho, theta, tracer_con, tracer_adv, constant
    type(field_type), intent(in) :: mr(nummr)

    ! Internal variables
    integer(kind=i_def)          :: mesh_index

    type(mesh_type), pointer     :: primary_mesh => null()
    type(mesh_type), pointer     :: shifted_mesh => null()

    primary_mesh => rho%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)

    mesh_index = find_mesh_index(primary_mesh%get_id())

    ! Store initial values for computing errors
    call rho%copy_field(rho0(mesh_index))
    call theta%copy_field(theta0(mesh_index))
    call tracer_con%copy_field(tracer_con0(mesh_index))
    call tracer_adv%copy_field(tracer_adv0(mesh_index))
    call constant%copy_field(constant0(mesh_index))
    call mr(1)%copy_field(mr0(1,mesh_index))

    ! Initialise any necessary transport fields or coefficients
    call reconstruct_w3_field_alg_init(primary_mesh)
    call wt_advective_update_alg_init(primary_mesh)
    call reconstruct_w3_field_alg_init(shifted_mesh)

    nullify(primary_mesh, shifted_mesh)

  end subroutine transport_init


  !=============================================================================
  !> @brief Performs a single transport-only step.
  !> @details This performs a single step of gungho in transport-only mode, by
  !!          transporting rho, theta, tracer and moisture mixing ratios. The
  !!          transporting wind field is prescribed, but may be updated if a
  !!          time-varying profile has been specified.
  !> @param[in]     model_clock        Time within the model
  !> @param[in,out] wind               The transporting wind field
  !> @param[in,out] rho                Dry density field to transport
  !> @param[in,out] theta              Pot. temperature field to transport
  !> @param[in,out] tracer_con         Tracer field to transport conservatively
  !> @param[in,out] tracer_adv         Tracer field to transport advectively
  !> @param[in,out] constant           Constant tracer field to transport conservatively
  !> @param[in,out] mr                 Bundle of mixing ratio fields to transport
  !> @param[in]     nummr_to_transport Number of moisture species to transport
  subroutine transport_step( model_clock, wind, &
                             rho, theta, tracer_con,   &
                             tracer_adv, constant, mr, &
                             nummr_to_transport )

    use field_bundle_mod,                 only: clone_bundle, copy_bundle
    use init_gungho_prognostics_alg_mod,  only: init_u_field
    use model_clock_mod,                  only: model_clock_type
    use moist_mr_transport_alg_mod,       only: moist_mr_transport_alg
    use transport_field_mod,              only: transport_field

    implicit none

    ! Arguments
    class(model_clock_type), intent(in) :: model_clock
    type(field_type),        intent(inout) :: wind, rho, theta
    type(field_type),        intent(inout) :: tracer_con, tracer_adv, constant
    type(field_type),        intent(inout) :: mr(nummr)
    integer(kind=i_def),     intent(in)    :: nummr_to_transport

    real(kind=r_def)             :: current_time
    real(r_def)                  :: cast_dt
    type(field_type)             :: rho_n, theta_n, constant_n
    type(field_type)             :: tracer_con_n, tracer_adv_n, mr_n(nummr)

    type(transport_runtime_type) :: transport_runtime
    type(mesh_type),     pointer :: primary_mesh => null()
    type(mesh_type),     pointer :: shifted_mesh => null()


    type(transport_metadata_type), pointer :: transport_metadata => null()

    ! Update the transporting wind field
    !
    !> @todo This is all kinds of bad and wrong. If the model needs the number
    !>       of seconds since the origin of the clock then the clock should
    !>       tell it.
    !>
    cast_dt = real(model_clock%get_seconds_per_step(), r_def)
    if ( time_varying_wind ) then
      current_time = model_clock%get_step() * cast_dt
      call init_u_field(wind, current_time)
    end if

    primary_mesh => wind%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)

    ! Create transport_runtime object (advecting wind etc)
    transport_runtime = transport_runtime_type( wind, wind, &
                                                model_clock,  shifted_mesh)
    call set_transport_runtime(transport_runtime)

    ! Transport dry density
    call log_event( "Transporting density...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('rho')
    call rho%copy_field(rho_n)
    call transport_field( rho, rho_n, cast_dt, transport_metadata )

    ! Transport potential temperature
    call log_event( "Transporting potential temperature...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('theta')
    call theta%copy_field(theta_n)
    call transport_field( theta, theta_n, cast_dt, transport_metadata )

    ! Transport conservative W3 tracer
    call log_event( "Transporting conservative tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer_con')
    call tracer_con%copy_field(tracer_con_n)
    call transport_field( tracer_con, tracer_con_n, &
                          cast_dt, transport_metadata )

    ! Transport advective W3 tracer
    call log_event( "Transporting advective tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer_adv')
    call tracer_adv%copy_field(tracer_adv_n)
    call transport_field( tracer_adv, tracer_adv_n, &
                          cast_dt, transport_metadata )

    ! Transport constant W3 tracer
    call log_event( "Transporting constant tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('constant')
    call constant%copy_field(constant_n)
    call transport_field( constant, constant_n, &
                          cast_dt, transport_metadata )

    ! Transport moisture mixing ratio fields
    call log_event("Transporting moisture mixing ratio fields...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('mr')
    call clone_bundle(mr, mr_n, nummr)
    call copy_bundle(mr, mr_n, nummr)
    call moist_mr_transport_alg( mr, mr_n, nummr_to_transport, &
                                 cast_dt, transport_metadata)

    nullify(primary_mesh, shifted_mesh)

  end subroutine transport_step


  !=============================================================================
  !> @brief Finalises transport only run.
  !> @details Calculates final error norms for transport schemes and calls
  !!          finalising routines for transport only run.
  !> @param[in] rho         Transported dry density field
  !> @param[in] theta       Transported pot. temperature field
  !> @param[in] tracer_con  Transported conservative tracer field
  !> @param[in] tracer_adv  Transported advective tracer field
  !> @param[in] constant    Transported constant tracer field
  !> @param[in] mr          Transported bundle of mixing ratio fields
  subroutine transport_final( rho, theta, tracer_con, tracer_adv, constant, mr )

    use transport_stats_mod,          only: write_transport_stats
    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_final
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_final

    implicit none

    ! Prognostic fields
    type(field_type), intent(in) :: rho, theta, tracer_con, tracer_adv, constant
    type(field_type), intent(in) :: mr(nummr)

    ! Internal variables
    character(str_def)  :: field_name
    integer(kind=i_def) :: mesh_index
    type(mesh_type), pointer :: mesh => null()

    mesh => rho%get_mesh()
    mesh_index = find_mesh_index(mesh%get_id())

    ! Calculate and write out statistics
    field_name = 'rho'
    call write_transport_stats(rho, rho0(mesh_index), field_name)
    field_name = 'theta'
    call write_transport_stats(theta, theta0(mesh_index), field_name)
    field_name = 'tracer_con'
    call write_transport_stats(tracer_con, tracer_con0(mesh_index), field_name)
    field_name = 'tracer_adv'
    call write_transport_stats(tracer_adv, tracer_adv0(mesh_index), field_name)
    field_name = 'constant'
    call write_transport_stats(constant, constant0(mesh_index), field_name)
    field_name = 'mr'
    call write_transport_stats(mr(1), mr0(1,mesh_index), field_name)

    call reconstruct_w3_field_alg_final()
    call wt_advective_update_alg_final()

    nullify( mesh )

  end subroutine transport_final

end module transport_control_alg_mod
