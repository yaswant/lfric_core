!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Control module for the transport miniapp, where the wind is prescribed.

module transport_control_alg_mod

  use constants_mod,                     only: i_def, r_def, l_def, str_def
  use extrusion_mod,                     only: SHIFTED
  use field_mod,                         only: field_type
  use log_mod,                           only: log_event,       &
                                               LOG_LEVEL_ERROR, &
                                               LOG_LEVEL_INFO,  &
                                               log_scratch_space
  use mesh_mod,                          only: mesh_type
  use mesh_collection_mod,               only: mesh_collection
  use mr_indices_mod,                    only: nummr
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_runtime_collection_mod,  only: set_transport_runtime, &
                                               get_transport_runtime
  use transport_metadata_collection_mod, only: transport_metadata_collection_type

  implicit none

  private

  logical(kind=l_def)         :: time_varying_wind
  logical(kind=l_def), public :: use_w2_vector
  logical(kind=l_def), public :: use_aerosols
  logical(kind=l_def)         :: use_w3_aerosol
  logical(kind=l_def)         :: use_wt_aerosol

  ! Initial fields, to be compared against at the end for measuring errors
  ! These are allocatable as there might be one for each mesh
  type(field_type) :: rho0
  type(field_type) :: theta0
  type(field_type) :: tracer_con0
  type(field_type) :: tracer_adv0
  type(field_type) :: constant0
  type(field_type) :: w2_vector0
  type(field_type) :: mr0(nummr)
  type(field_type) :: w3_aerosol0
  type(field_type) :: wt_aerosol0

  type(transport_metadata_collection_type) :: transport_metadata_collection

  ! Contained subroutines
  public :: transport_prerun_setup
  public :: transport_init
  public :: transport_step
  public :: transport_final

contains

  !=============================================================================
  !> @brief Set up various entities for transport-only time stepping.
  !> @details Taking the number of meshes, this allocates arrays of true fields
  !!          and sets up whether the wind is to be updated and the metadata for
  !!          the transported variables.
  !> @param[in] number_of_meshes Number of meshes to transport on
  subroutine transport_prerun_setup( number_of_meshes )

    use transport_config_mod,    only: profile_size,         &
                                       field_names,          &
                                       equation_form,        &
                                       scheme,               &
                                       splitting,            &
                                       horizontal_method,    &
                                       vertical_method,      &
                                       log_space,            &
                                       enforce_min_value,    &
                                       min_value,            &
                                       reversible,           &
                                       horizontal_monotone,  &
                                       vertical_monotone,    &
                                       vertical_monotone_order


    use initial_wind_config_mod, only: profile,                      &
                                       profile_curl_free_reversible, &
                                       profile_div_free_reversible,  &
                                       profile_xy_NL_case_1,         &
                                       profile_yz_NL_case_1,         &
                                       profile_NL_case_1,            &
                                       profile_NL_case_2,            &
                                       profile_NL_case_3,            &
                                       profile_NL_case_4,            &
                                       profile_hadley_like_dcmip,    &
                                       profile_sbr_with_vertical,    &
                                       profile_dcmip_101,            &
                                       profile_vertical_deformation, &
                                       profile_four_part_sbr

    implicit none

    integer(kind=i_def), intent(in) :: number_of_meshes
    integer(kind=i_def)             :: config
    type(transport_metadata_type)   :: transport_metadata

    ! ------------------------------------------------------------------------ !
    ! Determine if wind is time-varying or not
    ! ------------------------------------------------------------------------ !
    if ((profile == profile_xy_NL_case_1)         .or. &
        (profile == profile_yz_NL_case_1)         .or. &
        (profile == profile_NL_case_1)            .or. &
        (profile == profile_NL_case_2)            .or. &
        (profile == profile_NL_case_3)            .or. &
        (profile == profile_NL_case_4)            .or. &
        (profile == profile_hadley_like_dcmip)    .or. &
        (profile == profile_div_free_reversible)  .or. &
        (profile == profile_curl_free_reversible) .or. &
        (profile == profile_sbr_with_vertical)    .or. &
        (profile == profile_dcmip_101)            .or. &
        (profile == profile_vertical_deformation  .or. &
        (profile == profile_four_part_sbr))) then
      time_varying_wind = .true.
    else
      time_varying_wind = .false.
    end if

    ! ------------------------------------------------------------------------ !
    ! Set up metadata for variables
    ! ------------------------------------------------------------------------ !
    ! Set up linked list of metadatas
    transport_metadata_collection = transport_metadata_collection_type()

    use_aerosols = .false.
    use_w3_aerosol = .false.
    use_wt_aerosol = .false.
    use_w2_vector = .false.

    ! Set up configs using namelist entries
    do config = 1, profile_size

      write(log_scratch_space,'(3A)') 'Setting up ',trim(field_names(config)),' transport metadata'
      call log_event(log_scratch_space, LOG_LEVEL_INFO)

      transport_metadata = transport_metadata_type( field_names(config),             &
                                                    equation_form(config),           &
                                                    splitting(config),               &
                                                    scheme(config),                  &
                                                    horizontal_method(config),       &
                                                    vertical_method(config),         &
                                                    horizontal_monotone(config),     &
                                                    vertical_monotone(config),       &
                                                    vertical_monotone_order(config), &
                                                    enforce_min_value(config),       &
                                                    min_value(config),               &
                                                    log_space(config),               &
                                                    reversible(config) )

      call transport_metadata_collection%set_transport_metadata(transport_metadata)

      if (trim(field_names(config)) == 'w2_vector') then
        use_w2_vector = .true.
      end if
      if (trim(field_names(config)) == 'w3_aerosol') then
        use_w3_aerosol = .true.
      end if
      if (trim(field_names(config)) == 'wt_aerosol') then
        use_wt_aerosol = .true.
      end if

    end do

    use_aerosols = (use_w3_aerosol .or. use_wt_aerosol)

  end subroutine transport_prerun_setup


  !=============================================================================
  !> @brief Stores the initial values of the fields to be transported.
  !> @details This copies the initial fields to be transported into variables
  !!          to be held in this algorithm. At the end of the simulation, this
  !!          allows us to compare the final states of the field with their
  !!          initial values, so that the errors incurred by the transport can
  !!          be measured.
  !> @param[in] rho         Dry density field (in W3)
  !> @param[in] theta       Potential temperature field (in Wtheta)
  !> @param[in] tracer_con  Tracer field obeying conservative equation (in W3)
  !> @param[in] tracer_adv  Tracer field obeying advective equation (in W3)
  !> @param[in] constant    Constant tracer field obeying conservative equation (in W3)
  !> @param[in] mr          Bundle of mixing ratio fields (in Wtheta)
  !> @param[in] w2_vector   Vector-valued field replicating wind transport (in W2)
  !> @param[in] w3_aerosol  Tracer in W3 on coarse mesh
  !> @param[in] wt_aerosol  Tracer in Wtheta on coarse mesh
  subroutine transport_init( rho, theta, tracer_con, tracer_adv, constant, mr, &
                             w2_vector, w3_aerosol, wt_aerosol )

    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_init
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_init

    implicit none

    ! Prognostic fields
    type(field_type), intent(in) :: rho, theta, tracer_con, tracer_adv
    type(field_type), intent(in) :: constant, w2_vector, w3_aerosol, wt_aerosol
    type(field_type), intent(in) :: mr(nummr)

    ! Internal variables
    type(mesh_type), pointer     :: primary_mesh => null()
    type(mesh_type), pointer     :: shifted_mesh => null()
    type(mesh_type), pointer     :: aerosol_prime_mesh => null()
    type(mesh_type), pointer     :: aerosol_shifted_mesh => null()

    primary_mesh => rho%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)
    aerosol_prime_mesh => w3_aerosol%get_mesh()
    aerosol_shifted_mesh => mesh_collection%get_mesh(aerosol_prime_mesh, SHIFTED)

    ! Store initial values for computing errors
    call rho%copy_field_properties(rho0)
    call theta%copy_field_properties(theta0)
    call tracer_con%copy_field_properties(tracer_con0)
    call tracer_adv%copy_field_properties(tracer_adv0)
    call constant%copy_field_properties(constant0)
    call mr(1)%copy_field_properties(mr0(1))
    call w2_vector%copy_field_properties(w2_vector0)
    call w3_aerosol%copy_field_properties(w3_aerosol0)
    call wt_aerosol%copy_field_properties(wt_aerosol0)

    call invoke( setval_X(rho0, rho),               &
                 setval_X(theta0, theta),           &
                 setval_X(tracer_con0, tracer_con), &
                 setval_X(tracer_adv0, tracer_adv), &
                 setval_X(constant0, constant),     &
                 setval_X(mr0(1), mr(1)),           &
                 setval_X(w2_vector0, w2_vector),   &
                 setval_X(w3_aerosol0, w3_aerosol), &
                 setval_X(wt_aerosol0, wt_aerosol) )

    ! Initialise any necessary transport fields or coefficients
    call reconstruct_w3_field_alg_init(primary_mesh)
    call wt_advective_update_alg_init(primary_mesh)
    call reconstruct_w3_field_alg_init(shifted_mesh)
    if (primary_mesh%get_id() /= aerosol_prime_mesh%get_id()) then
      call reconstruct_w3_field_alg_init(aerosol_prime_mesh)
      call wt_advective_update_alg_init(aerosol_prime_mesh)
      call reconstruct_w3_field_alg_init(aerosol_shifted_mesh)
    end if

    nullify(primary_mesh, shifted_mesh, aerosol_prime_mesh, aerosol_shifted_mesh)

  end subroutine transport_init


  !=============================================================================
  !> @brief Performs a single transport-only step.
  !> @details This performs a single step of gungho in transport-only mode, by
  !!          transporting rho, theta, tracer and moisture mixing ratios. The
  !!          transporting wind field is prescribed, but may be updated if a
  !!          time-varying profile has been specified.
  !> @param[in]     model_clock        Time within the model
  !> @param[in,out] wind               The transporting wind field
  !> @param[in,out] rho                Dry density field to transport
  !> @param[in,out] theta              Pot. temperature field to transport
  !> @param[in,out] tracer_con         Tracer field to transport conservatively
  !> @param[in,out] tracer_adv         Tracer field to transport advectively
  !> @param[in,out] constant           Constant tracer field to transport conservatively
  !> @param[in,out] mr                 Bundle of mixing ratio fields to transport
  !> @param[in,out] w2_vector          Vector-valued field to transport advectively
  !> @param[in,out] w3_aerosol         Tracer in W3 on coarse mesh to transport advectively
  !> @param[in,out] wt_aerosol         Tracer in Wtheta on coarse mesh to transport advectively
  !> @param[in,out] aerosol_wind       Transporting wind field on the coarse mesh
  !> @param[in]     nummr_to_transport Number of moisture species to transport
  subroutine transport_step( model_clock, wind,        &
                             rho, theta, tracer_con,   &
                             tracer_adv, constant, mr, &
                             w2_vector, w3_aerosol,    &
                             wt_aerosol, aerosol_wind, &
                             nummr_to_transport )

    use field_bundle_mod,                 only: clone_bundle, copy_bundle
    use formulation_config_mod,           only: use_multires_coupling
    use init_gungho_prognostics_alg_mod,  only: init_u_field
    use intermesh_mappings_alg_mod,       only: map_w2_intermesh
    use mass_matrix_solver_alg_mod,       only: mass_matrix_solver_alg
    use model_clock_mod,                  only: model_clock_type
    use moist_mr_transport_alg_mod,       only: moist_mr_transport_alg
    use theta_transport_alg_mod,          only: theta_transport_alg
    use transport_field_mod,              only: transport_field
    use transport_runtime_alg_mod,        only: transport_runtime_type
    use wind_transport_alg_mod,           only: wind_transport_alg

    implicit none

    ! Arguments
    class(model_clock_type), intent(in)    :: model_clock
    type(field_type),        intent(inout) :: wind, rho, theta, w2_vector
    type(field_type),        intent(inout) :: tracer_con, tracer_adv, constant
    type(field_type),        intent(inout) :: w3_aerosol, wt_aerosol, aerosol_wind
    type(field_type),        intent(inout) :: mr(nummr)
    integer(kind=i_def),     intent(in)    :: nummr_to_transport

    real(kind=r_def)             :: current_time
    real(r_def)                  :: cast_dt
    type(field_type)             :: rho_n, theta_n, constant_n, w2_vector_n
    type(field_type)             :: tracer_con_n, tracer_adv_n, mr_n(nummr)
    type(field_type)             :: w3_aerosol_n, wt_aerosol_n
    type(field_type)             :: w2_vector_inc, rhs_w2, theta_inc

    type(mesh_type),     pointer :: primary_mesh => null()
    type(mesh_type),     pointer :: shifted_mesh => null()
    type(mesh_type),     pointer :: aerosol_prime_mesh => null()
    type(mesh_type),     pointer :: aerosol_shifted_mesh => null()
    logical(kind=l_def)          :: cheap_update_flag
    integer(kind=i_def)          :: iteration_number

    type(transport_runtime_type),  pointer :: dynamics_transport_runtime => null()
    type(transport_runtime_type),  pointer :: aerosol_transport_runtime => null()
    type(transport_metadata_type), pointer :: transport_metadata => null()

    ! Update the transporting wind field
    !
    !> @todo This is all kinds of bad and wrong. If the model needs the number
    !>       of seconds since the origin of the clock then the clock should
    !>       tell it.
    !>
    cast_dt = real(model_clock%get_seconds_per_step(), r_def)
    if ( time_varying_wind ) then
      current_time = model_clock%get_step() * cast_dt
      call init_u_field(wind, current_time)
      call map_w2_intermesh( aerosol_wind, wind )
    end if

    ! Set flag for cheap update to be false and iteration_number
    ! to 1 as these are only for SI timestepping which is not
    ! relevant for the transport miniapp
    cheap_update_flag = .false.
    iteration_number  = 1_i_def

    primary_mesh => wind%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)
    aerosol_prime_mesh => aerosol_wind%get_mesh()
    aerosol_shifted_mesh => mesh_collection%get_mesh(aerosol_prime_mesh, SHIFTED)

    ! Create transport_runtime object (advecting wind etc)
    call set_transport_runtime(wind, wind,        &
                               model_clock,       &
                               iteration_number,  &
                               cheap_update_flag, &
                               shifted_mesh)

    if (use_multires_coupling) then
      call set_transport_runtime(aerosol_wind, aerosol_wind,    &
                                 model_clock, iteration_number, &
                                 cheap_update_flag, aerosol_shifted_mesh)
    end if

    ! Transport dry density
    call log_event( "Transporting density...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('rho')
    call rho%copy_field_properties(rho_n)
    call invoke( setval_X(rho_n, rho) )
    call transport_field( rho, rho_n, cast_dt, transport_metadata )

    ! Transport conservative W3 tracer
    call log_event( "Transporting conservative tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer_con')
    call tracer_con%copy_field_properties(tracer_con_n)
    call invoke( setval_X(tracer_con_n, tracer_con) )
    call transport_field( tracer_con, tracer_con_n, &
                          cast_dt, transport_metadata )

    ! Transport advective W3 tracer
    call log_event( "Transporting advective tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer_adv')
    call tracer_adv%copy_field_properties(tracer_adv_n)
    call invoke( setval_X(tracer_adv_n, tracer_adv) )
    call transport_field( tracer_adv, tracer_adv_n, &
                          cast_dt, transport_metadata )

    ! Transport constant W3 tracer
    call log_event( "Transporting constant tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('constant')
    call constant%copy_field_properties(constant_n)
    call invoke( setval_X(constant_n, constant) )
    call transport_field( constant, constant_n, &
                          cast_dt, transport_metadata )

    ! Transport moisture mixing ratio fields
    call log_event("Transporting moisture mixing ratio fields...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('mr')
    call clone_bundle(mr, mr_n, nummr)
    call copy_bundle(mr, mr_n, nummr)
    call moist_mr_transport_alg( mr, mr_n, nummr_to_transport, &
                                 cast_dt, transport_metadata)

    ! Transport potential temperature
    call log_event( "Transporting potential temperature...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('theta')
    call theta%copy_field_properties(theta_n)
    call invoke( setval_X(theta_n, theta) )
    call theta%copy_field_properties(theta_inc)
    call theta_transport_alg(theta, theta_inc, theta_n, mr, mr_n, &
                             cast_dt, transport_metadata)


    ! Transport vector-valued W2 field
    if (use_w2_vector) then
      call log_event( "Transporting w2_vector...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('w2_vector')
      call w2_vector%copy_field_properties(w2_vector_n)
      call invoke( setval_X(w2_vector_n, w2_vector) )
      call rhs_w2%initialise(w2_vector%get_function_space())
      call w2_vector_inc%initialise(w2_vector%get_function_space())
      call wind_transport_alg( rhs_w2, w2_vector_n, cast_dt, transport_metadata )
      ! Convert rhs_u residual back into increment
      call invoke( setval_c(w2_vector_inc, 0.0_r_def) )
      call mass_matrix_solver_alg(w2_vector_inc, rhs_w2)
      call invoke( X_plus_Y(w2_vector, w2_vector_n, w2_vector_inc) )
    end if

    ! Copy dry fields from fine transport runtime to coarse
    if (use_multires_coupling .and. (use_w3_aerosol .or. use_wt_aerosol)) then
      dynamics_transport_runtime => get_transport_runtime(primary_mesh)
      aerosol_transport_runtime => get_transport_runtime(aerosol_prime_mesh)
      call aerosol_transport_runtime%copy_all_dry_fields(dynamics_transport_runtime)
      nullify(dynamics_transport_runtime, aerosol_transport_runtime)
    end if

    ! Transport coarse W3 tracer
    if (use_w3_aerosol) then
      call log_event( "Transporting coarse W3 tracer...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('w3_aerosol')
      call w3_aerosol%copy_field_properties(w3_aerosol_n)
      call invoke( setval_X(w3_aerosol_n, w3_aerosol) )
      call transport_field( w3_aerosol, w3_aerosol_n, cast_dt, transport_metadata )
    end if

    ! Transport coarse Wtheta tracer
    if (use_wt_aerosol) then
      call log_event( "Transporting coarse Wtheta tracer...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('wt_aerosol')
      call wt_aerosol%copy_field_properties(wt_aerosol_n)
      call invoke( setval_X(wt_aerosol_n, wt_aerosol) )
      call transport_field( wt_aerosol, wt_aerosol_n, cast_dt, transport_metadata )
    end if

    nullify(primary_mesh, shifted_mesh, aerosol_prime_mesh, aerosol_shifted_mesh)

  end subroutine transport_step


  !=============================================================================
  !> @brief Finalises transport only run.
  !> @details Calculates final error norms for transport schemes and calls
  !!          finalising routines for transport only run.
  !> @param[in] rho         Transported dry density field
  !> @param[in] theta       Transported pot. temperature field
  !> @param[in] tracer_con  Transported conservative tracer field
  !> @param[in] tracer_adv  Transported advective tracer field
  !> @param[in] constant    Transported constant tracer field
  !> @param[in] mr          Transported bundle of mixing ratio fields
  !> @param[in] w2_vector   Transported vector-valued field in W2
  !> @param[in] w3_aerosol  Transported tracer in W3 on coarse mesh
  !> @param[in] wt_aerosol  Transported tracer in Wtheta on coarse mesh
  subroutine transport_final( rho, theta, tracer_con, tracer_adv, &
                              constant, mr, w2_vector, w3_aerosol, wt_aerosol )

    use transport_stats_mod,          only: write_transport_stats
    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_final
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_final

    implicit none

    ! Prognostic fields
    type(field_type), intent(in) :: rho, theta, tracer_con, tracer_adv
    type(field_type), intent(in) :: w2_vector, constant, w3_aerosol, wt_aerosol
    type(field_type), intent(in) :: mr(nummr)

    ! Internal variables
    character(str_def)  :: field_name

    ! Calculate and write out statistics
    field_name = 'rho'
    call write_transport_stats(rho, rho0, field_name)
    field_name = 'theta'
    call write_transport_stats(theta, theta0, field_name)
    field_name = 'tracer_con'
    call write_transport_stats(tracer_con, tracer_con0, field_name)
    field_name = 'tracer_adv'
    call write_transport_stats(tracer_adv, tracer_adv0, field_name)
    field_name = 'constant'
    call write_transport_stats(constant, constant0, field_name)
    field_name = 'mr'
    call write_transport_stats(mr(1), mr0(1), field_name)
    ! NB: transport tests aren't designed to give meaningful answers for vector
    if (use_w2_vector) then
      field_name = 'w2_vector'
      call write_transport_stats(w2_vector, w2_vector0, field_name)
    end if
    if (use_w3_aerosol) then
      field_name = 'w3_aerosol'
      call write_transport_stats(w3_aerosol, w3_aerosol0, field_name)
    end if
    if (use_wt_aerosol) then
      field_name = 'wt_aerosol'
      call write_transport_stats(wt_aerosol, wt_aerosol0, field_name)
    end if

    call reconstruct_w3_field_alg_final()
    call wt_advective_update_alg_final()

  end subroutine transport_final

end module transport_control_alg_mod
