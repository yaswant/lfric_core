!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the advection of the prognostic
!>       equations
module advection_alg_mod

  use constants_mod,                  only: r_def, i_def
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use function_space_collection_mod,  only: function_space_collection
  use runtime_constants_mod,          only: get_coordinates, &
                                            get_div, &
                                            get_curl, &
                                            get_mass_matrix, &
                                            get_mass_matrix_diagonal
  use field_bundle_mod,               only: bundle_ax
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order, wtheta_on
  use formulation_config_mod,         only: supg
  use function_space_mod,             only: function_space_type
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type
  use operator_mod,                   only: operator_type
  use psykal_lite_mod,                only: invoke_set_field_scalar,  &
                                            invoke_multiply_field,    &
                                            invoke_sample_poly_flux,  &
                                            invoke_sample_poly_adv,   &
                                            invoke_rtheta_bd_kernel,  &
                                            invoke_axpy,              &
                                            invoke_copy_field_data,   &
                                            invoke_divide_field
  use quadrature_mod,                 only: quadrature_type, GAUSSIAN
  use rrho_kernel_mod,                only: rrho_kernel_type
  use rtheta_kernel_mod,              only: rtheta_kernel_type
  use rtheta_wtheta_kernel_mod,       only: rtheta_wtheta_kernel_type
  use rtheta_supg_kernel_mod,         only: rtheta_supg_kernel_type
  use flux_rhs_kernel_mod,            only: flux_rhs_kernel_type
  use solver_config_mod,              only: method,         &
                                            preconditioner, &
                                            solver_preconditioner_diagonal
  use solver_mod,                     only: solver_algorithm
  use transpose_matrix_vector_kernel_mod, &
                                      only: transpose_matrix_vector_kernel_type
  use vorticity_advection_kernel_mod, only: vorticity_advection_kernel_type
  use vorticity_rhs_kernel_mod,       only: vorticity_rhs_kernel_type
  use derived_config_mod,             only: bundle_size 

  use transport_config_mod,           only: operators, &
                                            fv_flux_order, &
                                            fv_advective_order, &
                                            transport_operators_fv, &
                                            transport_operators_fem
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR
  use evaluator_xyz_mod,              only: evaluator_xyz_type
  use mr_indices_mod,                    only: nummr
  use timestepping_config_mod,   only: dt
  use runge_kutta_init_mod,              only: num_rk_stage, ak
  implicit none

  private
  integer(i_def) :: flux_stencil_extent, &
                    advective_stencil_extent

  type( field_type ), allocatable :: mr_prediction(:)

  public :: advection_alg
  public :: advection_alg_init
  public :: advection_mr_alg

contains
!>@brief Initialisation routine to advection algortithm
  subroutine advection_alg_init(mesh_id)
    use mesh_mod,                          only: mesh_type
    use mesh_collection_mod,               only: mesh_collection
    use sample_poly_flux_kernel_mod,       only: sample_poly_flux_init
    use sample_poly_adv_kernel_mod,        only: sample_poly_adv_init
    
    integer(i_def),  intent(in) :: mesh_id

    type(mesh_type), pointer :: mesh => null()

    if ( operators == transport_operators_fv ) then
      if ( element_order == 0 ) then
        mesh => mesh_collection%get_mesh( mesh_id )
        call sample_poly_flux_init(fv_flux_order, mesh%get_nlayers())
        call sample_poly_adv_init (fv_advective_order, mesh%get_nlayers())
        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
      else
        call log_event( "Dynamo: subgrid mappings needed for FV MoL with high order elements", LOG_LEVEL_ERROR )
      end if

      allocate ( mr_prediction(num_rk_stage) )
    end if

  end subroutine advection_alg_init

!=============================================================================!
!>@details A wrapper algorithm for computing the advection of the prognostic
!>         equations, namely:
!>         \f[ \mathbf{R_u} = \xi \times \frac{\mathbf{F}}{\rho} \f]
!>         \f[ R_\theta = \frac{\mathbf{F}}{\rho}.\nabla\theta \f]
!>         \f[ R_\rho = \nabla.\mathbf{F} \f]
!>         with diagnostic fields:
!>
!>         Mass flux: \f$ \mathbf{F} = \mathbf{u}\rho \f$
!>         Vorticity: \f$ \xi = \nabla\times\mathbf{u} \f$
!>
!> @param[inout] advection Advective terms
!> @param[in]    state Current state of the model prognostics
!> @param[in]    state_np1 State at the next time level of the model prognostics
!> @param[in]    state_n State at the old time level of the model prognostics
!> @param[in]    xi Relative vorticity field
  subroutine advection_alg( advection, &
                            state, &
                            state_np1, &
                            state_n,   &
                            xi)
  
  implicit none
  ! Form of state and advection is [u,theta,rho] & [r_u,r_theta,r_rho]
  type(field_type), intent(in),    target  :: state(bundle_size)
  type(field_type), intent(in),    target  :: state_np1(bundle_size)
  type(field_type), intent(in),    target  :: state_n(bundle_size)
  type(field_type), intent(inout)          :: advection(bundle_size)
  type(field_type), intent(inout)          :: xi

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_w2, mm_w1, div, curl => null()
  type(field_type),    pointer :: mmd_w2, mmd_w1 => null()
  integer(i_def),              :: mesh 

  type(quadrature_type)     :: qr
  type(field_type), pointer :: u ,theta, rho, theta_np1, theta_n => null()
  type(field_type)          :: r_xi, mass_flux, r_rho, ones 

  type(function_space_type), pointer :: xi_fs, u_fs, rho_fs, theta_fs  => null()
  type(evaluator_xyz_type)           :: evaluator_u, evaluator_theta

  mm_w1  => get_mass_matrix(1)
  mm_w2  => get_mass_matrix(2)
  mmd_w1 => get_mass_matrix_diagonal(1)
  mmd_w2 => get_mass_matrix_diagonal(2)
  chi    => get_coordinates()
  div    => get_div()
  curl   => get_curl()
  mesh = chi(1)%get_mesh_id()

  u     => state(1)
  theta => state(2)
  rho   => state(3)

  theta_np1 => state_np1(2)
  theta_n => state_n(2)
 
  u_fs     => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                u%which_function_space() )
  xi_fs    => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                xi%which_function_space() )
  rho_fs   => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                rho%which_function_space() )
  theta_fs => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                theta%which_function_space() )

  mass_flux = field_type( vector_space = u_fs   )
  r_xi      = field_type( vector_space = xi_fs  )
  r_rho     = field_type( vector_space = rho_fs )

  ones = field_type( vector_space = rho_fs )
  call invoke_set_field_scalar( 1.0_r_def, ones )

  qr = quadrature_type(element_order+3, GAUSSIAN)

  ! Compute advection terms
  ! 1) mass flux ( F = rho * u )
  call invoke_set_field_scalar( 0.0_r_def, advection(1) ) 
  select case(operators)
    case(transport_operators_fv)
     evaluator_u = evaluator_xyz_type(u_fs%get_ndf( ), u_fs%get_nodes( ))
     call invoke_sample_poly_flux( mass_flux, u, rho, &
                                   flux_stencil_extent, evaluator_u )
    case(transport_operators_fem)      
      call invoke(flux_rhs_kernel_type( advection(1), u, rho, chi, qr ) )
      call invoke(enforce_bc_kernel_type( advection(1) ) )
      call invoke_set_field_scalar( 0.0_r_def, mass_flux ) 
      call solver_algorithm( mass_flux, advection(1), mesh, chi, method, &
                             mm=mm_w2, mmd=mmd_w2, &
                             preconditioner_choice=solver_preconditioner_diagonal)
  end select

  ! 2) Vorticity advection ( F/rho \cross curl(u))
  call invoke_set_field_scalar( 0.0_r_def, r_xi )
  call invoke( transpose_matrix_vector_kernel_type(r_xi, u, curl) )
  call invoke( enforce_bc_kernel_type( r_xi ) )
  call solver_algorithm( xi, r_xi, mesh, chi, method, &
                         mm=mm_w1, mmd=mmd_w1, &
                         preconditioner_choice=solver_preconditioner_diagonal)
  call invoke_set_field_scalar( 0.0_r_def, advection(1) ) 
  call invoke( vorticity_advection_kernel_type( advection(1), mass_flux, rho, xi, chi, qr ) )
  call invoke( enforce_bc_kernel_type( advection(1) ) )

  ! 3) theta_advection ( F/rho . grad(theta) )
  call invoke_set_field_scalar( 0.0_r_def, advection(2) )
  if ( wtheta_on ) then
    select case(operators)
      case(transport_operators_fv)
        evaluator_theta = evaluator_xyz_type(theta_fs%get_ndf( ), theta_fs%get_nodes( ))
        call invoke_sample_poly_adv( advection(2), u, theta, &
                                     advective_stencil_extent, evaluator_theta )
        call invoke_multiply_field(-1.0_r_def, advection(2), advection(2)) 
      case(transport_operators_fem)
        call invoke (rtheta_wtheta_kernel_type ( advection(2), theta, u, qr))
        call invoke_rtheta_bd_kernel ( advection(2), theta, u, ones, qr )
     end select
  else
    ! Only FEM operators available
    call invoke( rtheta_kernel_type( advection(2), theta, mass_flux, rho, qr) )
  end if
  if ( supg ) &
    call invoke( rtheta_supg_kernel_type( advection(2),     &
                                theta_np1, theta_n, mass_flux, rho, chi, qr) )

  ! 4) divergence of mass flux: M3^-1(div(F))
  call invoke_set_field_scalar( 0.0_r_def, r_rho )
  call invoke( matrix_vector_kernel_type( r_rho, mass_flux, div) )
  call invoke_multiply_field(-1.0_r_def, r_rho, r_rho) 
  call solver_algorithm( advection(3), r_rho, mesh, chi, method, qr=qr )

  end subroutine advection_alg

!>@details A wrapper algorithm for computing the advection of the moisture prognostic
!> @param[inout] advection Field array containing the advective terms
!> @param[in]    mr Field array. Mixing ratios
!> @param[in]    u Field array. Winds

  subroutine advection_mr_alg( mr, u )
  
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type
    implicit none
    type(field_type), intent(inout),    target  :: mr(nummr)
    type(field_type), intent(in),       target  :: u

    type(evaluator_xyz_type)  :: evaluator_theta
    integer(i_def)            :: mesh 
    type(function_space_type), pointer :: theta_fs  => null()
    type(operator_type)                :: mm_wtheta

    type(field_type), pointer :: chi(:) => null()
    type(field_type)          :: mr_inc, mr_adv, mr_n
    type(field_type)          :: mm_diagonal_wtheta

    type( field_type ) :: ones
    type( field_type ) :: mt_lumped
    integer :: imr, stage, st

    chi    => get_coordinates()
    mesh = chi(1)%get_mesh_id()
    theta_fs => function_space_collection%get_fs( mesh, &
                                                  element_order, &
                                                  mr(1)%which_function_space() )
    evaluator_theta = evaluator_xyz_type( theta_fs%get_ndf( ), theta_fs%get_nodes( ) )
    mm_wtheta = get_mass_matrix(5)
    mm_diagonal_wtheta = get_mass_matrix_diagonal(4)

    ones  = field_type( vector_space = theta_fs )
    mt_lumped  = field_type( vector_space = theta_fs )
    call invoke_set_field_scalar( 1.0_r_def, ones )
    call invoke_set_field_scalar( 0.0_r_def, mt_lumped)
    call invoke(matrix_vector_kernel_type(mt_lumped, ones, mm_wtheta) )

    mr_inc = field_type( vector_space = theta_fs )
    mr_adv = field_type( vector_space = theta_fs )
    mr_n   = field_type( vector_space = theta_fs )
    do stage = 1,num_rk_stage
      mr_prediction(stage) = field_type( vector_space = theta_fs )
    end do

    ! Runge-Kutta algorithm
    do imr=1,nummr
      call invoke_copy_field_data(mr(imr), mr_n)
      do stage = 1,num_rk_stage
        call invoke_sample_poly_adv(mr_prediction(stage), u, mr(imr), &
                                    advective_stencil_extent, evaluator_theta)
        call invoke_set_field_scalar(0.0_r_def, mr_adv)
        do st = 1, stage
          call invoke_axpy(-ak(stage,st), mr_prediction(st), mr_adv,  mr_adv)
        end do
        ! Use lumped mass matrix
        call invoke_divide_field(mr_adv, mt_lumped, mr_inc)          
        call invoke_axpy(dt, mr_inc, mr_n, mr(imr))
      end do
    end do

  end subroutine advection_mr_alg

end module advection_alg_mod


