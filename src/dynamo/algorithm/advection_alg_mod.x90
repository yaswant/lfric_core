!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the advection of the prognostic
!>       equations
module advection_alg_mod

  use constants_mod,                  only: r_def
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use field_bundle_mod,               only: bundle_ax
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order
  use formulation_config_mod,         only: supg
  use function_space_mod,             only: function_space_type
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type
  use mesh_mod,                       only: mesh_type
  use operator_mod,                   only: operator_type
  use psykal_lite_mod,                only: invoke_set_field_scalar, &
                                            invoke_flux_rhs, &
                                            invoke_multiply_field
  use quadrature_mod,                 only: quadrature_type, GAUSSIAN
  use rrho_kernel_mod,                only: rrho_kernel_type
  use rtheta_kernel_mod,              only: rtheta_kernel_type
  use rtheta_supg_kernel_mod,         only: rtheta_supg_kernel_type
  use runtime_constants_mod,          only: runtime_constants_type
  use solver_config_mod,              only: method,         &
                                            preconditioner, &
                                            solver_preconditioner_diagonal
  use solver_mod,                     only: solver_algorithm
  use timestepping_config_mod,        only: dt
  use transpose_matrix_vector_kernel_mod, &
                                      only: transpose_matrix_vector_kernel_type
  use vorticity_advection_kernel_mod, only: vorticity_advection_kernel_type
  use vorticity_rhs_kernel_mod,       only: vorticity_rhs_kernel_type

  implicit none

  private
  public :: advection_alg

contains
!>@details A wrapper algorithm for computing the advection of the prognostic
!>         equations, namely:
!>         \f[ \mathbf{R_u} = \xi \times \frac{\mathbf{F}}{\rho} \f]
!>         \f[ R_\theta = \frac{\mathbf{F}}{\rho}.\nabla\theta \f]
!>         \f[ R_\rho = \nabla.\mathbf{F} \f]
!>         with diagnostic fields:
!>
!>         Mass flux: \f[ \mathbf{F} = \mathbf{u}\rho \f]
!>         Vorticity: \f[ \xi = \nabla\times\mathbf{u} \f]
!>
!> @param[inout] advection Field array containing the advective terms
!> @param[in]    state Field array. Current state of the model prognostics (u, theta, rho)
!> @param[in]    xi The relative vorticity field
!> @param[in]    runtime constants Container of various constant operators and
!>               fields
  subroutine advection_alg( advection, &
                            state, &
                            state_np1, &
                            state_n,   &
                            xi, &
                            runtime_constants )
  
  implicit none
  ! Form of state and advection is [u,theta,rho] & [r_u,r_theta,r_rho]
  type(field_type), intent(in),    target  :: state(3)
  type(field_type), intent(in),    target  :: state_np1(3)
  type(field_type), intent(in),    target  :: state_n(3)
  type(field_type), intent(inout)          :: advection(3)
  type(field_type), intent(inout)          :: xi
  type(runtime_constants_type), intent(in) :: runtime_constants

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_w2, mm_w1, div, curl => null()
  type(field_type),    pointer :: mmd_w2, mmd_w1 => null()
  type(mesh_type),     pointer :: mesh => null()

  type(quadrature_type)     :: qr
  type(field_type), pointer :: u ,theta, rho, theta_np1, theta_n => null()
  type(field_type)          :: r_xi, mass_flux, r_rho 

  type(function_space_type) :: fs
  type(function_space_type), pointer :: xi_fs  => null()
  type(function_space_type), pointer :: u_fs   => null()
  type(function_space_type), pointer :: rho_fs => null()

  mesh   => runtime_constants%get_mesh()
  mm_w1  => runtime_constants%get_mass_matrix(1)
  mm_w2  => runtime_constants%get_mass_matrix(2)
  mmd_w1 => runtime_constants%get_mass_matrix_diagonal(1)
  mmd_w2 => runtime_constants%get_mass_matrix_diagonal(2)
  chi    => runtime_constants%get_coordinates()
  div    => runtime_constants%get_div()
  curl   => runtime_constants%get_curl()

  u     => state(1)
  theta => state(2)
  rho   => state(3)

  theta_np1 => state_np1(2)
  theta_n => state_n(2)
 
  u_fs   => fs%get_instance( mesh, element_order, u%which_function_space()   )
  xi_fs  => fs%get_instance( mesh, element_order, xi%which_function_space()  )
  rho_fs => fs%get_instance( mesh, element_order, rho%which_function_space() )


  mass_flux = field_type( vector_space = u_fs   )
  r_xi      = field_type( vector_space = xi_fs  )
  r_rho     = field_type( vector_space = rho_fs )

  qr = quadrature_type(element_order+3, GAUSSIAN)

  ! Compute advection terms
  ! 1) mass flux ( F = rho * u )
  call invoke_set_field_scalar( 0.0_r_def, advection(1) ) 
  call invoke_flux_rhs( advection(1), u, rho, chi, qr ) 
  call invoke_set_field_scalar( 0.0_r_def, mass_flux ) 
  call solver_algorithm( mass_flux, advection(1), mesh, chi, method, &
                         mm=mm_w2, mmd=mmd_w2, &
                         preconditioner_choice=solver_preconditioner_diagonal)

  ! 2) Vorticity advection dt*( F/rho \cross curl(u))
  call invoke_set_field_scalar( 0.0_r_def, r_xi )
  call invoke( transpose_matrix_vector_kernel_type(r_xi, u, curl) )
  call invoke( enforce_bc_kernel_type( r_xi ) )
  call solver_algorithm( xi, r_xi, mesh, chi, method, &
                         mm=mm_w1, mmd=mmd_w1, &
                         preconditioner_choice=solver_preconditioner_diagonal)
  call invoke_set_field_scalar( 0.0_r_def, advection(1) ) 
  call invoke( vorticity_advection_kernel_type( advection(1), mass_flux, rho, xi, chi, qr ) )
  call invoke( enforce_bc_kernel_type( advection(1) ) )

  ! 3) theta_advection dt*( F/rho . grad(theta) )
  call invoke_set_field_scalar( 0.0_r_def, advection(2) )
  call invoke( rtheta_kernel_type( advection(2), theta, mass_flux, rho, qr) )
  if ( supg ) &
    call invoke( rtheta_supg_kernel_type( advection(2),     &
                                theta_np1, theta_n, mass_flux, rho, chi, qr) )

  ! 4) divergence of mass flux: dt * M3^-1(div(F))
  call invoke_set_field_scalar( 0.0_r_def, r_rho )
  call invoke( matrix_vector_kernel_type( r_rho, mass_flux, div) )
  call invoke_multiply_field(-1.0_r_def, r_rho, r_rho) 
  call solver_algorithm( advection(3), r_rho, mesh, chi, method, qr=qr )

  ! Add in Dt factor
  call bundle_ax( dt, advection, advection, 3 )

  end subroutine advection_alg

end module advection_alg_mod


