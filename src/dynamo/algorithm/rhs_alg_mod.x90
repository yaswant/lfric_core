!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the rhs of the prognostic
!>       equations
module rhs_alg_mod

  use constants_mod,                     only: r_def
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use field_bundle_mod,                  only: clone_bundle
  use field_mod,                         only: field_type
  use finite_element_config_mod,         only: element_order
  use formulation_config_mod,            only: rotating
  use function_space_mod,                only: function_space_type
  use geopotential_gradient_kernel_mod,  only: geopotential_gradient_kernel_type
  use kinetic_energy_gradient_kernel_mod,only: kinetic_energy_gradient_kernel_type
  use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
  use mesh_mod,                          only: mesh_type
  use multiplicity_kernel_mod,           only: multiplicity_kernel_type
  use operator_mod,                      only: operator_type
  use pressure_gradient_kernel_mod,      only: pressure_gradient_kernel_type
  use psykal_lite_mod,                   only: invoke_axpy,               &
                                               invoke_multiply_field,     &
                                               invoke_sample_flux_kernel, &
                                               invoke_set_field_scalar
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use rotation_kernel_mod,               only: rotation_kernel_type
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use runtime_constants_mod,             only: runtime_constants_type
  use solver_config_mod,                 only: method
  use solver_mod,                        only: solver_algorithm

  implicit none

  private
  public :: rhs_alg

contains
!>@details A wrapper algorithm for computing the rhs of the prognostic
!>         equations. If computing the lhs of the semi-implicit equations
!>         a correction to the theta and rho advection terms is also computed 
!>         (d_adv terms) namely:
!>         \f[
!>            \mathbf{R_u} = \mathbf{u} 
!>                         + \alpha\Delta t\left[ 2\Omega \times \mathbf{u} 
!>                         + \nabla\left(\Phi + 1/2\mathbf{u}.\mathbf{u}\right)
!>                         + Cp\theta\nabla\Pi \right]
!>         \f]
!>         \f[ R_\rho = \rho + d_{adv}\alpha\Delta t \nabla.\left(\rho\mathbf{u}\right) \f]
!>         \f[ R_\theta = \theta + d_{adv}\alpha\Delta t\mathbf{u}.\nabla\theta \f]
!>         This can be given either timelevel n or n+1 fields to compute
!>         the appropriate part of the full right hand side
!> @param[inout] rhs The state vector to compute
!> @param[in]    alpha_dt The offcentering parameter times the timestep
!> @param[in]    state The current model prognostic state
!> @param[in]    runtime_constants Runtime constants for the model
!> @param[in]    l_from_solver flag set to true if computing the lhs
  subroutine rhs_alg(rhs, alpha_dt, state, runtime_constants, &
                     l_from_solver)
  
  implicit none

  real(kind=r_def),             intent(in)    :: alpha_dt
  ! Form of state and rhs is [u,theta,rho] & [rhs_tmp(1),rhs_tmp(2),rhs_tmp(3)]
  type(field_type), target,     intent(in)    :: state(3)
  type(field_type),             intent(inout) :: rhs(3)
  type(runtime_constants_type), intent(in)    :: runtime_constants
  logical,                      intent(in)    :: l_from_solver

  type(field_type), pointer :: chi(:), geopotential => null()
  type(operator_type), pointer :: mm_w2, mm_w0, mm_w3_inv, div => null()
  type(mesh_type),  pointer    :: mesh => null()

  type( quadrature_type )   :: qr 
  type(field_type), pointer :: u ,theta, rho
  type(field_type)          :: rhs_tmp(3)
  type(field_type)          :: f_star, ones, w2_multiplicity

  type(function_space_type) :: fs
  type(function_space_type), pointer :: u_fs   => null()
  type(function_space_type), pointer :: rho_fs => null()

  mesh         => runtime_constants%get_mesh()
  geopotential => runtime_constants%get_geopotential()
  mm_w0        => runtime_constants%get_mass_matrix(0)
  mm_w2        => runtime_constants%get_mass_matrix(2)
  mm_w3_inv    => runtime_constants%get_mass_matrix(4)
  chi          => runtime_constants%get_coordinates()

  u     => state(1)
  theta => state(2)
  rho   => state(3)
 
  call clone_bundle(rhs, rhs_tmp, 3)

  if ( l_from_solver ) then
    qr = quadrature_type(element_order+3, GAUSSIAN)
  else
    qr = quadrature_type(element_order+2, GAUSSIAN)
  end if


  if ( l_from_solver ) then    
    ! Need to create u*rho^ref \in W2 for rhs_tmp(3) kernel -> sampled mass flux
    u_fs => fs%get_instance( mesh, element_order, u%which_function_space() )

    w2_multiplicity = field_type( vector_space = u_fs )
    call invoke_set_field_scalar( 0.0_r_def, w2_multiplicity )
    call invoke ( multiplicity_kernel_type( w2_multiplicity ) )

    f_star = field_type( vector_space = u_fs )
    call invoke_set_field_scalar( 0.0_r_def, f_star )
    call invoke_sample_flux_kernel( f_star, u, w2_multiplicity, rho )
  end if

  ! Compute rhs_u
  call invoke_set_field_scalar( 0.0_r_def, rhs_tmp(1) )
  call invoke( pressure_gradient_kernel_type( rhs_tmp(1), rho, theta, qr ) )
  call invoke( kinetic_energy_gradient_kernel_type( rhs_tmp(1), u, chi, qr ) )
  if ( .not. l_from_solver ) &
    call invoke( geopotential_gradient_kernel_type( rhs_tmp(1), &
                                                    geopotential, qr ) )
  if ( rotating ) &
    call invoke( rotation_kernel_type( rhs_tmp(1), u, chi, qr ) )
  call invoke(enforce_bc_kernel_type(rhs_tmp(1)) )
  call invoke_set_field_scalar( 0.0_r_def, rhs(1) )
  call invoke( matrix_vector_kernel_type( rhs(1), u, mm_w2) )
  call invoke_axpy( alpha_dt, rhs_tmp(1), rhs(1), rhs(1) ) 
 
  ! Compute rhs_theta
  call invoke_set_field_scalar( 0.0_r_def, rhs_tmp(2) )
  if ( l_from_solver ) then
    qr = quadrature_type(element_order+1, GAUSSIAN)
    rho_fs => fs%get_instance( mesh, element_order, rho%which_function_space() )
    ones = field_type( vector_space = rho_fs )
    call invoke_set_field_scalar( 1.0_r_def, ones )
    call invoke( rtheta_kernel_type( rhs_tmp(2), theta, u, ones, qr) )
  end if
  call invoke_set_field_scalar( 0.0_r_def, rhs(2) )
  call invoke( matrix_vector_kernel_type( rhs(2), theta, mm_w0) )
  call invoke_axpy( alpha_dt, rhs_tmp(2), rhs(2), rhs(2) ) 

  ! Compute rhs_rho
  if ( l_from_solver ) then
    div => runtime_constants%get_div()
    call invoke_set_field_scalar( 0.0_r_def, rhs_tmp(3) )
    call invoke( matrix_vector_kernel_type( rhs_tmp(3), f_star, div) )
    call invoke_multiply_field(-1.0_r_def, rhs_tmp(3), rhs_tmp(3)) 
    call invoke_set_field_scalar( 0.0_r_def, rhs_tmp(3) )
    call invoke( matrix_vector_kernel_type( rhs_tmp(3), rhs_tmp(3), mm_w3_inv) )
  else
    call invoke_set_field_scalar( 0.0_r_def, rhs_tmp(3) )
  end if
  call invoke_axpy( alpha_dt, rhs_tmp(3), rho, rhs(3) )

  end subroutine rhs_alg

end module rhs_alg_mod


