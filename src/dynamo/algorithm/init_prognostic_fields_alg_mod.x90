!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief Initialisation of prognostic fields
module init_prognostic_fields_alg_mod

  use log_mod,                         only: log_event,         &
                                             log_scratch_space, &
                                             LOG_LEVEL_INFO,    &
                                             LOG_LEVEL_TRACE
  use constants_mod,                   only: r_def

  ! Configuration and restart/checkpoint options
  use finite_element_config_mod,       only: element_order
  use formulation_config_mod,          only: nonlinear
  use restart_control_mod,             only: restart_type
  ! I/O tools
  use field_io_mod,                    only: read_state_netcdf

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                 only: invoke_set_field_scalar

  ! PsyKAl PSYClone kernels
  use initial_theta_kernel_mod,        only: initial_theta_kernel_type
  use initial_rho_kernel_mod,          only: initial_rho_kernel_type
  use initial_u_kernel_mod,            only: initial_u_kernel_type

  ! Derived Types
  use mesh_mod,                        only: mesh_type
  use field_mod,                       only: field_type
  use function_space_mod,              only: function_space_type
  use quadrature_mod,                  only: quadrature_type, GAUSSIAN

  ! Handles
  use fs_continuity_mod,               only: W0, W1, W2, W3

  implicit none

  private
  public :: init_prognostic_fields_alg

contains
  !> @details An algorithm for initialising prognostic fields for 
  !>          all solvers.
  !> @param[in]    mesh Mesh object on which the model runs
  !> @param[inout] chi  The finite element form of the coordinates
  !> @param[inout] u  The 3D wind field
  !> @param[inout] rho The density
  !> @param[inout] theta The potential temperature
  !> @param[inout] xi The vorticity field 
  !> @param[in] restart Checkpoint/restart type with timestepping information
  subroutine init_prognostic_fields_alg( mesh, chi, u, rho, theta, xi, restart)

    implicit none

    ! Mesh
    type (mesh_type), intent(in) :: mesh
    ! Coordinate fields
    type( field_type ), intent( inout ) :: chi(3)
    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta, xi
    ! Control
    type( restart_type ), intent(in) :: restart

    type( function_space_type )     :: fs
    type( quadrature_type )         :: qr
    type( field_type ), allocatable :: state(:)

    integer :: n_fields

    qr = quadrature_type( element_order + 3, GAUSSIAN )

    !=== Initialise global prognostic fields ==================================!

    if (.not.restart%read_file()) then           ! No check point to start from

      call log_event( "Dynamo: Initialising prognostic fields", LOG_LEVEL_INFO )
      ! Initialise Theta, U, Xi (all formulations)
      call invoke( initial_theta_kernel_type( theta, chi ) ) 
      call invoke_set_field_scalar(0.0_r_def, u)
      call invoke_set_field_scalar(0.0_r_def, xi) 
      ! Initialise Rho (different for nonlinear or linear formulation)
      if ( nonlinear ) then
        call invoke( initial_rho_kernel_type ( rho, chi, qr ) )
      else
        call invoke_set_field_scalar(0.0_r_def, rho)
      end if
      call log_event( "Dynamo: Initialised prognostic fields", LOG_LEVEL_INFO )

    else                                   ! Recorded check point to start from

      allocate(state(4))
      n_fields = 1
      write(log_scratch_space,'(A,A)') "Reading file:", &
            trim(restart%startfname("rho"))
      call log_event(log_scratch_space,LOG_LEVEL_INFO)
      state(1) = field_type(vector_space = fs%get_instance(mesh, element_order, W3))
      call read_state_netcdf(n_fields, state(1), trim(restart%startfname("rho")))
      rho = state(1)

      write(log_scratch_space,'(A,A)') "Reading file:", &
            trim(restart%startfname("u"))
      call log_event(log_scratch_space,LOG_LEVEL_INFO)
      state(2) = field_type(vector_space = fs%get_instance(mesh, element_order, W2))
      call read_state_netcdf(n_fields, state(2), trim(restart%startfname("u")))
      u = state(2)

      write(log_scratch_space,'(A,A)') "Reading file:", &
            trim(restart%startfname("theta"))
      call log_event(log_scratch_space,LOG_LEVEL_INFO)
      state(3) = field_type(vector_space = fs%get_instance(mesh, element_order, W0))
      call read_state_netcdf(n_fields, state(3), &
           trim(restart%startfname("theta")))
      theta = state(3)

      write(log_scratch_space,'(A,A)') "Reading file:", &
            trim(restart%startfname("xi"))
      call log_event(log_scratch_space,LOG_LEVEL_INFO)
      state(4) = field_type(vector_space = fs%get_instance(mesh, element_order, W1))
      call read_state_netcdf(n_fields, state(4), trim(restart%startfname("xi")))
      xi = state(4)

      deallocate(state)
      call log_event( "Dynamo: Read prognostic fields from files", LOG_LEVEL_INFO )

    end if

    !==========================================================================!

  end subroutine init_prognostic_fields_alg

end module init_prognostic_fields_alg_mod
