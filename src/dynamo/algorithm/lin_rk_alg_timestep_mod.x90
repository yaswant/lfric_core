!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the linear 3D equations, currently
!>       using 3-stage SSP.
!>@details An algorithm for timstepping the 3D linear no advection equations
!>         using a 3-stage SSP Runge-Kutta algorithm. The algorithm
!>         initialises all fields, sets up temporay fields, performs the
!>         timestepping and checks to see if it should dump output
!>@deprecated The Usefulness of the linear model is to be re-evaluated at 
!>            the end of the Gung-Ho project and removed if possible
module lin_rk_alg_timestep_mod

  use log_mod,           only: log_event, log_scratch_space,                    &
                               LOG_LEVEL_INFO, LOG_LEVEL_TRACE
  use constants_mod,     only: r_def, str_max_filename

  ! Configuration and restart/checkpoint options 
  use configuration_mod,   only: solver_option, dt, element_order
  use restart_control_mod, only: restart_type

  ! PsyKAl-lite kernels
  use psykal_lite_mod,     only: invoke_copy_field_data,                          &
                               invoke_set_field_scalar,                         &
                               invoke_linear_ru_kernel,                         &
                               invoke_axpy

  ! PsyKAl PSYClone kernels
  use compute_geopotential_kernel_mod,   only: compute_geopotential_kernel_type
  use compute_mass_matrix_kernel_w0_mod, only: compute_mass_matrix_kernel_w0_type
  use compute_mass_matrix_kernel_w2_mod, only: compute_mass_matrix_kernel_w2_type
  use initial_rho_kernel_mod,            only: initial_rho_kernel_type  
  use initial_theta_kernel_mod,          only: initial_theta_kernel_type
  use linear_rtheta_kernel_mod,          only: linear_rtheta_kernel_type
  use linear_rrho_kernel_mod,            only: linear_rrho_kernel_type 

  use field_mod,           only: field_type 
  use function_space_mod,  only: function_space_type, W0, W1, W2, W3
  use galerkin_projection_algorithm_mod, only : galerkin_projection_algorithm
  use quadrature_mod,      only: quadrature_type, GAUSSIAN
  use solver_mod,          only: solver_algorithm
  use driver_layer,        only: interpolated_output
  use operator_mod,        only: operator_type
  use mesh_mod,            only: mesh_type
  use restart_control_mod, only: restart_type
  use output_alg_mod,      only: output_alg
  implicit none

  private
  public :: lin_rk_alg_timestep

contains
  !>-------------------------------------------------
  !> @brief A Runge-Kutta time-discretisation of the linear 3D equations,
  !>        currently using 3-stage SSP.
  !> @details An algorithm for timstepping the 3D linear
  !>          equations with no advection using a Runge-Kutta algortihm. The
  !>          algorithm initialialises all fields, sets up temporary fields
  !>          and performs the timestepping and checks to see if it should
  !>          dump output.
  !>          The type of Runge-Kutta scheme can be simply changed by 
  !>          modifying the (currently hardwired) Butcher tableau (ak array)
  !>          The current set up uses the 3rd-order three stage 
  !>          Strong-Stability-Preserving (SSP3) method
  !> @param[in]    mesh Mesh object on which the model runs
  !> @param[inout] chi The finite element form of the coordinates
  !> @param[inout] u The 3D wind field
  !> @param[inout] rho The density
  !> @param[inout] theta The potential temperature
  !> @param[in] restart checkpoint/restart type with timestepping information
  !> @deprecated The Usefulness of the linear model is to be re-evaluated at 
  !>             the end of the Gung-Ho project and removed if possible
  subroutine lin_rk_alg_timestep( mesh, chi, u, rho, theta, restart)

    implicit none

    type( mesh_type  ), intent( in )    :: mesh
! coordinate fields
    type( field_type ), intent( inout ) :: chi(3)
! prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta 
! restart timestep and filename information
    type(restart_type), intent( in )    :: restart
! temporary fields    
    type( field_type ) :: u_n, rho_n, theta_n,       &
                          r_u, r_rho, r_theta,       &
                          u_inc, rho_inc, theta_inc, &
                          geopotential

    type( field_type ), allocatable :: rt_prediction(:),  &
                                       ru_prediction(:),  &
                                       rr_prediction(:) 
    type( field_type ) :: projected_field(3)                                       
    
    integer :: theta_fs, u_fs, rho_fs
    real(kind=r_def), allocatable :: ak(:,:)
    type(function_space_type) :: fs
    type(operator_type) :: mm_w2, mm_w0  

    ! Timestepping variables
    integer :: timestep, ts_init
    integer :: stage, num_rk_stage, st
    type(quadrature_type) :: qr 
    integer, parameter :: vector_field = 3, &
                          scalar_field = 1
    
! SSP3 weights
    num_rk_stage = 3
    allocate ( ak (num_rk_stage,num_rk_stage) )
    ak(1,:) = (/ 1.0_r_def,  0.0_r_def,  0.0_r_def /)
    ak(2,:) = (/ 0.25_r_def, 0.25_r_def, 0.0_r_def /)
    ak(3,:) = (/ 1.0_r_def,  1.0_r_def,  4.0_r_def /)/6.0_r_def
    
    allocate ( rt_prediction(num_rk_stage), &
               ru_prediction(num_rk_stage), & 
               rr_prediction(num_rk_stage) )
               
 ! Local fields
    theta_fs  = theta%which_function_space()
    u_fs      = u%which_function_space()
    rho_fs    = rho%which_function_space()

    qr = quadrature_type(element_order+3, GAUSSIAN)

    theta_n   = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    u_n       = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    rho_n     = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    r_theta   = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    r_u       = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    r_rho     = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    theta_inc = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    u_inc     = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    rho_inc   = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    geopotential = field_type( vector_space = fs%get_instance(mesh, theta_fs) )

    do stage = 1,num_rk_stage
      rt_prediction(stage) = field_type                                        &
                             (vector_space = fs%get_instance(mesh, theta_fs))

      ru_prediction(stage) = field_type                                        &
                             (vector_space = fs%get_instance(mesh, u_fs))

      rr_prediction(stage) = field_type                                        &
                             (vector_space = fs%get_instance(mesh, rho_fs))

    end do   

    ! Create operators needed for timestepping
    mm_w0 = operator_type(fs%get_instance(mesh, W0),fs%get_instance(mesh, W0))              
    mm_w2 = operator_type(fs%get_instance(mesh, W2),fs%get_instance(mesh, W2)) 

    !=== Section 2: Initialise local algorithm fields ========================!
    call log_event( "Dynamo: computing Linear RK algorithm fields", &
                     LOG_LEVEL_INFO )
    ! Compute geopotential
    do stage = 1,3 
      projected_field(stage) = field_type                                      &
                               (vector_space = fs%get_instance(mesh, theta_fs))
    end do

    !Construct PSy layer given a list of kernels. This is the line the code
    !generator may parse and do its stuff.
    
! initialise        
    call invoke( compute_geopotential_kernel_type( geopotential, chi ) )

    ! Construct initial conditions
    call log_event( "Dynamo: computing initial fields", LOG_LEVEL_INFO )
    if(.not.restart%read_file()) then ! no check point to start from
       call log_event( "Dynamo: Initialising prognostic fields", LOG_LEVEL_INFO )
       call invoke( initial_theta_kernel_type( theta, chi ) )
       call invoke_set_field_scalar(0.0_r_def, u)
       call invoke_set_field_scalar(0.0_r_def, rho)
    end if

    call invoke( compute_mass_matrix_kernel_w0_type(mm_w0, chi, qr) )
    call invoke( compute_mass_matrix_kernel_w2_type(mm_w2, chi, qr) )

    !--- Intial output and output frequency -----------------------------------! 
    ! Output initial conditions
    call log_event( "Dynamo: Outputing initial fields", LOG_LEVEL_INFO )
    call galerkin_projection_algorithm( projected_field(1) &
                                      , theta              &
                                      , mesh               &
                                      , chi                &
                                      , scalar_field       &
                                      , qr                 &
                                      , mm=mm_w0 ) 
    ts_init = max( (restart%ts_start() - 1), 0 ) ! 0 or t previous.
    call output_alg(ts_init, restart, theta, u, rho, chi, mesh, mm_w0)

    !=== Section 3: Timestepping ==============================================!   

    do timestep = restart%ts_start(),restart%ts_end()
      call log_event( &
      '/****************************************************************************/ ', &
                      LOG_LEVEL_INFO )
      write( log_scratch_space, '(A,I0)' ) 'Start of timestep ', timestep
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      !PSY call invoke ( copy_field_data(theta,theta_n))
      call invoke_copy_field_data(theta,theta_n)
      !PSY call invoke ( copy_field_data(u,u_n))
      call invoke_copy_field_data(u,u_n)
      !PSY call invoke ( copy_field_data(rho,rho_n))
      call invoke_copy_field_data(rho,rho_n)
      
! Runge-Kutta algorithm
      do stage = 1,num_rk_stage
! Compute new rhs      
        !PSY call invoke ( set_field_scalar(0.0_r_def, rt_prediction(stage)))
        call invoke_set_field_scalar(0.0_r_def, rt_prediction(stage))
        call invoke(linear_rtheta_kernel_type( rt_prediction(stage), u, geopotential, chi, qr) )
        !PSY call invoke ( set_field_scalar(0.0_r_def, ru_prediction(stage)))
        call invoke_set_field_scalar(0.0_r_def, ru_prediction(stage))
        call invoke_linear_ru_kernel ( ru_prediction(stage), u, rho, theta, &
                                          geopotential, chi, qr ) 
        call invoke( linear_rrho_kernel_type ( rr_prediction(stage), u, geopotential, chi, qr ) )
        !PSY call invoke ( set_field_scalar(0.0_r_def, r_theta))
        call invoke_set_field_scalar(0.0_r_def, r_theta)
        !PSY call invoke ( set_field_scalar(0.0_r_def, r_u))
        call invoke_set_field_scalar(0.0_r_def, r_u)
        !PSY call invoke ( set_field_scalar(0.0_r_def, r_rho))
        call invoke_set_field_scalar(0.0_r_def, r_rho) 
        
        do st = 1, stage          
          !PSY call invoke ( axpy(ak(stage,st), rt_prediction(st),r_theta, r_theta))
          call invoke_axpy(ak(stage,st), rt_prediction(st),r_theta, r_theta)
          !PSY call invoke ( axpy(ak(stage,st), ru_prediction(st),r_u, r_u))
          call invoke_axpy(ak(stage,st), ru_prediction(st),r_u, r_u)
          !PSY call invoke ( axpy(ak(stage,st), rr_prediction(st),r_rho, r_rho))
          call invoke_axpy(ak(stage,st), rr_prediction(st),r_rho, r_rho)
        end do

        ! Invert mass matrices
        call solver_algorithm(theta_inc, r_theta, mesh, chi, &
                              solver_option, mm=mm_w0)
        call solver_algorithm(u_inc,     r_u,     mesh, chi, &
                              solver_option, mm=mm_w2)
        call solver_algorithm(rho_inc,   r_rho,   mesh, chi, &
                              solver_option, qr=qr)

        ! Add increments
        ! PSY call invoke ( axpy(dt, theta_inc, theta_n, theta))
        call invoke_axpy(dt, theta_inc, theta_n, theta)
        ! PSY call invoke ( axpy(dt, u_inc, u_n, u))
        call invoke_axpy(dt, u_inc, u_n, u)
        ! PSY call invoke ( axpy(dt, rho_inc, rho_n, rho))
        call invoke_axpy(dt, rho_inc, rho_n, rho)

        ! Diagnostics
        call theta_inc%log_minmax(LOG_LEVEL_TRACE, 'theta_inc');
        call u_inc%log_minmax(LOG_LEVEL_TRACE, 'u_inc');
        call rho_inc%log_minmax(LOG_LEVEL_TRACE, 'rho_inc');

      end do
       !---------End of timestep diagnostics ----------------------------------!
      if ( mod(timestep, (restart%ts_start()+restart%diag_freq()) )  == 0 ) then
        call output_alg(timestep, restart, theta, u, rho, chi, mesh, mm_w0)
      end if
      write( log_scratch_space, '(A,I0)' ) 'End of timestep ', timestep
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      call log_event( '\****************************************************************************/ ', &
                      LOG_LEVEL_INFO )
    end do
    call log_event( "Dynamo: Finished timestep", LOG_LEVEL_INFO )
    !==========================================================================

  end subroutine lin_rk_alg_timestep

end module lin_rk_alg_timestep_mod
