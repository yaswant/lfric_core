!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------
!
!> @brief Contains methods and algorithms for solving a system A.x = b for known
!! input field b and matrix A and returns field x
!!
!! @details Contains a selction of solvers for inverting the matrix vector
!! system A.x = b to return x = A^{-1}.b Depending upom the type of system to
!! solve a number of iterative solver algorithms are possible or for
!! discontinuous systems an exact solver can be used
module solver_mod

  use constants_mod,                 only : r_def, str_def, i_def
  use function_space_collection_mod, only : function_space_collection
  use field_mod,                     only : field_type
  use finite_element_config_mod,     only : element_order
  use fs_continuity_mod,             only : W3, fs_name
  use function_space_mod,            only : function_space_type
  use log_mod,                   only : log_event,         &
                                        log_scratch_space, &
                                        LOG_LEVEL_ERROR,   &
                                        LOG_LEVEL_INFO,    &
                                        LOG_LEVEL_DEBUG,   &
                                        LOG_LEVEL_TRACE
  use matrix_vector_kernel_mod,  only : matrix_vector_kernel_type
  use operator_mod,              only : operator_type
  use psykal_lite_mod,           only : invoke_inner_prod,              &
                                        invoke_axpy,                    &
                                        invoke_minus_field_data,        &
                                        invoke_divide_field,            &
                                        invoke_copy_scaled_field_data
  use quadrature_mod,            only : quadrature_type
  use solver_config_mod,         only : solver_method_cg,               &
                                        solver_method_bicgstab,         &
                                        solver_method_jacobi,           &
                                        solver_method_gmres,            &
                                        solver_method_gcr,              &
                                        tolerance,                      &
                                        maximum_iterations,             &
                                        solver_preconditioner_none,     &
                                        solver_preconditioner_diagonal, &
                                        gcrk
  use w3_solver_kernel_mod,      only : w3_solver_kernel_type

  implicit none

  private
  real(r_def), parameter :: sc_err_min = 1.0e-16_r_def
  public :: solver_algorithm

contains

!> @brief Wrapper for specific solver routines for solving system A.x = b
!! @details solves A.x = b for using a choice of solver where A is a mass
!! matrix for a given space and x and b are fields belonging to that space.
!! For a discontinous space the element mass matrix is exactly inverted, for
!! continuous spaces an iterative solver is used.
!! The current choices of iteratives solver are:
!! cg: Conjugate gradient method without preconditioning
!! bicgstab: bi-conjugate gradient, stabilised without preconditioning
!! jacobi: a fixed number of jacobi iterations
!> @param[inout] lhs Field to be solved for (x)
!> @param[inout] rhs Right hand side field (b)
!> @param[in]    mesh Mesh object the model for fields
!> @param[inout] chi Coordinate array fields
!> @param[in]    solver_type (optional) Type of iterative solver to use for
!>               continuous systems
!> @param[in] qr (optional) Quadrature rule.
!> @param[inout] mm (optional) Mass matrix
!! Either qr or mm are required, but not both.
!> @param[in] preconditioner_choice (optional) Choice of preconditioner type
!> @param[in] mmd (optional) Matrix diagonal

  subroutine solver_algorithm( lhs, rhs, mesh, chi, solver_type, qr, mm, &
                               preconditioner_choice, mmd )

    implicit none

    type(field_type), intent(inout) :: lhs
    type(field_type), intent(inout) :: rhs
    integer(i_def),   intent(in)    :: mesh

    ! chi is really intent(in) but this currently causes
    ! problems because PSyclone makes everything (inout)
    type(field_type), intent(inout) :: chi(3)

    integer(i_def),                  intent(in)    :: solver_type
    type(quadrature_type), optional, intent(in)    :: qr
    type(operator_type),   optional, intent(inout) :: mm
    integer(i_def),        optional, intent(in)    :: preconditioner_choice
    type(field_type),      optional, intent(in)    :: mmd

    integer(i_def), parameter :: NUM_JACOBI_ITERS = 5

    integer(i_def) :: fs_l, fs_r
    integer(i_def) :: prec

    if ( present(preconditioner_choice) ) then
      prec = preconditioner_choice
    else
      prec = solver_preconditioner_none
    end if

    fs_l = lhs%which_function_space()
    fs_r = rhs%which_function_space()
    ! check the arguments qr .or. mm not both or neither
    if( present(qr) .and. .not.present(mm) ) then
       ! quadrature present, only for W3
       if( (fs_l == W3) .and. (fs_r == W3) ) then
          ! we are on the right space
          call invoke( w3_solver_kernel_type(lhs, rhs, chi, qr) )
       else
          write( log_scratch_space, '(A,I3,",",I3)' ) 'quadrature required for w3 solver, stopping',fs_l,fs_r
          call log_event( log_scratch_space, LOG_LEVEL_ERROR )
       end if
    else if( .not.present(qr) .and. present(mm) ) then
       ! mass matrix

       if(fs_l == W3) then
         ! mm is inverse mass matrix
         call invoke( matrix_vector_kernel_type(rhs, lhs, mm) )
       else
       select case ( solver_type )
          case ( solver_method_cg )
            call cg_solver_algorithm(lhs, rhs, mm, mesh, prec, mmd=mmd)
          case ( solver_method_bicgstab )
            call bicg_solver_algorithm(lhs, rhs, mm, mesh, prec, mmd=mmd)
          case ( solver_method_jacobi )
            call jacobi_solver_algorithm(lhs, rhs, mm, mesh, NUM_JACOBI_ITERS)
          case ( solver_method_gmres )
            call gmres_solver_algorithm( lhs, rhs, mm, mesh,               &
                                         solver_preconditioner_none, prec, &
                                         mmd )
          case ( solver_method_gcr )
            call gcr_solver_algorithm(lhs, rhs, mm, mesh, prec, mmd=mmd)
          case default
            write( log_scratch_space, '(A)' )  'Invalid linear solver choice, stopping'
            call log_event( log_scratch_space, LOG_LEVEL_ERROR )
        end select
       end if
    else if( present(qr) .and. present(mm) ) then
       ! both - bork
       write( log_scratch_space, '(A)' )  'quadrature OR mass matrix required for solver not both. Whats a guy to do?, stopping'
       call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    else
       ! neither - bork
       write( log_scratch_space, '(A)' )  'quadrature OR mass matrix required for solver. Gimme something to work with, stopping'
       call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine solver_algorithm

!> @brief BiCGStab solver with no preconditioning.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! the stabilised bi-conjugate gradient method. The choice of matrix is
!! encoded in the matrix vector kernel that is called
!! @param[in]  rhs_field Input b
!! @param[inout] lhs_field The answer, x
!! @param[in] mm operator type, Mass matrix
!! @param[in] mesh Id of the mesh object the model for fields#
!! @param[in] precond_option Choice of preconditioner
!! @param[in] mmd (optional) Mass matrix diagonal
  subroutine bicg_solver_algorithm(lhs, rhs, mm, mesh, precond_option, mmd)
    implicit none
    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(inout) :: mm
    integer(i_def),      intent(in)    :: mesh
    type(field_type),    intent(in), optional :: mmd
    integer(i_def),      intent(in)    :: precond_option

    type(function_space_type), pointer :: rhs_fs => null()

    ! The temporary fields
    type(field_type)                   :: res, p, v, s, t, z, y

    ! the scalars
    ! the greeks - standard BiCGStab
    real(kind=r_def)                   :: rho,alpha,omega,beta, norm
    real(kind=r_def)                   :: ts,tt
    ! others
    real(kind=r_def)                   :: err,sc_err, init_err
    integer(i_def)                     :: iter

    ! compute the residual this is a global sum to the PSy ---
    call invoke_inner_prod(rhs,rhs,sc_err)
    sc_err = max(sqrt(sc_err), sc_err_min)
    write( log_scratch_space, '(A,E15.8)' ) &
         "solver_algorithm: bicgstab starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    alpha  = 1.0_r_def
    omega  = 1.0_r_def
    norm   = 1.0_r_def

    rhs_fs => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                rhs%which_function_space() )

    v   = field_type( vector_space = rhs_fs )
    z   = field_type( vector_space = rhs_fs )
    p   = field_type( vector_space = rhs_fs )
    t   = field_type( vector_space = rhs_fs )
    s   = field_type( vector_space = rhs_fs )
    y   = field_type( vector_space = rhs_fs )
    res = field_type( vector_space = rhs_fs )

    call invoke( set_field_scalar(0.0_r_def, lhs), &
                 copy_field(rhs, res) )

    call invoke_inner_prod(res,res,err)
    err = sqrt(err)/sc_err
    init_err=err
    if (err < tolerance) then
      write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)') &
          trim(fs_name(rhs_fs%which()))//                 &
          "-space solver_algorithm:converged in ", 0,     &
          " iters, init=", init_err,                      &
          " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      return
   end if

    call invoke( set_field_scalar(0.0_r_def, v), & 
                 set_field_scalar(0.0_r_def, p) )

    do iter = 1, maximum_iterations

      call invoke_inner_prod(res,rhs,rho)
      beta = (rho/norm) * (alpha/omega)
      ! p = r + beta*(p - omega*v)
      call invoke_axpy(beta,p,res,p)
      call invoke_axpy((-beta*omega),v,p,p)
      call precondition( y, p, precond_option, diagonal=mmd )
      call invoke( set_field_scalar(0.0_r_def, v) )
      call invoke( matrix_vector_kernel_type(v, y, mm) )

      call invoke_inner_prod(rhs,v,norm)
      alpha = rho/norm
      call invoke_axpy(-alpha,v,res,s)
      call precondition( z, s, precond_option, diagonal=mmd )
      call invoke( set_field_scalar(0.0_r_def, t) )
      call invoke( matrix_vector_kernel_type(t, z, mm) )

      call invoke_inner_prod(t,t,tt)
      call invoke_inner_prod(t,s,ts)

      omega = ts/tt

      ! lhs = lhs + omega * z + alpha * y
      call invoke_axpy(omega,z,lhs,lhs)
      call invoke_axpy(alpha,y,lhs,lhs)
      call invoke_axpy(-omega,t,s,res)
      norm = rho

      ! Check for convergence
      call invoke_inner_prod(res, res, err)
      err = sqrt(err)/sc_err

      write( log_scratch_space, '(A,I2,A, E15.8)' ) "solver_algorithm[", iter, &
                                                    "]: res = ", err
      call log_event(log_scratch_space, LOG_LEVEL_TRACE)

      if (err < tolerance) then
        write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)' ) &
            trim(fs_name(rhs_fs%which()))//                  &
            "-space solver_algorithm:converged in ", iter,   &
            " iters, init=", init_err,                       &
            " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if(iter >= maximum_iterations) then
      write(log_scratch_space, '(A, I3, A, E15.8)') &
           "solver_algorithm: NOT converged in", iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine bicg_solver_algorithm
!--------------------------------------------------

!> @brief CG solver for the system A.x = b with no preconditioning.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! the conjugate gradient method. The choice of matrix is
!! encoded in the matrix vector kernel that is called.
!! @param[in] rhs_field Input b
!! @param[inout] lhs_field The answer, x
!! @param[in] mm Mass matrix
!! @param[in] mesh Id of mesh object the model for fields
!! @param[in] precond_option Choice of preconditioner
!! @param[in] mmd Mass matrix diagonal
  subroutine cg_solver_algorithm(lhs, rhs, mm, mesh, precond_option, mmd)
    implicit none
    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(inout) :: mm
    integer(i_def),      intent(in)    :: mesh
    integer(i_def),      intent(in)    :: precond_option
    type(field_type),    intent(in), optional :: mmd

    type(function_space_type), pointer :: rhs_fs => null()

    ! The temporary fields
    type(field_type)                   :: res, p, Ap, z

    ! The scalars
    real(kind=r_def)                   :: alpha, beta
    real(kind=r_def)                   :: rs_new, rs_old
    ! Others
    real(kind=r_def)                   :: err,sc_err, init_err
    integer(i_def)                     :: iter

    call invoke_inner_prod( rhs, rhs, rs_old )

    ! compute the residual this is a global sum to the PSy ---

    rhs_fs => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                rhs%which_function_space() )

    res = field_type(vector_space = rhs_fs )
    p   = field_type(vector_space = rhs_fs )
    Ap  = field_type(vector_space = rhs_fs )
    z   = field_type(vector_space = rhs_fs )

    if ( present(mmd) ) then
    ! First guess: lhs = rhs/diag(M)
      call invoke_divide_field(rhs,mmd,lhs)
    else
    ! First guess: lhs = 0
      call invoke( set_field_scalar(0.0_r_def, lhs) )
    end if
    call invoke( matrix_vector_kernel_type(Ap, lhs, mm) )

    call invoke_minus_field_data( rhs, Ap, res )
    call precondition( z, res, precond_option, diagonal=mmd )
    call invoke( copy_field(z, p) )

    call invoke_inner_prod( res, z, rs_old )
    err = sqrt(rs_old)
    sc_err = max(err, sc_err_min)
    init_err=sc_err
    write( log_scratch_space, '(A,E15.8)' ) &
         "cg solver_algorithm: starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    if (err < tolerance) then
      write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
           "cg solver_algorithm:converged in ", 0,              &
           " iters, init=", init_err,                           &
           " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if

    do iter = 1, maximum_iterations
       call invoke( set_field_scalar(0.0_r_def, Ap) )
       call invoke( matrix_vector_kernel_type(Ap, p, mm) )

      call invoke_inner_prod( p, Ap, rs_new )
      alpha = rs_old/rs_new

      call invoke_axpy( alpha, p, lhs, lhs )
      call invoke_axpy( -alpha, Ap, res, res )

      ! Check for convergence
      call invoke_inner_prod(res,res,rs_new)
      err = sqrt(rs_new)/sc_err

      write( log_scratch_space, '(A, I2, A, E15.8)' ) &
           "cg solver_algorithm[", iter, "]: res = ", err
      call log_event( log_scratch_space, LOG_LEVEL_TRACE )
      if (err < tolerance) then
        write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)' )  &
            trim(fs_name(rhs_fs%which()))//                   &
            "-space cg solver_algorithm:converged in ", iter, &
            " iters, init=", init_err,                        &
            " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if

      call precondition( z, res, precond_option, diagonal=mmd )
      call invoke_inner_prod(z,res,rs_new)
      beta = rs_new/rs_old
      rs_old = rs_new
      call invoke_axpy(beta,p,z,p)

    end do

    if(iter >= maximum_iterations) then
      write( log_scratch_space, '(A, I3, A, E15.8)' ) &
           "cg solver_algorithm: NOT converged in", iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine cg_solver_algorithm

!--------------------------------------------------

!> @brief Jacobi solver for the system A.x = b.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! a fixed (n_iter) number of iterations. The choice of matrix is
!! encoded in the matrix vector kernel that is called. No measure of convergence
!! is used instead the algorithm is assumed to have converged sufficiently
!! after (n_iter) iterations
!! @param[in] rhs_field Input b
!! @param[inout] lhs_field The answer, x
!! @param[in] mm Mass matrix
!! @param[in] mesh Id of mesh object the model for fields
!! @param[in] n_iter Number of Jacobi iterations to perform
  subroutine jacobi_solver_algorithm(lhs, rhs, mm, mesh, n_iter)

  use mm_diagonal_kernel_mod, only: mm_diagonal_kernel_type
  implicit none

  integer(i_def),      intent(in)    :: n_iter
  type(field_type),    intent(inout) :: lhs, rhs
  type(operator_type), intent(inout) :: mm
  integer(i_def),      intent(in)    :: mesh
  type(field_type)                   :: Ax, diagonal, res

  real(kind=r_def), parameter :: MU = 0.9_r_def

  integer(i_def) :: iter

  type(function_space_type), pointer :: rhs_fs => null()

  rhs_fs => function_space_collection%get_fs( mesh, &
                                              element_order, &
                                              rhs%which_function_space() )

  diagonal = field_type( vector_space = rhs_fs )
  res      = field_type( vector_space = rhs_fs )

  call invoke( mm_diagonal_kernel_type(diagonal, mm) )
  call invoke_divide_field( rhs, diagonal, lhs )

! Initial guess
  call invoke( set_field_scalar(0.0_r_def, lhs) )

  do iter = 1,n_iter
    call invoke( set_field_scalar(0.0_r_def, Ax) )
    call invoke( matrix_vector_kernel_type(Ax, lhs, mm) )

    call invoke_minus_field_data( rhs, Ax, res )
    call invoke_divide_field( res, diagonal, res )
    call invoke_axpy( MU, res, lhs, lhs )

! Ready for next iteration
  end do

  end subroutine jacobi_solver_algorithm

!--------------------------------------------------

!> @brief GMRes solver for the system A.x = b.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! GMRes algorithm. The choice of matrix is
!! encoded in the matrix vector kernel that is called. No measure of convergence
!! is used instead the algorithm is assumed to have converged sufficiently
!! after (n_iter) iterations
!! @param[in] rhs Input b
!! @param[inout] lhs Answer, x
!! @param[inout] mm Mass matrix
!! @param[in] mesh Id of  mesh object the model for fields
!! @param[in] precond_option Choice of preconditioner
!! @param[in] pstcond_option Choice of postconditioner
!! @param[in] mmd (optional) Diagonal mass matrix used for conditioning
  subroutine gmres_solver_algorithm(lhs, rhs, mm, mesh, &
                                    precond_option, pstcond_option, mmd)

    implicit none
    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(inout) :: mm
    integer(i_def),      intent(in)    :: mesh
    integer(i_def),      intent(in)    :: precond_option, pstcond_option
    type(field_type),    intent(in), optional :: mmd
    ! The temporary fields
    type(field_type)                   :: Ax, r, s, w, v(GCRK)

    ! The scalars
    real(kind=r_def)                   :: h(GCRK+1, GCRK), u(GCRK), g(GCRK+1)
    real(kind=r_def)                   :: beta, si, ci, nrm, h1, h2, p, q
    ! Others
    real(kind=r_def)                   :: err, sc_err, init_err
    integer(i_def)                     :: iter, i, j, k, m

    type(function_space_type), pointer :: rhs_fs => null()


    rhs_fs => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                rhs%which_function_space() )

    Ax = field_type(vector_space = rhs_fs)
    r  = field_type(vector_space = rhs_fs)
    s  = field_type(vector_space = rhs_fs)
    w  = field_type(vector_space = rhs_fs)

    do iter = 1,GCRK
      v(iter) = field_type(vector_space = rhs_fs)
    end do

    call invoke_inner_prod( rhs, rhs, err )
    sc_err = max( sqrt(err), sc_err_min )
    init_err = sc_err

    if (err < tolerance) then
      write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
           "gmres solver_algorithm:converged in ", 0,           &
           " iters, init=", init_err,                           &
           " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if
    call invoke( set_field_scalar(0.0_r_def, Ax) )
    call invoke( matrix_vector_kernel_type(Ax, lhs, mm) )

    call invoke_minus_field_data( rhs, Ax, r )

    call precondition( s, r, precond_option, diagonal=mmd )

    call invoke_inner_prod( s, s, err )
    beta = sqrt(err)

    call invoke_copy_scaled_field_data( 1.0_r_def/beta, s, v(1) )


    h(:,:) = 0.0_r_def
    g(:)   = 0.0_r_def
    g(1)   = beta

    do iter = 1, maximum_iterations

      do j = 1, GCRk

        call precondition( w, v(j), pstcond_option, diagonal=mmd )
        call invoke( set_field_scalar(0.0_r_def, s) )
        call invoke( matrix_vector_kernel_type(s, w, mm) )

        call precondition( w, s, precond_option, diagonal=mmd )

        do k = 1, j
          call invoke_inner_prod( v(k), w, h(k,j)  )
          call invoke_axpy( -h(k,j), v(k), w, w )
        end do
        call invoke_inner_prod( w, w, err  )
        h(j+1,j) = sqrt( err )
        if( j < GCRk ) then
          call invoke_copy_scaled_field_data(1.0_r_def/h(j+1,j), w, v(j+1))
        end if
      end do

! Solve (7.23) of Wesseling (see Saad's book)
      do m = 1, GCRK
        nrm    = sqrt( h(m,m)*h(m,m) + h(m+1,m)*h(m+1,m) )
        si     = h(m+1,m)/nrm
        ci     = h(m,m)/nrm
        p      = ci*g(m) + si*g(m+1)
        q      = -si*g(m) + ci*g(m+1)
        g(m)   = p
        g(m+1) = q
        do j = m, GCRK
          h1       = ci*h(m,j)   + si*h(m+1,j)
          h2       =-si*h(m,j)   + ci*h(m+1,j)
          h(m,j)   = h1
          h(m+1,j) = h2
        end do
      end do

      u(GCRK) = g(GCRK)/h(GCRK,GCRK)
      do i = GCRK-1, 1, -1
        u(i) = g(i)
        do j = i+1, GCRK
          u(i) = u(i) - h(i,j)*u(j)
        end do
        u(i) = u(i)/h(i,i)
      end do

      do i = 1, GCRK
        call precondition( s, v(i), pstcond_option, diagonal=mmd )
        call invoke_axpy( u(i), s, lhs, lhs )
      end do

! Check for convergence
      call invoke( set_field_scalar(0.0_r_def, Ax) )
      call invoke( matrix_vector_kernel_type(Ax, lhs, mm) )
      call invoke_minus_field_data( rhs, Ax, r )

      call invoke_inner_prod(r, r, err )
      beta = sqrt(err)

      err = beta/sc_err
      if( err <  tolerance ) then
        write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
             "GMRES solver_algorithm:converged in ", iter,        &
             " iters, init=", init_err,                           &
             " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if

      call precondition( s, r, precond_option, diagonal=mmd )
      call invoke_copy_scaled_field_data(1.0_r_def/beta, s, v(1))

      g(:) = 0.0_r_def
      g(1) = beta

    end do

    if( iter >= maximum_iterations .and. err >  tolerance ) then
      write( log_scratch_space, '(A, I3, A, E15.8)') &
           "GMRES solver_algorithm: NOT converged in", iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine gmres_solver_algorithm

!--------------------------------------------------

!> @brief GCR solver for the system A.x = b.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! the Preconditioned GCR(k) algorithm from Wesseling. The choice of matrix is
!! encoded in the matrix vector kernel that is called. No measure of convergence
!! is used instead the algorithm is assumed to have converged sufficiently
!! after (n_iter) iterations
!! @param[in] rhs_field Input b
!! @param[inout] lhs_field Answer, x
!! @param[inout] mm Mass matrix
!! @param[in] mesh Id mesh object the model for fields
!! @param[in] precond_option Choice of preconditioner
!! @param[in] mmd (optional) Mass matrix diagonal
  subroutine gcr_solver_algorithm( lhs, rhs, mm, mesh , precond_option, mmd )

    implicit none

    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(inout) :: mm
    integer(i_def),      intent(in)    :: mesh
    type(field_type),    intent(in), optional :: mmd
    integer(i_def),      intent(in)    :: precond_option

    ! The temporary fields
    type(field_type)                   :: Ax, r, s(GCRK), v(GCRK)

    ! The scalars
    real(kind=r_def)                   :: alpha
    ! Others
    real(kind=r_def)                   :: err, sc_err, init_err
    integer(i_def)                     :: iter, m, n

    type(function_space_type), pointer :: rhs_fs => null()

    rhs_fs => function_space_collection%get_fs( mesh, &
                                                element_order, &
                                                rhs%which_function_space() )

    Ax = field_type(vector_space = rhs_fs)
    r  = field_type(vector_space = rhs_fs)

    do iter = 1,GCRK
      s(iter)  = field_type (vector_space = rhs_fs)
      v(iter)  = field_type (vector_space = rhs_fs)
    end do
    call invoke_inner_prod( rhs, rhs, err )
    sc_err = max( sqrt(err), sc_err_min )
    init_err = sc_err

    if (err < tolerance) then
      write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
           "gcr solver_algorithm:converged in ", 0,             &
           " iters, init=", init_err,                           &
           " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if
    call invoke( set_field_scalar(0.0_r_def, Ax) )
    call invoke( matrix_vector_kernel_type(Ax, lhs, mm) )

    call invoke_minus_field_data( rhs, Ax, r )

    do iter = 1, maximum_iterations
      do m = 1, GCRk
! This is the correct settings -> call Precon(s(:,:,m),r,prit,prec)
        call precondition( s(m), r, precond_option, diagonal=mmd )
        call invoke( set_field_scalar(0.0_r_def, v(m)) )
        call invoke( matrix_vector_kernel_type(v(m), s(m), mm) )


        do n = 1, m-1
          call invoke_inner_prod( v(m), v(n), alpha )
          call invoke_axpy( -alpha, v(n), v(m), v(m))
          call invoke_axpy( -alpha, s(n), s(m), s(m))
        end do
        call invoke_inner_prod( v(m), v(m), err )
        alpha = sqrt(err)
        call invoke_copy_scaled_field_data( 1.0_r_def/alpha, v(m), v(m) )
        call invoke_copy_scaled_field_data( 1.0_r_def/alpha, s(m), s(m) )

        call invoke_inner_prod( r, v(m), alpha )
        call invoke_axpy( alpha, s(m), lhs, lhs )
        call invoke_axpy( -alpha, v(m), r, r )
      end do

      call invoke_inner_prod( r, r, err )
      err = sqrt( err )/sc_err
      if ( err <  tolerance ) then
        write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)' )   &
            trim(fs_name(rhs_fs%which()))//                    &
            "-space GCR solver_algorithm:converged in ", iter, &
            " iters, init=", init_err,                         &
            " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if( iter >= maximum_iterations .and. err >  tolerance ) then
      write( log_scratch_space, '(A, I3, A, E15.8)' ) &
           "GCR solver_algorithm: NOT converged in", iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

end subroutine gcr_solver_algorithm


!> @brief Applies a selected prconditioner to a vector x
!! @details Applies one of s number of preconditioners to a field x
!! and returns the preconditioned field y. Currently no preconditioner
!! is applied and y = x.
!! @param[in]    x Input field
!! @param[inout] y Output field
!! @param[in] preconditioner Type of preconditioner to be used
!! routine to use
  subroutine precondition(y, x, preconditioner, diagonal)

    use psykal_lite_mod, only: invoke_divide_field

    implicit none

    type(field_type), intent(inout) :: y
    type(field_type), intent(in)    :: x
    integer(i_def),   intent(in)    :: preconditioner
    type(field_type), intent(in), optional :: diagonal

    select case ( preconditioner )
      case ( solver_preconditioner_diagonal )
        if ( present(diagonal) ) then
          call invoke_divide_field(x, diagonal, y)
        else
          call log_event( 'No mass matrix diagonal present', LOG_LEVEL_ERROR )
        end if
      case default ! Do nothing
        call invoke( copy_field(x, y) )
    end select

  end subroutine precondition

end module solver_mod
