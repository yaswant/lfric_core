!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the lhs of the prognostic
!>       equations
module lhs_alg_mod

  use constants_mod,                     only: r_def
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use field_bundle_mod,                  only: clone_bundle
  use field_mod,                         only: field_type
  use finite_element_config_mod,         only: element_order
  use function_space_mod,                only: function_space_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use pert_pressure_gradient_kernel_mod, only: pert_pressure_gradient_kernel_type
  use psykal_lite_mod,                   only: invoke_axpy,               &
                                               invoke_copy_field_data,    &
                                               invoke_multiply_field,     &
                                               invoke_sample_flux_kernel, &
                                               invoke_set_field_scalar
  use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
  use mesh_mod,                          only: mesh_type
  use multiplicity_kernel_mod,           only: multiplicity_kernel_type
  use operator_mod,                      only: operator_type
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use runtime_constants_mod,             only: runtime_constants_type
  use w3_solver_kernel_mod,              only: w3_solver_kernel_type

  implicit none

  private
  public :: lhs_alg

contains
!>@details A wrapper for computing the lhs of the prognostic
!>         equations by choosing certain terms to approximate the 
!>         Jacobian, namely:
!>         \f[
!>         \mathbf{L_u} = \mathbf{u}' 
!>                      + \alpha\Delta t Cp\left( \theta^*\nabla\Pi' 
!>                                                +\theta'\nabla\Pi^*\right)
!>         \f]
!>         \f[ L_\rho = \rho' 
!>                    + \alpha\Delta t\nabla.\left(\rho^*\mathbf{u}'\right) \f]
!>         \f[ L_\theta = \theta' + \alpha\Delta t\mathbf{u}'.\nabla\theta^*\f]
!>
!>         Where primed terms are increments to the n+1 timelevel field and
!>         star terms are a reference profile
!> @param[inout] lhs The state vector to compute
!> @param[in]    alpha_dt The offcentring parameter times the timestep
!> @param[inout] state The current model prognostic state
!> @param[in]    runtime_constants Runtime constants for the model
!> @param[in]    l_newton_krylov true if computing timelevel n+1 terms 
  subroutine lhs_alg(lhs, alpha_dt, state, ref_state, runtime_constants)

  implicit none

  real(kind=r_def),             intent(in)    :: alpha_dt
  ! Form of state and lhs is [u,theta,rho] & [lhs_u,lhs_theta,lhs_rho]
  type(field_type), target,     intent(inout) :: state(3)
  type(field_type), target,     intent(in)    :: ref_state(3)
  type(field_type),             intent(inout) :: lhs(3)
  type(runtime_constants_type), intent(in)    :: runtime_constants

  type(quadrature_type)     :: qr
  type(function_space_type) :: fs

  type(field_type), pointer :: chi(:)=> null()
  type(operator_type), pointer :: mm_w2, mm_w0, mm_w3_inv => null()
  type(operator_type), pointer :: div => null()
  type(mesh_type),           pointer :: mesh   => null()
  type(function_space_type), pointer :: rho_fs => null()
  type(function_space_type), pointer :: u_fs   => null()

  type(field_type), pointer :: u ,theta, rho, u_ref, theta_ref, rho_ref
  type(field_type)          :: ones, f_star, w2_multiplicity, r_rho



  type(field_type)          :: lhs_tmp(3)

  mesh         => runtime_constants%get_mesh()
  mm_w0        => runtime_constants%get_mass_matrix(0)
  mm_w2        => runtime_constants%get_mass_matrix(2)
  mm_w3_inv    => runtime_constants%get_mass_matrix(4)
  chi          => runtime_constants%get_coordinates()
  div          => runtime_constants%get_div()

  u     => state(1)
  theta => state(2)
  rho   => state(3)

  u_ref     => ref_state(1)
  theta_ref => ref_state(2)
  rho_ref   => ref_state(3)

  call clone_bundle(lhs, lhs_tmp, 3)

  qr = quadrature_type(element_order+2, GAUSSIAN)

  ! Compute lhs_u
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(1) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(1) )
  call invoke( pert_pressure_gradient_kernel_type(  &
                 lhs_tmp(1), rho, rho_ref, theta, theta_ref, qr ), &
               matrix_vector_kernel_type( lhs(1), u, mm_w2) )
  call invoke( enforce_bc_kernel_type( lhs_tmp(1) ) )
  call invoke_axpy( alpha_dt, lhs_tmp(1), lhs(1), lhs(1) ) 
 
  rho_fs => fs%get_instance (mesh,element_order,rho%which_function_space() )
  u_fs   => fs%get_instance (mesh,element_order,u%which_function_space()   )

  qr = quadrature_type(element_order+1, GAUSSIAN)

  ! Compute lhs_theta
  ones = field_type( vector_space = rho_fs )
  call invoke_set_field_scalar( 1.0_r_def, ones )
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(2) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(2) )
  call invoke( rtheta_kernel_type( lhs_tmp(2), theta_ref, u, ones, qr), & 
               matrix_vector_kernel_type( lhs(2), theta, mm_w0) )
  call invoke_axpy( alpha_dt, lhs_tmp(2), lhs(2), lhs(2) ) 

  ! Compute lhs_rho
  ! Need to create u*rho^ref \in W2 for lhs_tmp(3) kernel -> sampled mass flux
  w2_multiplicity = field_type( vector_space = u_fs )
  call invoke_set_field_scalar( 0.0_r_def, w2_multiplicity )
  call invoke ( multiplicity_kernel_type( w2_multiplicity ) )

  f_star = field_type( vector_space = u_fs )
  call invoke_set_field_scalar( 0.0_r_def, f_star )
  call invoke_sample_flux_kernel( f_star, u, w2_multiplicity, rho_ref )

  r_rho = field_type( vector_space = rho_fs )
  call invoke_set_field_scalar( 0.0_r_def, r_rho )
  call invoke( matrix_vector_kernel_type( r_rho, f_star, div) )
  call invoke_multiply_field(-1.0_r_def, r_rho, r_rho) 
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(3) )
  call invoke( matrix_vector_kernel_type( lhs_tmp(3), r_rho, mm_w3_inv) )
  call invoke_axpy( alpha_dt, lhs_tmp(3), rho, lhs(3) )

  end subroutine lhs_alg

end module lhs_alg_mod


