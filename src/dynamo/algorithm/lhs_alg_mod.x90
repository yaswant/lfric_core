!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the lhs of the prognostic
!>       equations
module lhs_alg_mod

  use constants_mod,                     only: r_def, i_def
  use function_space_collection_mod,     only: function_space_collection
  use runtime_constants_mod,             only: get_coordinates, &
                                               get_div, &
                                               get_mass_matrix
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type

  implicit none

  type(field_type),              private      :: ones, w2_multiplicity, f_star, r_rho
  type(field_type), allocatable, private      :: lhs_tmp(:)
  type(function_space_type), pointer, private :: u_fs => null()

  private
  public  :: lhs_alg
  public  :: lhs_init
  private :: on_the_fly_lhs_alg
  private :: operator_lhs_alg
contains

!>@brief Initialise fields to be used for computing the lhs
  subroutine lhs_init(state)
    use field_bundle_mod,          only: clone_bundle
    use finite_element_config_mod, only: element_order
    use psykal_lite_mod,           only: invoke_set_field_scalar
    use mesh_mod,                  only: mesh_type
    use multiplicity_kernel_mod,   only: multiplicity_kernel_type
    use derived_config_mod,        only: si_bundle_size

    implicit none

    type(field_type), intent(in) :: state(si_bundle_size)

    type(function_space_type), pointer :: rho_fs => null()
    integer(i_def),                    :: mesh_id
    integer                            :: fs_handle

    allocate( lhs_tmp(si_bundle_size) )
    call clone_bundle(state, lhs_tmp, si_bundle_size)

    ! Get the mesh for all lhs fields
    mesh_id = state(3)%get_mesh_id()

    ! For computing lhs_theta
    fs_handle = state(3)%which_function_space()
    rho_fs => function_space_collection%get_fs(mesh_id, element_order, fs_handle)
    ones = field_type( vector_space = rho_fs )
    call invoke_set_field_scalar( 1.0_r_def, ones )
    r_rho = field_type( vector_space = rho_fs )

    ! for computing lhs rho
    fs_handle = state(1)%which_function_space()
    u_fs => function_space_collection%get_fs(mesh_id, element_order, fs_handle)
    w2_multiplicity = field_type( vector_space = u_fs )
    call invoke_set_field_scalar( 0.0_r_def, w2_multiplicity )
    call invoke ( multiplicity_kernel_type( w2_multiplicity ) )
    f_star = field_type( vector_space = u_fs )

  end subroutine lhs_init
  !============================================================================!
!>@details A wrapper for computing the lhs of the prognostic
!>         equations by choosing certain terms to approximate the 
!>         Jacobian, namely:
!>         \f[
!>         \mathbf{L_u} = \mathbf{u}' 
!>                      + \alpha\Delta t Cp\left( \theta^*\nabla\Pi' 
!>                                                +\theta'\nabla\Pi^*\right)
!>         \f]
!>         \f[ L_\rho = \rho' 
!>                    + \alpha\Delta t\nabla.\left(\rho^*\mathbf{u}'\right) \f]
!>         \f[ L_\theta = \theta' + \alpha\Delta t\mathbf{u}'.\nabla\theta^*\f]
!>
!>         Where primed terms are increments to the n+1 timelevel field and
!>         star terms are a reference profile
!> @param[inout] lhs State vector to compute
!> @param[in]    tau_dt Relaxation parameter times the timestep
!> @param[inout] state Current model prognostic state
!> @param[in] ref_state Reference state of the model fields
  subroutine lhs_alg(lhs, state, ref_state, tau_dt)
  use derived_config_mod, only: si_bundle_size, bundle_size
  use solver_config_mod,  only: use_operators

  implicit none
  ! Form of state and lhs is [u,theta,rho,exner]
  type(field_type),                  intent(inout) :: lhs(si_bundle_size)
  type(field_type),                  intent(inout) :: state(si_bundle_size)

  type(field_type),        optional, intent(in)    :: ref_state(bundle_size)
  real(kind=r_def),                  intent(in)    :: tau_dt

  if ( use_operators ) then
    call operator_lhs_alg(lhs, state, tau_dt)
  else
    call on_the_fly_lhs_alg(lhs, state, ref_state, tau_dt)
  end if

  end subroutine lhs_alg
  !============================================================================!
  !>@brief Apply LHS terms with operators computed on the fly
  subroutine on_the_fly_lhs_alg(lhs, state, ref_state, tau_dt)
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use formulation_config_mod,            only: eliminate_p
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use rtheta_wtheta_kernel_mod,          only: rtheta_wtheta_kernel_type
  use pert_pressure_gradient_kernel_mod, only: pert_pressure_gradient_kernel_type
  use exner_gradient_kernel_mod,         only: exner_gradient_kernel_type
  use psykal_lite_mod,                   only: invoke_axpy,               &
                                               invoke_copy_field_data,    &
                                               invoke_multiply_field,     &
                                               invoke_sample_flux_kernel, &
                                               invoke_set_field_scalar,   &
                                               invoke_rtheta_bd_kernel,   &
                                               invoke_exner_gradient_bd_kernel, &
                                               invoke_pert_pressure_gradient_bd_kernel
  use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
  use operator_mod,                      only: operator_type
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use evaluator_xyz_mod,                 only: evaluator_xyz_type
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use w3_solver_kernel_mod,              only: w3_solver_kernel_type
  use derived_config_mod,                only: si_bundle_size, bundle_size
  use lhs_exner_kernel_mod,              only: lhs_exner_kernel_type
  use finite_element_config_mod,         only: element_order, wtheta_on

  implicit none

  real(kind=r_def),             intent(in)    :: tau_dt
  ! Form of state and lhs is [u,theta,rho,exner]
  type(field_type), target,     intent(inout) :: state(si_bundle_size)
  type(field_type), target,     intent(in)    :: ref_state(bundle_size)
  type(field_type),             intent(inout) :: lhs(si_bundle_size)

  type(quadrature_type)        :: qr
  type(field_type),    pointer :: chi(:)=> null()
  type(operator_type), pointer :: mm_w2, mm_w3_inv, mm_wtheta => null()
  type(operator_type), pointer :: div => null()
  type(field_type),    pointer :: u ,theta, rho, exner, theta_ref, rho_ref => null()
  type(evaluator_xyz_type)     :: evaluator

  mm_w2        => get_mass_matrix(2)
  mm_w3_inv    => get_mass_matrix(4)
  if(wtheta_on) then
    mm_wtheta  => get_mass_matrix(5)
  else
    mm_wtheta  => get_mass_matrix(0)
  end if
  chi          => get_coordinates()
  div          => get_div()

  u     => state(1)
  theta => state(2)
  rho   => state(3)

  theta_ref => ref_state(2)
  rho_ref   => ref_state(3)

  qr = quadrature_type(element_order+2, GAUSSIAN)

  ! Compute lhs_u
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(1) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(1) )
  if ( eliminate_p ) then
    if(wtheta_on) then
      call invoke_pert_pressure_gradient_bd_kernel( lhs_tmp(1), rho, rho_ref, &
                                                    theta, theta_ref, qr )
    end if
    call invoke( pert_pressure_gradient_kernel_type(  &
                   lhs_tmp(1), rho, rho_ref, theta, theta_ref, qr ), &
                 matrix_vector_kernel_type( lhs(1), u, mm_w2) )
  else 
    ! Use r_rho as a zero field so that exner' = 0 in pert_pressure_gradient_kernel
    call invoke_set_field_scalar( 0.0_r_def, r_rho )
    exner => state(4)

    if(wtheta_on) then
      call invoke_exner_gradient_bd_kernel( lhs_tmp(1), exner, theta_ref, qr )
      call invoke_pert_pressure_gradient_bd_kernel( lhs_tmp(1), r_rho, rho_ref, &
                                                     theta, theta_ref, qr )
    end if
    call invoke( exner_gradient_kernel_type( lhs_tmp(1), exner, theta_ref, qr ), &
                 pert_pressure_gradient_kernel_type( lhs_tmp(1), r_rho, rho_ref, &
                                                     theta, theta_ref, qr ), &
                 matrix_vector_kernel_type( lhs(1), u, mm_w2) )

  end if
  call invoke( enforce_bc_kernel_type( lhs_tmp(1) ) )
  call invoke_axpy( -tau_dt, lhs_tmp(1), lhs(1), lhs(1) ) 
 

  qr = quadrature_type(element_order+1, GAUSSIAN)
  evaluator = evaluator_xyz_type( u_fs%get_ndf( ), u_fs%get_nodes( ) )

  ! Compute lhs_theta
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(2) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(2) )
  if(wtheta_on) then
    call invoke_rtheta_bd_kernel ( lhs_tmp(2), theta_ref, u, ones, qr )
    call invoke( rtheta_wtheta_kernel_type( lhs_tmp(2), theta_ref, u, qr) )
  else
    call invoke( rtheta_kernel_type( lhs_tmp(2), theta_ref, u, ones, qr) )
  end if
  call invoke( matrix_vector_kernel_type( lhs(2), theta, mm_wtheta ) )

  call invoke_axpy( -tau_dt, lhs_tmp(2), lhs(2), lhs(2) ) 

  ! Compute lhs_rho
  ! Need to create u*rho^ref \in W2 for lhs_tmp(3) kernel -> sampled mass flux
  call invoke_set_field_scalar( 0.0_r_def, f_star )
  call invoke_sample_flux_kernel( f_star, u, w2_multiplicity, rho_ref, evaluator )
  call invoke_set_field_scalar( 0.0_r_def, r_rho )
  call invoke( matrix_vector_kernel_type( r_rho, f_star, div) )
  call invoke_multiply_field(-1.0_r_def, r_rho, r_rho) 
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(3) )
  call invoke( matrix_vector_kernel_type( lhs_tmp(3), r_rho, mm_w3_inv) )
  call invoke_axpy( -tau_dt, lhs_tmp(3), rho, lhs(3) )

  ! Compute lhs exner
  if ( .not. eliminate_p ) then
    exner => state(4)
    call invoke_set_field_scalar( 0.0_r_def, lhs(4) )
    call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(4) )
    call invoke( lhs_exner_kernel_type(lhs_tmp(4), theta, rho, exner, &
                                       theta_ref, rho_ref, chi, qr ) )
    call invoke( matrix_vector_kernel_type( lhs(4), lhs_tmp(4), mm_w3_inv) )

  end if

  end subroutine on_the_fly_lhs_alg

  !============================================================================!
  !>@brief Apply LHS terms with precomputed operators
  subroutine operator_lhs_alg(lhs, state, tau_dt)

  use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
  use operator_mod,                       only: operator_type
  use derived_config_mod,                 only: si_bundle_size
  use finite_element_config_mod,          only: wtheta_on
  use psykal_lite_mod,                    only: invoke_multiply_field_data, &
                                                invoke_inc_axpy, &
                                                invoke_inc_axpby, &
                                                invoke_set_field_scalar
  use si_operators_alg_mod,               only: get_p2theta, &
                                                get_div_star, &
                                                get_ptheta2, &
                                                get_m3_rho_star, &
                                                get_m3_exner_star, &
                                                get_p3theta, &
                                                get_rho_at_u
  use planet_config_mod,                  only: cp, kappa
  use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type

  implicit none

  ! Form of state and lhs is [u,theta,rho,exner]
  type(field_type), target,        intent(inout) :: state(si_bundle_size)
  type(field_type),                intent(inout) :: lhs(si_bundle_size)
  real(kind=r_def),                intent(in)    :: tau_dt

  type(operator_type), pointer :: mm_w2, mm_w3_inv, mm_wtheta => null()
  type(operator_type), pointer :: div => null()
  type(field_type),    pointer :: u ,theta, rho, exner => null()
  type(operator_type), pointer :: p2theta, div_star, ptheta2, m3_rho_star, &
                                  m3_exner_star, p3theta => null()
  type(field_type),    pointer :: rho_at_u => null()
  
  mm_w2        => get_mass_matrix(2)
  mm_w3_inv    => get_mass_matrix(4)
  if(wtheta_on) then
    mm_wtheta  => get_mass_matrix(5)
  else
    mm_wtheta  => get_mass_matrix(0)
  end if
  div          => get_div()

  u     => state(1)
  theta => state(2)
  rho   => state(3)
  exner => state(4)

  p2theta       => get_p2theta()
  div_star      => get_div_star()
  ptheta2       => get_ptheta2()
  m3_rho_star   => get_m3_rho_star()
  m3_exner_star => get_m3_exner_star()
  p3theta       => get_p3theta()
  rho_at_u      => get_rho_at_u()

  ! Use operators
  ! L_u
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(1) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(1) )
  call invoke( matrix_vector_kernel_type(lhs(1), theta, p2theta) )
  call invoke( transpose_matrix_vector_kernel_type(lhs(1), exner, div_star) )
  call invoke( enforce_bc_kernel_type( lhs(1) ) )
  call invoke( matrix_vector_kernel_type(lhs_tmp(1), u, mm_w2) )
  call invoke_inc_axpy(-tau_dt*cp, lhs(1), lhs_tmp(1))
  ! L_theta
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(2) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(2) )
  call invoke( matrix_vector_kernel_type(lhs(2), u, ptheta2) )
  call invoke( matrix_vector_kernel_type(lhs_tmp(2), theta, mm_wtheta) )
  call invoke_inc_axpy(tau_dt, lhs(2), lhs_tmp(2))  
  ! L_rho
  call invoke_multiply_field_data(rho_at_u, u, f_star)
  call invoke( dg_matrix_vector_kernel_type(lhs_tmp(3), f_star, div) )
  call invoke( dg_matrix_vector_kernel_type(lhs(3), lhs_tmp(3), mm_w3_inv) )
  call invoke_inc_axpy(tau_dt, lhs(3), rho)  
  ! L_pi 
  call invoke( dg_matrix_vector_kernel_type(lhs(4), rho, m3_rho_star) )
  call invoke( matrix_vector_kernel_type(lhs(4), theta, p3theta) )
  call invoke( dg_matrix_vector_kernel_type(lhs_tmp(4), exner, m3_exner_star))
  call invoke_inc_axpby(((1.0_r_def-kappa)/kappa), lhs_tmp(4), -1.0_r_def, lhs(4))
  call invoke( dg_matrix_vector_kernel_type( lhs(4), lhs_tmp(4), mm_w3_inv) )

  end subroutine operator_lhs_alg
  !============================================================================!

end module lhs_alg_mod


