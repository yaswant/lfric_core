!-------------------------------------------------------------------------------
! (C) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the non-linear 3D equations,
!>       currently using 3-stage SSP.
!>@details An algorithm for timestepping the 3D nonlinear linear
!>         equations using a multistage explicit Runge-Kutta algorithm.
module rk_alg_timestep_mod

  use constants_mod,                     only: i_def,r_def
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE

  ! Configuration options
  use finite_element_config_mod, only: element_order, wtheta_on
  use formulation_config_mod,    only: rotating
  use solver_config_mod,         only: method, preconditioner
  use runge_kutta_init_mod,      only: num_rk_stage, ak
  use timestepping_config_mod,   only: dt, alpha, beta, &
                                       outer_iterations, inner_iterations
  use idealised_config_mod,      only: test, idealised_test_held_suarez
  use derived_config_mod,        only: bundle_size
  use runtime_constants_mod,     only: get_geopotential, &
                                       get_mass_matrix, &
                                       get_mass_matrix_diagonal, &
                                       get_qr

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_copy_field_data,  &
                                               invoke_set_field_scalar, &
                                               invoke_ru_bd_kernel
  use field_bundle_mod,                  only: clone_bundle, &
                                               bundle_axpy, & 
                                               bundle_axpby, &
                                               add_bundle, &
                                               copy_bundle, &
                                               set_bundle_scalar

  ! PsyKAl PSYClone kernels
  use held_suarez_kernel_mod,              only: held_suarez_kernel_type
  use enforce_bc_kernel_mod,               only: enforce_bc_kernel_type
  use rotation_kernel_mod,                 only: rotation_kernel_type
  use pressure_gradient_kernel_mod,        only: pressure_gradient_kernel_type
  use pressure_gradient_wtheta_kernel_mod, only: pressure_gradient_wtheta_kernel_type
  use kinetic_energy_gradient_kernel_mod,  only: kinetic_energy_gradient_kernel_type
  use geopotential_gradient_kernel_mod,    only: geopotential_gradient_kernel_type

  ! Derived Types
  use function_space_collection_mod,     only: function_space_collection
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use quadrature_mod,                    only: quadrature_type
  use operator_mod,                      only: operator_type

  ! Algorithms
  use solver_mod,                        only: solver_algorithm
  use conservation_algorithm_mod,        only: conservation_algorithm
  use rhs_alg_mod,                       only: rhs_alg
  use advection_alg_mod,                 only: advection_alg
  use si_solver_alg_mod,                 only: si_solver_alg, si_solver_init



  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type ), allocatable :: state(:), state_n(:), rhs(:), inc(:)
  type( field_type ), allocatable :: rhs_prediction(:,:)

  public :: rk_alg_init
  public :: rk_alg_step

contains

  !> @details Initialisation procedure for the rk timestepping algorithm
  !>          Initialises various internal fields
  !> @param[in]    mesh_id Id of mesh object on which the model runs
  !> @param[inout] u 3D wind field
  !> @param[inout] rho Density
  !> @param[inout] theta Potential temperature

  subroutine rk_alg_init( mesh_id, u, rho, theta)
    implicit none

    ! Mesh
    integer(i_def), intent(in)          :: mesh_id 

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta


    type(function_space_type), pointer :: theta_fs => null()
    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()


    ! Timestepping variables
    integer :: stage

    !=== Allocate internal state field arrays ================================!

    allocate(state(bundle_size))   
    allocate(state_n(bundle_size))
    allocate(rhs(bundle_size))
    allocate(inc(bundle_size))

    allocate ( rhs_prediction(bundle_size,num_rk_stage) )

    !=== Initialise internal state field objects =============================!

    theta_fs => function_space_collection%get_fs( mesh_id, &
                                                  element_order, &
                                                  theta%which_function_space() )
    u_fs     => function_space_collection%get_fs( mesh_id, &
                                                  element_order, &
                                                  u%which_function_space()     )
    rho_fs   => function_space_collection%get_fs( mesh_id, &
                                                  element_order, &
                                                  rho%which_function_space()   )


    state(1) = field_type( vector_space = u_fs     )
    state(2) = field_type( vector_space = theta_fs )
    state(3) = field_type( vector_space = rho_fs   )

    call clone_bundle(state, state_n, 3)
    call clone_bundle(state, rhs, 3)
    call clone_bundle(state, inc, 3)

    do stage = 1,num_rk_stage
      call clone_bundle(state, rhs_prediction(:,stage), 3) 
    end do


    !=== Copy prognostic field data to state arrays ===========================!
    call invoke_copy_field_data(u,     state(1))
    call invoke_copy_field_data(theta, state(2))
    call invoke_copy_field_data(rho,   state(3))

    call log_event( "Dynamo: initialised timestepping algorithm", LOG_LEVEL_INFO )

  end subroutine rk_alg_init

  !> @brief A Runge-Kutta time-discretisation of the non-linear 3D equations,
  !>        currently using 3-stage SSP.
  !> @details An algorithm for timstepping the 3D nonlinear
  !>          equations using a Runge-Kutta algortihm. 
  !>          The type of Runge-Kutta scheme can be simply changed by
  !>          modifying the (currently hardwired) Butcher tableau (ak array)
  !>          The current set up uses the 3rd-order three stage
  !>          Strong-Stability-Preserving (SSP3) method
  !> @param[in]    mesh_id Id of mesh object on which the model runs
  !> @param[inout] chi  Finite element form of the coordinates
  !> @param[inout] u 3D wind field
  !> @param[inout] rho Density
  !> @param[inout] theta Potential temperature
  !> @param[inout] xi Vorticity field  

  subroutine rk_alg_step(mesh_id, chi, u, rho, theta, xi)

    integer(i_def), intent(in)          :: mesh_id
    ! Coordinate fields
    type( field_type ), intent( inout ) :: chi(3)

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta, xi

    ! the quadrature object
    type( quadrature_type )    :: qr

    ! Temporary items
    type( field_type )    :: diagnostic_field

    ! temps for retrieving things from runtime_constants
    type(operator_type)                :: mm_w0, mm_w2, mm_wtheta
    type(field_type)                   :: mm_diagonal_w0, mm_diagonal_w2, mm_diagonal_wtheta
    type(field_type)                   :: geopotential

    integer(i_def) :: st, stage

    qr = get_qr()

    ! Get geopotential field from runtime_constants
    geopotential = get_geopotential()

    ! Get mm operators from runtime_constants 
    mm_w0 = get_mass_matrix(0)
    mm_w2 = get_mass_matrix(2)
    mm_wtheta = get_mass_matrix(5)
    ! Get mmd fields from runtime_constants

    mm_diagonal_w0 = get_mass_matrix_diagonal(0)
    mm_diagonal_w2 = get_mass_matrix_diagonal(2)
    mm_diagonal_wtheta = get_mass_matrix_diagonal(4)

    !=== Do a single timestep ==============================================!

    ! Runge-Kutta algorithm
    call copy_bundle(state, state_n, 3)
    do stage = 1,num_rk_stage
      write( log_scratch_space, '(A,I0)' ) '  Start of stage ', stage
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      ! Compute advection terms
      call advection_alg( rhs_prediction(:,stage), &
                          state, state, state_n, xi)
      ! Compute new rhs
      if ( rotating ) &
        call invoke( rotation_kernel_type( rhs_prediction(1,stage), state(1), chi, qr ) )
        if( wtheta_on ) then
          call invoke (pressure_gradient_wtheta_kernel_type ( rhs_prediction(1, stage), state(3), state(2), qr ))
          call invoke_ru_bd_kernel ( rhs_prediction(1, stage), state(3), state(2), qr )
        else
          call invoke( pressure_gradient_kernel_type       &
             ( rhs_prediction(1,stage), state(3), state(2), qr ) )
        end if

        call invoke( kinetic_energy_gradient_kernel_type &
             ( rhs_prediction(1,stage), state(1), chi, qr ) )
        call invoke( geopotential_gradient_kernel_type   &
             ( rhs_prediction(1,stage), geopotential, qr ) )
        call invoke( enforce_bc_kernel_type( rhs_prediction(1,stage) ) ) 
        call set_bundle_scalar(0.0_r_def, rhs, 3)

      do st = 1, stage
        call bundle_axpy(ak(stage,st), rhs_prediction(:,stage), rhs, rhs, 3)
      end do

      ! Invert mass matrices
      if( wtheta_on ) then
        call solver_algorithm( inc(2), rhs(2),       &
                               mesh_id, chi, method, mm=mm_wtheta,&
                               mmd=mm_diagonal_wtheta, &
                               preconditioner_choice=preconditioner )
      else
        call solver_algorithm( inc(2), rhs(2),       &
                               mesh_id, chi, method, mm=mm_w0,&
                               mmd=mm_diagonal_w0, &
                               preconditioner_choice=preconditioner )
      end if
      call solver_algorithm( inc(1), rhs(1),       &
                             mesh_id,, chi, method, mm=mm_w2, &
                             mmd=mm_diagonal_w2, & 
                             preconditioner_choice=preconditioner )
      call invoke_copy_field_data(rhs(3),inc(3))

      ! Add increments
      call bundle_axpy(dt, inc, state_n, state, 3)

      ! Diagnostics
      diagnostic_field = inc(2)
      call diagnostic_field%log_minmax(LOG_LEVEL_TRACE, 'theta_inc');
      diagnostic_field = inc(1)
      call diagnostic_field%log_minmax(LOG_LEVEL_TRACE, 'u_inc');
      diagnostic_field = inc(3)
      call diagnostic_field%log_minmax(LOG_LEVEL_TRACE, 'rho_inc');

    end do


    ! Return fields in u, theta, rho arrays
    call invoke_copy_field_data(state(1), u)
    call invoke_copy_field_data(state(2), theta)
    call invoke_copy_field_data(state(3), rho)


  end subroutine rk_alg_step

end module rk_alg_timestep_mod
