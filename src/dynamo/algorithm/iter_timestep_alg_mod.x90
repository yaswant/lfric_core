!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A two time-level iterative time-discretisation of the nonlinear 
!>       3D equations
module iter_timestep_alg_mod

  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE
  use constants_mod,                     only: r_def    

  ! Configuration and restart/checkpoint options                                                      
  use configuration_mod,                 only: solver_option, dt, &
                                               l_newton_krylov,   &
                                               ALPHA, BETA,       &
                                               N_OUTER_ITER, N_INNER_ITER, &
                                               element_order
  use restart_control_mod,               only: restart_type

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_axpby,                  &
                                               invoke_plus_field_data,        &
                                               invoke_minus_field_data,       &
                                               invoke_copy_field_data,        &
                                               invoke_set_field_scalar
  use field_bundle_mod,                  only: clone_bundle, & 
                                               bundle_axpy, & 
                                               bundle_axpby, &
                                               add_bundle, &
                                               copy_bundle

  ! PsyKAl PSYClone kernels
  use initial_u_kernel_mod,              only: initial_u_kernel_type
  use compute_mass_matrix_kernel_w0_mod, only: compute_mass_matrix_kernel_w0_type
  use compute_mass_matrix_kernel_w1_mod, only: compute_mass_matrix_kernel_w1_type
  use compute_mass_matrix_kernel_w2_mod, only: compute_mass_matrix_kernel_w2_type
  use compute_geopotential_kernel_mod,   only: compute_geopotential_kernel_type
  use mm_diagonal_kernel_mod,            only: mm_diagonal_kernel_type

  ! Derived Types
  use mesh_mod,                          only: mesh_type
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type, W0, W1, W2, W3
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use operator_mod,                      only: operator_type
  use runtime_constants_mod,             only: runtime_constants_type

  ! Algorithms
  use solver_mod,                        only: solver_algorithm
  use conservation_algorithm_mod,        only: conservation_algorithm
  use rhs_alg_mod,                       only: rhs_alg
  use advection_alg_mod,                 only: advection_alg
  use output_alg_mod,                    only: output_alg
  use si_solver_alg_mod,                 only: si_solver_alg

  implicit none

  private
  public :: iter_timestep_alg

contains
  !> @details An algorithm for timstepping the 3D nonlinear equations
  !>         using a iterative process of the same form as endgame.
  !>         Initialialises all fields, sets up tempoary fields, performs the
  !>         timestepping and checks to see if it should dump output.
  !>         The algorithm splits all processes into one of three parts.
  !>         Old time level forcings computed once per timestep.
  !>         Advection terms computed in an outer loop using time-averaged
  !>         fields.
  !>         New time level forcings computed in an inner loop.
  !>         To match ENDGame 2 outer and 2 inner loops are used per timestep
  !>         by default. This means that there is one evaluation of old time
  !>         level terms, 2 evaluation of advective terms and 4 evaluations 
  !>         of new time level terms and increment updates per timestep
  !> @param[in]    mesh Mesh object on which the model runs
  !> @param[inout] chi  The finite element form of the coordinates
  !> @param[inout] u  The 3D wind field
  !> @param[inout] rho The density
  !> @param[inout] theta The potential temperature
  !> @param[inout] xi The vorticity field 
  !> @param[in] restart Checkpoint/restart type with timestepping information
  subroutine iter_timestep_alg( mesh, chi, u, rho, theta, xi, &
       restart)

    implicit none

    ! Mesh
    type (mesh_type), intent(in) :: mesh 
    ! Coordinate fields
    type( field_type ), intent( inout ) :: chi(3)
    ! Prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta, xi
    ! Restart for timestep control and diagnostic output control
    type( restart_type ), intent(in)    :: restart

    ! Temporary fields    
    type( field_type ) :: geopotential, r_u
    type( field_type ) :: state_n(3), state_np1(3), state_adv(3)
    type( field_type ) :: rhs_n(3), rhs_np1(3), rhs_adv(3)
    type( field_type ) :: mm_diagonal_w3, &
                          mm_diagonal_w2, &
                          mm_diagonal_w1, &
                          mm_diagonal_w0,
    
    type( runtime_constants_type ) :: runtime_constants

    integer :: theta_fs, u_fs, rho_fs, xi_fs

    type( function_space_type )      :: fs
    type( quadrature_type )          :: qr
    type( operator_type )            :: mm_w2, mm_w1, mm_w0

    ! Iterative timestepping variables
    integer            :: timestep, ts_init
    integer            :: outer, inner

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    theta_fs  = theta%which_function_space()
    u_fs      = u%which_function_space()
    rho_fs    = rho%which_function_space()
    xi_fs     = xi%which_function_space()

    qr = quadrature_type(element_order+3, GAUSSIAN)

    ! Create field bundles
    state_np1(1) = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    state_np1(2) = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    state_np1(3) = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    call clone_bundle(state_np1, state_adv, mesh, 3)
    call clone_bundle(state_np1, state_n,   mesh, 3)
    call clone_bundle(state_np1, rhs_n,     mesh, 3)
    call clone_bundle(state_np1, rhs_np1,   mesh, 3)
    call clone_bundle(state_np1, rhs_adv,   mesh, 3)
    
    ! Create W2 field needed for u initialisation
    r_u = field_type( vector_space = fs%get_instance(mesh, u_fs) )

    ! Create W0 fields needed for timestepping
    geopotential = field_type( vector_space = fs%get_instance(mesh, theta_fs) )

    ! Create operators needed for timestepping
    mm_w0 = operator_type(fs%get_instance(mesh, W0),fs%get_instance(mesh, W0))
    mm_w1 = operator_type(fs%get_instance(mesh, W1),fs%get_instance(mesh, W1))
    mm_w2 = operator_type(fs%get_instance(mesh, W2),fs%get_instance(mesh, W2))

    !=== Section 2: Initialise local algorithm fields ========================!
    call log_event( "Dynamo: computing Semi-Implicit algorithm fields", &
                     LOG_LEVEL_INFO )
    ! Compute geopotential
    call invoke( compute_geopotential_kernel_type( geopotential, chi ) )
    ! Compute mass matrices
    call invoke( compute_mass_matrix_kernel_w0_type(mm_w0, chi, qr), &
                 compute_mass_matrix_kernel_w1_type(mm_w1, chi, qr), &
                 compute_mass_matrix_kernel_w2_type(mm_w2, chi, qr) )

    ! Compute mass matrix diagonals
    mm_diagonal_w0 = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    mm_diagonal_w1 = field_type( vector_space = fs%get_instance(mesh, xi_fs) )
    mm_diagonal_w2 = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    mm_diagonal_w3 = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    call invoke_set_field_scalar(0.0_r_def,mm_diagonal_w0)
    call invoke_set_field_scalar(0.0_r_def,mm_diagonal_w1)
    call invoke_set_field_scalar(0.0_r_def,mm_diagonal_w2)

    call invoke( mm_diagonal_kernel_type(mm_diagonal_w0,mm_w0))
    call invoke( mm_diagonal_kernel_type(mm_diagonal_w1,mm_w1))
    call invoke( mm_diagonal_kernel_type(mm_diagonal_w2,mm_w2))
    ! W3 equations are solved pointwise and so the mass matrix is inverted
    ! exactly, therfore the diagonal, where used should be 1
    call invoke_set_field_scalar(1.0_r_def,mm_diagonal_w3)

    ! Create fixed state container
    runtime_constants = runtime_constants_type(mesh, chi, geopotential, &
                                               mm_w0, mm_w1, mm_w2, &
                                               mm_diagonal_w0, &
                                               mm_diagonal_w1, &
                                               mm_diagonal_w2, &
                                               mm_diagonal_w3)
    ! Prognostics
    if(.not.restart%read_file()) then ! no check point to start from
      call invoke_set_field_scalar(0.0_r_def, u)
      call invoke_set_field_scalar(0.0_r_def, r_u) 
      call invoke( initial_u_kernel_type( r_u, chi, qr ) )
      call solver_algorithm(u, r_u, mesh, chi, solver_option, mm=mm_w2)
    end if

    !--- Intial output and output frequency -----------------------------------! 
    ! Output initial conditions
    call log_event( "Dynamo: Outputing initial fields", LOG_LEVEL_INFO )
    ts_init = max( (restart%ts_start() - 1), 0 ) ! 0 or t previous.
    call output_alg(ts_init, restart, theta, u, rho, chi, mesh, mm_w0)
    call conservation_algorithm(ts_init, mesh, rho, u, theta, xi, &
                                geopotential, chi)

    !=== Section 3: Timestepping ==============================================!
    call invoke_copy_field_data(u,     state_np1(1))
    call invoke_copy_field_data(theta, state_np1(2))
    call invoke_copy_field_data(rho,   state_np1(3))

    do timestep = restart%ts_start(),restart%ts_end()
       call log_event( &
       "/****************************************************************************\ ", &
            LOG_LEVEL_TRACE )
       write( log_scratch_space, '(A,I0)' ) 'Start of timestep ', timestep
       call log_event( log_scratch_space, LOG_LEVEL_INFO )
       ! Time level n fields
       call copy_bundle(state_np1, state_n, 3)
       call rhs_alg(rhs_n, BETA*dt, state_n, runtime_constants, .false.)
       !=== Section 3.1:  Outer (advection loop) ==============================!
       do outer = 1,N_OUTER_ITER
          ! Set advecting velocity & terms
          call bundle_axpby(ALPHA, state_np1, BETA, state_n, state_adv, 3)
          call advection_alg(rhs_adv, state_adv, state_np1, state_n,  &
               xi, runtime_constants)
          !=== Section 3.2: Inner (nonlinear, coriolis loop) ===================!
          do inner = 1,N_INNER_ITER
             call rhs_alg(rhs_np1, -ALPHA*dt, state_np1, runtime_constants, .false.)
             
             ! === Section 3.3: Solve for increments ============================!
             ! Add on advective terms: rhs = rhs_n - rhs_np1 + rhs_adv
             ! (reuse rhs_np1 for rhs)
             call bundle_axpy(-1.0_r_def, rhs_np1, rhs_n, rhs_np1, 3)
             call add_bundle(rhs_np1, rhs_adv, rhs_np1, 3)
             
             write( log_scratch_space, '(A,I6,2I3)' ) &
                  'loop indices (n, o, i): ', timestep, outer, inner
             call log_event( log_scratch_space, LOG_LEVEL_INFO )
             call si_solver_alg(state_np1, rhs_np1, state_n, runtime_constants)
             !=== End Section 3.3 ===============================================!         
          end do
          !=== End Section 3.2 =================================================!
       end do
       !=== End Section 3.1 ===================================================!
       !=== Section 3.4: End of timestep diagnostics ==========================!
       if ( mod(timestep, (restart%ts_start()+restart%diag_freq() - 1) ) == 0 ) then
         call output_alg(timestep, restart, state_np1(2), state_np1(1), &
                         state_np1(3), chi, mesh, mm_w0)
       end if
       call conservation_algorithm(timestep, mesh, state_np1(3), state_np1(1), &
         state_np1(2), xi, geopotential, chi)
       
       write( log_scratch_space, '(A,I0)' ) 'End of timestep ', timestep
       call log_event( log_scratch_space, LOG_LEVEL_TRACE )
       call log_event( &
       '\****************************************************************************/ ', &
            LOG_LEVEL_TRACE )
       !=== End of Section 3.4 ================================================!
    end do

    ! Return fields in u, theta, rho arrays
    call invoke_copy_field_data(state_np1(1), u)
    call invoke_copy_field_data(state_np1(2), theta)
    call invoke_copy_field_data(state_np1(3), rho)

    call log_event( "Dynamo: Finished timestep", LOG_LEVEL_INFO )
    !=== End Section 3.0 ======================================================!
  end subroutine iter_timestep_alg

end module iter_timestep_alg_mod
