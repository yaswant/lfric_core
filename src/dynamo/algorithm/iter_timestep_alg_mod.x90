!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A two time-level iterative time-discretisation of the nonlinear 
!>       3D equations
module iter_timestep_alg_mod

  use constants_mod,                     only: i_def,r_def
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE

  ! Configuration options
  use finite_element_config_mod, only: element_order
  use restart_control_mod,       only: restart_type
  use formulation_config_mod,    only: use_moisture
  use output_config_mod,         only: diagnostic_frequency
  use solver_config_mod,         only: method, helmholtz_solve, use_operators
  use timestepping_config_mod,   only: dt, alpha, &
                                       outer_iterations, inner_iterations, &
                                       spinup_period, spinup_alpha, spinup_winds
  use idealised_config_mod,      only: test, idealised_test_held_suarez
  use derived_config_mod,        only: bundle_size
  use runtime_constants_mod,     only: get_geopotential, &
                                       get_mass_matrix, &
                                       get_mass_matrix_diagonal, &
                                       get_qr

  ! PsyKAl-lite kernels
use psykal_lite_mod,                   only: invoke_axpby, &
                                             invoke_viscosity



  use field_bundle_mod,                  only: clone_bundle, & 
                                               bundle_axpy, & 
                                               bundle_axpby, &
                                               add_bundle, &
                                               copy_bundle, &
                                               set_bundle_scalar, &
                                               bundle_ax 

  ! PsyKAl PSYClone kernels
  use held_suarez_kernel_mod,            only: held_suarez_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type

  ! Derived Types
  use function_space_collection_mod,     only: function_space_collection
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use quadrature_mod,                    only: quadrature_type

  ! Algorithms
  use solver_mod,                        only: solver_algorithm
  use rhs_alg_mod,                       only: rhs_alg
  use advection_alg_mod,                 only: advection_alg, advection_alg_init, advection_mr_alg
  use si_solver_alg_mod,                 only: si_solver_alg, si_solver_init
  use si_operators_alg_mod,              only: create_si_operators, compute_si_operators
  use helmholtz_solver_alg_mod,          only: helmholtz_solver_init, &
                                               compute_inv_hb

  ! Moisture species
  use mr_indices_mod,                    only: nummr

  ! Mixing settings
  use mixing_config_mod,                 only: viscosity
  implicit none

  private

  ! 'State' items private to the algorithm that need to be 
  !  created once but used every step
  type( field_type ), allocatable :: state(:), state_n(:)
  type( field_type ), allocatable :: rhs_n(:), rhs_np1(:), rhs_adv(:)
  type( field_type ), allocatable :: rhs_heldsuarez(:), inc(:)
  type( field_type ) :: u_adv   ! Advective wind (centered in time)


  public :: iter_alg_init
  public :: iter_alg_step

contains
  !> @details Initialisation procedure for the timestepping algorithm
  !>         Initialises various internal fields
  !> @param[in]    mesh_id Mesh id of the mesh object on which the model runs
  !> @param[inout] u  3D wind field
  !> @param[inout] rho Density
  !> @param[inout] theta Potential temperature


  subroutine iter_alg_init( mesh_id, u, rho, theta)

    implicit none

    ! Mesh
    integer(i_def), intent(in) :: mesh_id 


    ! Prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta

    type(function_space_type), pointer :: theta_fs => null()
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: u_fs     => null()


    !=== Allocate internal state field arrays ================================!

    allocate(state(bundle_size))
    allocate(state_n(bundle_size))
    allocate(rhs_n(bundle_size))
    allocate(rhs_np1(bundle_size))
    allocate(rhs_adv(bundle_size))
    allocate(rhs_heldsuarez(bundle_size))
    allocate(inc(bundle_size))


    !=== Initialise internal state field objects =============================!

    theta_fs => function_space_collection%get_fs ( mesh_id, element_order        &
                                                 ,theta%which_function_space() )
    u_fs     => function_space_collection%get_fs ( mesh_id, element_order        &
                                                 ,u%which_function_space()     )
    rho_fs   => function_space_collection%get_fs ( mesh_id, element_order        &
                                                 ,rho%which_function_space()   )

    state(1) = field_type( vector_space = u_fs     )
    state(2) = field_type( vector_space = theta_fs )
    state(3) = field_type( vector_space = rho_fs   )

    call clone_bundle(state, state_n,   bundle_size)
    call clone_bundle(state, rhs_n,     bundle_size)
    call clone_bundle(state, rhs_np1,   bundle_size)
    call clone_bundle(state, rhs_adv,   bundle_size)
    call clone_bundle(state, rhs_heldsuarez,   bundle_size)
    call clone_bundle(state, inc,       bundle_size)

    ! If held-suarez forcing is not used, then we want the following to be 
    ! initialized to zero
    call set_bundle_scalar(0.0_r_def, rhs_heldsuarez, bundle_size)

    ! Operators for si solves
    if ( helmholtz_solve ) call helmholtz_solver_init(state)
    if ( helmholtz_solve .or. use_operators ) call create_si_operators(mesh_id)

    !=== Copy prognostic field data to state arrays ===========================!
    call invoke( copy_field(u,     state(1)), &
                 copy_field(theta, state(2)), &
                 copy_field(rho,   state(3)) )
    !=== Initialise fields ====================================================!
    call si_solver_init(state)
    call advection_alg_init(mesh_id)

    u_adv = field_type( vector_space = u_fs ) 

    call log_event( "Dynamo: initialised timestepping algorithm", LOG_LEVEL_INFO )


  end subroutine iter_alg_init

  !> @details An algorithm for timestepping the 3D nonlinear equations
  !>         using a iterative process of the same form as endgame.
  !>         The algorithm splits all processes into one of three parts.
  !>         Old time level forcings computed once per timestep.
  !>         Advection terms computed in an outer loop using time-averaged
  !>         fields.
  !>         New time level forcings computed in an inner loop.
  !>         To match ENDGame 2 outer and 2 inner loops are used per timestep
  !>         by default. This means that there is one evaluation of old time
  !>         level terms, 2 evaluation of advective terms and 4 evaluations 
  !>         of new time level terms and increment updates per timestep
  !> @param[inout] chi  Finite element form of the coordinates
  !> @param[inout] u  3D wind field
  !> @param[inout] rho Density
  !> @param[inout] theta Potential temperature
  !> @param[inout] xi Vorticity field

  subroutine iter_alg_step(chi, u, rho, theta, mr, xi, timestep)

    implicit none


    ! Coordinate fields
    type( field_type ), intent( inout ) :: chi(3)

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta, xi
    type( field_type ), intent( inout ) :: mr(nummr)

    ! Timestep value
    integer, intent(in) :: timestep  

    ! quadrature object
    type(quadrature_type)       :: qr

    integer            :: outer, inner
    real(kind=r_def)   :: varalpha, varbeta ! alpha, beta weight to use
                                            ! these may differ from input values
                                            ! during the spinup period

    qr = get_qr()

    !Pass updated fields into state
    if (spinup_winds .and. timestep <= spinup_period)then
      call invoke( copy_field(u,     state(1)), &
                   copy_field(theta, state(2)), &
                   copy_field(rho,   state(3)) )
    end if

    if (spinup_alpha .and. timestep <= spinup_period)then
      varalpha = alpha + (spinup_period - timestep + 1) * & 
         (1.0 - alpha)/spinup_period
    else
      varalpha = alpha
    end if
    varbeta=1.0 - varalpha

    !=== Do a single timestep ==============================================!
    call copy_bundle(state, state_n, bundle_size)
    if ( helmholtz_solve .or. use_operators ) call compute_si_operators(state_n)
    if ( helmholtz_solve ) call compute_inv_hb()
    call rhs_alg(rhs_n, varbeta*dt, state_n)
    !=== Section 3.1:  Outer (advection loop) ==============================!
    do outer = 1,outer_iterations
      ! Some idealized (fast) physics terms
      if ( test == idealised_test_held_suarez) then
        call set_bundle_scalar(0.0_r_def, rhs_heldsuarez, 3)
        call invoke(held_suarez_kernel_type(rhs_heldsuarez(1), rhs_heldsuarez(2), &
                    state_n(1), state_n(2), state_n(3), chi, qr))
        call invoke( enforce_bc_kernel_type(rhs_heldsuarez(1)) )
      end if

      ! Set advecting velocity & terms
      call invoke_axpby(varalpha, state_n(1), varbeta, state(1), u_adv)
      call advection_alg(rhs_adv, state_n, xi, u_adv)
      if ( use_moisture ) call advection_mr_alg(mr, u_adv)
      call bundle_ax(dt, rhs_adv, rhs_adv, bundle_size) 
      !=== Section 3.2: Inner (nonlinear, coriolis loop) ===================!
      do inner = 1,inner_iterations
        call rhs_alg(rhs_np1, -varalpha*dt, state)

        ! === Section 3.3: Solve for increments ============================!
        ! Add on advective terms: rhs = rhs_n - rhs_np1 + rhs_adv
        ! (reuse rhs_np1 for rhs)

        call bundle_axpy(-1.0_r_def, rhs_np1, rhs_n, rhs_np1, bundle_size)
        call add_bundle(rhs_np1, rhs_adv, rhs_np1, bundle_size)
        call add_bundle(rhs_np1, rhs_heldsuarez, rhs_np1, bundle_size)
             
        write( log_scratch_space, '(A,2I3)' ) 'loop indices (o, i): ', &
                                                  , outer, inner
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        call si_solver_alg(state, rhs_np1, state_n)
        !=== End Section 3.3 ===============================================!
      end do ! INNER
      !=== End Section 3.2 =================================================!
    end do ! OUTER
    !=== End Section 3.1 ===================================================!
    ! Apply viscosity
    if ( viscosity ) then
      call log_event( 'Applying Viscosity', LOG_LEVEL_INFO )      
      call invoke_viscosity(inc(2), theta, inc(1), u, chi)
      call invoke( set_field_scalar(0.0_r_def, inc(3)) )
      call bundle_axpy(dt, inc, state, state, 3)
    end if    
    
    ! Return fields in u, theta, rho arrays
    ! The if statement prevents this update if spinup_winds is true
    if (.not. (spinup_winds .and. timestep <= spinup_period))then
      call invoke( copy_field(state(1), u) )
    end if

    call invoke( copy_field(state(2), theta), &
                 copy_field(state(3), rho) )

  end subroutine iter_alg_step

end module iter_timestep_alg_mod
