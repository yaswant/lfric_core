!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------
!>@brief Routines for solving the semi-implicit equation set by
!!       eliminating all variables in favour of the exner pressure increment

module helmholtz_solver_alg_mod
  use field_mod,                 only: field_type
  use constants_mod,             only: i_def, r_def
  use si_operators_alg_mod,      only: get_m3_rho_star, &
                                       get_m3_exner_star, &
                                       get_compound_div, &
                                       get_div_star, &
                                       get_ptheta2, &
                                       get_p2theta, &
                                       get_mt_lumped, &
                                       get_p3theta, &
                                       get_rho_at_u, &
                                       get_tri_precon, &
                                       get_helm_diag
  use runtime_constants_mod,     only: get_coordinates, &
                                       get_mass_matrix, &
                                       get_mass_matrix_diagonal, &
                                       get_div
  use solver_config_mod,         only: normalise
  use derived_config_mod,        only: si_bundle_size, bundle_size
  implicit none

  private 
  real(kind=r_def),    private, parameter :: tau_u = 0.5_r_def
  real(kind=r_def),    private, parameter :: tau_t = 0.5_r_def
  real(kind=r_def),    private, parameter :: tau_r = 0.5_r_def
  real(kind=r_def),    private, parameter :: sc_err_min = 1.0e-5_r_def
  type(field_type),    private            :: helmholtz_rhs
  type(field_type),    private            :: exner_increment

  ! Temporary fields needed for: 
  ! Fields for bicgstab (all W3)
  type(field_type), private :: res, p, v, s, t, z, y
  ! For building rhs
  type(field_type), private :: r_u, r_p, u_term, rho_at_u, &
                               flux, theta_adv_term, m2_u, mt_r_t
  ! For applying lhs
  type(field_type), private :: grad_p, pi_term
  ! For Back substitute
  type(field_type), private, allocatable :: rhs_inc(:)
  type(field_type), private :: rho_inc, u_inc, theta_inc

  type(field_type) :: hb_inv


  ! Sub algorithms used for solving the helmholtz equation
  public  :: helmholtz_solver_init
  public  :: helmholtz_solver_alg
  private :: apply_variable_helmholtz
  private :: build_helmholtz_rhs
  public  :: compute_inv_hb
  private :: apply_helmholtz_lhs
  private :: bicgstab
  private :: back_substitute 
  private :: helmholtz_precondition
contains
!=============================================================================!
!>@brief Create all the required fields for the Helmholtz solver
  subroutine helmholtz_solver_init(state)
    use function_space_mod,        only: function_space_type
    use finite_element_config_mod, only: element_order
    use field_bundle_mod,          only: clone_bundle
    use function_space_collection_mod,  &
                                   only: function_space_collection
    implicit none
    type(field_type), intent(in)       :: state(bundle_size)
    type(function_space_type), pointer :: w3, w2, wtheta => null()
    integer(kind=i_def)                :: mesh
    integer(kind=i_def)                :: fs_handle

    ! Get needed function spaces
    mesh = state(3)%get_mesh_id()
    fs_handle = state(3)%which_function_space()
    w3 => function_space_collection%get_fs(mesh, element_order, fs_handle)
    fs_handle = state(1)%which_function_space()
    w2 => function_space_collection%get_fs(mesh, element_order, fs_handle)
    fs_handle = state(2)%which_function_space()
    wtheta => function_space_collection%get_fs(mesh, element_order, fs_handle)

    helmholtz_rhs   = field_type(vector_space = w3)
    exner_increment = field_type(vector_space = w3)

    ! For building the rhs
    r_u            = field_type(vector_space = w2)
    r_p            = field_type(vector_space = w3)
    u_term         = field_type(vector_space = w2)
    flux           = field_type(vector_space = w2)
    theta_adv_term = field_type(vector_space = wtheta)
    m2_u           = field_type(vector_space = w2)
    mt_r_t         = field_type(vector_space = wtheta)

    ! Create invert_h_b fields
    hb_inv = field_type(vector_space = w2)

    ! Create bicgstab fields
    v   = field_type( vector_space = w3)
    z   = field_type( vector_space = w3)
    p   = field_type( vector_space = w3)
    t   = field_type( vector_space = w3)
    s   = field_type( vector_space = w3)
    y   = field_type( vector_space = w3)
    res = field_type( vector_space = w3)
    
    ! Apply lhs
    grad_p  = field_type(vector_space = w2)
    pi_term = field_type(vector_space = w3)

    ! Back substitute
    allocate( rhs_inc(bundle_size) )
    call clone_bundle( state, rhs_inc, bundle_size)
    rho_inc   = field_type(vector_space = w3)
    u_inc     = field_type(vector_space = w2)
    theta_inc = field_type(vector_space = wtheta)

  end subroutine helmholtz_solver_init

!=============================================================================!
!>@brief Control routine for the helmholtz solver
!>@details Control routine for the helmholtz solver:
!>         1) Builds the helmholtz rhs 
!>         2) Solves for the presssure increment using a Krylov method
!>         3) Back substitutes to find remaining field increments

  subroutine helmholtz_solver_alg(x0, rhs0)
    implicit none

    type(field_type), intent(inout) :: x0(si_bundle_size)
    type(field_type), intent(in)    :: rhs0(si_bundle_size)

    ! Build Helmholtz RHS
    call build_helmholtz_rhs(helmholtz_rhs, rhs0)

    ! Krylov solver to obtain pressure increment
    call bicgstab(exner_increment, helmholtz_rhs)

    ! Back substitution to obtain other fields
    call back_substitute(x0, exner_increment, rhs0)

  end subroutine helmholtz_solver_alg

!=============================================================================!
!>@brief Apply the H(x) function where x is a field in the velocity space
!>@details Apply H(x) operator which consists of a divergence type term 
!>         and a projection term arising from the continuity and thermodynamic 
!>         equations respectively
  subroutine apply_variable_helmholtz(Hx, x)
    use psykal_lite_mod,             only: invoke_multiply_field_data, &
                                           invoke_divide_field_data,   &
                                           invoke_scale_field_data
    use matrix_vector_kernel_mod,    only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use operator_mod,                only: operator_type

    implicit none
    type(field_type), intent(inout) :: Hx
    type(field_type), intent(in)    :: x
   
    type(operator_type), pointer :: compound_div, ptheta2, p3theta => null()
    type(field_type),    pointer :: mt_diag, rho_at_u => null()

    compound_div => get_compound_div()
    ptheta2      => get_ptheta2()
    mt_diag      => get_mt_lumped()
    p3theta      => get_p3theta()
    rho_at_u     => get_rho_at_u()
 
    call invoke( set_field_scalar(0.0_r_def, theta_adv_term) )
    call invoke_multiply_field_data(rho_at_u, x, flux)
    call invoke( dg_matrix_vector_kernel_type(Hx, flux, compound_div) )
    call invoke_scale_field_data(tau_r,Hx)

    call invoke(matrix_vector_kernel_type(theta_adv_term, x, ptheta2)) 
    call invoke_divide_field_data(theta_adv_term, mt_diag)
    ! Multiply theta_adv_term by tau_theta
    call invoke_scale_field_data(tau_t,theta_adv_term)
    call invoke( matrix_vector_kernel_type(Hx, theta_adv_term, p3theta) )    

  end subroutine apply_variable_helmholtz
!=============================================================================!
!>@brief Compute the rhs to the helmholtz equation for the pressure increment
  subroutine build_helmholtz_rhs(helmholtz_rhs, rhs0)
    use psykal_lite_mod,          only: invoke_divide_field,      &
                                        invoke_divide_field_data, &
                                        invoke_inc_axpy, &
                                        invoke_multiply_field_data, &
                                        invoke_scale_field_data
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use timestepping_config_mod,  only: dt
    use planet_config_mod,        only: cp
    use operator_mod,             only: operator_type
    use enforce_bc_kernel_mod,    only: enforce_bc_kernel_type
    use log_mod,                  only: LOG_LEVEL_DEBUG

    implicit none
    type(field_type),                intent(inout) :: helmholtz_rhs
    type(field_type),                intent(in)    :: rhs0(si_bundle_size)

    type(operator_type), pointer :: m3_rho_star, m3_inv, &
                                    p2theta, p3theta => null()
    type(field_type),    pointer :: mt_diag => null()
    type(field_type),    pointer :: H_diag => null()

    p2theta     => get_p2theta()
    p3theta     => get_p3theta()
    m3_rho_star => get_m3_rho_star()
    mt_diag     => get_mt_lumped()
    m3_inv      => get_mass_matrix(4)
    
    ! r_u = rhs_u + tau*dt*cp*P02*M0^-1*rhs_t       
    call invoke_divide_field(rhs0(2), mt_diag, mt_r_t)
    call invoke( set_field_scalar(0.0_r_def, r_u) )
    call invoke( matrix_vector_kernel_type(r_u, mt_r_t, p2theta) )
    call invoke_inc_axpy(tau_u*dt*cp, r_u, rhs0(1)) 
    ! Compute H_B * u_term = r_u
    call invoke( enforce_bc_kernel_type( r_u ) )
    call invoke_multiply_field_data(r_u, hb_inv, u_term)

    ! Compute H(u_term)
    call apply_variable_helmholtz(helmholtz_rhs, u_term)

    ! r_pi = rhs_pi + P03*M0^-1*rhs_t + M3rho*M3^-1*rhs_r
    ! rhs_pi \equiv 0
    ! r_rho already contains M3^-1 factor
    call invoke( dg_matrix_vector_kernel_type(r_p, rhs0(3), m3_rho_star) )
    call invoke( matrix_vector_kernel_type(r_p, mt_r_t, p3theta) )

    call invoke_inc_axpy(-dt, helmholtz_rhs, r_p)

    if ( normalise ) then 
      H_diag => get_helm_diag()
      call invoke_divide_field_data(helmholtz_rhs, H_diag)
    end if

    call helmholtz_rhs%log_minmax(LOG_LEVEL_DEBUG, 'helmholtz_rhs')

  end subroutine build_helmholtz_rhs

!=============================================================================!
!>@brief Compute the lumped inverse H_B operator
  subroutine compute_inv_hb
    use timestepping_config_mod,       only: dt
    use planet_config_mod,             only: cp
    use psykal_lite_mod,               only: invoke_divide_field_data,     &
                                             invoke_inc_axpy,              &
                                             invoke_raise_field
    use matrix_vector_nobc_kernel_mod, only: matrix_vector_nobc_kernel_type
    use operator_mod,                  only: operator_type
    use enforce_bc_kernel_mod,         only: enforce_bc_kernel_type
    use function_space_mod,            only: function_space_type
    use finite_element_config_mod,     only: element_order
    use function_space_collection_mod, only: function_space_collection

    implicit none
    type(operator_type), pointer                   :: m2, p2theta,         &
                                                      ptheta2 => null()
    type(field_type),    pointer                   :: mt_diag => null()
    real(kind=r_def)                               :: timestep_term
    type(field_type)                               :: ones
    type(function_space_type), pointer             :: w2 => null()
    integer(kind=i_def)                            :: mesh
    integer(kind=i_def)                            :: fs_handle

    ! Get needed function spaces

    timestep_term = cp*tau_u*tau_t*dt**2

    m2 => get_mass_matrix(2)
    p2theta => get_p2theta()
    ptheta2 => get_ptheta2()
    mt_diag => get_mt_lumped()

    mesh = hb_inv%get_mesh_id()
    fs_handle = hb_inv%which_function_space()
    w2 => function_space_collection%get_fs(mesh, element_order, fs_handle)
    ones = field_type( vector_space = w2 )

    call invoke(set_field_scalar(1.0_r_def, ones), &
                set_field_scalar(0.0_r_def, hb_inv), &
                set_field_scalar(0.0_r_def, m2_u), &
                set_field_scalar(0.0_r_def, theta_adv_term) )
    call invoke( matrix_vector_nobc_kernel_type(m2_u, ones, m2), &
                 matrix_vector_nobc_kernel_type(theta_adv_term, ones, ptheta2) )
    call invoke_divide_field_data(theta_adv_term, mt_diag)
    call invoke( matrix_vector_nobc_kernel_type(hb_inv, theta_adv_term, p2theta) )  
    call invoke_inc_axpy( timestep_term, hb_inv, m2_u )
    call invoke_raise_field(hb_inv, -1_i_def)
 
  end subroutine compute_inv_hb

!=============================================================================!
!>@brief Apply the full Helmholtz lhs to a pressure field p, this is the Ax
!>       routine called from the Krylov solver 
  subroutine apply_helmholtz_lhs(Hp, p)
    use timestepping_config_mod,  only: dt
    use planet_config_mod,        only: cp
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod, &
                                  only: dg_matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, &
                                  only: transpose_matrix_vector_kernel_type
    use psykal_lite_mod,          only: invoke_divide_field_data, &
                                        invoke_inc_axpby, &
                                        invoke_multiply_field_data
    use operator_mod,             only: operator_type
    use enforce_bc_kernel_mod,    only: enforce_bc_kernel_type

    implicit none
    type(field_type),                intent(inout) :: Hp
    type(field_type),                intent(in)    :: p

    type(operator_type), pointer :: m3_exner_star, div_star => null()
    real(kind=r_def)             :: timestep_term
    type(field_type),    pointer :: H_diag => null()

    m3_exner_star => get_m3_exner_star()
    div_star      => get_div_star()

    timestep_term = cp*tau_u*dt**2

    ! Initialise fields
    call invoke( set_field_scalar(0.0_r_def, grad_p), &
                 set_field_scalar(0.0_r_def, Hp) )

    ! grad_p = D^{\theta*}*p
    call invoke( transpose_matrix_vector_kernel_type(grad_p, p, div_star) )

    ! Compute H_B * u_term = grad_p
    call invoke( enforce_bc_kernel_type( grad_p ) )   
    call invoke_multiply_field_data(grad_p, hb_inv, u_term)

    ! Compute H(u_term)
    call apply_variable_helmholtz(Hp, u_term )
       
    ! Add (1-k)/k * Pi'
    call invoke( dg_matrix_vector_kernel_type(pi_term, p, m3_exner_star) )    
    call invoke_inc_axpby( timestep_term, Hp, 1.0_r_def, pi_term)

    if ( normalise ) then 
      H_diag => get_helm_diag()
      call invoke_divide_field_data(Hp, H_diag)
    end if

  end subroutine apply_helmholtz_lhs

!=============================================================================!
!>@brief Krylov solver specifically for solving the Helmholtz equation 
  subroutine bicgstab(lhs, rhs)
    use solver_config_mod,     only: maximum_iterations, &
                                     si_pressure_tolerance
    use psykal_lite_mod,       only: invoke_inner_prod, &
                                     invoke_axpy,       &
                                     invoke_inc_axpy,   &
                                     invoke_inc_xpby
    use log_mod,               only: log_event,         &
                                     log_scratch_space, &
                                     LOG_LEVEL_ERROR,   &
                                     LOG_LEVEL_INFO,    &
                                     LOG_LEVEL_DEBUG,   &
                                     LOG_LEVEL_TRACE
    implicit none
    type(field_type),             intent(inout) :: lhs
    type(field_type),             intent(in)    :: rhs

    ! the scalars
    real(kind=r_def)                   :: rho,alpha,omega,beta, norm
    real(kind=r_def)                   :: ts,tt
    ! others
    real(kind=r_def)                   :: err,sc_err, init_err
    integer(kind=i_def)                :: iter
    
    ! compute the residual this is a global sum to the PSy ---
    call invoke_inner_prod(rhs,rhs,sc_err)
    sc_err = max(sqrt(sc_err), sc_err_min)
    write( log_scratch_space, '(A,E15.8)' ) &
         "solver_algorithm: bicgstab starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    alpha  = 1.0_r_def
    omega  = 1.0_r_def
    norm   = 1.0_r_def

    call invoke( set_field_scalar(0.0_r_def, lhs), &
                 copy_field(rhs,res) )

    call invoke_inner_prod(res,res,err)
    err = sqrt(err)/sc_err
    init_err=err
    if (err < si_pressure_tolerance) then
      write( log_scratch_space, '(A,I3,A,E12.4,A,E15.8)') &
           "helmholtz solver_algorithm:converged in ", 0,  &
           " iters, init=", init_err," final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if

    call invoke( set_field_scalar(0.0_r_def, v), &
                 set_field_scalar(0.0_r_def, p) )

    do iter = 1, maximum_iterations

      call invoke_inner_prod(res,rhs,rho)
      beta = (rho/norm) * (alpha/omega)
      ! p = r + beta*(p - omega*v)
      call invoke_inc_axpy(beta, p, res)
      call invoke_inc_xpby(p, -beta*omega, v)
      call helmholtz_precondition( y, p)
      call apply_helmholtz_lhs( v, y)
      
      call invoke_inner_prod(rhs,v,norm)
      alpha = rho/norm
      call invoke_axpy(-alpha,v,res,s)
      call helmholtz_precondition( z, s )
      call apply_helmholtz_lhs( t, z )

      call invoke_inner_prod(t,t,tt)
      call invoke_inner_prod(t,s,ts)

      omega = ts/tt

      ! lhs = lhs + omega * z + alpha * y
      call invoke_inc_xpby(lhs, omega, z)
      call invoke_inc_xpby(lhs, alpha, y)
      call invoke_axpy(-omega,t,s,res)

      norm = rho

      ! check for convergence
      call invoke_inner_prod(res,res,err)
      err = sqrt(err)/sc_err

      write( log_scratch_space, '(A,I3,A,E15.8)' ) &
             "solver_algorithm[", iter, "]: res = ", err
      call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

      if (err < si_pressure_tolerance) then
        write( log_scratch_space, '(A,I3,A,E12.4,A,E15.8)' )      &
             "Helmholtz solver_algorithm:converged in ", iter,    &
             " iters, init=", init_err, " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if(iter >= maximum_iterations) then
      write(log_scratch_space, '(A, I3, A, E15.8)') &
           "Helmholtz solver_algorithm: NOT converged in", iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if
  end subroutine bicgstab

!=============================================================================!
!>@brief Obtain the increments to each field from the pressure field given by
!>       the helmholtz equation
  subroutine back_substitute( state, exner_inc, rhs)
    use log_mod,                     only: LOG_LEVEL_DEBUG,                    &
                                           LOG_LEVEL_INFO
    use timestepping_config_mod,     only: dt
    use planet_config_mod,           only: cp
    use psykal_lite_mod,          only: invoke_inc_axpy,            &
                                        invoke_divide_field,        &
                                        invoke_multiply_field_data, &
                                        invoke_increment_field
    use matrix_vector_kernel_mod,    only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, &
                                     only: transpose_matrix_vector_kernel_type
    use operator_mod,                only: operator_type
    use enforce_bc_kernel_mod,       only: enforce_bc_kernel_type
    use formulation_config_mod,      only: eliminate_p

    implicit none
    type(field_type),                intent(inout) :: state(si_bundle_size)
    type(field_type),                intent(in)    :: exner_inc
    type(field_type),                intent(in)    :: rhs(si_bundle_size)

    type(field_type),    pointer :: mt_diag => null(), rho_at_u => null()
    type(operator_type), pointer :: div_star => null(), ptheta2 => null(), &
                                    div => null(), m3_inv => null()

    ! Need to pass in mathfrak{R}_u
    mt_diag      => get_mt_lumped()
    div_star     => get_div_star()
    ptheta2      => get_ptheta2()
    rho_at_u     => get_rho_at_u()
    div          => get_div()
    m3_inv       => get_mass_matrix(4)

    ! Initialise increment fields
    call invoke( set_field_scalar(0.0_r_def, rhs_inc(1)), &
                 set_field_scalar(0.0_r_def, rhs_inc(2)) )

    ! u increment
    call invoke( transpose_matrix_vector_kernel_type(rhs_inc(1), exner_inc, div_star) )
    call invoke_inc_axpy((tau_u*dt*cp), rhs_inc(1), r_u)
    call invoke( enforce_bc_kernel_type( rhs_inc(1) ) )
    call invoke_multiply_field_data(rhs_inc(1), hb_inv, u_inc)

    ! theta increment
    call invoke( matrix_vector_kernel_type(rhs_inc(2), u_inc, ptheta2) )
    call invoke_inc_axpy(-(tau_t*dt), rhs_inc(2), rhs(2) )  
    call invoke_divide_field(rhs_inc(2), mt_diag, theta_inc)

    ! rho increment
    call invoke_multiply_field_data(rho_at_u, u_inc, flux)
    call invoke( dg_matrix_vector_kernel_type(rhs_inc(3), flux, div) )
    call invoke( dg_matrix_vector_kernel_type(rho_inc, rhs_inc(3), m3_inv) )
    call invoke_inc_axpy( -(tau_r*dt), rho_inc, rhs(3))

    call exner_inc%log_minmax(LOG_LEVEL_DEBUG, 'exner increment ') 
    call u_inc    %log_minmax(LOG_LEVEL_DEBUG, 'u increment     ') 
    call theta_inc%log_minmax(LOG_LEVEL_DEBUG, 'theta increment ') 
    call rho_inc  %log_minmax(LOG_LEVEL_DEBUG, 'rho increment   ') 

    call invoke_increment_field(u_inc,     state(1))
    call invoke_increment_field(theta_inc, state(2))
    call invoke_increment_field(rho_inc,   state(3))
    if ( .not. eliminate_p ) call invoke_increment_field(exner_inc, state(4))
  
  end subroutine back_substitute
!=============================================================================!
!>@brief Preconditioner for the helmholtz equation 
!>@details Options to precondition the helmholtz equation, currently allows only
!>         preconditioning with the inverse mass matrix or no preconditioner
  subroutine helmholtz_precondition( y, x, prec)
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use operator_mod,             only: operator_type 
    use tri_solve_kernel_mod,     only: tri_solve_kernel_type
    use solver_config_mod,        only: si_pressure_preconditioner, &
                                        solver_si_pressure_preconditioner_tridiagonal, & 
                                        solver_si_pressure_preconditioner_diagonal 

    implicit none
    type(field_type),  intent(inout) :: y
    type(field_type),  intent(in)    :: x
    integer, optional, intent(in)    :: prec

    integer                      :: precon
    type(operator_type), pointer :: m3_inv => null()
    type(field_type)             :: z
    type(field_type),    pointer :: tri(:) => null()

    if ( .not. present(prec) ) then
      precon = si_pressure_preconditioner
    else
      precon = prec
    end if
    select case ( precon )
      case ( solver_si_pressure_preconditioner_diagonal )       
        m3_inv   => get_mass_matrix(4)
        call invoke( dg_matrix_vector_kernel_type(y, x, m3_inv) )     
      case ( solver_si_pressure_preconditioner_tridiagonal )
        z = y
        tri => get_tri_precon()
        m3_inv   => get_mass_matrix(4)
        call invoke( dg_matrix_vector_kernel_type(z, x, m3_inv), &
                     tri_solve_kernel_type(y, z, tri) )
      case default
        call invoke( copy_field(x, y) )
    end select
  end subroutine helmholtz_precondition
!=============================================================================!
end module helmholtz_solver_alg_mod

