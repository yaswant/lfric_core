!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!> An algorithm for computing the galerkin projection 
!> As a first step fields are projected into a continuous space

module galerkin_projection_algorithm_mod

  use log_mod,                 only: log_event, log_scratch_space, LOG_LEVEL_INFO
  use solver_mod,              only: solver_algorithm
  use constants_mod,           only: r_def 
  use configuration_mod,       only: solver_option  
  use psykal_lite_mod,         only: invoke_copy_field_data, invoke_set_field_scalar
  use gp_rhs_kernel_mod,       only: gp_rhs_kernel_type
  use gp_vector_rhs_kernel_mod,only: gp_vector_rhs_kernel_type
  use field_mod,               only: field_type
  use quadrature_mod,          only: quadrature_type
  use function_space_mod,      only: function_space_type, W0, W3
  use operator_mod,            only: operator_type
  use mesh_mod,                only: mesh_type

  implicit none

  private 
  public :: galerkin_projection_algorithm

contains
!> @brief An algorithm to compute the galerkin projection of a field
!> @details Computes the Galerkin projection of a field f_in into the space
!>          of field f_out. Solves M*f_out = rhs where rhs = int(gamma*f_in)
!>          and gamma is a test function from the same space as f_out and M is 
!>          the mass matrix for the space of f_out.
!>          If f_in is in a vector space then it is decomposed into
!>          orthogonal components and the galerkin projection of each
!>          component is computed.
!> @param[out] f_out A field to project to
!> @param[in]  f_in  The field to project
!> @param[in]  mesh The mesh object the model for fields
!> @param[in]  chi   A 3D coordinate field
!> @param[in]  space_dimension The dimension of the space f_in (scalar or vector)
  subroutine galerkin_projection_algorithm( f_out           &
                                          , f_in            &
                                          , mesh            &
                                          , chi             &
                                          , space_dimension &
                                          , qr              &
                                          , mm ) 
    
    implicit none

! dimension of space to project
    integer,            intent(in)    :: space_dimension
! Field to output
    type( field_type ), intent(inout) :: f_out(space_dimension)
! Field to intput
    type( field_type ), intent(inout) :: f_in  
    type( mesh_type),   intent(in)    :: mesh
! Coordinate fields
    type( field_type ), intent(inout) :: chi(3)  
    type( quadrature_type ), intent(in) :: qr
    type( operator_type ), optional, intent(inout) :: mm

    integer                          :: out_fs
    type( field_type )               :: rhs(space_dimension)
    integer                          :: dir, space 
    type(function_space_type)        :: fs


! Create continuous fields to project data into
    out_fs = f_out(1)%which_function_space()
    do dir = 1,space_dimension
      rhs(dir) = field_type( vector_space = fs%get_instance(mesh, out_fs) )
      call invoke_set_field_scalar(0.0_r_def, rhs(dir))
    end do
    
! Project field into continuous space
    write( log_scratch_space, '(A)' ) 'Computing Galerkin projection...'
    call log_event( log_scratch_space, LOG_LEVEL_INFO )  
    if ( f_in%which_function_space() == out_fs ) then
       write( log_scratch_space, '(A)' ) '   function spaces match, no projection needed'
       call log_event( log_scratch_space, LOG_LEVEL_INFO )
       call invoke_copy_field_data(f_in, f_out(1))
    else
       if ( space_dimension == 1 ) then
          write( log_scratch_space, '(A)' ) '    scalar field ... '
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          call invoke( gp_rhs_kernel_type(rhs(1), f_in, chi, qr) )
       else
          write( log_scratch_space, '(A)' ) '    vector field ... '
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          call invoke( gp_vector_rhs_kernel_type(rhs, f_in, chi, qr) )
       end if
       space = f_out(1)%which_function_space()
       do dir = 1,space_dimension
          if( present(mm) .and. space /= W3 ) then
             call solver_algorithm( f_out(dir)    &
                                  , rhs(dir)      &
                                  , mesh          &
                                  , chi           &
                                  , solver_option &
                                  , mm=mm )
          else
             call solver_algorithm( f_out(dir)    & 
                                  , rhs(dir)      &
                                  , mesh          &
                                  , chi           &
                                  , solver_option &
                                  , qr=qr )
          end if
       end do
    end if

  end subroutine galerkin_projection_algorithm
  
end module galerkin_projection_algorithm_mod
