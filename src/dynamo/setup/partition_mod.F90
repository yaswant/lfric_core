!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!> @brief Provides partitioning functionality

!> @details Partitions the mesh for the supported mesh types:
!> bi-periodic plane and cubed sphere.
!> Generates a list of cells known to this partition. The order of the list is
!> as follows:
!> The cells that are wholly owned by the partition are followed by the cells
!> that might have dofs in the halo and finally come the cells that form the
!> the halo. These are generated by applying a stencil to the owned cells

module partition_mod

implicit none

private apply_stencil_biperiodic

contains 

!> Partitions the mesh on a bi-periodic plane. It returns the global ids of
!> the cells in the given partition.
!>
!> @param num_cells_x Number of cells (globally) in the x-direction (input)
!> @param num_cells_y Number of cells (globally) in the y-direction (input)
!> @param xproc Number of processors along x-direction (input)
!> @param yproc Number of processors along y-direction (input)
!> @param local_rank Local rank (between 0 and xproc*yproc-1) (input)
!> @param partitioned_cells Returned array that holds the global ids of all
!>                          cells in local partition (output)
!> @param num_core Number of cells that are wholly owned by the partition 
!>                 (i.e. all dofs in these cells are wholly owned by the
!>                 partition). The cell ids of these cells appear first in the
!>                 partitioned_cells array (output)
!> @param num_owned Number of cells that are owned by the partition, but may
!>                  have dofs that are also owned by halo cells. The cell ids
!>                  of these cells follow the core cells in the
!>                  partitioned_cells array (output)
!> @param num_halo Number of cells that are halo cells. The cell ids of these
!>                 cells follow the owned cells in the partitioned_cells
!>                 array (output)
  subroutine partition_biperiodic( num_cells_x, num_cells_y, &
                                   xproc, yproc, local_rank, &
                                   partitioned_cells, &
                                   num_core, num_owned, num_halo )

! The cells in the biperiodic domain are numbered (globally) starting at 1
! in the SW corner and incrementing to num_cells_x in the SE corner. This
! repeats over the next row (to the north) and repeats until cell
! (num_cells_x*num_cells_y) is reached in the NE corner

  use linked_list_mod, only : linked_list_type, add_item, add_unique_item, clear_list

  implicit none

  integer, intent(in) :: num_cells_x
  integer, intent(in) :: num_cells_y
  integer, intent(in) :: xproc
  integer, intent(in) :: yproc
  integer, intent(in) :: local_rank
  integer, allocatable,  intent(inout) :: partitioned_cells( : )
  integer, intent(out) :: num_core
  integer, intent(out) :: num_owned
  integer, intent(out) :: num_halo

  integer :: local_xproc, local_yproc ! x- and y-dirn processor id of this partition
  integer :: start_x   ! global cell id of start of the domain on this partition in x-dirn
  integer :: num_x     ! number of cells in the domain on this partition in x-dirn
  integer :: start_y   ! global cell id of start of the domain on this partition in y-dirn
  integer :: num_y     ! number of cells in the domain on this partition in y-dirn
  integer :: num_in_list !total number of cells known to this partition (owned+halo)
  integer :: num_added ! number of cells added to the linked list 
  integer :: ix, iy    ! loop counters over cells on this partition in x- and y-dirns

  type(linked_list_type), pointer :: curr=>null()  ! the current position at which items will be added
                                                   ! to the list that holds cells known to this partition
  type(linked_list_type), pointer :: start=>null() ! start of the list that holds cells known to this partition

  integer :: i         ! loop counter over all items being sorted in the bubble sort
  integer :: swap_temp ! temporary swap space used to swap items in the bubble sort
  logical :: swapped   ! flag set to true if the current iteration of the bubble sort swapped any items

  !convert the local rank number into a local xproc and yproc
  local_xproc=modulo(local_rank,xproc)
  local_yproc=local_rank/xproc

  !Work out the start index and number of cells (in x- and y-dirn) for 
  !the local partition - this algorithm should spread out the number of
  !cells each partition gets fairly evenly
  start_x = int(real(local_xproc)*real(num_cells_x)/ &
                real(xproc)+0.5)+1
  num_x   = int(real(local_xproc+1)*real(num_cells_x)/ &
                real(xproc)+0.5)-start_x+1

  start_y = int(real(local_yproc)*real(num_cells_y)/ &
                real(yproc)+0.5)+1
  num_y   = int(real(local_yproc+1)*real(num_cells_y)/ &
                real(yproc)+0.5)-start_y+1

  !Create a linked list of cells known to this partition
  !Start with the core cells - those with all dofs wholly owned by the partition
  num_in_list=0
  do iy=start_y + 1, start_y+num_y - 2
    do ix=start_x + 1, start_x+num_x - 2
      call add_item(curr,(iy-1)*num_cells_x+ix)
      if(.not.associated(start))start => curr
      num_in_list=num_in_list+1
    end do
  end do 
  num_core = num_in_list

  ! Now add the owned cells - those still owned by the partition -
  ! but may have dofs shared with halo cells
  ! Those cells along the top/bottom
  do ix=start_x, start_x+num_x-1
    call add_item(curr,(start_y-1)*num_cells_x+ix)
    num_in_list=num_in_list+1
    if(.not.associated(start))start => curr
    call add_unique_item(start,curr,(start_y+num_y-2)*num_cells_x+ix,num_added)
    num_in_list=num_in_list+num_added
  end do
  ! Those along the left/right
  do iy=start_y+1, start_y+num_y-2
    call add_unique_item(start,curr,(iy-1)*num_cells_x+start_x,num_added)
    num_in_list=num_in_list+num_added
    call add_unique_item(start,curr,(iy-1)*num_cells_x+start_x+num_x-1,num_added)
    num_in_list=num_in_list+num_added
  end do
  num_owned=num_in_list-num_core

  ! look for halos around top and bottom rows
  do ix=start_x, start_x+num_x-1
    call apply_stencil_biperiodic(ix,start_y,num_cells_x,num_cells_y,start,curr,num_in_list)
    call apply_stencil_biperiodic(ix,start_y+num_y-1,num_cells_x,num_cells_y,start,curr,num_in_list)
  end do
  ! look for halos around left and right edges
  do iy=start_y, start_y+num_y-1
    call apply_stencil_biperiodic(start_x,iy,num_cells_x,num_cells_y,start,curr,num_in_list)
    call apply_stencil_biperiodic(start_x+num_x-1,iy,num_cells_x,num_cells_y,start,curr,num_in_list)
  end do
  num_halo = num_in_list - num_core - num_owned

  allocate(partitioned_cells(num_in_list))
  curr => start
  do i = 1,num_in_list
    partitioned_cells(i)=curr%dat
    curr=>curr%next
  end do

  !Deallocate the list
  call clear_list(start)

  ! Cell ids within the three separate groups have to be in numerical order.
  ! Core cells are already correctly ordered so now (bubble) sort the other two groups
  !
  !Sort owned cells
  do
    swapped=.false.
    do i = num_in_list-num_halo-num_owned+1,num_in_list-num_halo-1
      if(partitioned_cells(i) > partitioned_cells(i+1))then
        swap_temp=partitioned_cells(i)
        partitioned_cells(i)=partitioned_cells(i+1)
        partitioned_cells(i+1)=swap_temp
        swapped=.true.
      end if
    end do
    if(.not.swapped)exit
  end do
  !
  !Sort halo cells
  do
    swapped=.false.
    do i = num_in_list-num_halo+1,num_in_list-1
      if(partitioned_cells(i) > partitioned_cells(i+1))then
        swap_temp=partitioned_cells(i)
        partitioned_cells(i)=partitioned_cells(i+1)
        partitioned_cells(i+1)=swap_temp
        swapped=.true.
      end if
    end do
    if(.not.swapped)exit
  end do

  end subroutine partition_biperiodic

!> Partitions the mesh on a cubed sphere
!>
!> @param num_cells_x Number of cells (globally) across one of the faces of the 'cube' (input)
!> @param local_rank Local rank (between 0 and 6*xproc*yproc-1) (input)
!> @param partitioned_cells Returned array that holds the global ids of all
!>                          cells in local partition (output)
!> @param num_core Number of cells that are wholly owned by the partition 
!>                 (i.e. all dofs in these cells are wholly owned by the
!>                 partition). The cell ids of these cells appear first in the
!>                 partitioned_cells array (output)
!> @param num_owned Number of cells that are owned by the partition, but may
!>                  have dofs that are also owned by halo cells. The cell ids
!>                  of these cells follow the core cells in the
!>                  partitioned_cells array (output)
!> @param num_halo Number of cells that are halo cells. The cell ids of these
!>                 cells follow the owned cells in the partitioned_cells
!>                 array (output)
  subroutine partition_cubedsphere( num_cells_x, &
                                    local_rank, &
                                    partitioned_cells,&
                                    num_core, num_owned, num_halo )

  use log_mod, only : log_event, LOG_LEVEL_ERROR

! Currently not written to partition the mesh (that will come later)
! - will just return one big partition that holds everything
  implicit none

  integer, intent(in) :: num_cells_x
  integer, intent(in) :: local_rank
  integer, allocatable, intent(inout) :: partitioned_cells( : )
  integer, intent(out) :: num_core
  integer, intent(out) :: num_owned
  integer, intent(out) :: num_halo

  integer :: i

  if( local_rank /= 0 )then
   call log_event( 'Cubed-sphere meshes cannot be decomposed at present',&
     LOG_LEVEL_ERROR )
  endif

  num_core = 6*num_cells_x*num_cells_x
  num_owned = 0
  num_halo = 0

  allocate(partitioned_cells(num_core+num_owned+num_halo))
  do i=1, num_core+num_owned+num_halo
    partitioned_cells(i)=i
  end do

  end subroutine partition_cubedsphere

!> @brief Applies a nine-point stencil in a bi-periodic domain around a cell and adds
!> the global ids of the stencil cells to a list of cells known to the partition - if
!> they are not already in the list.
!> @param[in] ix Global x-coordinate of the cell on which to apply the stencil
!> @param[in] iy Global y-coordinate of the cell on which to apply the stencil
!> @param[in] num_cells_x Number of cells in the global domain in the x-direction
!> @param[in] num_cells_y Number of cells in the global domain in the y-direction
!> @param[in] start Start of the linked-list that holds cells known to this partition
!> @param[inout] current Current position at which items will be added to the list that holds cells known to this partition
!> @param[inout] num_in_list Total number of cells known to this partition
  subroutine apply_stencil_biperiodic(ix,iy,num_cells_x,num_cells_y,start,curr,num_in_list)
  use linked_list_mod, only : linked_list_type, add_unique_item
  implicit none
  integer, intent(in) :: ix, iy
  integer, intent(in) :: num_cells_x, num_cells_y
  type(linked_list_type), intent(inout), pointer :: curr
  type(linked_list_type), intent(in), pointer :: start
  integer, intent(inout) :: num_in_list

  integer :: j         ! counter over the points in the stencil
  integer :: ix1, iy1  ! x- and y-coordinate of cell in the stencil
  integer :: num_added ! number of cells added to the linked list 

  do j=1,8  ! there are 8 cells around a centre cell in a 9-point stencil
    select case (j)
    case (1)  !South
      ix1=ix
      iy1=iy-1
    case (2)  !Southwest
      ix1=ix-1
      iy1=iy-1
    case (3)  !West
      ix1=ix-1
      iy1=iy
    case (4)  !Northwest
      ix1=ix-1
      iy1=iy+1
    case (5)  !North
      ix1=ix
      iy1=iy+1
    case (6)  !Northeast
      ix1=ix+1
      iy1=iy+1
    case (7)  !East
      ix1=ix+1
      iy1=iy
    case (8)  !Southeast
      ix1=ix+1
      iy1=iy-1
    case default
      ix1=ix
      iy1=iy
    end select
    !wrap-around
    if (ix1<1)ix1=num_cells_x
    if (ix1>num_cells_x)ix1=1
    if (iy1<1)iy1=num_cells_y
    if (iy1>num_cells_y)iy1=1

    call add_unique_item(start,curr,(iy1-1)*num_cells_x+ix1,num_added)
    num_in_list=num_in_list+num_added
  end do

  end subroutine apply_stencil_biperiodic

end module partition_mod
