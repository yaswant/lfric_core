!-----------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-----------------------------------------------------------------------------

module runtime_constants_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: runtime_constants_test_type, test_all

  @TestCase
  type, extends(TestCase) :: runtime_constants_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type runtime_constants_test_type

  integer(i_def), parameter :: element_order = 0

  real(r_def), parameter :: gravity = 10.0_r_def
  real(r_def), parameter :: radius  = 6000000_r_def
  real(r_def), parameter :: omega   = 8.0E-5_r_def
  real(r_def), parameter :: p_zero  = 100000.0_r_def
  real(r_def), parameter :: rd      = 300.0_r_def
  real(r_def), parameter :: cp      = 1000.0_r_def
  real(r_def), parameter :: scaling = 1.0_r_def

  contains

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine setUp( this )

      use finite_element_config_mod, only : finite_element_shape_quadrilateral
      use frig_config_mod,           only : frig_planet_config
      use reference_element_mod,     only : reference_cube,   &
                                            reference_element

      implicit none

      class(runtime_constants_test_type), intent(inout) :: this

      call frig_planet_config( radius, gravity, omega, rd, cp, p_zero, scaling )

      reference_element = finite_element_shape_quadrilateral
      call reference_cube()

    end subroutine setup

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine tearDown( this )

      use function_space_mod,       only : purge_function_spaces
      use reference_element_mod,    only : deallocate_reference

      implicit none

      class(runtime_constants_test_type), intent(inout) :: this

      call purge_function_spaces()
      call deallocate_reference()

    end subroutine tearDown

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    @test
    subroutine test_all( this )

      use field_mod,             only : field_type, field_proxy_type
      use fs_continuity_mod,     only : W0, W1, W2, W3
      use function_space_mod,    only : function_space_type
      use mesh_mod,              only : mesh_type, PLANE_BI_PERIODIC
      use operator_mod,          only : operator_type
      use runtime_constants_mod, only : runtime_constants_type

      implicit none

      class(runtime_constants_test_type), intent(inout) :: this

      real(kind=r_def), parameter    :: DX = 6000.0_r_def, &
                                        DY = 1000.0_r_def, &
                                        DZ = 2000.0_r_def
      real(kind=r_def), parameter    :: TOL = 1.0e-12_r_def

      type(runtime_constants_type) :: rt_const
      type(mesh_type)              :: mesh
      type(function_space_type)    :: fs
      type(operator_type)          :: mm_w3, mm_w2, mm_w1, mm_w0
      type(operator_type)          :: mm_w3_inv
      type(operator_type)          :: grad, curl, div
      type(field_type)             :: mmd_w3, mmd_w2, mmd_w1, mmd_w0
      type(field_type)             :: chi(3), geo
      type(field_proxy_type)       :: chi_p(3), geo_p, tmp_p

      type(function_space_type), pointer :: w0_fs => null()
      type(function_space_type), pointer :: w1_fs => null()
      type(function_space_type), pointer :: w2_fs => null()
      type(function_space_type), pointer :: w3_fs => null()
      type(mesh_type),           pointer :: mesh_ptr => null()
      type(operator_type),       pointer :: mm_w3_ptr => null(), &
                                            mm_w2_ptr => null(), &
                                            mm_w1_ptr => null(), &
                                            mm_w0_ptr => null(), &
                                            mm_w3_inv_ptr => null(), &
                                            grad_ptr => null(), &
                                            curl_ptr => null(), &
                                            div_ptr  => null()

      type(field_type),          pointer :: chi_ptr(:) => null(), &
                                            geo_ptr => null()
      integer,                   pointer :: map_w0(:) => null()

      integer                        :: i, j, k, cell, err

      ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
      mesh = mesh_type(PLANE_BI_PERIODIC)

      ! Create function spaces
      w0_fs => fs%get_instance( mesh, element_order, W0 )
      w1_fs => fs%get_instance( mesh, element_order, W1 )
      w2_fs => fs%get_instance( mesh, element_order, W2 )
      w3_fs => fs%get_instance( mesh, element_order, W3 )

      ! Make a coordinate field with a function space
      do i = 1,3
        chi(i) = field_type( vector_space = w0_fs )
        chi_p(i) = chi(i)%get_proxy()
      end do
      geo = field_type( vector_space = w0_fs )
      geo_p = geo%get_proxy()

      ! Compute coordinates
      cell = 1
      do j = 1,3
        do i = 1,3
          map_w0 => chi_p(1)%vspace%get_cell_dofmap( cell )
          do k = 0,3
            chi_p(1)%data(map_w0(1) + k) = real(i-1)*DX
            chi_p(2)%data(map_w0(1) + k) = real(j-1)*DY
            chi_p(3)%data(map_w0(1) + k) = real(k)  *DZ
            geo_p   %data(map_w0(1) + k) = real(k)  *DZ*gravity
          end do
          cell = cell + 1
        end do
      end do

      ! Create operators
      mm_w0 = operator_type(w0_fs,w0_fs)
      mm_w1 = operator_type(w1_fs,w1_fs)
      mm_w2 = operator_type(w2_fs,w2_fs)
      mm_w3 = operator_type(w3_fs,w3_fs)
      grad = operator_type( w1_fs, w0_fs )
      curl = operator_type( w2_fs, w1_fs )
      div  = operator_type( w3_fs, w2_fs )
      mm_w3_inv = operator_type(w3_fs,w3_fs)

      ! Create diagonals
      mmd_w0 = field_type( vector_space = w0_fs )
      mmd_w1 = field_type( vector_space = w1_fs )
      mmd_w2 = field_type( vector_space = w2_fs )
      mmd_w3 = field_type( vector_space = w3_fs )

      ! Make the runtime_constants object
      rt_const = runtime_constants_type( mesh, chi, geo, &
                                         mm_w0, mm_w1, mm_w2, mm_w3, &
                                         mm_w3_inv, &
                                         mmd_w0, mmd_w1, mmd_w2, mmd_w3, &
                                         grad, curl, div)

      ! Check we get back what we sowed
      mesh_ptr  => rt_const%get_mesh()
      chi_ptr   => rt_const%get_coordinates()
      geo_ptr   => rt_const%get_geopotential()
      mm_w0_ptr => rt_const%get_mass_matrix(0)
      mm_w1_ptr => rt_const%get_mass_matrix(1)
      mm_w2_ptr => rt_const%get_mass_matrix(2)
      mm_w3_ptr => rt_const%get_mass_matrix(3)
      mm_w3_inv_ptr => rt_const%get_mass_matrix(4)
      grad_ptr  => rt_const%get_grad()
      curl_ptr  => rt_const%get_curl()
      div_ptr   => rt_const%get_div()

      ! Some simple tests to check we have the same information
      @assertEqual( mesh_ptr%get_ncells(), mesh%get_ncells() )
      do i = 1, 3
        tmp_p = chi_ptr(i)%get_proxy()
        @assertEqual( tmp_p%data(:), chi_p(i)%data(:), TOL )
      end do
      tmp_p = geo_ptr%get_proxy()
      @assertEqual( tmp_p%data(:), geo_p%data(:), TOL )
      @assertEqual( mm_w0_ptr%which_fs_from(), mm_w0%which_fs_from() )
      @assertEqual( mm_w1_ptr%which_fs_from(), mm_w1%which_fs_from() )
      @assertEqual( mm_w2_ptr%which_fs_from(), mm_w2%which_fs_from() )
      @assertEqual( mm_w3_ptr%which_fs_from(), mm_w3%which_fs_from() )
      @assertEqual( mm_w3_inv_ptr%which_fs_from(), mm_w3_inv%which_fs_from() )
      @assertEqual( grad_ptr%which_fs_from(), grad%which_fs_from() )
      @assertEqual( curl_ptr%which_fs_from(), curl%which_fs_from() )
      @assertEqual( div_ptr%which_fs_from(),  div%which_fs_from() )
      

    end  subroutine test_all

end module runtime_constants_mod_test
