!-----------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-----------------------------------------------------------------------------

!> Test the field representation
!>
module field_mod_test

  use field_mod,               only : field_type,      &
                                      field_proxy_type
  use function_space_mod,      only : function_space_type, V0
  use constants_mod,           only : r_def, i_def
  use mesh_mod,                only : num_cells, v_unique_dofs, num_layers
  use gaussian_quadrature_mod, only : gaussian_quadrature_type, &
                                      ngp_h, ngp_v
  use basis_function_mod,      only : v0_basis, &
                                      v0_diff_basis, &
                                      v0_nodal_coords
  use dofmap_mod,              only : v0_dofmap
  use pFUnit_Mod

  implicit none 

  @TestCase
  type, public, extends( TestCase ) :: field_test_type

    procedure( runMethod ), pointer :: userMethod => null()
  contains

    procedure :: setUp
    procedure :: tearDown
    procedure :: runMethod
    procedure :: test_field_data
    procedure :: test_half_field

  end type field_test_type

  interface field_test_type
    module procedure create_field_test_type
  end interface field_test_type

contains

  !> Constructor.
  !>
  function create_field_test_type( name, userMethod ) result( this )

    character( len=*), intent( in ) :: name
    procedure( runMethod )          :: userMethod

    type( field_test_type ) :: this

    call this%setName( name )
    this%userMethod => userMethod

  end function create_field_test_type

  !> Prepare fixtures
  !>
  subroutine setUp( this )

    implicit none

    class( field_test_type ), intent( inout ) :: this

    integer( i_def ) :: num_dofs, num_unique_dofs
    integer( i_def ) :: i

    num_layers=50
    num_cells = 35
    num_dofs=4
    num_unique_dofs = 100
    do i = 1, 4
      v_unique_dofs(i,1)=num_unique_dofs
      v_unique_dofs(i,2)=num_dofs
    enddo
    allocate(v0_basis(1,v_unique_dofs(1,2),ngp_h,ngp_v))
    allocate(v0_diff_basis(3,v_unique_dofs(1,2),ngp_h,ngp_v))
    allocate(v0_nodal_coords(3,v_unique_dofs(1,2)))
    v0_basis=sqrt(2.0)
    v0_diff_basis=atan(4.0)
    v0_nodal_coords(1,:)=0.152689632_r_def
    v0_nodal_coords(2,:)=0.562554751_r_def
    v0_nodal_coords(3,:)=-0.8234_r_def
    allocate( v0_dofmap(0:num_cells,v_unique_dofs(1,2)) )
    do i=0,num_cells
       v0_dofmap(i,:) = i+64
    end do

  end subroutine setUp

  !> Destroy fixtures
  !>
  subroutine tearDown( this )

    implicit none

    class( field_test_type ), intent( inout ) :: this

    deallocate(v0_basis)
    deallocate(v0_diff_basis)
    deallocate(v0_nodal_coords)
    deallocate(v0_dofmap)

  end subroutine tearDown

  !> Ensure constructor and getters work.
  !>
  @test
  subroutine test_field_data( this )

    implicit none

    class( field_test_type ), intent( inout ) :: this

    type( function_space_type )      :: func_space
    type( field_type )               :: f_field
    type( field_proxy_type )         :: f_field_proxy
    type( gaussian_quadrature_type ) :: gq
    integer                          :: num_dofs,num_unique_dofs
    integer                          :: testncell,       &
                                        testnlayers
    integer :: i,j, fs

    f_field = field_type( vector_space = func_space%get_instance(V0), &
                          gq = gq%get_instance() )

    f_field_proxy = f_field % get_proxy( )

    ! test the procedures of the type
    testncell = f_field_proxy%vspace%get_ncell()
    @assertEqual( num_cells, testncell )

    testnlayers = f_field_proxy%vspace%get_nlayers()
    @assertEqual( num_layers, testnlayers )

    fs = f_field%which_function_space()
    @assertEqual(fs,V0)

  end subroutine test_field_data

  !> Ensure constructor without gaussian quadrature works
  !>
  @test
  subroutine test_half_field( this )

    use field_mod,          only: field_type, field_proxy_type
    use function_space_mod, only: function_space_type, V0

    implicit none

    class( field_test_type ), intent( inout ) :: this

    type( function_space_type ) :: function_space
    type( field_type )          :: test_field
    type( field_proxy_type )    :: test_field_accessor

    test_field          = field_type( function_space%get_instance( V0 ) )
    test_field_accessor = test_field%get_proxy()

    ! test the procedures of the type
    @assertEqual( test_field_accessor%vspace%get_ncell(), num_cells )

    @assertEqual( test_field_accessor%vspace%get_nlayers(), num_layers )

    @assertEqual( test_field%which_function_space(), V0 )

    @assertFalse( associated( test_field_accessor%gaussian_quadrature ) )

  end subroutine test_half_field

  !> Test framework boilerplate
  !>
  subroutine runMethod( this )

    implicit none

    class( field_test_type ), intent( inout ) :: this

    call this%userMethod()

  end subroutine runMethod

end module field_mod_test
