!-----------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-----------------------------------------------------------------------------

!> Test the Operator representation
!>

module operator_mod_test

  use constants_mod, only: i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: operator_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type operator_test_type

  integer(i_def), parameter :: element_order = 0
contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use finite_element_config_mod, only : finite_element_shape_quadrilateral
    use reference_element_mod,     only : reference_cube, reference_element

    implicit none

    class(operator_test_type), intent(inout) :: this

    reference_element = finite_element_shape_quadrilateral
    call reference_cube()

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use function_space_mod,    only : purge_function_spaces
    use reference_element_mod, only : deallocate_reference

    implicit none

    class(operator_test_type), intent(inout) :: this

    call purge_function_spaces()
    call deallocate_reference()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all( this )

    use operator_mod,       only: operator_type, operator_proxy_type
    use mesh_mod,           only: mesh_type, PLANE_BI_PERIODIC
    use function_space_mod, only: function_space_type
    use fs_continuity_mod,  only: W1, W2

    implicit none

    class(operator_test_type), intent(inout) :: this

    type( operator_type )       :: Op
    type( operator_proxy_type ) :: Op_p

    type(mesh_type)             :: mesh
    type(mesh_type),pointer     :: mesh_out => null()
    type( function_space_type ) :: fs
    type( function_space_type ), pointer :: fs1  => null()
    type( function_space_type ), pointer :: fs2  => null()

    integer(i_def) :: err
    integer(i_def) :: i, iface, iedge, lid, test_integer
    integer(i_def) :: ncell_3d_1, ncell_3d_2, ls_size

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    mesh = mesh_type(PLANE_BI_PERIODIC)

    fs1 => fs%get_instance( mesh, element_order, W1 )
    fs2 => fs%get_instance( mesh, element_order, W2 )

    ! make an operator
    Op = operator_type( fs2, fs1 )  ! fs1 --> fs2

    ! get the proxy
    Op_p = Op%get_proxy()

    ! Check we get back what we sowed
    @assertEqual( Op%which_fs_from(), W1 )
    @assertEqual( Op%which_fs_to(),   W2 )

    ! Only meaningful test without PSy and Kernel layers is to check array
    ! sizes on the proxy.
    ncell_3d_1 = Op_p%fs_from%get_ncell() * Op_p%fs_from%get_nlayers()
    ncell_3d_2 = Op_p%fs_to%get_ncell() * Op_p%fs_to%get_nlayers()
    @assertEqual( Op_p%ncell_3d, ncell_3d_1 )
    @assertEqual( Op_p%ncell_3d, ncell_3d_2 )
    ls_size = ncell_3d_1 * Op_p%fs_from%get_ndf() * Op_p%fs_to%get_ndf()
    @assertEqual( size( Op_p%local_stencil ), ls_size )

    ! Test if the operator returns the correct mesh
    ! Use a subset of the tests from mesh_mod_test.pf
    mesh_out => Op%get_mesh()

    !-------------------------------------------------------------------
    ! Test get_face_on_cell()
    iface=3
    lid=9
    test_integer = mesh_out%get_face_on_cell(iface, lid)
    @assertEqual ( 28, test_integer )

    !-------------------------------------------------------------------
    ! Test get_edge_on_cell()
    iedge=1
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 27, test_integer )

    iedge=5
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 11, test_integer )

    iedge=9
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 28, test_integer )

    iedge=12
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 36, test_integer )

    iedge=6
    lid=9
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 32, test_integer )

  end  subroutine test_all

end module operator_mod_test
