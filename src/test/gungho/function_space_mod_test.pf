!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
module function_space_mod_test
  implicit none 

contains

  @test
  subroutine test_func_space()
    use pFUnit_Mod
    use function_space_mod, only : function_space_type, W0, W1, W2, W3, Wtheta, W2V, W2H
    use constants_mod, only : r_def
    use quadrature_mod, only : quadrature_type, QR3 
    use function_space_build_mod, only : & 
                                  w0_func_space, w1_func_space,              &
                                  w2_func_space, w3_func_space,              &
                                  wtheta_func_space,		             &
                                  w2v_func_space, w2h_func_space,            &
                                  fs_build, fs_destroy,get_test_map,         &
                                  basis_func_w0, diff_basis_func_w0,         &
                                  basis_func_w1, diff_basis_func_w1,         &
                                  basis_func_w2, diff_basis_func_w2,         &
                                  basis_func_w3, diff_basis_func_w3,         &
                                  basis_func_wtheta, diff_basis_func_wtheta, &
                                  basis_func_w2v, diff_basis_func_w2v,       &
                                  basis_func_w2h, diff_basis_func_w2h

    use mesh_mod,                 only : mesh_type, PLANE_BI_PERIODIC
    
    implicit none

    type(quadrature_type), pointer :: qr => null()
    type(mesh_type)  :: mesh
    type(mesh_type)  :: mesh_out
    integer          :: test_fs
    integer          :: scalar, vector
    integer          :: nqp_h, nqp_v

    real(kind=r_def), pointer :: xp(:,:) => null()
    real(kind=r_def), pointer :: zp(:) => null()
    integer, pointer :: testmap(:,:)
    real(kind=r_def) :: epsilon
    
    real(kind=r_def), allocatable, dimension(:,:,:,:) :: basis, test_basis

    integer, pointer,     dimension(:) :: map => null()
    integer                            :: cell

    integer :: ndf
    integer :: iface, iedge, lid, test_integer

    scalar=1
    vector=3

    epsilon = 1.0e-14_r_def

    nqp_h = 9
    nqp_v = 3
    qr => qr%get_instance(QR3,nqp_h,nqp_v)
    xp => qr%get_xqp_h()
    zp => qr%get_xqp_v()

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    mesh = mesh_type(PLANE_BI_PERIODIC)

    ! Make the function spaces
    call fs_build(mesh)

    ! -----------------------------------
    ! Test w0
    test_fs = w0_func_space%which()
    @assertEqual( test_fs, W0 )

    ndf = w0_func_space%get_ndf()
    ! W0 at lowest order on quads ...
    @assertEqual(ndf,8) 
    ! 36 for w0
    @assertEqual( w0_func_space%get_undf(), 36 ) 
    @assertEqual( w0_func_space%get_ncell(), 9)
    @assertEqual( w0_func_space%get_nlayers(),3 )
    @assertEqual( w0_func_space%get_dim_space(), scalar )  
    @assertEqual( w0_func_space%get_dim_space_diff(), vector ) 

    call get_test_map(testmap,W0)
    do cell = 1, w0_func_space%get_ncell()
       map => w0_func_space%get_cell_dofmap( cell )
       @assertEqual( map, testmap(:,cell) )
    end do

    allocate(basis(     w0_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w0_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    call basis_func_w0(test_basis)
    call w0_func_space%compute_basis_function(                       &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)
    allocate(basis(     w0_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w0_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    call diff_basis_func_w0(test_basis)
    call w0_func_space%compute_diff_basis_function(                   &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    ! ------------------------------------------------
    ! Test w1
    test_fs = w1_func_space%which()
    @assertEqual( test_fs, W1 )

    call get_test_map(testmap,W1)
    do cell = 1, w1_func_space%get_ncell()
       map => w1_func_space%get_cell_dofmap( cell )
       @assertEqual( map, testmap(:,cell) )
    end do

    ndf = w1_func_space%get_ndf()
    ! W1 at lowest order on quads ...
    @assertEqual(ndf,12)
    ! 99 for w1
    @assertEqual( w1_func_space%get_undf(), 99 )
    @assertEqual( w1_func_space%get_ncell(), 9)
    @assertEqual( w1_func_space%get_nlayers(),3 )
    @assertEqual( w1_func_space%get_dim_space(), vector )
    @assertEqual( w1_func_space%get_dim_space_diff(), vector )

    allocate(basis(     w1_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w1_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    call basis_func_w1(test_basis)
    call w1_func_space%compute_basis_function(                       &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    allocate(basis(     w1_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w1_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    call diff_basis_func_w1(test_basis)
    call w1_func_space%compute_diff_basis_function(                   &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    ! ---------------------------------------------
    ! Test w2 
    test_fs = w2_func_space%which()
    @assertEqual( test_fs, W2 )

    call get_test_map(testmap,W2)
    do cell = 1, w2_func_space%get_ncell()
       map => w2_func_space%get_cell_dofmap( cell )
       @assertEqual( map, testmap(:,cell) )
    end do

    ndf = w2_func_space%get_ndf()
    ! W2 at lowest order on quads ...
    @assertEqual(ndf,6) 
    ! 90 for w2
    @assertEqual( w2_func_space%get_undf(), 90 ) 
    @assertEqual( w2_func_space%get_ncell(), nqp_h)
    @assertEqual( w2_func_space%get_nlayers(), nqp_v )
    @assertEqual( w2_func_space%get_dim_space(), vector )  
    @assertEqual( w2_func_space%get_dim_space_diff(), scalar ) 

    allocate(basis(     w2_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w2_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    call basis_func_w2(test_basis)
    call w2_func_space%compute_basis_function(                       &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    allocate(basis(     w2_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w2_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    call diff_basis_func_w2(test_basis)
    call w2_func_space%compute_diff_basis_function(                   &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    ! ---------------------------------------------
    ! Test w3 
    test_fs = w3_func_space%which()
    @assertEqual( test_fs, W3 )

    call get_test_map(testmap,W3)
     do cell = 1, w3_func_space%get_ncell()
       map => w3_func_space%get_cell_dofmap( cell )
       @assertEqual( map, testmap(:,cell) )
    end do

    ndf = w3_func_space%get_ndf()
    ! W3 at lowest order on quads ...
    @assertEqual(ndf,1) 
    ! 27 for w3
    @assertEqual( w3_func_space%get_undf(), 27 ) 
    @assertEqual( w3_func_space%get_ncell(), nqp_h)
    @assertEqual( w3_func_space%get_nlayers(), nqp_v )
    @assertEqual( w3_func_space%get_dim_space(), scalar )  
    @assertEqual( w3_func_space%get_dim_space_diff(), scalar ) 

    allocate(basis(     w3_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w3_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    call basis_func_w3(test_basis)
    call w3_func_space%compute_basis_function(                       &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    allocate(basis(     w3_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w3_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    call diff_basis_func_w3(test_basis)
    call w3_func_space%compute_diff_basis_function(                   &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    ! ---------------------------------------------
    ! Test wtheta
    test_fs = wtheta_func_space%which()
    @assertEqual( test_fs, Wtheta )
    call get_test_map(testmap,Wtheta)
    do cell = 1, wtheta_func_space%get_ncell()
       map => wtheta_func_space%get_cell_dofmap( cell )
       @assertEqual( map, testmap(:,cell) )
    end do

    ndf = wtheta_func_space%get_ndf()
    ! Wtheta at lowest order on quads ...
    @assertEqual(ndf,2)
    ! 36 for wtheta
    @assertEqual( wtheta_func_space%get_undf(), 36 )
    @assertEqual( wtheta_func_space%get_ncell(), nqp_h)
    @assertEqual( wtheta_func_space%get_nlayers(), nqp_v )
    @assertEqual( wtheta_func_space%get_dim_space(), scalar )
    @assertEqual( wtheta_func_space%get_dim_space_diff(), vector )

    allocate(basis(     wtheta_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(wtheta_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    call basis_func_wtheta(test_basis)
    call wtheta_func_space%compute_basis_function(                       &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    allocate(basis(     wtheta_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(wtheta_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    call diff_basis_func_wtheta(test_basis)
    call wtheta_func_space%compute_diff_basis_function(                   &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)
   
    ! ---------------------------------------------
    ! Test w2v
    test_fs = w2v_func_space%which()
    @assertEqual( test_fs, W2V )

    call get_test_map(testmap,W2V)
    do cell = 1, w2v_func_space%get_ncell()
       map => w2v_func_space%get_cell_dofmap( cell )
       @assertEqual( map, testmap(:,cell) )
    end do

    ndf = w2v_func_space%get_ndf()
    ! W2V at lowest order on quads ...
    @assertEqual(ndf,2)
    ! 36 for w2v
    @assertEqual( w2v_func_space%get_undf(), 36 )
    @assertEqual( w2v_func_space%get_ncell(), nqp_h)
    @assertEqual( w2v_func_space%get_nlayers(), nqp_v )
    @assertEqual( w2v_func_space%get_dim_space(), vector )
    @assertEqual( w2v_func_space%get_dim_space_diff(), scalar )

    allocate(basis(     w2v_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w2v_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    call basis_func_w2v(test_basis)
    call w2v_func_space%compute_basis_function(                       &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    allocate(basis(     w2v_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w2v_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    call diff_basis_func_w2v(test_basis)
    call w2v_func_space%compute_diff_basis_function(                   &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    ! ---------------------------------------------
    ! Test w2h
    test_fs = w2h_func_space%which()
    @assertEqual( test_fs, W2H )

    call get_test_map(testmap,W2H)
    do cell = 1, w2h_func_space%get_ncell()
       map => w2h_func_space%get_cell_dofmap( cell )
       @assertEqual( map, testmap(:,cell) )
    end do

    ndf = w2h_func_space%get_ndf()
    ! W2H at lowest order on quads ...
    @assertEqual(ndf,4)
    ! 54 for w2h
    @assertEqual( w2h_func_space%get_undf(), 54 )
    @assertEqual( w2h_func_space%get_ncell(), nqp_h)
    @assertEqual( w2h_func_space%get_nlayers(), nqp_v )
    @assertEqual( w2h_func_space%get_dim_space(), vector )
    @assertEqual( w2h_func_space%get_dim_space_diff(), scalar )

    allocate(basis(     w2h_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w2h_func_space%get_dim_space(), ndf, nqp_h, nqp_v) )
    call basis_func_w2h(test_basis)
    call w2h_func_space%compute_basis_function(                       &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)

    allocate(basis(     w2h_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    allocate(test_basis(w2h_func_space%get_dim_space_diff(), ndf, nqp_h, nqp_v) )
    call diff_basis_func_w2h(test_basis)
    call w2h_func_space%compute_diff_basis_function(                   &
         basis, ndf, nqp_h, nqp_v, xp, zp )
    @assertEqual(test_basis, basis, epsilon)
    deallocate(basis, test_basis)


    ! Test if the function space returns the correct mesh
    ! Use a subset of the tests from mesh_mod_test.pf
    mesh_out = w1_func_space%get_mesh()

    !-------------------------------------------------------------------
    ! Test get_face_on_cell()
    iface=3
    lid=9
    test_integer = mesh_out%get_face_on_cell(iface, lid)
    @assertEqual ( 28, test_integer )

    !-------------------------------------------------------------------
    ! Test get_edge_on_cell()
    iedge=1
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 27, test_integer )

    iedge=5
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 11, test_integer )

    iedge=9
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 28, test_integer )

    iedge=12
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 36, test_integer )

    iedge=6
    lid=9
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 32, test_integer )


    ! Tear down that which we have build, 'cos there are some module scope
    ! allocated arrays. Yuk, but it works
    call fs_destroy()

  end subroutine test_func_space 

end module function_space_mod_test
 
 
