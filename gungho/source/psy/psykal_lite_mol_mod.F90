!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------

!> @brief Provides an implementation of the Psy layer for the polynomial
!>        reconstruction routines used by the Method of Lines (MoL)
!>        avection scheme

module psykal_lite_mol_mod

  use field_mod,                    only : field_type, field_proxy_type 
  use constants_mod,                only : r_def, i_def, l_def
  use mesh_mod,                     only : mesh_type
  use function_space_mod,           only : BASIS, DIFF_BASIS

  ! The following modules are not currently implemented as part of the main
  ! code but they do have unit tests so need to be declared here so they are
  ! built ready for unit testing.
  use quadrature_xoyoz_mod
  use quadrature_xyz_mod
  use quadrature_xyoz_mod, only : quadrature_xyoz_type, &
                                  quadrature_xyoz_proxy_type
  use quadrature_face_mod, only : quadrature_face_type, &
                                  quadrature_face_proxy_type
  use quadrature_edge_mod, only : quadrature_edge_type, &
                                  quadrature_edge_proxy_type
  implicit none

  real(kind=r_def), allocatable, dimension(:,:,:), private :: flux_coeff_h, &
                                                              flux_coeff_v, &
                                                              adv_coeff_h, &
                                                              adv_coeff_v

  public

contains

!-------------------------------------------------------------------------------
! This gives a PSy layer representation of the coefficient arrays to avoid
! copying the algorithm level representation of the data as a 2d array of field
! types into the PSy and kernel level representation of a single
! multidimensional array.
! When PSyclone and LFRic support fields with multi-dimensional arrays
! these can be removed
!-------------------------------------------------------------------------------
subroutine psykal_lite_mol_init(theta, rho, order, h_stencil_size, &
                                adv_order, adv_h_stencil_size,     &
                                nfaces_h, nfaces_v)

  implicit none

  type(field_type), intent(in) :: theta, rho
  integer(i_def),   intent(in) :: order, h_stencil_size
  integer(i_def),   intent(in) :: adv_order, adv_h_stencil_size
  integer(i_def),   intent(in) ::  nfaces_h, nfaces_v
  integer(i_def)               :: undf_w3, undf_wt
  type(field_proxy_type)       :: theta_proxy, rho_proxy

  rho_proxy   = rho%get_proxy()
  theta_proxy = theta%get_proxy()

  undf_w3 = rho_proxy%vspace%get_undf()
  undf_wt = theta_proxy%vspace%get_undf()

  ! Allocate vertical coefficients
  allocate( flux_coeff_v(order+1,     nfaces_v, undf_w3), &
             adv_coeff_v(adv_order+2, nfaces_v, undf_wt) )

  ! Allocate horizontal coefficients
  allocate( flux_coeff_h(h_stencil_size,     nfaces_h, undf_w3), &
             adv_coeff_h(adv_h_stencil_size, nfaces_h, undf_wt) )

end subroutine psykal_lite_mol_init

!-------------------------------------------------------------------------------
! This deallocates the advection coefficients when they are no longer needed
!-------------------------------------------------------------------------------
subroutine psykal_lite_mol_final()

  implicit none

  deallocate( flux_coeff_h, flux_coeff_v, &
              adv_coeff_h, adv_coeff_v )

end subroutine psykal_lite_mol_final

!-------------------------------------------------------------------------------
! Psy layer call to apply the horizontal advection coefficients for flux form
! advection. This can not currently be generated by PSyclone for 2 reasons
! 1) Uses a runtime specified 2D array of fields (coeff)
! 2) Uses a REGION type stencil that varied in size and needs the local size
!    passed into the kernel: Issue #194
!-------------------------------------------------------------------------------
subroutine invoke_poly2d_flux( flux, wind, density, coeff, order, stencil_size, nfaces_h )

  use poly2d_flux_kernel_mod,          only: poly2d_flux_code
  use stencil_dofmap_mod,              only: stencil_dofmap_type, STENCIL_REGION
  use reference_element_mod,           only: reference_element_type

  implicit none

  type(field_type), intent(inout)      :: flux
  type(field_type), intent(in)         :: wind
  type(field_type), intent(in)         :: density
  integer(i_def), intent(in)           :: order
  integer(i_def), intent(in)           :: stencil_size
  integer(i_def), intent(in)           :: nfaces_h 
  type(field_type), intent(in)         :: coeff(stencil_size, nfaces_h)
  
  class(reference_element_type), pointer :: reference_element => null()
  type( field_proxy_type )  :: flux_proxy, wind_proxy, density_proxy
  type( field_proxy_type )  :: coeff_proxy(stencil_size, nfaces_h)
  type(stencil_dofmap_type), pointer :: stencil => null()

  integer(i_def), pointer :: map_w2(:,:)        => null()
  integer(i_def), pointer :: stencil_map(:,:,:) => null()

  integer(i_def) :: undf_w3, ndf_w3
  integer(i_def) :: undf_w2, ndf_w2
  integer(i_def) :: df_w2, qp, df
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: stencil_extent, cells_in_stencil
  integer(i_def) :: direction, polynomial, idx
  integer(i_def) :: dim_w2
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), pointer :: nodes_w2(:,:) => null()
  real(kind=r_def), allocatable :: basis_w2(:,:,:)
  real(r_def), allocatable :: out_face_normal(:,:)
  logical(l_def) :: swap

  flux_proxy    = flux%get_proxy()
  wind_proxy    = wind%get_proxy()
  density_proxy = density%get_proxy()

  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do

  ndf_w3  = density_proxy%vspace%get_ndf()
  undf_w3 = density_proxy%vspace%get_undf()

  ndf_w2  = flux_proxy%vspace%get_ndf()
  undf_w2 = flux_proxy%vspace%get_undf()
  dim_w2  = flux_proxy%vspace%get_dim_space()
  nodes_w2 => flux_proxy%vspace%get_nodes()

  ! Evaluate the basis function
  allocate (basis_w2(dim_w2, ndf_w2, ndf_w2))
  do qp = 1, ndf_w2
    do df_w2 = 1, ndf_w2
      basis_w2(:,df_w2,qp) = wind_proxy%vspace%call_function(BASIS,df_w2,nodes_w2(:,qp))
    end do
  end do

  nlayers = flux_proxy%vspace%get_nlayers()

  stencil => density_proxy%vspace%get_stencil_dofmap(STENCIL_REGION, order)
  stencil_map => stencil%get_whole_dofmap()
  map_w2 => flux_proxy%vspace%get_whole_dofmap()

  if(wind_proxy%is_dirty(depth=1) ) &
    call wind_proxy%halo_exchange(depth=1)

  stencil_extent = order/2

  if(density_proxy%is_dirty(depth=stencil_extent+1) ) &
    call density_proxy%halo_exchange(depth=stencil_extent+1)

  if(flux_proxy%is_dirty(depth=1) ) &
    call flux_proxy%halo_exchange(depth=1)

  swap = .false.
  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      if(coeff_proxy(polynomial, direction)%is_dirty(depth=1) ) then
        call coeff_proxy(polynomial, direction)%halo_exchange(depth=1)
        swap = .true.
      end if
    end do
  end do

  ! Make sure module array has the correct halo swapped values
  if ( swap ) then
    do df = 1,undf_w3
      do direction = 1,nfaces_h
        do polynomial = 1,stencil_size
          flux_coeff_h(polynomial, direction,df) = coeff_proxy(polynomial, direction)%data(df)
        end do
      end do
    end do
  end if

  mesh => flux%get_mesh()
  reference_element => mesh%get_reference_element()
  call reference_element%get_normals_to_out_faces( out_face_normal )

  do cell = 1,mesh%get_last_halo_cell(1)
      cells_in_stencil = stencil%get_local_size(cell)
      call poly2d_flux_code( nlayers,                     &
                             flux_proxy%data,             &
                             wind_proxy%data,             &
                             density_proxy%data,          &
                             flux_coeff_h,                &
                             ndf_w2,                      &
                             undf_w2,                     &
                             map_w2(:,cell),              &
                             basis_w2,                    &
                             ndf_w3,                      &
                             undf_w3,                     &
                             stencil_size,                &
                             stencil_map(:,:,cell),       &
                             nfaces_h,                    &
                             cells_in_stencil,            &
                             out_face_normal              &
                             )

  end do
  call flux_proxy%set_dirty()
  deallocate( basis_w2, out_face_normal )

end subroutine invoke_poly2d_flux

!-------------------------------------------------------------------------------
! Psy layer call to compute the horizontal advection coefficients for flux form
! advection. This can not currently be generated by PSyclone for 3 reasons
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
! 2) Uses a REGION type stencil that varied in size and needs the local size
!    passed into the kernel: Issue #194
! 3) Needs two quadrature rules, one for volume integrals (supported by
!    PSyclone) and one for face quadrature: Issue #195
! 4) Uses face quadrature: Issue #193
!-------------------------------------------------------------------------------
subroutine invoke_poly2d_flux_coeffs( coeff, mdw3, chi, qr, qrf, order, stencil_size, nfaces_h )

  use poly2d_flux_coeffs_kernel_mod, only: poly2d_flux_coeffs_code
  use stencil_dofmap_mod,            only: stencil_dofmap_type, STENCIL_REGION
  implicit none

  integer(i_def), intent(in)          :: order
  integer(i_def), intent(in)          :: stencil_size
  integer(i_def), intent(in)          :: nfaces_h
  type(field_type), intent(inout)     :: coeff(stencil_size,nfaces_h)
  type(field_type), intent(in)        :: chi(3), mdw3
  type(quadrature_xyoz_type), intent( in ) :: qr
  type(quadrature_face_type), intent( in ) :: qrf

  type(quadrature_xyoz_proxy_type) :: qr_proxy
  type(quadrature_face_proxy_type) :: qrf_proxy

  type( field_proxy_type )  :: chi_proxy(3), mdw3_proxy
  type( field_proxy_type )  :: coeff_proxy(stencil_size,nfaces_h)
  type(stencil_dofmap_type), pointer :: w3_stencil => null()
  type(stencil_dofmap_type), pointer :: wx_stencil => null()

  integer(i_def), pointer :: w3_stencil_map(:,:,:) => null()
  integer(i_def), pointer :: wx_stencil_map(:,:,:) => null()

  integer(i_def) :: undf_w3, ndf_w3
  integer(i_def) :: undf_wx, ndf_wx
  integer(i_def) :: df
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: w3_stencil_size, wx_stencil_size  
  integer(i_def) :: polynomial, direction, idx
  integer(i_def) :: dim_wx
  integer(i_def) :: stencil_extent, cells_in_stencil
  integer(i_def) :: nqp_h, nqp_v, nqp_f, nfaces

  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), allocatable :: basis_wx(:,:,:,:), face_basis_wx(:,:,:,:)
  real(kind=r_def), pointer :: wqp_h(:)   => null(), &
                               wqp_v(:)   => null(), &
                               wqp_f(:,:) => null()

  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do
  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    chi_proxy(idx) = chi(idx)%get_proxy()
  end do
  mdw3_proxy = mdw3%get_proxy()

  ndf_w3  = coeff_proxy(1,1)%vspace%get_ndf()
  undf_w3 = coeff_proxy(1,1)%vspace%get_undf()

  ndf_wx  = chi_proxy(1)%vspace%get_ndf()
  undf_wx = chi_proxy(1)%vspace%get_undf()
  dim_wx  = chi_proxy(1)%vspace%get_dim_space()

  ! Pull out the quadrature
  qr_proxy  = qr%get_quadrature_proxy()
  nqp_h = qr_proxy%np_xy
  nqp_v = qr_proxy%np_z
  wqp_h => qr_proxy%weights_xy
  wqp_v => qr_proxy%weights_z

  qrf_proxy = qrf%get_quadrature_proxy()
  nfaces = qrf_proxy%nfaces
  nqp_f  = qrf_proxy%np_xyz
  wqp_f => qrf_proxy%weights_xyz

  ! Evaluate the basis functions in the volume
  allocate (basis_wx(dim_wx, ndf_wx,nqp_h,nqp_v))
  call qr%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, basis_wx)

  ! Evaluate the basis functions on the faces
  allocate( face_basis_wx(dim_wx,ndf_wx,nqp_f,nfaces))
  call qrf%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, face_basis_wx)

  nlayers = coeff_proxy(1,1)%vspace%get_nlayers()

  stencil_extent = order/2

  w3_stencil => coeff_proxy(1,1)%vspace%get_stencil_dofmap(STENCIL_REGION, &
                                                           order)
  w3_stencil_size = w3_stencil%get_size()
  w3_stencil_map => w3_stencil%get_whole_dofmap()

  wx_stencil => chi_proxy(1)%vspace%get_stencil_dofmap(STENCIL_REGION, &
                                                       order)
  wx_stencil_size = wx_stencil%get_size()
  wx_stencil_map => wx_stencil%get_whole_dofmap()

  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    if ( chi_proxy(idx)%is_dirty(depth=stencil_extent+1) ) &    
      call chi_proxy(idx)%halo_exchange(depth=stencil_extent+1)
  end do
  if ( mdw3_proxy%is_dirty(depth=stencil_extent+1) )  &
    call mdw3_proxy%halo_exchange(depth=stencil_extent+1)


  mesh => coeff(1,1)%get_mesh()
  do cell = 1,mesh%get_last_halo_cell(1)
      cells_in_stencil = w3_stencil%get_local_size(cell)
      call poly2d_flux_coeffs_code( nlayers,                     &
                                    flux_coeff_h,                &
                                    mdw3_proxy%data,             &
                                    chi_proxy(1)%data,           &
                                    chi_proxy(2)%data,           &
                                    chi_proxy(3)%data,           &
                                    ndf_w3,                      &
                                    undf_w3,                     &
                                    w3_stencil_size,             &
                                    w3_stencil_map(:,:,cell),    &
                                    ndf_wx,                      &
                                    undf_wx,                     &
                                    wx_stencil_size,             &
                                    wx_stencil_map(:,:,cell),    &
                                    basis_wx,                    &
                                    face_basis_wx,               &
                                    order,                       &
                                    nfaces_h,                    &
                                    cells_in_stencil,            &
                                    nqp_h, nqp_v, wqp_h, wqp_v,  &
                                    nfaces, nqp_f, wqp_f         &
                                  )

  end do
  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      do df = 1,undf_w3
        coeff_proxy(polynomial, direction)%data(df) = flux_coeff_h(polynomial, direction,df)
      end do
      call coeff_proxy(polynomial, direction)%set_dirty()
    end do
  end do
  deallocate( basis_wx, face_basis_wx  )
end subroutine invoke_poly2d_flux_coeffs

!-------------------------------------------------------------------------------
! Psy layer call to apply the horizontal advection coefficients for flux form
! advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): ticket #1104 & #1105
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_flux( flux, wind, density, coeff, order, stencil_extent, nfaces_h )

  use poly1d_flux_kernel_mod,          only: poly1d_flux_code
  use stencil_dofmap_mod,              only: stencil_dofmap_type, STENCIL_CROSS
  use reference_element_mod,           only: reference_element_type

  implicit none

  type(field_type), intent(inout)      :: flux
  type(field_type), intent(in)         :: wind
  type(field_type), intent(in)         :: density
  integer(i_def), intent(in)           :: order
  integer(i_def), intent(in)           :: stencil_extent
  integer(i_def), intent(in)           :: nfaces_h
  type(field_type), intent(in)         :: coeff(order+1,nfaces_h)
  
  class(reference_element_type), pointer :: reference_element => null()
  type( field_proxy_type )  :: flux_proxy, wind_proxy, density_proxy
  type( field_proxy_type )  :: coeff_proxy(order+1,nfaces_h)
  type(stencil_dofmap_type), pointer :: stencil => null()

  integer(i_def), pointer :: map_w2(:,:)        => null()
  integer(i_def), pointer :: stencil_map(:,:,:) => null()

  integer(i_def) :: undf_w3, ndf_w3
  integer(i_def) :: undf_w2, ndf_w2
  integer(i_def) :: df_w2, qp, df
  integer(i_def) :: cell
  integer(i_def) :: nlayers, stencil_size
  integer(i_def) :: direction, polynomial, idx
  integer(i_def) :: dim_w2
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), pointer :: nodes_w2(:,:) => null()
  real(kind=r_def), allocatable :: basis_w2(:,:,:)
  real(r_def), allocatable :: out_face_normal(:,:)
  logical(l_def) :: swap

  flux_proxy    = flux%get_proxy()
  wind_proxy    = wind%get_proxy()
  density_proxy = density%get_proxy()

  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do

  ndf_w3  = density_proxy%vspace%get_ndf()
  undf_w3 = density_proxy%vspace%get_undf()

  ndf_w2  = flux_proxy%vspace%get_ndf()
  undf_w2 = flux_proxy%vspace%get_undf()
  dim_w2  = flux_proxy%vspace%get_dim_space()
  nodes_w2 => flux_proxy%vspace%get_nodes()

  ! Evaluate the basis function
  allocate (basis_w2(dim_w2, ndf_w2, ndf_w2))
  do qp = 1, ndf_w2
    do df_w2 = 1, ndf_w2
      basis_w2(:,df_w2,qp) = wind_proxy%vspace%call_function(BASIS,df_w2,nodes_w2(:,qp))
    end do
  end do

  nlayers = flux_proxy%vspace%get_nlayers()

  stencil => density_proxy%vspace%get_stencil_dofmap(STENCIL_CROSS, stencil_extent)
  stencil_size = stencil%get_size()
  stencil_map => stencil%get_whole_dofmap()
  map_w2 => flux_proxy%vspace%get_whole_dofmap()

  if(wind_proxy%is_dirty(depth=1) ) &
    call wind_proxy%halo_exchange(depth=1)

  if(density_proxy%is_dirty(depth=stencil_extent+1) ) &
    call density_proxy%halo_exchange(depth=stencil_extent+1)

  if(flux_proxy%is_dirty(depth=1) ) &
    call flux_proxy%halo_exchange(depth=1)

  swap = .false.
  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      if(coeff_proxy(polynomial, direction)%is_dirty(depth=1) ) then
        call coeff_proxy(polynomial, direction)%halo_exchange(depth=1)
        swap = .true.
      end if
    end do
  end do

  ! Make sure module array has the correct halo swapped values
  if ( swap ) then
    do df = 1,undf_w3
      do direction = 1,nfaces_h
        do polynomial = 1,order+1
          flux_coeff_h(polynomial, direction,df) = coeff_proxy(polynomial, direction)%data(df)
        end do
      end do
    end do
  end if

  mesh => flux%get_mesh()
  reference_element => mesh%get_reference_element()
  call reference_element%get_normals_to_out_faces( out_face_normal )

  do cell = 1,mesh%get_last_halo_cell(1)
      call poly1d_flux_code( nlayers,                     &
                             flux_proxy%data,             &
                             wind_proxy%data,             &
                             density_proxy%data,          &
                             flux_coeff_h,                &
                             ndf_w2,                      &
                             undf_w2,                     &
                             map_w2(:,cell),              &
                             basis_w2,                    &
                             ndf_w3,                      &
                             undf_w3,                     &
                             stencil_size,                &
                             stencil_map(:,:,cell),       &
                             order,                       &
                             nfaces_h,                    &
                             out_face_normal              &
                             )

  end do
  call flux_proxy%set_dirty()
  deallocate( basis_w2 )

end subroutine invoke_poly1d_flux

!-------------------------------------------------------------------------------
! Psy layer call to compute the horizontal advection coefficients for flux form
! advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
! 2) Needs two quadrature rules, one for volume integrals (supported by
!    PSyclone) and one for face quadrature (not supported by PSyclone): Issue
!    #195
! 3) Uses face quadrature: Issue #193
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_flux_coeffs( coeff, mdw3, chi, qr, qrf, order, stencil_extent, nfaces_h )

  use poly1d_flux_coeffs_kernel_mod, only: poly1d_flux_coeffs_code
  use stencil_dofmap_mod,            only: stencil_dofmap_type, STENCIL_CROSS
  implicit none

  integer(i_def), intent(in)          :: order, stencil_extent
  integer(i_def), intent(in)          :: nfaces_h
  type(field_type), intent(inout)     :: coeff(order+1,nfaces_h)
  type(field_type), intent(in)        :: chi(3), mdw3
  type(quadrature_xyoz_type), intent( in ) :: qr
  type(quadrature_face_type), intent( in ) :: qrf

  type(quadrature_xyoz_proxy_type) :: qr_proxy
  type(quadrature_face_proxy_type) :: qrf_proxy

  type( field_proxy_type )  :: chi_proxy(3), mdw3_proxy
  type( field_proxy_type )  :: coeff_proxy(order+1,nfaces_h)
  type(stencil_dofmap_type), pointer :: w3_stencil => null()
  type(stencil_dofmap_type), pointer :: wx_stencil => null()

  integer(i_def), pointer :: w3_stencil_map(:,:,:) => null()
  integer(i_def), pointer :: wx_stencil_map(:,:,:) => null()

  integer(i_def) :: undf_w3, ndf_w3
  integer(i_def) :: undf_wx, ndf_wx
  integer(i_def) :: df
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: w3_stencil_size, wx_stencil_size  
  integer(i_def) :: polynomial, direction, idx
  integer(i_def) :: dim_wx
  integer(i_def) :: nqp_h, nqp_v, nqp_f, nface
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), allocatable :: basis_wx(:,:,:,:), face_basis_wx(:,:,:,:)
  real(kind=r_def), pointer :: wqp_h(:) => null(), &
                               wqp_v(:) => null(), &
                               wqp_f(:,:) => null()

  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do
  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    chi_proxy(idx) = chi(idx)%get_proxy()
  end do
  mdw3_proxy = mdw3%get_proxy()

  ndf_w3  = coeff_proxy(1,1)%vspace%get_ndf()
  undf_w3 = coeff_proxy(1,1)%vspace%get_undf()

  ndf_wx  = chi_proxy(1)%vspace%get_ndf()
  undf_wx = chi_proxy(1)%vspace%get_undf()
  dim_wx  = chi_proxy(1)%vspace%get_dim_space()

  ! Pull out the quadrature
  qr_proxy = qr%get_quadrature_proxy()
  nqp_h = qr_proxy%np_xy
  nqp_v = qr_proxy%np_z
  wqp_h => qr_proxy%weights_xy
  wqp_v => qr_proxy%weights_z

  qrf_proxy = qrf%get_quadrature_proxy()
  nqp_f = qrf_proxy%np_xyz
  wqp_f => qrf_proxy%weights_xyz
  nface = qrf_proxy%nfaces

  ! Evaluate the basis functions in the volume
  allocate (basis_wx(dim_wx, ndf_wx,nqp_h,nqp_v))
  call qr%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, basis_wx)

  ! Evaluate the basis functions on the faces
  allocate (face_basis_wx(dim_wx, ndf_wx, nqp_f, nface))
  call qrf%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, face_basis_wx)

  nlayers = coeff_proxy(1,1)%vspace%get_nlayers()

  w3_stencil => coeff_proxy(1,1)%vspace%get_stencil_dofmap(STENCIL_CROSS, &
                                                           stencil_extent)
  w3_stencil_size = w3_stencil%get_size()
  w3_stencil_map => w3_stencil%get_whole_dofmap()

  wx_stencil => chi_proxy(1)%vspace%get_stencil_dofmap(STENCIL_CROSS, &
                                                       stencil_extent)
  wx_stencil_size = wx_stencil%get_size()
  wx_stencil_map => wx_stencil%get_whole_dofmap()

  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    if ( chi_proxy(idx)%is_dirty(depth=stencil_extent+1) ) &    
      call chi_proxy(idx)%halo_exchange(depth=stencil_extent+1)
  end do
  if ( mdw3_proxy%is_dirty(depth=stencil_extent+1) ) &    
    call mdw3_proxy%halo_exchange(depth=stencil_extent+1) 

  mesh => coeff(1,1)%get_mesh()
  do cell = 1,mesh%get_last_halo_cell(1)
      call poly1d_flux_coeffs_code( nlayers,                     &
                                    flux_coeff_h,                &
                                    mdw3_proxy%data,             &
                                    chi_proxy(1)%data,           &
                                    chi_proxy(2)%data,           &
                                    chi_proxy(3)%data,           &
                                    ndf_w3,                      &
                                    undf_w3,                     &
                                    w3_stencil_size,             &
                                    w3_stencil_map(:,:,cell),    &
                                    ndf_wx,                      &
                                    undf_wx,                     &
                                    wx_stencil_size,             &
                                    wx_stencil_map(:,:,cell),    &
                                    basis_wx,                    &
                                    face_basis_wx,               &
                                    order,                       &
                                    nfaces_h,                    &
                                    nqp_h, nqp_v, wqp_h, wqp_v,  &
                                    nface, nqp_f, wqp_f          &
                                  )
  end do
  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      do df = 1,undf_w3
        coeff_proxy(polynomial, direction)%data(df) = flux_coeff_h(polynomial, direction,df)
      end do
      call coeff_proxy(polynomial, direction)%set_dirty()
    end do
  end do

  deallocate( basis_wx, face_basis_wx )
end subroutine invoke_poly1d_flux_coeffs

!-------------------------------------------------------------------------------
! Psy layer call to apply the vertical advection coefficients for flux form
! advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_vert_flux( flux, wind, density, coeff, order, nfaces_v )

  use poly1d_vert_flux_kernel_mod,     only: poly1d_vert_flux_code
  use reference_element_mod,           only: reference_element_type

  implicit none

  type(field_type), intent(inout)      :: flux
  type(field_type), intent(in)         :: wind
  type(field_type), intent(in)         :: density
  integer(i_def), intent(in)           :: order
  integer(i_def), intent(in)           :: nfaces_v
  type(field_type), intent(in)         :: coeff(order+1,nfaces_v)
  
  class(reference_element_type), pointer :: reference_element => null()
  type( field_proxy_type )  :: flux_proxy, wind_proxy, density_proxy
  type( field_proxy_type )  :: coeff_proxy(order+1,nfaces_v)

  integer(i_def), pointer :: map_w2(:,:) => null()
  integer(i_def), pointer :: map_w3(:,:) => null()

  integer(i_def) :: undf_w3, ndf_w3
  integer(i_def) :: undf_w2, ndf_w2
  integer(i_def) :: df_w2, qp, df
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: direction, polynomial, idx
  integer(i_def) :: dim_w2
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), pointer :: nodes_w2(:,:) => null()
  real(kind=r_def), allocatable :: basis_w2(:,:,:)
  real(r_def), allocatable :: out_face_normal(:,:)
  logical(l_def) :: swap

  flux_proxy    = flux%get_proxy()
  wind_proxy    = wind%get_proxy()
  density_proxy = density%get_proxy()

  do direction = 1,nfaces_v
    do polynomial = 1,order+1
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do

  ndf_w3  = density_proxy%vspace%get_ndf()
  undf_w3 = density_proxy%vspace%get_undf()

  ndf_w2  = flux_proxy%vspace%get_ndf()
  undf_w2 = flux_proxy%vspace%get_undf()
  dim_w2  = flux_proxy%vspace%get_dim_space()
  nodes_w2 => flux_proxy%vspace%get_nodes()

  ! Evaluate the basis function
  allocate (basis_w2(dim_w2, ndf_w2, ndf_w2))
  do qp = 1, ndf_w2
    do df_w2 = 1, ndf_w2
      basis_w2(:,df_w2,qp) = wind_proxy%vspace%call_function(BASIS,df_w2,nodes_w2(:,qp))
    end do
  end do

  nlayers = flux_proxy%vspace%get_nlayers()

  map_w3 => density_proxy%vspace%get_whole_dofmap()
  map_w2 => flux_proxy%vspace%get_whole_dofmap()

  if(wind_proxy%is_dirty(depth=1) ) &
    call wind_proxy%halo_exchange(depth=1)

  if(density_proxy%is_dirty(depth=1) ) &
    call density_proxy%halo_exchange(depth=1)

  if(flux_proxy%is_dirty(depth=1) ) &
    call flux_proxy%halo_exchange(depth=1)

  swap = .false.
  do direction = 1,nfaces_v
    do polynomial = 1,order+1
      if(coeff_proxy(polynomial, direction)%is_dirty(depth=1) ) then
        call coeff_proxy(polynomial, direction)%halo_exchange(depth=1)
        swap = .true.
      end if
    end do
  end do

  ! Make sure module array has the correct halo swapped values
  if ( swap ) then
    do df = 1,undf_w3
      do direction = 1,nfaces_v
        do polynomial = 1,order+1
          flux_coeff_v(polynomial, direction,df) = coeff_proxy(polynomial, direction)%data(df)
        end do
      end do
    end do
  end if

  mesh => flux%get_mesh()
  reference_element => mesh%get_reference_element()
  call reference_element%get_normals_to_out_faces( out_face_normal )

  do cell = 1,mesh%get_last_halo_cell(1)
      call poly1d_vert_flux_code( nlayers,                     &
                                  flux_proxy%data,             &
                                  wind_proxy%data,             &
                                  density_proxy%data,          &
                                  flux_coeff_v,                &
                                  ndf_w2,                      &
                                  undf_w2,                     &
                                  map_w2(:,cell),              &
                                  basis_w2,                    &
                                  ndf_w3,                      &
                                  undf_w3,                     &
                                  map_w3(:,cell),              &
                                  order,                       &
                                  nfaces_v,                    &
                                  out_face_normal              &
                                 )

  end do
  call flux_proxy%set_dirty()
  deallocate( basis_w2 )
end subroutine invoke_poly1d_vert_flux

!-------------------------------------------------------------------------------
! Psy layer call to compute the vertical advection coefficients for flux form
! advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
! 2) Needs two quadrature rules, one for volume integrals (supported by
!    PSyclone) and one for face quadrature (not supported by PSyclone): Issue
!    #195
! 3) Uses face quadrature: Issue #193
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_vert_flux_coeffs( coeff, mdw3, chi, qr, qrf, order, nfaces_v )

  use poly1d_vert_flux_coeffs_kernel_mod, only: poly1d_vert_flux_coeffs_code
  implicit none

  integer(i_def), intent(in)          :: order
  integer(i_def), intent(in)          :: nfaces_v
  type(field_type), intent(inout)     :: coeff(order+1,nfaces_v)
  type(field_type), intent(in)        :: chi(3), mdw3
  type(quadrature_xyoz_type), intent( in ) :: qr
  type(quadrature_face_type), intent( in ) :: qrf

  type(quadrature_xyoz_proxy_type) :: qr_proxy
  type(quadrature_face_proxy_type) :: qrf_proxy

  type( field_proxy_type )  :: chi_proxy(3), mdw3_proxy
  type( field_proxy_type )  :: coeff_proxy(order+1,nfaces_v)

  integer(i_def), pointer :: map_w3(:,:) => null()
  integer(i_def), pointer :: map_wx(:,:) => null()

  integer(i_def) :: undf_w3, ndf_w3
  integer(i_def) :: undf_wx, ndf_wx
  integer(i_def) :: df
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: polynomial, direction, idx
  integer(i_def) :: dim_wx
  integer(i_def) :: nqp_h, nqp_v, nqp_f, nface
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), allocatable :: basis_wx(:,:,:,:), face_basis_wx(:,:,:,:)
  real(kind=r_def), pointer :: wqp_h(:) => null(), &
                               wqp_v(:) => null(), &
                               wqp_f(:,:) => null()

  do direction = 1,nfaces_v
    do polynomial = 1,order+1
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do
  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    chi_proxy(idx) = chi(idx)%get_proxy()
  end do
  mdw3_proxy = mdw3%get_proxy()

  ndf_w3  = coeff_proxy(1,1)%vspace%get_ndf()
  undf_w3 = coeff_proxy(1,1)%vspace%get_undf()

  ndf_wx  = chi_proxy(1)%vspace%get_ndf()
  undf_wx = chi_proxy(1)%vspace%get_undf()
  dim_wx  = chi_proxy(1)%vspace%get_dim_space()

  ! Pull out the quadrature
  qr_proxy = qr%get_quadrature_proxy()
  nqp_h = qr_proxy%np_xy
  nqp_v = qr_proxy%np_z
  wqp_h => qr_proxy%weights_xy
  wqp_v => qr_proxy%weights_z

  qrf_proxy = qrf%get_quadrature_proxy()
  nqp_f = qrf_proxy%np_xyz
  wqp_f => qrf_proxy%weights_xyz
  nface = qrf_proxy%nfaces

  ! Evaluate the basis functions in the volume
  allocate (basis_wx(dim_wx, ndf_wx, nqp_h, nqp_v))
  call qr%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, basis_wx)

  ! Evaluate the basis functions on the faces
  allocate (face_basis_wx(dim_wx, ndf_wx, nqp_f, nface))
  call qrf%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, face_basis_wx)

  nlayers = coeff_proxy(1,1)%vspace%get_nlayers()

  map_w3 => coeff_proxy(1,1)%vspace%get_whole_dofmap()
  map_wx => chi_proxy(1)%vspace%get_whole_dofmap()

  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    if ( chi_proxy(idx)%is_dirty(depth=1) ) &    
      call chi_proxy(idx)%halo_exchange(depth=1)
  end do
  if ( mdw3_proxy%is_dirty(depth=1) ) &    
    call mdw3_proxy%halo_exchange(depth=1) 

  mesh => coeff(1,1)%get_mesh()
  do cell = 1,mesh%get_last_halo_cell(1)
      call poly1d_vert_flux_coeffs_code( nlayers,                     &
                                         flux_coeff_v,                &
                                         mdw3_proxy%data,             &
                                         chi_proxy(1)%data,           &
                                         chi_proxy(2)%data,           &
                                         chi_proxy(3)%data,           &
                                         ndf_w3,                      &
                                         undf_w3,                     &
                                         map_w3(:,cell),              &
                                         ndf_wx,                      &
                                         undf_wx,                     &
                                         map_wx(:,cell),              &
                                         basis_wx,                    &
                                         face_basis_wx,               &
                                         order,                       &
                                         nfaces_v,                    &
                                         nqp_h, nqp_v, wqp_h, wqp_v,  &
                                         nface, nqp_f, wqp_f          &
                                        )

  end do
  do direction = 1,nfaces_v
    do polynomial = 1,order+1
      do df = 1,undf_w3
        coeff_proxy(polynomial, direction)%data(df) = flux_coeff_v(polynomial, direction,df)
      end do
      call coeff_proxy(polynomial, direction)%set_dirty()
    end do
  end do

  deallocate( basis_wx, face_basis_wx )
end subroutine invoke_poly1d_vert_flux_coeffs

!-------------------------------------------------------------------------------
! Psy layer call to apply the horizontal advection coefficients for advective 
! form advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105 
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_adv_recon( reconstruction, wind, tracer, coeff, order, stencil_extent, nfaces_h )

  use poly1d_adv_recon_kernel_mod,     only: poly1d_adv_recon_code
  use stencil_dofmap_mod,              only: stencil_dofmap_type, STENCIL_CROSS
  use reference_element_mod,           only: reference_element_type

  implicit none

  type(field_type), intent(inout)      :: reconstruction
  type(field_type), intent(in)         :: wind
  type(field_type), intent(in)         :: tracer
  integer(i_def), intent(in)           :: order
  integer(i_def), intent(in)           :: stencil_extent
  integer(i_def), intent(in)           :: nfaces_h
  type(field_type), intent(in)         :: coeff(order+1,nfaces_h)
  
  class(reference_element_type), pointer :: reference_element => null()
  type( field_proxy_type )  :: recon_proxy, wind_proxy, tracer_proxy
  type( field_proxy_type )  :: coeff_proxy(order+1,nfaces_h)
  type(stencil_dofmap_type), pointer :: stencil => null()

  integer(i_def), pointer :: map_w1(:,:)        => null()
  integer(i_def), pointer :: map_w2(:,:)        => null()
  integer(i_def), pointer :: stencil_map(:,:,:) => null()

  integer(i_def) :: undf_wt, ndf_wt
  integer(i_def) :: undf_w2, ndf_w2
  integer(i_def) :: undf_w1, ndf_w1
  integer(i_def) :: df_w2, qp, df
  integer(i_def) :: cell
  integer(i_def) :: nlayers, stencil_size
  integer(i_def) :: direction, polynomial, idx
  integer(i_def) :: dim_w2
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), pointer :: nodes_w1(:,:) => null()
  real(kind=r_def), allocatable :: basis_w2(:,:,:)
  real(r_def), allocatable :: out_face_normal(:,:)
  logical(l_def) :: swap

  recon_proxy  = reconstruction%get_proxy()
  wind_proxy   = wind%get_proxy()
  tracer_proxy = tracer%get_proxy()

  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do

  ndf_w1  = recon_proxy%vspace%get_ndf()
  undf_w1 = recon_proxy%vspace%get_undf()
  nodes_w1 => recon_proxy%vspace%get_nodes()

  ndf_wt  = tracer_proxy%vspace%get_ndf()
  undf_wt = tracer_proxy%vspace%get_undf()

  ndf_w2  = wind_proxy%vspace%get_ndf()
  undf_w2 = wind_proxy%vspace%get_undf()
  dim_w2  = wind_proxy%vspace%get_dim_space()

  ! Evaluate the basis function
  allocate (basis_w2(dim_w2, ndf_w2, ndf_w1))
  do qp = 1, ndf_w1
    do df_w2 = 1, ndf_w2
      basis_w2(:,df_w2,qp) = wind_proxy%vspace%call_function(BASIS,df_w2,nodes_w1(:,qp))
    end do
  end do

  nlayers = recon_proxy%vspace%get_nlayers()

  stencil => tracer_proxy%vspace%get_stencil_dofmap(STENCIL_CROSS, stencil_extent)
  stencil_size = stencil%get_size()
  stencil_map => stencil%get_whole_dofmap()
  map_w2 => wind_proxy%vspace%get_whole_dofmap()
  map_w1 => recon_proxy%vspace%get_whole_dofmap()

  if(recon_proxy%is_dirty(depth=1) ) &
    call recon_proxy%halo_exchange(depth=1)

  if(wind_proxy%is_dirty(depth=1) ) &
    call wind_proxy%halo_exchange(depth=1)

  if(tracer_proxy%is_dirty(depth=stencil_extent+1) ) &
    call tracer_proxy%halo_exchange(depth=stencil_extent+1)

  swap = .false.
  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      if(coeff_proxy(polynomial, direction)%is_dirty(depth=1) ) then
        call coeff_proxy(polynomial, direction)%halo_exchange(depth=1)
        swap = .true.
      end if
    end do
  end do

  ! Make sure module array has the correct halo swapped values
  if ( swap ) then
    do df = 1,undf_wt
      do direction = 1,nfaces_h
        do polynomial = 1,order+1
          adv_coeff_h(polynomial, direction,df) = coeff_proxy(polynomial, direction)%data(df)
        end do
      end do
    end do
  end if

  mesh => reconstruction%get_mesh()
  reference_element => mesh%get_reference_element()
  call reference_element%get_normals_to_out_faces( out_face_normal )

  do cell = 1,mesh%get_last_halo_cell(1)
      call poly1d_adv_recon_code( nlayers,                     &
                                  recon_proxy%data,            &
                                  wind_proxy%data,             &
                                  tracer_proxy%data,           &
                                  adv_coeff_h,                 &
                                  ndf_w1,                      &
                                  undf_w1,                     &
                                  map_w1(:,cell),              &
                                  ndf_w2,                      &
                                  undf_w2,                     &
                                  map_w2(:,cell),              &
                                  basis_w2,                    &
                                  ndf_wt,                      &
                                  undf_wt,                     &
                                  stencil_size,                &
                                  stencil_map(:,:,cell),       &
                                  order,                       &
                                  nfaces_h,                    &
                                  out_face_normal              &
                                  )

  end do
  call recon_proxy%set_dirty()
  deallocate( basis_w2 )

end subroutine invoke_poly1d_adv_recon

!-------------------------------------------------------------------------------
! Psy layer call to compute the horizontal advection coefficients for advective 
! form advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
! 2) Needs two quadrature rules, one for volume integrals (supported by
!    PSyclone) and one for face quadrature (not supported by PSyclone): Issue
!    #195
! 3) Uses edge quadrature: Issue #193
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_advective_coeffs( coeff, mdwt, chi, qr, qre, order, stencil_extent, nfaces_h )

  use poly1d_advective_coeffs_kernel_mod, only: poly1d_advective_coeffs_code
  use stencil_dofmap_mod,                 only: stencil_dofmap_type, STENCIL_CROSS
  implicit none

  integer(i_def),   intent(in)        :: order, stencil_extent, nfaces_h
  type(field_type), intent(inout)     :: coeff(order+1,nfaces_h)
  type(field_type), intent(in)        :: chi(3), mdwt
  type(quadrature_xyoz_type), intent( in ) :: qr
  type(quadrature_edge_type), intent( in ) :: qre

  type(quadrature_xyoz_proxy_type) :: qr_proxy
  type(quadrature_edge_proxy_type) :: qre_proxy

  type( field_proxy_type )  :: chi_proxy(3), mdwt_proxy
  type( field_proxy_type )  :: coeff_proxy(order+1,nfaces_h)
  type(stencil_dofmap_type), pointer :: wt_stencil => null()
  type(stencil_dofmap_type), pointer :: wx_stencil => null()

  integer(i_def), pointer :: wt_stencil_map(:,:,:) => null()
  integer(i_def), pointer :: wx_stencil_map(:,:,:) => null()

  integer(i_def) :: undf_wt, ndf_wt
  integer(i_def) :: undf_wx, ndf_wx
  integer(i_def) :: df
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: wt_stencil_size, wx_stencil_size  
  integer(i_def) :: polynomial, direction, idx
  integer(i_def) :: dim_wx
  integer(i_def) :: nqp_h, nqp_v, nqp_e, nedge
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), allocatable :: basis_wx(:,:,:,:), edge_basis_wx(:,:,:,:)
  real(kind=r_def), pointer :: wqp_v(:) => null(),  wqp_h(:) => null(), wqp_e(:,:) => null()

  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do
  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    chi_proxy(idx) = chi(idx)%get_proxy()
  end do
  mdwt_proxy = mdwt%get_proxy()

  ndf_wt  = coeff_proxy(1,1)%vspace%get_ndf()
  undf_wt = coeff_proxy(1,1)%vspace%get_undf()

  ndf_wx  = chi_proxy(1)%vspace%get_ndf()
  undf_wx = chi_proxy(1)%vspace%get_undf()
  dim_wx  = chi_proxy(1)%vspace%get_dim_space()

  ! Pull out the quadrature
  qr_proxy = qr%get_quadrature_proxy()
  nqp_h = qr_proxy%np_xy
  nqp_v = qr_proxy%np_z
  wqp_h => qr_proxy%weights_xy
  wqp_v => qr_proxy%weights_z

  qre_proxy = qre%get_quadrature_proxy()
  nqp_e = qre_proxy%np_xyz
  wqp_e => qre_proxy%weights_xyz
  nedge = qre_proxy%nedges

  ! Evaluate the basis functions in the volume
  allocate (basis_wx(dim_wx, ndf_wx, nqp_h, nqp_v))
  call qr%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, basis_wx)

  ! Evaluate the basis functions on the edges
  allocate( edge_basis_wx(dim_wx,ndf_wx,nqp_e,nedge))
  call qre%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, edge_basis_wx)

  nlayers = coeff_proxy(1,1)%vspace%get_nlayers()

  wt_stencil => coeff_proxy(1,1)%vspace%get_stencil_dofmap(STENCIL_CROSS, &
                                                           stencil_extent)
  wt_stencil_size = wt_stencil%get_size()
  wt_stencil_map => wt_stencil%get_whole_dofmap()

  wx_stencil => chi_proxy(1)%vspace%get_stencil_dofmap(STENCIL_CROSS, &
                                                       stencil_extent)
  wx_stencil_size = wx_stencil%get_size()
  wx_stencil_map => wx_stencil%get_whole_dofmap()

  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    if ( chi_proxy(idx)%is_dirty(depth=stencil_extent+1) ) &    
      call chi_proxy(idx)%halo_exchange(depth=stencil_extent+1)
  end do
  if ( mdwt_proxy%is_dirty(depth=stencil_extent+1) ) &    
    call mdwt_proxy%halo_exchange(depth=stencil_extent+1) 

  mesh => coeff(1,1)%get_mesh()
  do cell = 1,mesh%get_last_halo_cell(1)
      call poly1d_advective_coeffs_code( nlayers,                     &
                                         adv_coeff_h,                 &
                                         mdwt_proxy%data,             &
                                         chi_proxy(1)%data,           &
                                         chi_proxy(2)%data,           &
                                         chi_proxy(3)%data,           &
                                         ndf_wt,                      &
                                         undf_wt,                     &
                                         wt_stencil_size,             &
                                         wt_stencil_map(:,:,cell),    &
                                         ndf_wx,                      &
                                         undf_wx,                     &
                                         wx_stencil_size,             &
                                         wx_stencil_map(:,:,cell),    &
                                         basis_wx,                    &
                                         edge_basis_wx,               &
                                         order,                       &
                                         nfaces_h,                    &
                                         nqp_h, nqp_v, wqp_h, wqp_v,  &
                                         nedge, nqp_e, wqp_e          &
                                       )
  end do
  do direction = 1,nfaces_h
    do polynomial = 1,order+1
      do df = 1,undf_wt
        coeff_proxy(polynomial, direction)%data(df) = adv_coeff_h(polynomial, direction,df)
      end do
      call coeff_proxy(polynomial, direction)%set_dirty()
    end do
  end do

  deallocate( basis_wx, edge_basis_wx )
end subroutine invoke_poly1d_advective_coeffs

!-------------------------------------------------------------------------------
! Psy layer call to apply the horizontal advection coefficients for advective 
! form advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
! 2) Uses a REGION stencil that requires the local size to be passed to the
!    kernel: Issue #193
!-------------------------------------------------------------------------------
subroutine invoke_poly2d_adv_recon( reconstruction, wind, tracer, coeff, order, stencil_size, nfaces_h )

  use poly2d_adv_recon_kernel_mod,     only: poly2d_adv_recon_code
  use stencil_dofmap_mod,              only: stencil_dofmap_type, STENCIL_REGION
  use reference_element_mod,           only: reference_element_type

  implicit none

  type(field_type), intent(inout)      :: reconstruction
  type(field_type), intent(in)         :: wind
  type(field_type), intent(in)         :: tracer
  integer(i_def), intent(in)           :: order
  integer(i_def), intent(in)           :: stencil_size
  integer(i_def), intent(in)           :: nfaces_h
  type(field_type), intent(in)         :: coeff(stencil_size,nfaces_h)
  
  class(reference_element_type), pointer :: reference_element => null()
  type( field_proxy_type )  :: recon_proxy, wind_proxy, tracer_proxy
  type( field_proxy_type )  :: coeff_proxy(stencil_size,nfaces_h)
  type(stencil_dofmap_type), pointer :: stencil => null()

  integer(i_def), pointer :: map_w1(:,:)        => null()
  integer(i_def), pointer :: map_w2(:,:)        => null()
  integer(i_def), pointer :: stencil_map(:,:,:) => null()

  integer(i_def) :: undf_wt, ndf_wt
  integer(i_def) :: undf_w2, ndf_w2
  integer(i_def) :: undf_w1, ndf_w1
  integer(i_def) :: df_w2, qp, df
  integer(i_def) :: cell
  integer(i_def) :: nlayers, stencil_extent, cells_in_stencil
  integer(i_def) :: direction, polynomial, idx
  integer(i_def) :: dim_w2
  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), pointer :: nodes_w1(:,:) => null()
  real(kind=r_def), allocatable :: basis_w2(:,:,:)
  real(r_def), allocatable :: out_face_normal(:,:)
  logical(l_def) :: swap

  recon_proxy  = reconstruction%get_proxy()
  wind_proxy   = wind%get_proxy()
  tracer_proxy = tracer%get_proxy()

  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do

  ndf_w1  = recon_proxy%vspace%get_ndf()
  undf_w1 = recon_proxy%vspace%get_undf()
  nodes_w1 => recon_proxy%vspace%get_nodes()

  ndf_wt  = tracer_proxy%vspace%get_ndf()
  undf_wt = tracer_proxy%vspace%get_undf()

  ndf_w2  = wind_proxy%vspace%get_ndf()
  undf_w2 = wind_proxy%vspace%get_undf()
  dim_w2  = wind_proxy%vspace%get_dim_space()

  ! Evaluate the basis function
  allocate (basis_w2(dim_w2, ndf_w2, ndf_w1))
  do qp = 1, ndf_w1
    do df_w2 = 1, ndf_w2
      basis_w2(:,df_w2,qp) = wind_proxy%vspace%call_function(BASIS,df_w2,nodes_w1(:,qp))
    end do
  end do

  nlayers = recon_proxy%vspace%get_nlayers()

  stencil_extent = order/2
  stencil => tracer_proxy%vspace%get_stencil_dofmap(STENCIL_REGION, &
                                                    order)
  stencil_map => stencil%get_whole_dofmap()
  map_w2 => wind_proxy%vspace%get_whole_dofmap()
  map_w1 => recon_proxy%vspace%get_whole_dofmap()

  if(recon_proxy%is_dirty(depth=1) ) &
    call recon_proxy%halo_exchange(depth=1)

  if(wind_proxy%is_dirty(depth=1) ) &
    call wind_proxy%halo_exchange(depth=1)

  if(tracer_proxy%is_dirty(depth=stencil_extent+1) ) &
    call tracer_proxy%halo_exchange(depth=stencil_extent+1)

  swap = .false.
  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      if(coeff_proxy(polynomial, direction)%is_dirty(depth=1) ) then
        call coeff_proxy(polynomial, direction)%halo_exchange(depth=1)
        swap = .true.
      end if
    end do
  end do

  ! Make sure module array has the correct halo swapped values
  if ( swap ) then
    do df = 1,undf_wt
      do direction = 1,nfaces_h
        do polynomial = 1,stencil_size
          adv_coeff_h(polynomial, direction,df) = coeff_proxy(polynomial, direction)%data(df)
        end do
      end do
    end do
  end if

  mesh => reconstruction%get_mesh()
  reference_element => mesh%get_reference_element()
  call reference_element%get_normals_to_out_faces( out_face_normal )

  do cell = 1,mesh%get_last_halo_cell(1)
      cells_in_stencil = stencil%get_local_size(cell)
      call poly2d_adv_recon_code( nlayers,                     &
                                  recon_proxy%data,            &
                                  wind_proxy%data,             &
                                  tracer_proxy%data,           &
                                  adv_coeff_h,                 &
                                  ndf_w1,                      &
                                  undf_w1,                     &
                                  map_w1(:,cell),              &
                                  ndf_w2,                      &
                                  undf_w2,                     &
                                  map_w2(:,cell),              &
                                  basis_w2,                    &
                                  ndf_wt,                      &
                                  undf_wt,                     &
                                  stencil_size,                &
                                  stencil_map(:,:,cell),       &
                                  cells_in_stencil,            &
                                  nfaces_h,                    &
                                  out_face_normal              &
                                  )

  end do
  call recon_proxy%set_dirty()
  deallocate( basis_w2 )

end subroutine invoke_poly2d_adv_recon

!-------------------------------------------------------------------------------
! Psy layer call to compute the horizontal advection coefficients for advective 
! form advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
! 2) Uses a REGION stencil that requires the local size to be passed to the
!    kernel: Issue #194
! 3) Needs two quadrature rules, one for volume integrals (supported by
!    PSyclone) and one for face quadrature (not supported by PSyclone): Issue
!    #195
! 4) Uses edge quadrature: Issue #193
!-------------------------------------------------------------------------------
subroutine invoke_poly2d_advective_coeffs( coeff, mdwt, chi, qr, qre, order, stencil_size, nfaces_h )

  use poly2d_advective_coeffs_kernel_mod, only: poly2d_advective_coeffs_code
  use stencil_dofmap_mod,                only: stencil_dofmap_type, STENCIL_REGION
  implicit none

  integer(i_def), intent(in)          :: order
  integer(i_def), intent(in)          :: stencil_size
  integer(i_def), intent(in)          :: nfaces_h
  type(field_type), intent(inout)     :: coeff(stencil_size,nfaces_h)
  type(field_type), intent(in)        :: chi(3), mdwt
  type(quadrature_xyoz_type), intent( in ) :: qr
  type(quadrature_edge_type), intent( in ) :: qre

  type(quadrature_xyoz_proxy_type) :: qr_proxy
  type(quadrature_edge_proxy_type) :: qre_proxy

  type( field_proxy_type )  :: chi_proxy(3), mdwt_proxy
  type( field_proxy_type )  :: coeff_proxy(stencil_size,nfaces_h)
  type(stencil_dofmap_type), pointer :: wt_stencil => null()
  type(stencil_dofmap_type), pointer :: wx_stencil => null()

  integer(i_def), pointer :: wt_stencil_map(:,:,:) => null()
  integer(i_def), pointer :: wx_stencil_map(:,:,:) => null()

  integer(i_def) :: undf_wt, ndf_wt
  integer(i_def) :: undf_wx, ndf_wx
  integer(i_def) :: df
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: wt_stencil_size, wx_stencil_size  
  integer(i_def) :: polynomial, direction, idx
  integer(i_def) :: dim_wx
  integer(i_def) :: stencil_extent, cells_in_stencil
  integer(i_def) :: nqp_h, nqp_v, nqp_e, nedge

  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), allocatable :: basis_wx(:,:,:,:), edge_basis_wx(:,:,:,:)
  real(kind=r_def), pointer :: wqp_h(:) => null(), &
                               wqp_v(:) => null(), &
                               wqp_e(:,:) => null()

  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do
  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    chi_proxy(idx) = chi(idx)%get_proxy()
  end do
  mdwt_proxy = mdwt%get_proxy()

  ndf_wt  = coeff_proxy(1,1)%vspace%get_ndf()
  undf_wt = coeff_proxy(1,1)%vspace%get_undf()

  ndf_wx  = chi_proxy(1)%vspace%get_ndf()
  undf_wx = chi_proxy(1)%vspace%get_undf()
  dim_wx  = chi_proxy(1)%vspace%get_dim_space()

  ! Pull out the quadrature
  qr_proxy = qr%get_quadrature_proxy()
  nqp_h = qr_proxy%np_xy
  nqp_v = qr_proxy%np_z
  wqp_h => qr_proxy%weights_xy
  wqp_v => qr_proxy%weights_z

  qre_proxy = qre%get_quadrature_proxy()
  nqp_e = qre_proxy%np_xyz
  wqp_e => qre_proxy%weights_xyz
  nedge = qre_proxy%nedges
  ! Evaluate the basis functions in the volume
  allocate (basis_wx(dim_wx, ndf_wx, nqp_h, nqp_v))
  call qr%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, basis_wx)

  ! Evaluate the basis functions on the faces
  allocate( edge_basis_wx(dim_wx,ndf_wx,nqp_e,nedge))
  call qre%compute_function(BASIS, chi_proxy(1)%vspace, dim_wx, ndf_wx, edge_basis_wx)

  nlayers = coeff_proxy(1,1)%vspace%get_nlayers()

  stencil_extent = order/2

  wt_stencil => coeff_proxy(1,1)%vspace%get_stencil_dofmap(STENCIL_REGION, &
                                                           order)
  wt_stencil_size = wt_stencil%get_size()
  wt_stencil_map => wt_stencil%get_whole_dofmap()

  wx_stencil => chi_proxy(1)%vspace%get_stencil_dofmap(STENCIL_REGION, &
                                                       order)
  wx_stencil_size = wx_stencil%get_size()
  wx_stencil_map => wx_stencil%get_whole_dofmap()

  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    if ( chi_proxy(idx)%is_dirty(depth=stencil_extent+1) ) &    
      call chi_proxy(idx)%halo_exchange(depth=stencil_extent+1)
  end do
  if ( mdwt_proxy%is_dirty(depth=stencil_extent+1) )  &
    call mdwt_proxy%halo_exchange(depth=stencil_extent+1)

  mesh => coeff(1,1)%get_mesh()
  do cell = 1,mesh%get_last_halo_cell(1)
      cells_in_stencil = wt_stencil%get_local_size(cell)
      call poly2d_advective_coeffs_code( nlayers,                     &
                                         adv_coeff_h,                 &
                                         mdwt_proxy%data,             &
                                         chi_proxy(1)%data,           &
                                         chi_proxy(2)%data,           &
                                         chi_proxy(3)%data,           &
                                         ndf_wt,                      &
                                         undf_wt,                     &
                                         wt_stencil_size,             &
                                         wt_stencil_map(:,:,cell),    &
                                         ndf_wx,                      &
                                         undf_wx,                     &
                                         wx_stencil_size,             &
                                         wx_stencil_map(:,:,cell),    &
                                         basis_wx,                    &
                                         edge_basis_wx,               &
                                         order,                       &
                                         nfaces_h,                    &
                                         cells_in_stencil,            &
                                         nqp_h, nqp_v, wqp_h, wqp_v,  &
                                         nedge, nqp_e, wqp_e          &
                                       )

  end do
  do direction = 1,nfaces_h
    do polynomial = 1,stencil_size
      do df = 1,undf_wt
        coeff_proxy(polynomial, direction)%data(df) = adv_coeff_h(polynomial, direction,df)
      end do
      call coeff_proxy(polynomial, direction)%set_dirty()
    end do
  end do
  deallocate( basis_wx, edge_basis_wx )
end subroutine invoke_poly2d_advective_coeffs

!-------------------------------------------------------------------------------
! Psy layer call to apply the vertical advection coefficients for advective 
! form advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_vert_adv_coeffs( coeff, mdwt, chi, order, nfaces_v )

  use poly1d_vert_adv_coeffs_kernel_mod, only: poly1d_vert_adv_coeffs_code
  implicit none

  integer(i_def),   intent(in)        :: order, nfaces_v
  type(field_type), intent(inout)     :: coeff(order+2,nfaces_v)
  type(field_type), intent(in)        :: chi(3), mdwt

  type( field_proxy_type )  :: chi_proxy(3), mdwt_proxy
  type( field_proxy_type )  :: coeff_proxy(order+2,nfaces_v)

  integer(i_def), pointer :: map_wt(:,:) => null()
  integer(i_def), pointer :: map_wx(:,:) => null()

  integer(i_def) :: undf_wt, ndf_wt
  integer(i_def) :: undf_wx, ndf_wx
  integer(i_def) :: df, dft
  integer(i_def) :: cell
  integer(i_def) :: nlayers
  integer(i_def) :: polynomial, direction, idx
  integer(i_def) :: dim_wx

  type(mesh_type), pointer :: mesh => null()
  real(kind=r_def), allocatable :: basis_wx(:,:,:)
  real(kind=r_def), pointer :: nodes(:,:) => null()

  do direction = 1,nfaces_v
    do polynomial = 1,order+2
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do
  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    chi_proxy(idx) = chi(idx)%get_proxy()
  end do
  mdwt_proxy = mdwt%get_proxy()

  ndf_wt  = coeff_proxy(1,1)%vspace%get_ndf()
  undf_wt = coeff_proxy(1,1)%vspace%get_undf()
  nodes => coeff_proxy(1,1)%vspace%get_nodes()

  ndf_wx  = chi_proxy(1)%vspace%get_ndf()
  undf_wx = chi_proxy(1)%vspace%get_undf()
  dim_wx  = chi_proxy(1)%vspace%get_dim_space()

  allocate (basis_wx(dim_wx, ndf_wx, ndf_wt))
  do dft = 1,ndf_wt
    do df = 1,ndf_wx
      basis_wx(:,df,dft) = chi_proxy(1)%vspace%call_function(BASIS,df,nodes(:,dft))
    end do
  end do

  nlayers = coeff_proxy(1,1)%vspace%get_nlayers()

  map_wt => coeff_proxy(1,1)%vspace%get_whole_dofmap()
  map_wx => chi_proxy(1)%vspace%get_whole_dofmap()

  ! Since chi is described as a field vector of length 3 in the kernel metadata
  ! then we loop over all 3 proxies
  do idx = 1,3
    if ( chi_proxy(idx)%is_dirty(depth=1) ) &    
      call chi_proxy(idx)%halo_exchange(depth=1)
  end do
  if ( mdwt_proxy%is_dirty(depth=1) ) &    
    call mdwt_proxy%halo_exchange(depth=1) 

  mesh => coeff(1,1)%get_mesh()
  do cell = 1,mesh%get_last_edge_cell()
      call poly1d_vert_adv_coeffs_code( nlayers,                     &
                                        adv_coeff_v,                 &
                                        mdwt_proxy%data,             &
                                        chi_proxy(1)%data,           &
                                        chi_proxy(2)%data,           &
                                        chi_proxy(3)%data,           &
                                        ndf_wt,                      &
                                        undf_wt,                     &
                                        map_wt(:,cell),              &
                                        ndf_wx,                      &
                                        undf_wx,                     &
                                        map_wx(:,cell),              &
                                        basis_wx,                    &
                                        order,                       &
                                        nfaces_v                     &
                                        )

  end do
  do direction = 1,nfaces_v
    do polynomial = 1,order+2
      do df = 1,undf_wt
        coeff_proxy(polynomial, direction)%data(df) = adv_coeff_v(polynomial, direction,df)
      end do
      call coeff_proxy(polynomial, direction)%set_dirty()
    end do
  end do

  deallocate( basis_wx )
end subroutine invoke_poly1d_vert_adv_coeffs

!-------------------------------------------------------------------------------
! Psy layer call to compute the vertical advection coefficients for advective 
! form advection. This can not currently be generated by PSyclone because
! 1) Uses a runtime specified 2D array of fields (coeff): Ticket #1104 & #1105
! 2) Needs two quadrature rules, one for volume integrals (supported by
!    PSyclone) and one for face quadrature (not supported by PSyclone): Issue
!    #195
!-------------------------------------------------------------------------------
subroutine invoke_poly1d_vert_adv( advective, wind, tracer, coeff, order, nfaces_v )

  use poly1d_vert_adv_kernel_mod, only: poly1d_vert_adv_code

  implicit none

  type(field_type), intent(inout)      :: advective
  type(field_type), intent(in)         :: wind
  type(field_type), intent(in)         :: tracer
  integer(i_def),   intent(in)         :: order
  integer(i_def),   intent(in)         :: nfaces_v
  type(field_type), intent(in)         :: coeff(order+2,nfaces_v)
  
  type( field_proxy_type )  :: adv_proxy, wind_proxy, tracer_proxy
  type( field_proxy_type )  :: coeff_proxy(order+2,nfaces_v)

  integer(i_def), pointer :: map_w2(:,:) => null()
  integer(i_def), pointer :: map_wt(:,:) => null()

  integer(i_def) :: undf_wt, ndf_wt
  integer(i_def) :: undf_w2, ndf_w2
  integer(i_def) :: cell, df
  integer(i_def) :: nlayers
  integer(i_def) :: direction, polynomial, idx
  type(mesh_type), pointer :: mesh => null()
  logical(l_def) :: swap

  adv_proxy    = advective%get_proxy()
  wind_proxy   = wind%get_proxy()
  tracer_proxy = tracer%get_proxy()

  do direction = 1,nfaces_v
    do polynomial = 1,order+2
      coeff_proxy(polynomial, direction) = coeff(polynomial, direction)%get_proxy()
    end do
  end do

  ndf_wt  = tracer_proxy%vspace%get_ndf()
  undf_wt = tracer_proxy%vspace%get_undf()

  ndf_w2  = wind_proxy%vspace%get_ndf()
  undf_w2 = wind_proxy%vspace%get_undf()

  nlayers = adv_proxy%vspace%get_nlayers()

  map_wt => adv_proxy%vspace%get_whole_dofmap()
  map_w2 => wind_proxy%vspace%get_whole_dofmap()

  if(wind_proxy%is_dirty(depth=1) ) &
    call wind_proxy%halo_exchange(depth=1)

  if(tracer_proxy%is_dirty(depth=1) ) &
    call tracer_proxy%halo_exchange(depth=1)

  if(adv_proxy%is_dirty(depth=1) ) &
    call adv_proxy%halo_exchange(depth=1)

  swap = .false.
  do direction = 1,nfaces_v
    do polynomial = 1,order+2
      if(coeff_proxy(polynomial, direction)%is_dirty(depth=1) ) then
        call coeff_proxy(polynomial, direction)%halo_exchange(depth=1)
        swap = .true.
      end if
    end do
  end do

  ! Make sure module array has the correct halo swapped values
  if ( swap ) then
    do df = 1,undf_wt
      do direction = 1,nfaces_v
        do polynomial = 1,order+2
          adv_coeff_v(polynomial, direction,df) = coeff_proxy(polynomial, direction)%data(df)
        end do
      end do
    end do
  end if

  mesh => advective%get_mesh()
  do cell = 1,mesh%get_last_edge_cell()
      call poly1d_vert_adv_code( nlayers,                     &
                                 adv_proxy%data,              &
                                 wind_proxy%data,             &
                                 tracer_proxy%data,           &
                                 adv_coeff_v,                 &
                                 ndf_wt,                      &
                                 undf_wt,                     &
                                 map_wt(:,cell),              &
                                 ndf_w2,                      &
                                 undf_w2,                     &
                                 map_w2(:,cell),              &
                                 order,                       &
                                 nfaces_v                     &
                                 )

  end do
  call adv_proxy%set_dirty()

end subroutine invoke_poly1d_vert_adv

end module psykal_lite_mol_mod
