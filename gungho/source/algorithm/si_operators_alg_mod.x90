!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Compute the locally assembled SI operators
module si_operators_alg_mod
  use constants_mod,             only: i_def, r_def
  use operator_mod,              only: operator_type
  use field_mod,                 only: field_type
  use fs_continuity_mod,         only: W2
  use log_mod,                   only: log_event,      &
                                       LOG_LEVEL_INFO, &
                                       LOG_LEVEL_ERROR, &
                                       log_scratch_space
  use helmholtz_solver_config_mod, &
                                 only: preconditioner,              &
                                       preconditioner_tridiagonal,  &
                                       preconditioner_multigrid,    &
                                       normalise
  use io_config_mod,             only: subroutine_timers 
  use timer_mod,                 only: timer

  use function_space_chain_mod,  only: multigrid_function_space_chain, &
                                       w2_multigrid_function_space_chain, &
                                       wtheta_multigrid_function_space_chain       
  use multigrid_config_mod,      only: multigrid_chain_nitems, l_multigrid
  
  implicit none
  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them 
  type(operator_type), allocatable, dimension(:), target :: m3_rho_star
  type(operator_type), allocatable, dimension(:), target :: m3_exner_star
  type(operator_type), allocatable, dimension(:), target :: div_star
  type(operator_type), allocatable, dimension(:), target :: p2theta
  type(operator_type), allocatable, dimension(:), target :: ptheta2
  type(operator_type), allocatable, dimension(:), target :: ptheta2v
  type(operator_type), allocatable, dimension(:), target :: p3theta
  type(operator_type), allocatable, dimension(:), target :: compound_div
  
  type(field_type), allocatable, dimension(:),   target :: rho_at_u
  type(field_type), allocatable, dimension(:,:), target :: tri_precon
  type(field_type), allocatable, dimension(:),   target :: Helm_diag
  type(field_type), allocatable, dimension(:),   target :: Hb_lumped_inv
  integer(kind=i_def) :: multigrid_levels
  
 ! Public functions to create and access the module contents
  public :: create_si_operators
  public :: compute_si_operators
  public :: final_si_operators
  public :: get_m3_rho_star
  public :: get_m3_exner_star 
  public :: get_div_star
  public :: get_p2theta
  public :: get_ptheta2 
  public :: get_ptheta2v
  public :: get_p3theta
  public :: get_compound_div 
  public :: get_rho_at_u 
  public :: get_tri_precon
  public :: get_helm_diag
  public :: get_Hb_lumped_inv

  !F90 function overloading
  interface get_m3_rho_star
     module procedure get_m3_rho_star_fine, get_m3_rho_star_mg
  end interface get_m3_rho_star
  
  interface get_m3_exner_star
     module procedure get_m3_exner_star_fine, get_m3_exner_star_mg
  end interface get_m3_exner_star

  interface get_div_star
     module procedure get_div_star_fine, get_div_star_mg
  end interface get_div_star

  interface get_p2theta
     module procedure get_p2theta_fine, get_p2theta_mg
  end interface get_p2theta

  interface get_ptheta2
     module procedure get_ptheta2_fine, get_ptheta2_mg
  end interface get_ptheta2

  interface get_ptheta2v
     module procedure get_ptheta2v_fine, get_ptheta2v_mg
  end interface get_ptheta2v

  interface get_p3theta
     module procedure get_p3theta_fine, get_p3theta_mg
  end interface get_p3theta

  interface get_compound_div
     module procedure get_compound_div_fine, get_compound_div_mg
  end interface get_compound_div

  interface get_rho_at_u
     module procedure get_rho_at_u_fine, get_rho_at_u_mg
  end interface get_rho_at_u

  interface get_tri_precon
     module procedure get_tri_precon_fine, get_tri_precon_mg
  end interface get_tri_precon

  interface get_helm_diag
     module procedure get_helm_diag_fine, get_helm_diag_mg
  end interface get_helm_diag

  interface get_Hb_lumped_inv
     module procedure get_Hb_lumped_inv_fine, get_Hb_lumped_inv_mg
  end interface get_Hb_lumped_inv
  
contains

  !>@brief Subroutine to create the si operators
  !>@param[in] mesh_id Identifier for the mesh
  subroutine create_si_operators(mesh_id)

    use function_space_mod,        only: function_space_type
    use fs_continuity_mod,         only: W0, W2, W3, Wtheta
    use finite_element_config_mod, only: element_order
    use function_space_collection_mod, &
                                   only: function_space_collection

    implicit none

    integer(kind=i_def), intent(in) :: mesh_id

    integer(kind=i_def) :: i
    type(function_space_type), pointer     :: w2_fs => null()
    type(function_space_type), pointer     :: w3_fs => null()
    type(function_space_type), pointer     :: wt_fs => null()

    if ( subroutine_timers ) call timer('si_operators_alg:create')
    call log_event( "Gungho: creating si_operators", LOG_LEVEL_INFO )

    if(l_multigrid) then
       multigrid_levels=multigrid_chain_nitems
    else
       multigrid_levels=1
    end if    

    w2_fs => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w3_fs => function_space_collection%get_fs( mesh_id, element_order, W3 )
    wt_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )

    allocate(m3_rho_star(multigrid_levels))
    allocate(m3_exner_star(multigrid_levels))
    allocate(div_star(multigrid_levels))
    allocate(p2theta(multigrid_levels))
    allocate(ptheta2(multigrid_levels))
    allocate(ptheta2v(multigrid_levels))
    allocate(p3theta(multigrid_levels))
    allocate(compound_div(multigrid_levels))

    !fields
    allocate(rho_at_u(multigrid_levels))
    if ( preconditioner == preconditioner_tridiagonal .or. &
                  preconditioner == preconditioner_multigrid) then
      if ( element_order /= 0 ) then
         call log_event( "tridiagonal precon only valid for order 0", &
              LOG_LEVEL_ERROR )
      end if
      allocate(tri_precon(3,multigrid_levels))
   end if
   allocate(helm_diag(multigrid_levels))
   allocate(Hb_lumped_inv(multigrid_levels))

   if (l_multigrid) then
      call multigrid_function_space_chain%set_current(w3_fs%get_id())
      call w2_multigrid_function_space_chain%set_current(w2_fs%get_id())
      call wtheta_multigrid_function_space_chain%set_current(wt_fs%get_id())
   end if

    do i = 1, multigrid_levels
       
       write(log_scratch_space,'(A,I0,A)') "si_ops[",i,"]:creating ops"
       call log_event(log_scratch_space,LOG_LEVEL_INFO)
       
       m3_rho_star(i)    = operator_type( w3_fs, w3_fs )
       m3_exner_star(i)  = operator_type( w3_fs, w3_fs )
       div_star(i)       = operator_type( w2_fs, w3_fs )
       p2theta(i)        = operator_type( w2_fs, wt_fs )
       ptheta2(i)        = operator_type( wt_fs, w2_fs )
       ptheta2v(i)       = operator_type( wt_fs, w2_fs )
       p3theta(i)        = operator_type( w3_fs, wt_fs )
       compound_div(i)   = operator_type( w3_fs, w2_fs )
       
       rho_at_u(i)  = field_type(vector_space = w2_fs)
       if ( preconditioner == preconditioner_tridiagonal .or. &
            preconditioner == preconditioner_multigrid ) then
          tri_precon(1,i) = field_type(vector_space = w3_fs)
          tri_precon(2,i) = field_type(vector_space = w3_fs)
          tri_precon(3,i) = field_type(vector_space = w3_fs)
       end if
       helm_diag(i)     = field_type(vector_space = w3_fs)
       Hb_lumped_inv(i) = field_type(vector_space = w2_fs)      
       if(l_multigrid) then
          w3_fs=>multigrid_function_space_chain%get_next()
          w2_fs=>w2_multigrid_function_space_chain%get_next()
          wt_fs=>wtheta_multigrid_function_space_chain%get_next()
       end if
    end do
   nullify( w2_fs, w3_fs, wt_fs )
   
   if ( subroutine_timers ) call timer('si_operators_alg:create')

  end subroutine create_si_operators

  !> @brief Explicitly reclaim memory from module scope variables
  subroutine final_si_operators()

    implicit none
   ! deallocate everything!
    
    if(allocated(m3_rho_star)) then
       deallocate(m3_rho_star)
    end if

    if(allocated(m3_exner_star)) then
       deallocate(m3_exner_star)
    end if

    if(allocated(div_star)) then
       deallocate(div_star)
    end if

    if(allocated(p2theta)) then    
       deallocate( p2theta )
    end if

    if(allocated(ptheta2)) then    
       deallocate(ptheta2)
    end if

    if(allocated(ptheta2v)) then
       deallocate(ptheta2v)
    end if

    if(allocated(p3theta)) then
       deallocate(p3theta)
    end if

    if(allocated(compound_div)) then
       deallocate(compound_div)
    end if

    if(allocated(rho_at_u)) then
       deallocate(rho_at_u)
    end if

    if(allocated(Helm_diag)) then
       deallocate(Helm_diag)
    end if

    if(allocated(tri_precon)) then
       deallocate(tri_precon)
    end if

    if(allocated(hb_lumped_inv)) then
       deallocate(hb_lumped_inv)
    end if

  end subroutine final_si_operators

  !>@brief Subroutine to compute the si operators
  !>@param[in] ref_state Bundle of reference states used to create linear operators
  subroutine compute_si_operators(ref_state)
    use quadrature_xyoz_mod,             only: quadrature_xyoz_type
    use quadrature_face_mod,             only: quadrature_face_type
    use quadrature_rule_gaussian_mod,    only: quadrature_rule_gaussian_type
    use eos_operators_kernel_mod,        only: eos_operators_kernel_type
    use weighted_div_kernel_mod,         only: weighted_div_kernel_type
    use weighted_proj_2theta_kernel_mod, only: weighted_proj_2theta_kernel_type
    use weighted_proj_theta2_kernel_mod, only: weighted_proj_theta2_kernel_type
    use weighted_proj_theta2_vert_kernel_mod, &
                                         only: weighted_proj_theta2_vert_kernel_type
    use compound_operator_kernel_mod,    only: compound_operator_kernel_type
    use mg_flux_kernel_mod,              only: mg_flux_kernel_type
    use sample_flux_kernel_mod,          only: sample_flux_kernel_type
    use psykal_lite_mod,                 only: invoke_weighted_div_bd_kernel_type,         &
                                               invoke_weighted_div_bd_kernel_type,         &
                                               invoke_weighted_proj_2theta_bd_kernel_type, &
                                               invoke_weighted_proj_theta2_bd_kernel_type
    use finite_element_config_mod,       only: element_order, &
                                               nqp_exact
    use function_space_mod,              only: function_space_type
    use runtime_constants_mod,           only: get_coordinates, &
                                               get_div, &
                                               get_mass_matrix, &
                                               w2_id, w3inv_id, wt_id, dl_id, &
                                               get_rmultiplicity, &
                                               get_normalisation
    use derived_config_mod,              only: bundle_size
    use invert_local_operator_kernel_mod,only: invert_local_operator_kernel_type
    use field_indices_mod,               only: igh_u, igh_t, igh_d, igh_p
    use planet_config_mod,               only: kappa, cp
    use timestepping_config_mod,         only: tau_r, tau_t, tau_u, dt
    use reference_element_mod,           only: reference_element_type
    use mesh_mod,                        only: mesh_type
    use matrix_vector_kernel_mod,        only: matrix_vector_kernel_type
    use restrict_kernel_mod,             only: restrict_kernel_type    
    use formulation_config_mod,          only: dlayer_on
    use compute_p0_vert_precon_kernel_mod, &
                                         only: compute_p0_vert_precon_kernel_type

    implicit none

    type(field_type), target, intent(in)   :: ref_state(bundle_size) ! (u, theta, rho, exner)
    type(field_type)                       :: theta, rho, exner, coarse_field
    type(quadrature_xyoz_type)             :: qr
    type(quadrature_face_type)             :: qrf
    type(quadrature_rule_gaussian_type)    :: quadrature_rule
    type(field_type),              pointer :: chi(:) => null()
    type(operator_type),           pointer :: m3_inv => null(), div => null()
    type(field_type)                       :: ones
    type(field_type),              pointer :: w2_rmultiplicity => null()
    type(function_space_type),     pointer :: w3_fs => null()
    type(function_space_type),     pointer :: w2_fs => null()
    type(function_space_type),     pointer :: wt_fs => null()    
    real(r_def)                            :: const1, const2
    integer(i_def), parameter              :: imone = -1_i_def
    real(r_def), parameter                 :: one   = 1_r_def
    class(reference_element_type), pointer :: reference_element =>null()
    type(mesh_type),               pointer :: mesh => null()
    type(operator_type),           pointer :: m2 => null()
    type(field_type),              pointer :: u_normalisation => null(), &
                                              t_normalisation => null() 
    type(field_type)                       :: m2_u, theta_adv_term
    integer(kind=i_def) :: level
    
    if ( subroutine_timers ) call timer('si_operators_alg:compute')
    call log_event( "Gungho: computing si_operators", LOG_LEVEL_INFO )

    exner  = ref_state(igh_p)
    rho    = ref_state(igh_d)
    theta  = ref_state(igh_t)

    w3_fs => ref_state(igh_p)%get_function_space()    
    w2_fs => ref_state(igh_u)%get_function_space()
    wt_fs => ref_state(igh_t)%get_function_space()

    ! Set the function space chains to the finest levels.
    if(l_multigrid) then
       call multigrid_function_space_chain%set_current(w3_fs%get_id())
       call w2_multigrid_function_space_chain%set_current(w2_fs%get_id())
       call wtheta_multigrid_function_space_chain%set_current(wt_fs%get_id())
    end if

    ! quadrature rules set once outside MG loop
    mesh => ref_state(igh_t)%get_mesh()
    reference_element => mesh%get_reference_element()
    qrf = quadrature_face_type(element_order+2, .true., .false., &
                               reference_element, quadrature_rule)
    qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)


    do level = 1, multigrid_levels
       
       write(log_scratch_space,'(A,I0)') "si_ops: mg level=",level
       call log_event(log_scratch_space, LOG_LEVEL_INFO)

       chi    => get_coordinates(level)
    
       ! Operators for the equation of state
       const1 = (1.0_r_def-kappa)/kappa
       call invoke( eos_operators_kernel_type(m3_exner_star(level), m3_rho_star(level), &
                    p3theta(level), &
                    exner, rho, theta, chi, const1, qr) )

       ! The rest of the operators are topological and so do not need as high
       ! quadrature order
       qr = quadrature_xyoz_type(element_order+2, quadrature_rule)

       ! Cell kernels
       const1 = tau_u*dt*cp
       const2 = tau_t*dt
       call invoke( weighted_div_kernel_type(div_star(level), theta, const1, qr), &
            weighted_proj_2theta_kernel_type(p2theta(level), exner, const1, qr),  & 
            weighted_proj_theta2_vert_kernel_type(ptheta2v(level), theta, const2, &
            qr),                      &
            weighted_proj_theta2_kernel_type(ptheta2(level), theta, const2, qr) )

       ! Boundary kernels
       call invoke_weighted_div_bd_kernel_type(div_star(level), theta, const1, qrf)
       call invoke_weighted_proj_theta2_bd_kernel_type(ptheta2(level), theta, const2, qrf)
       call invoke_weighted_proj_2theta_bd_kernel_type(p2theta(level), exner, const1, qrf)

       ! Compute rho^ref at u nodal points

       if(l_multigrid) then
          ! rmultiplicity is a half at lowest order, at higher order, MG has to do
          ! something different anyway
          call invoke(setval_c(rho_at_u(level), 0.0_r_def), &
               mg_flux_kernel_type(rho_at_u(level), rho) )
       else
          ! for non MG, at higher order, need computed rmultiplicity
          ones = field_type( vector_space = w2_fs )
          w2_rmultiplicity => get_rmultiplicity( W2 )
          call invoke( setval_c(ones,     1.0_r_def),                &
               setval_c(rho_at_u(level), 0.0_r_def),                 &
               sample_flux_kernel_type(rho_at_u(level), ones,        &
               w2_rmultiplicity, rho) )
       end if
       

       const1 = tau_r*dt
       m3_inv => get_mass_matrix(w3inv_id, level)
       div    => get_div(level)
       call invoke( compound_operator_kernel_type( &
                           compound_div(level), m3_rho_star(level), &
                           m3_inv, div, &
                           rho_at_u(level), const1) )
       
       ! Compute Hb_lumped_inv field
       if (dlayer_on) then
          m2 => get_mass_matrix(dl_id, level)
       else
          m2 => get_mass_matrix(w2_id, level)
       end if
       u_normalisation => get_normalisation(w2_id, level)
       t_normalisation => get_normalisation(wt_id, level)
    
       m2_u           = field_type( vector_space = w2_fs )
       ones           = field_type( vector_space = w2_fs )
       theta_adv_term = field_type( vector_space = wt_fs )
       
    call invoke( name = "Compute lumped inverse H_B operator",               &
                 setval_c(ones, 1.0_r_def),                                  &
                 setval_c(Hb_lumped_inv(level), 0.0_r_def),                  &
                 setval_c(m2_u, 0.0_r_def),                                  &
                 setval_c(theta_adv_term, 0.0_r_def),                        &
                 matrix_vector_kernel_type(m2_u, ones, m2),                  &
                 matrix_vector_kernel_type(                                  &
                           theta_adv_term, ones, ptheta2v(level)),           &
                 inc_X_times_Y(theta_adv_term, t_normalisation),             &
                 matrix_vector_kernel_type(                                  &
                           Hb_lumped_inv(level), theta_adv_term,             &
                           p2theta(level) ),                                 & 
                 inc_aX_plus_Y(one, Hb_lumped_inv(level), m2_u),             &
                 inc_X_times_Y(Hb_lumped_inv(level), u_normalisation),       &
                 inc_X_powint_n(Hb_lumped_inv(level), imone) )

    ! Compute terms for tridiagonal preconditioner
    if ( preconditioner == preconditioner_tridiagonal .or. &
         preconditioner == preconditioner_multigrid ) then
       ! Build using the FEM helmholtz operator, only valid for lowest order
       if ( element_order == 0 ) then 
          call invoke( compute_p0_vert_precon_kernel_type(                           &
                             tri_precon(:,level),                                    &
                             div_star(level), hb_lumped_inv(level), u_normalisation, &
                             t_normalisation, compound_div(level), p3theta(level),   &
                             ptheta2v(level), m3_exner_star(level),  m3_inv) )
       else
          call log_event( "Gungho: tridiagonal preconditioner invalid for element_order > 0", LOG_LEVEL_ERROR )
       end if
    end if
    if ( normalise .and. &
         preconditioner == preconditioner_tridiagonal ) then
       Helm_diag(level) = tri_precon(1,level)
       call invoke( name = "Normalise tridiagonal preconditioner", &
                   inc_X_powint_n(Helm_diag(level), imone),              &
                   inc_X_times_Y(tri_precon(1,level), Helm_diag(level)),       &
                   inc_X_times_Y(tri_precon(2,level), Helm_diag(level)),       &
                   inc_X_times_Y(tri_precon(3,level), Helm_diag(level)) )
    else
       call invoke( setval_c(Helm_diag(level), 1.0_r_def) )
    end if

       ! Restrict the fields for the next level, provided not last time round
       ! the loop
       if(level < multigrid_levels) then
          ! should not get here if no multigrid, but just in case
          if(l_multigrid) then

             write(log_scratch_space,'(A,I0,A,I0)') &
                  "si_ops:MG restrict L",level," to L",level+1
             call log_event(log_scratch_space,LOG_LEVEL_INFO)

             ! copy current field to coarse field          
             coarse_field = field_type(vector_space = wt_fs)
             coarse_field = theta
             ! set the fs to the next (fine)
             wt_fs=>wtheta_multigrid_function_space_chain%get_next()
             theta = field_type(vector_space = wt_fs)
             ! call restrict
             call invoke( restrict_kernel_type(theta, coarse_field) )
             
             ! copy current field to coarse field          
             coarse_field = field_type(w3_fs)
             coarse_field = rho
             ! set the fs to the next (fine)
             w3_fs=>multigrid_function_space_chain%get_next()
             rho = field_type(vector_space = w3_fs )
             ! call restrict
             call invoke( restrict_kernel_type(rho, coarse_field) )
             ! copy current field to coarse field
             coarse_field = exner
             ! fs already set fine
             exner = field_type(vector_space = w3_fs )          
             ! call restrict
             call invoke( restrict_kernel_type(exner, coarse_field) )
             ! set w2_fs to next in chain
             w2_fs=>w2_multigrid_function_space_chain%get_next()
          end if
       end if

    end do ! end of multigrid levels loop
    
    nullify( chi, m3_inv, div, w2_rmultiplicity, &
             mesh, reference_element, m2, u_normalisation, t_normalisation )

    if ( subroutine_timers ) call timer('si_operators_alg:compute')

  end subroutine compute_si_operators

  !> @brief Function to return a pointer to the m3_rho_star
  !! on the finest multigrid level
  !> @return The operator
  function get_m3_rho_star_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => m3_rho_star(1)
  end function get_m3_rho_star_fine

  !> @brief Function to return a pointer to the m3_rho_star
  !! on the specified multigrid level
  !> @param[in] level integer, the multigrid level
  !> @return The operator  
  function get_m3_rho_star_mg(level) result(op)
    implicit none
    integer(kind=i_def), intent(in) :: level
    type(operator_type), pointer ::op
    op => m3_rho_star(level)
  end function get_m3_rho_star_mg

  !> @brief Function to return a pointer to the m3_exner_star
  !! on the finest multigrid level  
  !> @return The operator
  function get_m3_exner_star_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => m3_exner_star(1)
  end function get_m3_exner_star_fine

  !> @brief Function to return a pointer to the m3_exner_star
  !! on the specified multigrid level    
  !> @param[in] level integer, the multigrid level  
  !> @return The operator
  function get_m3_exner_star_mg(level) result(op)
    implicit none
    integer, intent(in) :: level
    type(operator_type), pointer ::op
    op => m3_exner_star(level)
  end function get_m3_exner_star_mg

  !> @brief Function to return a pointer to the div_star
  !! on the finest multigrid level  
  !> @return The operator
  function get_div_star_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => div_star(1)
  end function get_div_star_fine
  
  !> @brief Function to return a pointer to the div_star
  !! on the specified multigrid level  
  !> @param[in] level integer, the multigrid level
  !> @return The operator  
  function get_div_star_mg(level) result(op)
    implicit none
    integer, intent(in) :: level      
    type(operator_type), pointer ::op
    op => div_star(level)
  end function get_div_star_mg

  !> @brief Function to return a pointer to the p2theta
  !! on the finest multigrid level  
  !> @return The operator
  function get_p2theta_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => p2theta(1)
  end function get_p2theta_fine

  !> @brief Function to return a pointer to the p2theta
  !! on the specified multigrid level  
  !> @param[in] level integer, the multigrid level
  !> @return The operator
  function get_p2theta_mg(level) result(op)
    implicit none
    integer, intent(in) :: level      
    type(operator_type), pointer ::op
    op => p2theta(level)
  end function get_p2theta_mg

  !> @brief Function to return a pointer to the ptheta2
  !! on the finest multigrid level  
  !> @return The operator
  function get_ptheta2_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => ptheta2(1)
  end function get_ptheta2_fine

  !> @brief Function to return a pointer to the ptheta2
  !! on the specified multigrid level  
  !> @param[in] level integer, the multigrid level
  !> @return The operator  
  function get_ptheta2_mg(level) result(op)
    implicit none
    integer, intent(in) :: level          
    type(operator_type), pointer ::op
    op => ptheta2(level)
  end function get_ptheta2_mg

  !> @brief Function to return a pointer to the ptheta2v
  !! on the finest multigrid level  
  !> @return The operator
  function get_ptheta2v_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => ptheta2v(1)
  end function get_ptheta2v_fine

  !> @brief Function to return a pointer to the ptheta2v
  !! on the specified multigrid level  
  !> @param[in] level integer, the multigrid level
  !> @return The operator
  function get_ptheta2v_mg(level) result(op)
    implicit none
    integer, intent(in) :: level              
    type(operator_type), pointer ::op
    op => ptheta2v(level)
  end function get_ptheta2v_mg

  !> @brief Function to return a pointer to the p3theta
  !! on the finest multigrid level  
  !> @return The operator
  function get_p3theta_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => p3theta(1)
  end function get_p3theta_fine

  !> @brief Function to return a pointer to the p3theta
  !! on the specified multigrid level
  !> @param[in] level integer, the multigrid level    
  !> @return The operator
  function get_p3theta_mg(level) result(op)
    implicit none
    integer, intent(in) :: level                    
    type(operator_type), pointer ::op
    op => p3theta(level)
  end function get_p3theta_mg

  !> @brief Function to return a pointer to the compound div
  !! on the finest multigrid level  
  !> @return The operator
  function get_compound_div_fine() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => compound_div(1)
  end function get_compound_div_fine

  !> @brief Function to return a pointer to the compound div
  !! on the specified multigrid level
  !> @param[in] level integer, the multigrid level        
  !> @return The operator
  function get_compound_div_mg(level) result(op)
    implicit none
    integer, intent(in) :: level                        
    type(operator_type), pointer ::op
    op => compound_div(level)
  end function get_compound_div_mg

  !> @brief Function to return a pointer to the rho_at_u
  !! on the finest multigrid level  
  !> @return The field
  function get_rho_at_u_fine() result(field)
    implicit none
    type(field_type), pointer :: field
    field => rho_at_u(1)
  end function get_rho_at_u_fine

  !> @brief Function to return a pointer to the rho_at_u
  !! on the specified multigrid level
  !> @param[in] level integer, the multigrid level          
  !> @return The field
  function get_rho_at_u_mg(level) result(field)
    implicit none
    integer, intent(in) :: level                            
    type(field_type), pointer :: field
    field => rho_at_u(level)
  end function get_rho_at_u_mg

  !> @brief Function to return a pointer to the tri_precon
  !! on the finest multigrid level  
  !> @return The field
  function get_tri_precon_fine() result(field)
    implicit none
    type(field_type), pointer :: field(:)
    field => tri_precon(:,1)
  end function get_tri_precon_fine

  !> @brief Function to return a pointer to the tri_precon
  !! on the specified multigrid level
  !> @param[in] level integer, the multigrid level            
  !> @return The field
  function get_tri_precon_mg(level) result(field)
    implicit none
    integer, intent(in) :: level                            
    type(field_type), pointer :: field(:)
    field => tri_precon(:,level)
  end function get_tri_precon_mg

  !> @brief Function to return a pointer to the Helm diagonal
  !! on the finest multigrid level  
  !> @return The field
  function get_helm_diag_fine() result(field)
    implicit none
    type(field_type), pointer :: field
    field => helm_diag(1)
  end function get_helm_diag_fine

  !> @brief Function to return a pointer to the Helm diagonal
  !! on the specified multigrid level
  !> @param[in] level integer, the multigrid level              
  !> @return The field
  function get_helm_diag_mg(level) result(field)
    implicit none
    integer, intent(in) :: level                                
    type(field_type), pointer :: field
    field => helm_diag(level)
  end function get_helm_diag_mg

  !> @brief Function to return a pointer to the lumped inverse Hb operator
  !! on the finest multigrid level  
  !> @return The field
  function get_hb_lumped_inv_fine() result(field)
    implicit none
    type(field_type), pointer :: field
    field => hb_lumped_inv(1)
  end function get_hb_lumped_inv_fine

  !> @brief Function to return a pointer to the lumped inverse Hb operator
  !! on the specified multigrid level
  !> @param[in] level integer, the multigrid level                
  !> @return The field
  function get_hb_lumped_inv_mg(level) result(field)
    implicit none
    integer, intent(in) :: level                                
    type(field_type), pointer :: field
    field => hb_lumped_inv(level)
  end function get_hb_lumped_inv_mg

end module si_operators_alg_mod
