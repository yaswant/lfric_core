!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief compute the locally assembled SI operators
module si_operators_alg_mod
  use constants_mod,             only: i_def, r_def
  use operator_mod,              only: operator_type
  use field_mod,                 only: field_type
  use finite_element_config_mod, only: wtheta_on
  use fs_continuity_mod,         only: W2
  use log_mod,                   only: log_event,      &
                                       LOG_LEVEL_INFO, &
                                       LOG_LEVEL_ERROR
  use solver_config_mod,         only: si_pressure_preconditioner, &
                                       solver_si_pressure_preconditioner_tridiagonal, &
                                       normalise
  use output_config_mod,         only: subroutine_timers 
  use timer_mod,                 only: timer
  use timestepping_config_mod,   only: tau_r

  implicit none
  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them 
  type(operator_type), target :: m3_rho_star
  type(operator_type), target :: m3_exner_star
  type(operator_type), target :: m3_exner_star_inv
  type(operator_type), target :: div_star
  type(operator_type), target :: p2theta
  type(operator_type), target :: ptheta2
  type(operator_type), target :: p3theta
  type(operator_type), target :: compound_div
  type(field_type),    target :: rho_at_u
  type(field_type),    target :: tri_precon(3)
  type(field_type),    target :: Helm_diag

 ! Public functions to create and access the module contents
  public :: create_si_operators
  public :: compute_si_operators
  public :: get_m3_rho_star
  public :: get_m3_exner_star 
  public :: get_m3_exner_star_inv 
  public :: get_div_star
  public :: get_p2theta
  public :: get_ptheta2 
  public :: get_p3theta
  public :: get_compound_div 
  public :: get_rho_at_u 
  public :: get_tri_precon
  public :: get_helm_diag
contains

!> Subroutine to create the si operators
subroutine create_si_operators(mesh_id)
  use function_space_mod,        only: function_space_type
  use fs_continuity_mod,         only: W0, W2, W3, Wtheta
  use finite_element_config_mod, only: element_order
  use function_space_collection_mod, &
                                 only: function_space_collection

  implicit none

  integer(i_def), intent(in) :: mesh_id

  type(function_space_type), pointer     :: w2_fs => null()
  type(function_space_type), pointer     :: w3_fs => null()
  type(function_space_type), pointer     :: wt_fs => null()

  if ( subroutine_timers ) call timer('si_operators_alg:create')
  call log_event( "Gungho: creating si_operators", LOG_LEVEL_INFO )

  w2_fs     => function_space_collection%get_fs( mesh_id, element_order, W2 )
  w3_fs     => function_space_collection%get_fs( mesh_id, element_order, W3 )
  if (wtheta_on) then
    wt_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )
  else
    wt_fs => function_space_collection%get_fs( mesh_id, element_order, W0 )
  end if
 
  m3_rho_star       = operator_type( w3_fs, w3_fs )
  m3_exner_star     = operator_type( w3_fs, w3_fs )
  m3_exner_star_inv = operator_type( w3_fs, w3_fs )
  div_star          = operator_type( w2_fs, w3_fs )
  p2theta           = operator_type( w2_fs, wt_fs )
  ptheta2           = operator_type( wt_fs, w2_fs )
  p3theta           = operator_type( w3_fs, wt_fs )
  compound_div      = operator_type( w3_fs, w2_fs )

  rho_at_u  = field_type(vector_space = w2_fs)

  if ( si_pressure_preconditioner == solver_si_pressure_preconditioner_tridiagonal ) then
    if ( element_order /= 0 ) then
      call log_event( "tridiagonal precon only valid for order 0", &
                      LOG_LEVEL_ERROR )
    end if
    tri_precon(1) = field_type(vector_space = w3_fs)
    tri_precon(2) = field_type(vector_space = w3_fs)
    tri_precon(3) = field_type(vector_space = w3_fs)
  end if
  helm_diag = field_type(vector_space = w3_fs)
  if ( subroutine_timers ) call timer('si_operators_alg:create')

end subroutine create_si_operators

!> Subroutine to compute the si operators
subroutine compute_si_operators(ref_state)
  use quadrature_mod,                  only: quadrature_type, GAUSSIAN
  use weighted_m3_rho_kernel_mod,      only: weighted_m3_rho_kernel_type
  use weighted_m3_exner_kernel_mod,    only: weighted_m3_exner_kernel_type
  use weighted_div_kernel_mod,         only: weighted_div_kernel_type
  use weighted_proj_2theta_kernel_mod, only: weighted_proj_2theta_kernel_type
  use weighted_proj_theta2_kernel_mod, only: weighted_proj_theta2_kernel_type
  use weighted_proj_theta2_wt_kernel_mod, &
                                       only: weighted_proj_theta2_wt_kernel_type
  use weighted_proj_3theta_kernel_mod, only: weighted_proj_3theta_kernel_type
  use compound_operator_kernel_mod,    only: compound_operator_kernel_type
  use psykal_lite_mod,                 only: invoke_sample_flux_kernel,                  &
                                             invoke_compute_tri_precon_kernel,           &
                                             invoke_inc_X_times_Y,                       &
                                             invoke_weighted_div_bd_kernel_type,         &
                                             invoke_weighted_proj_2theta_bd_kernel_type, &
                                             invoke_weighted_proj_theta2_bd_kernel_type, &
                                             invoke_raise_field
  use finite_element_config_mod,       only: element_order, wtheta_on
  use function_space_mod,              only: function_space_type
  use runtime_constants_mod,           only: get_coordinates, &
                                             get_div, &
                                             get_mass_matrix, &
                                             w3inv_id, theta_space_id, &
                                             get_rmultiplicity
  use derived_config_mod,              only: bundle_size
  use invert_local_operator_kernel_mod,only: invert_local_operator_kernel_type
  use field_indices_mod,               only: igh_u, igh_t, igh_d

  implicit none

  type(field_type), target, intent(in) :: ref_state(bundle_size) ! (u, theta, rho)
  type(field_type),            pointer :: theta => null(), rho => null()
  type(quadrature_type)                :: qr
  type(field_type),            pointer :: chi(:) => null()
  type(operator_type),         pointer :: m3_inv => null(), div => null()
  type(field_type)                     :: ones
  type(field_type), pointer            :: w2_rmultiplicity => null()
  type(function_space_type),   pointer :: u_fs => null()

  if ( subroutine_timers ) call timer('si_operators_alg:compute')
  call log_event( "Gungho: computing si_operators", LOG_LEVEL_INFO )

  qr = quadrature_type(element_order+3, GAUSSIAN)
  theta  => ref_state(igh_t)
  rho    => ref_state(igh_d)  
  chi    => get_coordinates()
  m3_inv => get_mass_matrix(w3inv_id)
  div    => get_div()
  w2_rmultiplicity => get_rmultiplicity( W2 )

  call invoke( weighted_m3_rho_kernel_type(m3_rho_star, rho, chi, qr) )
  call invoke( weighted_m3_exner_kernel_type(m3_exner_star, rho, theta, chi, qr), &
               invert_local_operator_kernel_type(m3_exner_star_inv, m3_exner_star) )

  ! Split off due to use of any_space for chi
  ! Weighted operator from W2 to W3
  call invoke( weighted_div_kernel_type(div_star, theta, qr) )
  ! And its boundary part in the case of horizontally discontinuous theta
  if (wtheta_on) then
    call invoke_weighted_div_bd_kernel_type(div_star, theta, qr)
  end if
  ! Weighted operator from W2 to Wtheta
  if (wtheta_on .and. .false.) then
    ! Operator is integrated by parts
    call invoke( weighted_proj_theta2_wt_kernel_type(ptheta2, theta, qr) )
    call invoke_weighted_proj_theta2_bd_kernel_type(ptheta2, theta, qr)
  else
    call invoke( weighted_proj_theta2_kernel_type(ptheta2, theta, qr) )
  end if
  ! Weighted operator from Wtheta to W2
  call invoke( weighted_proj_2theta_kernel_type(p2theta, theta, rho, qr) )
  ! And its boundary part in the case of horizontally discontinuous theta
  if (wtheta_on) then
    call invoke_weighted_proj_2theta_bd_kernel_type(p2theta, theta, rho, qr)
  end if
  call invoke( weighted_proj_3theta_kernel_type(p3theta, theta, chi, qr) )

  ! Compute rho^ref at u nodal points
  u_fs => ref_state(igh_u)%get_function_space()
  ones             = field_type( vector_space = u_fs )
  ! Initialise fields
  call invoke( set_field_scalar(1.0_r_def, ones),            &
               set_field_scalar(0.0_r_def, rho_at_u) )
  ! Calculate rho^ref
  call invoke_sample_flux_kernel( rho_at_u, ones, w2_rmultiplicity, rho)

  call invoke( compound_operator_kernel_type(compound_div, m3_rho_star, m3_inv, div, &
                                             rho_at_u, tau_r) )

  ! compute terms for tridiagonal preconditioner
  if ( si_pressure_preconditioner == solver_si_pressure_preconditioner_tridiagonal ) then
    call invoke_compute_tri_precon_kernel(tri_precon, theta, rho, chi, m3_inv)
  end if
  if ( normalise ) then
    if ( si_pressure_preconditioner == solver_si_pressure_preconditioner_tridiagonal) then
      Helm_diag = tri_precon(1)
      call invoke_raise_field(Helm_diag, -1_i_def)
      call invoke_inc_X_times_Y(tri_precon(1), Helm_diag)
      call invoke_inc_X_times_Y(tri_precon(2), Helm_diag)
      call invoke_inc_X_times_Y(tri_precon(3), Helm_diag)
    else
      call invoke( set_field_scalar(1.0_r_def, Helm_diag) )
    end if
  else
    call invoke( set_field_scalar(1.0_r_def, Helm_diag) )
  end if
  if ( subroutine_timers ) call timer('si_operators_alg:compute')

end subroutine compute_si_operators


 !> Function to return a pointer to the m3_rho_star
 !> @return The operator
  function get_m3_rho_star() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => m3_rho_star
  end function get_m3_rho_star

 !> Function to return a pointer to the m3_exner_star
 !> @return The operator
  function get_m3_exner_star() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => m3_exner_star
  end function get_m3_exner_star

 !> Function to return a pointer to the m3_exner_star_inv
 !> @return The operator
  function get_m3_exner_star_inv() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => m3_exner_star_inv
  end function get_m3_exner_star_inv

 !> Function to return a pointer to the div_star
 !> @return The operator
  function get_div_star() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => div_star
  end function get_div_star

 !> Function to return a pointer to the p2theta
 !> @return The operator
  function get_p2theta() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => p2theta
  end function get_p2theta

 !> Function to return a pointer to the ptheta2
 !> @return The operator
  function get_ptheta2() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => ptheta2
  end function get_ptheta2

 !> Function to return a pointer to the p3theta
 !> @return The operator
  function get_p3theta() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => p3theta
  end function get_p3theta

 !> Function to return a pointer to the compound div
 !> @return The operator
  function get_compound_div() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => compound_div
  end function get_compound_div

 !> Function to return a pointer to the rho_at_u
 !> @return The field
  function get_rho_at_u() result(field)
    implicit none
    type(field_type), pointer :: field
    field => rho_at_u
  end function get_rho_at_u

 !> Function to return a pointer to the tri_precon
 !> @return The field
  function get_tri_precon() result(field)
    implicit none
    type(field_type), pointer :: field(:)
    field => tri_precon
  end function get_tri_precon

 !> Function to return a pointer to the Helm diagonal
 !> @return The field
  function get_helm_diag() result(field)
    implicit none
    type(field_type), pointer :: field
    field => helm_diag
  end function get_helm_diag

end module si_operators_alg_mod
