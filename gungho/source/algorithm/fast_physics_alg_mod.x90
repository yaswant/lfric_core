!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief Calls to the fast physics schemes
module fast_physics_alg_mod

  use section_choice_config_mod, only: boundary_layer, boundary_layer_um, &
                                       convection, convection_um,         &
                                       surface, surface_jules,            &
                                       cloud, cloud_um
  use clock_mod,            only: clock_type
  use constants_mod,        only: i_def,r_def
  use log_mod,              only: LOG_LEVEL_INFO
  use io_config_mod,        only: subroutine_timers, &
                                  write_conservation_diag
  use timer_mod,            only: timer

  use physics_config_mod,   only: blayer_placement, blayer_placement_fast, &
                                  convection_placement,                    &
                                  convection_placement_fast
  use formulation_config_mod, only: use_moisture
  use convection_config_mod,only: cv_scheme, cv_scheme_lambert_lewis, &
                                  cv_scheme_gregory_rowntree
  use cloud_config_mod,     only: scheme, scheme_pc2, scheme_bimodal,      &
                                  pc2ini, pc2ini_bimodal
  ! Derived Types
  use field_mod,            only: field_type
  use field_collection_mod, only: field_collection_type
  ! Moisture species
  use mr_indices_mod,       only: nummr, imr_v
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type
  use moisture_conservation_alg_mod,  only: moisture_conservation_alg

  use timestepping_config_mod, only : outer_iterations

#ifdef UM_PHYSICS
  ! UM BL scheme
  use bl_imp_alg_mod,  only: bl_imp_alg
  ! UM conv scheme
  use conv_ll_alg_mod, only: conv_ll_alg
  use conv_gr_alg_mod, only: conv_gr_alg
  use pc2_conv_coupling_alg_mod, only: pc2_conv_coupling_alg
  use bm_tau_alg_mod,  only: bm_tau_alg
  ! Jules surface schemes
  use jules_extra_alg_mod, only: jules_extra_alg
#endif

  implicit none

contains

  !> @details Collection of procedures for subgrid physics that act
  !>          within the outer loop of the solver
  !> @param[in,out] du                  Increment to wind field
  !> @param[in,out] dtheta              Increment to theta field
  !> @param[in,out] mr                  Mixing ratios to be updated
  !> @param[in]     theta               Theta field at start of timestep
  !> @param[in]     rho                 Rho on w3 space
  !> @param[in]     exner               Exner pressure on w3 space
  !> @param[in]     mr_n                Mixing ratios at start of timestep
  !> @param[in]     derived_fields      Group of derived fields
  !> @param[in]     radition_fields     Fields for radiation scheme
  !> @param[in]     microphysics_fields Fields for microphysics scheme
  !> @param[in]     orography_fields    Fields for orographic drag scheme
  !> @param[in,out] turbulence_fields   Fields for turbulence scheme
  !> @param[in,out] convection_fields   Fields for convection scheme
  !> @param[in,out] cloud_fields        Fields for cloud scheme
  !> @param[in,out] surface_fields      Fields for surface scheme
  !> @param[in,out] soil_fields         Fields for soil hydrology scheme
  !> @param[in,out] snow_fields         Fields for snow scheme
  !> @param[in]     outer               Outer loop counter
  !> @param[in]     clock               The clock object
  !> @param[in]     rho_guess           Estimate of rho^n+1 for conservation
  !!                                    diagnostics
    subroutine fast_physics(du, dtheta, mr, theta, rho, exner, mr_n,           &
                            derived_fields, radiation_fields,                  &
                            microphysics_fields, orography_fields,             &
                            turbulence_fields, convection_fields, cloud_fields,&
                            surface_fields, soil_fields, snow_fields,          &
                            outer, clock, rho_guess)

    implicit none

    ! Fields
    type( field_type ), intent( inout ) :: du, dtheta
    type( field_type ), intent( in )    :: theta, rho, exner, rho_guess

    ! Field bundles
    type( field_type ), intent( inout ) :: mr(nummr)  ! Latest value, to update
    type( field_type ), intent( in )    :: mr_n(nummr)! Start of timestep
                                                      ! Do not alter

    ! Field groups
    type( field_collection_type ), intent(in)    :: derived_fields
    type( field_collection_type ), intent(in)    :: radiation_fields
    type( field_collection_type ), intent(in)    :: microphysics_fields
    type( field_collection_type ), intent(in)    :: orography_fields
    type( field_collection_type ), intent(inout) :: turbulence_fields
    type( field_collection_type ), intent(inout) :: convection_fields
    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: surface_fields
    type( field_collection_type ), intent(inout) :: soil_fields
    type( field_collection_type ), intent(inout) :: snow_fields

    ! scalars
    integer(kind=i_def), intent(in) :: outer
    class(clock_type),   intent(in) :: clock

    ! Local fields...
    ! ...for boundary layer
    type( field_type ) :: dtheta_bl
    type( field_type ), pointer :: du_bl => null()
#ifdef UM_PHYSICS
    ! ...surface fields passed from BL to Jules
    type( field_type ) :: snow_sublimation
    type( field_type ) :: surf_heat_flux
    type( field_type ) :: canopy_evap
    type( field_type ) :: water_extraction
    type( field_type ) :: total_snowmelt

    ! Temporary field to unpack from field collection
    type( field_type), pointer :: dmv_conv => null()
#endif

    ! Flags to indicate whether scheme has run and increments need adding
    logical :: boundary_layer_done

    integer(i_def) :: i_mr

    if ( subroutine_timers ) call timer("fast_physics")

    if (write_conservation_diag .and. outer == outer_iterations .and. use_moisture) &
      call moisture_conservation_alg( clock%get_step(), rho_guess, mr, 'Before fast' )

    !--------------------------------------------------------------------
    ! Initialisation of fields and flags
    !--------------------------------------------------------------------
    call invoke( setval_c(dtheta, 0.0_r_def), &
                 setval_c(du, 0.0_r_def) )
    boundary_layer_done = .false.

    !--------------------------------------------------------------------
    ! UM convection scheme
    !--------------------------------------------------------------------
#ifdef UM_PHYSICS
    if (convection == convection_um .and.                       &
        convection_placement == convection_placement_fast) then
      if ( cv_scheme == cv_scheme_lambert_lewis ) then
        ! Call the UM Lambert-Lewis convection scheme
        call conv_ll_alg(mr, exner, derived_fields, convection_fields,    &
                         outer)
      else if ( cv_scheme == cv_scheme_gregory_rowntree ) then
        ! Call the UM Gregory Rowntree convection scheme
        call conv_gr_alg(mr, rho, exner, derived_fields,                  &
                         turbulence_fields, convection_fields,            &
                         cloud_fields, surface_fields, outer)
      end if

      if ( cloud == cloud_um .and. scheme == scheme_pc2 ) then
        ! Update the cloud fields if using PC2
        call pc2_conv_coupling_alg( mr, derived_fields,                  &
                                    convection_fields, cloud_fields )
      else
        ! Without PC2, just update vapour field
        dmv_conv => convection_fields%get_field('dmv_conv')
        call invoke( inc_X_plus_Y(mr(imr_v), dmv_conv) )
      end if

    end if

    if ( cloud == cloud_um .and. ( scheme == scheme_bimodal .or.          &
        ( scheme == scheme_pc2 .and. pc2ini == pc2ini_bimodal ) ) ) then

      call bm_tau_alg(mr, theta, derived_fields, turbulence_fields,       &
                     cloud_fields)

    end if


    !--------------------------------------------------------------------
    ! UM implicit boundary layer and Jules surface schemes
    !--------------------------------------------------------------------
    if (boundary_layer == boundary_layer_um .and. &
        blayer_placement == blayer_placement_fast) then
      du_bl => turbulence_fields%get_field('du_bl')
      call bl_imp_alg(dtheta_bl, du_bl, mr, snow_sublimation,             &
                      surf_heat_flux, canopy_evap, water_extraction,      &
                      total_snowmelt, theta, exner, mr_n,                 &
                      derived_fields, radiation_fields, orography_fields, &
                      turbulence_fields, convection_fields, cloud_fields, &
                      surface_fields, soil_fields, snow_fields, outer, clock)
      boundary_layer_done=.true. ! Collect this increment later on
    end if

    !--------------------------------------------------------------------
    ! Jules surface and sub-surface (snow and hydrology)
    !--------------------------------------------------------------------
    if ( surface == surface_jules .and. &
       outer == outer_iterations ) then
      call jules_extra_alg(microphysics_fields, convection_fields,        &
                           surface_fields, soil_fields, snow_fields,      &
                           snow_sublimation, surf_heat_flux, canopy_evap, &
                           water_extraction, total_snowmelt)
    end if
#endif

    !=====================================================================
    ! Update the main fields and increments to pass out
    !=====================================================================
    if (boundary_layer_done) then
      ! N.B. as currently coded, the convection increments are added in the
      ! boundary layer as part of the implicit solution
      call invoke(inc_X_plus_Y(du, du_bl), &
                  inc_X_plus_Y(dtheta, dtheta_bl) )
    end if

    call dtheta%log_minmax(LOG_LEVEL_INFO, 'fast physics: dtheta' )
    call du%log_minmax(LOG_LEVEL_INFO, 'fast physics: du' )

    if (use_moisture) then
      do i_mr = 1, nummr
        call invoke( enforce_lower_bound_kernel_type (mr(i_mr), 0.0_r_def) )
      end do

      if (write_conservation_diag .and. outer == outer_iterations) &
        call moisture_conservation_alg( clock%get_step(), rho_guess, mr, 'After fast' )
    end if

    if ( subroutine_timers ) call timer("fast_physics")

  end subroutine fast_physics

end module fast_physics_alg_mod
