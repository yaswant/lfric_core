!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief Algorithms to do field processing to produce generic and specific
!>        diagnostics for different I/O methods
module diagnostic_alg_mod
   use constants_mod,                 only: i_def, r_def, str_max_filename
   use finite_element_config_mod,     only: element_order
   use base_mesh_config_mod,          only: geometry, &
                                            geometry_spherical
   use mesh_mod,                      only: mesh_type
   use mesh_collection_mod,           only: mesh_collection
   use function_space_collection_mod, only: function_space_collection
   use fs_continuity_mod,             only: W1, W2, W3, Wtheta, W2H
   use field_mod,                     only: field_type
   use operator_mod,                  only: operator_type
   use nodal_coordinates_kernel_mod,  only: nodal_coordinates_kernel_type
   use psykal_lite_mod,               only: invoke_compute_dof_level_kernel
   use psykal_builtin_light_mod,      only: invoke_convert_cart2sphere_vector, &
                                            invoke_pointwise_convert_xyz2llr
   use runtime_constants_mod,         only: get_rmultiplicity,   &
                                            get_coordinates_xyz, &
                                            get_coordinates,     &
                                            get_panel_id
   use project_output_mod,            only: project_output
   use log_mod,                       only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO
   implicit none

   private
   public :: divergence_diagnostic_alg
   public :: density_diagnostic_alg
   public :: hydbal_diagnostic_alg
   public :: split_wind_diagnostic_alg
   public :: scalar_nodal_diagnostic_alg
   public :: vector_nodal_diagnostic_alg
   public :: scalar_ugrid_diagnostic_alg
   public :: vorticity_diagnostic_alg
   public :: l2norm_diff_2fields

contains

  !> @details Calculates the l2 error norm for wind divergence
  !> @param[inout] divergence  Divergence field
  !> @param[inout] l2          l2 norm
  !> @param[in] u              3D wind field
  !> @param[in] mesh_id        Mesh_id
  subroutine divergence_diagnostic_alg(divergence, l2, u, mesh_id)
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use runtime_constants_mod,       only: get_mass_matrix, &
                                           get_div, &
                                           w3inv_id
    use planet_config_mod,           only: scaled_radius
    use constants_mod,               only: pi

    implicit none
    type(field_type), intent(inout) :: divergence
    real(r_def), intent(inout)      :: l2
    type(field_type), intent(in)    :: u
    integer(i_def),   intent(in)    :: mesh_id

    type(field_type)             :: div_u
    type(operator_type), pointer :: div => null(), m3_inv => null()
    real(r_def)                  :: norm




    call divergence%initialise( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    call div_u%initialise( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div    => get_div()
    m3_inv => get_mass_matrix(w3inv_id)
    ! Compute l2 norm of area integrated quantity
    call invoke( dg_matrix_vector_kernel_type( div_u, u, div ),             &
                 dg_matrix_vector_kernel_type( divergence, div_u , m3_inv), &
                 X_innerproduct_Y( l2, div_u, divergence ) )
    ! Normalisation factor: surface area of planet
    if ( geometry == geometry_spherical ) then
      norm = 4.0_r_def*pi*scaled_radius**2
    else
      norm = 1.0_r_def
    end if
    l2 = sqrt(l2)

    ! Convert to pointwise W3 field for output
    call invoke( dg_matrix_vector_kernel_type( divergence, div_u , m3_inv ) )


  end subroutine divergence_diagnostic_alg

!=============================================================================!
  !> @details An algorithm for calculating the l2 error for the density field.
  !>          It is capable of calculating the error at each timestep by using
  !>          set_rho_alg algorithm which will return the analytic density value
  !>          at each timestep.
  !> @param[inout] l2  l2 norm
  !> @param[in] rho_num  Density
  !> @param[in] timestep Timestep
  subroutine density_diagnostic_alg(l2, rho_num, timestep)
    use runtime_constants_mod,        only: get_mass_matrix, &
                                            w3_id
    use operator_mod,                 only: operator_type
    use field_mod,                    only: field_type
    use quadrature_xyoz_mod,          only: quadrature_xyoz_type
    use set_rho_alg_mod,              only: set_rho_alg

    implicit none

    real(r_def), intent(inout)   :: l2
    type(field_type), intent(in) :: rho_num
    integer(i_def),   intent(in) :: timestep

    type(field_type)             :: rho_analytic
    type(field_type)             :: rho_diff
    type(field_type)             :: w3_rho_diff
    type(field_type)             :: w3_rho_analytic

    real(r_def)                  :: sum_diff, sum_analytic
    type(operator_type), pointer :: mm_w3 => null()

    call rho_analytic%initialise( vector_space = rho_num%get_function_space() )
    call rho_diff%initialise( vector_space = rho_num%get_function_space() )
    call w3_rho_diff%initialise( vector_space = rho_num%get_function_space() )
    call w3_rho_analytic%initialise( vector_space = rho_num%get_function_space() )

    mm_w3 => get_mass_matrix(w3_id)

    call set_rho_alg( rho_analytic, timestep )

    ! The normalised l2 error norm with cell volume weightings is calculated as:
    ! l2 = sqrt(I((rho_num - rho_analytic)^2))/sqrt(I(rho_analtyic^2))
    ! where I(rho) = sum(rho_i*volume_of_cell_i).
    ! Here we let sum_diff = I((rho_num - rho_analytic)^2)
    ! and         sum_analytic = I(rho_analtyic^2)
    ! To calculate sum_diff we use the inner product operator and multiply one of
    ! the differences by the W3 matrix which contains the cell volumes.
    ! sum_diff = inner_product( rho_num-rho_analytic, W3*(rho_num-rho_analytic))
    ! Similarly for sum_analytic the following is calculated:
    ! sum_analytic = inner_product( rho_analytic, W3*rho_analytic)

    call invoke( X_minus_Y( rho_diff, rho_num, rho_analytic ),                            &
                 dg_matrix_vector_kernel_type( w3_rho_diff, rho_diff , mm_w3 ),           &
                 X_innerproduct_Y( sum_diff, w3_rho_diff, rho_diff ),                     &
                 dg_matrix_vector_kernel_type( w3_rho_analytic, rho_analytic , mm_w3 ),   &
                 X_innerproduct_Y( sum_analytic, w3_rho_analytic, rho_analytic ) )


    l2 = sqrt(sum_diff)/sqrt(sum_analytic)

    nullify( mm_w3 )

  end subroutine density_diagnostic_alg

!=============================================================================!
  !> @details An algorithm for calculating the l2 norm for the hydrostatic
  !>          imbalance. It calculates the sum of pressure gradient and
  !>          gravity term at each timestep using the hydrostatic kernel.
  !> @param[in,out] l2        l2 norm
  !> @param[in]     theta     Potential temperature
  !> @param[in]     moist_dyn Moist dynamics factors
  !> @param[in]     exner     Exner pressure
  !> @param[in]     mesh_id   Mesh_id
  subroutine hydbal_diagnostic_alg(l2, theta, moist_dyn, exner, mesh_id)
    use field_mod,                   only: field_type
    use quadrature_xyoz_mod,         only: quadrature_xyoz_type
    use fs_continuity_mod,           only: W2V

    use moist_dyn_mod,               only: num_moist_factors

    ! PsyKAl PSYClone kernels
    use enforce_bc_kernel_mod,               only: enforce_bc_kernel_type
    use hydrostatic_kernel_mod,              only: hydrostatic_kernel_type
    use runtime_constants_mod,               only: get_geopotential,         &
                                                   get_qr


    implicit none
    type(field_type), intent(in) :: theta, moist_dyn(num_moist_factors), exner
    real(r_def), intent(inout)   :: l2
    type(field_type), pointer    :: geopotential => null()
    type(field_type)             :: hyd_imbal
    integer(i_def),   intent(in) :: mesh_id

    ! the quadrature object
    type( quadrature_xyoz_type ) :: qr

    call hyd_imbal%initialise( vector_space = function_space_collection%get_fs(mesh_id,element_order, W2V) )

    qr = get_qr()

    ! Get geopotential field from runtime_constants
    geopotential => get_geopotential()

    call invoke( setval_c(hyd_imbal, 0.0_r_def), &
                 hydrostatic_kernel_type( hyd_imbal, exner, theta, moist_dyn, &
                                          geopotential, qr ), &
                 enforce_bc_kernel_type( hyd_imbal ), &
                 X_innerproduct_X(l2, hyd_imbal) )

    l2 = sqrt(l2)

  end subroutine hydbal_diagnostic_alg

  !> @details Splits a 3D wind field into Horizontal (on W2H) and Vertical (on W2V)
  !>          fields after projecting to physical space using the Piola transform
  !> @param[inout] u1_wind  Meridional wind component
  !> @param[inout] u2_wind  Zonal wind component
  !> @param[inout] u3_wind  Vertical wind component
  !> @param[in] wind        3D wind field
  !> @param[in] mesh_id     Mesh_id
  subroutine split_wind_diagnostic_alg(u1_wind, u2_wind, u3_wind, &
                                       wind, mesh_id)

    use convert_hdiv_field_kernel_mod,       only: convert_hdiv_field_kernel_type
    use extract_w_kernel_mod,                only: extract_w_kernel_type
    use extract_uv_kernel_mod,               only: extract_uv_kernel_type



    implicit none

    type(field_type), intent(inout)  :: u1_wind, u2_wind, u3_wind
    type(field_type), intent(in)     :: wind
    integer(i_def),   intent(in)     :: mesh_id

    type(field_type), pointer    :: chi_xyz(:) => null(), &
                                    chi_sph(:) => null(), &
                                    panel_id => null()
    type(field_type)             :: physical_wind(3)
    type(field_type)             :: physical_chi(3)
    type(field_type), pointer    :: w2_rmultiplicity

    integer(i_def)               :: i


    ! get chi field
    chi_xyz => get_coordinates_xyz()
    chi_sph => get_coordinates()
    panel_id => get_panel_id()

    ! Create intermediate fields
    do i = 1,3
      call wind%copy_field_properties(physical_wind(i))
      call wind%copy_field_properties(physical_chi(i))
      call invoke( setval_c(physical_wind(i), 0.0_r_def) )
    end do

    call u1_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, W2H) )

    call u2_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, W2H) )

    call u3_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, Wtheta) )

    w2_rmultiplicity => get_rmultiplicity( W2 )

    call invoke( setval_c(u1_wind, 0.0_r_def), &
                 setval_c(u2_wind, 0.0_r_def), &
                 setval_c(u3_wind, 0.0_r_def) )

    ! Convert coordinate field to physical space

    call invoke( nodal_coordinates_kernel_type(physical_chi, chi_xyz) )

    ! Convert 3D wind field to 3 components using the Piola transform

    call invoke( convert_hdiv_field_kernel_type(physical_wind, wind, chi_sph, panel_id) )

    ! Scale fields by the reciprocal of multiplicity
    do i = 1,3
      call invoke( inc_X_times_Y(physical_wind(i), w2_rmultiplicity) )
    end do

    ! Convert to standard SI units (m/s) in orthogonal directions

    if ( geometry == geometry_spherical ) then
        call invoke_convert_cart2sphere_vector(physical_wind, physical_chi)
    end if

    ! Extract vertical wind into W2V and u,v winds into W2H

    call invoke( extract_w_kernel_type(u3_wind, physical_wind(3)),  &
                 extract_uv_kernel_type(u1_wind, physical_wind(1)), &
                 extract_uv_kernel_type(u2_wind, physical_wind(2)) )


  end subroutine split_wind_diagnostic_alg

  !> @details Generic diagnostic processing for a scalar field to nodal format
  !>          Allows optional projection to W3
  !> @param[inout] output_field      The output field
  !> @param[inout] nodal_coordinates Coordinates of the output field
  !> @param[inout] level             Levels of the output field
  !> @param[in] field_name           Name of the field to be output
  !> @param[in] field                The input field
  !> @param[in] mesh_id              Mesh_id
  !> @param[in] W3_project           Logical to allow projection to W3
  subroutine scalar_nodal_diagnostic_alg(output_field, nodal_coordinates, level, &
                                         field_name, field,                      &
                                         mesh_id, W3_project)

    implicit none

    type(field_type), intent(inout) :: nodal_coordinates(3)
    type(field_type), intent(inout) :: output_field(3)
    type(field_type), intent(inout) :: level
    character(len=*), intent(in)    :: field_name
    type(field_type), intent(in)    :: field
    integer(i_def),   intent(in)    :: mesh_id
    logical,          intent(in)    :: W3_project

    ! Local variables
    type(field_type), pointer       :: chi_xyz(:) => null()
    integer(i_def)                  :: i


    ! get chi field
    chi_xyz => get_coordinates_xyz()

    ! Check if projection required, setup output field and filename

    if (W3_project) then

      ! Projection to W3, but check if field is already W3

      if (field%which_function_space() == W3) then

        ! Already on W3, so log a warning but continue
        write( log_scratch_space, '(A,A,A)' )  'Diagnostics: ', &
                                  trim(field_name), &
                                  ' already on W3, no projection applied'
        call log_event( log_scratch_space, LOG_LEVEL_INFO )

        ! Setup output field the same as input
        call field%copy_field_properties(output_field(1))
        call invoke( setval_X(output_field(1), field) )

      else

        ! Project the field to the output field
        call project_output(field, output_field, 1, W3 , mesh_id)

      end if

    else

      ! No projection required

      ! Setup output field the same as input
      call field%copy_field_properties(output_field(1))
      call invoke( setval_X(output_field(1), field) )

    end if

    ! Create nodal coordinates and levels fields from the properties
    ! of the output field
    do i = 1,3
      call output_field(1)%copy_field_properties(nodal_coordinates(i))
    end do

    call output_field(1)%copy_field_properties(level)

    ! Convert field to physical nodal output & sample chi on nodal points
    call invoke( nodal_coordinates_kernel_type(nodal_coordinates, chi_xyz) )

    ! If in spherical geometry,
    ! convert the coordinate field to (longitude, latitude, radius)
    if ( geometry == geometry_spherical ) then
      call invoke_pointwise_convert_xyz2llr(nodal_coordinates)
    end if

    ! Compute fractional level of every dof
    call invoke_compute_dof_level_kernel(level)


  end subroutine scalar_nodal_diagnostic_alg

  !> @details Generic diagnostic processing for a vector field to nodal format
  !> @param[inout] output_field      The output field
  !> @param[inout] output_dim        Dimension of the output field
  !> @param[inout] nodal_coordinates Coordinates of the output field
  !> @param[inout] level             Levels of the output field
  !> @param[in] field_name           Name of the field to be output
  !> @param[in] field                The input field
  subroutine vector_nodal_diagnostic_alg(output_field, output_dim, &
                                         nodal_coordinates, level, &
                                         field_name, field)

    use convert_hdiv_field_kernel_mod,  only: convert_hdiv_field_kernel_type
    use convert_hcurl_field_kernel_mod, only: convert_hcurl_field_kernel_type

    implicit none

    integer(i_def), intent(inout)   :: output_dim
    type(field_type), intent(inout) :: nodal_coordinates(3)
    type(field_type), intent(inout) :: output_field(3)
    type(field_type), intent(inout) :: level
    character(len=*), intent(in)    :: field_name
    type(field_type), intent(in)    :: field

    ! Local variables
    type(field_type), pointer       :: chi_xyz(:) => null(), &
                                       chi_sph(:) => null(), &
                                       panel_id => null()
    integer(i_def)                  :: i
    integer(i_def)                  :: output_fs
    type(field_type), pointer       :: rmultiplicity

    ! get chi field
    chi_xyz => get_coordinates_xyz()
    chi_sph => get_coordinates()
    panel_id => get_panel_id()

    ! Create nodal coordinates, nodal output and levels fields
    ! from the properties of the input field

    do i = 1,3
      call field%copy_field_properties(nodal_coordinates(i))
      call field%copy_field_properties(output_field(i))
      call invoke( setval_c(output_field(i), 0.0_r_def) )
    end do

    call field%copy_field_properties(level)

    ! Convert field to physical nodal output & sample chi on nodal points
    call invoke( nodal_coordinates_kernel_type(nodal_coordinates, chi_xyz) )

    output_fs = field%which_function_space()

    ! Apply Piola transform to get collocated components

    if ( output_fs == W1 ) then
      call invoke( convert_hcurl_field_kernel_type(output_field, field, chi_sph, panel_id) )
      output_dim = 3
    else if ( output_fs == W2 ) then
      call invoke( convert_hdiv_field_kernel_type(output_field, field, chi_sph, panel_id) )
      output_dim = 3
    else
      ! If we didn't get a W1 or W2 field, just pass it through
      write( log_scratch_space, '(A,A,A)' )  'Diagnostics: ', &
                                 trim(field_name), &
                                 ' not W1 or W2, no conversion applied'
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      call invoke( setval_X(output_field(1), field) )
      output_dim = 1
    end if

    ! Scale by the reciprocal of multiplicity (number of shared dofs
    ! in a cell
    if ( output_fs == W1 .or. output_fs == W2) then
      rmultiplicity => get_rmultiplicity( output_fs )
      do i = 1,output_dim
        call invoke( inc_X_times_Y(output_field(i), rmultiplicity) )
      end do
    end if

    ! Convert the vector spaces to standard SI units
    ! (m/s) in orthogonal directions and, if in spherical geometry,
    !  convert the coordinate field to (longitude, latitude, radius)
    if ( geometry == geometry_spherical ) then
      if ( output_fs == W1 .or. output_fs == W2) then
        call invoke_convert_cart2sphere_vector(output_field, nodal_coordinates)
      end if
      call invoke_pointwise_convert_xyz2llr(nodal_coordinates)
    end if

    ! Compute fractional level of every dof
    call invoke_compute_dof_level_kernel(level)


  end subroutine vector_nodal_diagnostic_alg


  !> @details Generic diagnostic processing for a scalar field output in ugrid format
  !>          Allows optional projection to W3
  !> @param[inout] output_field       The output field
  !> @param[in] field_name            The field name to use for output
  !> @param[in] field                 The input field
  !> @param[in] mesh_id               Mesh_id
  !> @param[in] W3_project            Logical to allow projection to W3
  subroutine scalar_ugrid_diagnostic_alg(output_field, field_name, field, &
                                         mesh_id, W3_project)

    implicit none
    type(field_type), intent(inout) :: output_field(1)
    character(len=*), intent(in)    :: field_name
    type(field_type), intent(in)    :: field
    integer(i_def),   intent(in)    :: mesh_id
    logical,          intent(in)    :: W3_project

    ! Local variables
    type(mesh_type), pointer        :: mesh => null()


    ! get pointer to local mesh
    mesh => mesh_collection%get_mesh( mesh_id )


    ! Check if projection required, setup output field and filename

    if (W3_project) then

      ! Projection to W3, but check if field is already W3

      if (field%which_function_space() == W3) then

        ! Already on W3, so log a warning but continue
        write( log_scratch_space, '(A,A,A)' )  'Diagnostics: ', &
                                  trim(field_name), &
                                  ' already on W3, no projection applied'
        call log_event( log_scratch_space, LOG_LEVEL_INFO )

      else

        ! Project the field to the output field
        call project_output(field, output_field, 1, W3 , mesh_id)

      end if

    else

      ! No projection required

      ! Setup output field the same as input
      call field%copy_field_properties(output_field(1))
      call invoke( setval_X(output_field(1), field) )

    end if

  end subroutine scalar_ugrid_diagnostic_alg

  !> @details Calculates the diagnostic vorticity from the wind
  !> @param[out] vorticity  Vorticity ( curl(u) ) to compute
  !> @param[in]  u          3D wind field
  !> @param[in]  timestep   Model timestep number
  subroutine vorticity_diagnostic_alg(vorticity, u)
    use io_config_mod,                  only: use_xios_io
    use fs_continuity_mod,              only: W1, W2
    use compute_vorticity_alg_mod,      only: compute_vorticity_alg
    use finite_element_config_mod,      only: element_order, &
                                              vorticity_in_w1
    use function_space_collection_mod,  only: function_space_collection
    use field_parent_mod,               only: write_interface
    use lfric_xios_write_mod,           only: write_field_face
    implicit none

    type(field_type), intent(out) :: vorticity
    type(field_type), intent(in)  :: u

    procedure(write_interface), pointer :: tmp_write_ptr => null()
    integer(i_def)                      :: mesh_id

    mesh_id = u%get_mesh_id()
    if ( vorticity_in_w1 ) then
      call vorticity%initialise( vector_space = &
          function_space_collection%get_fs(mesh_id, element_order, W1) )
    else
      call vorticity%initialise( vector_space = &
          function_space_collection%get_fs(mesh_id, element_order, W2) )
    end if
    call compute_vorticity_alg(vorticity, u, .false.)

    if ( use_xios_io ) then
      tmp_write_ptr => write_field_face
      ! Vector fields that are projected to scalar components
      call vorticity%set_write_behaviour(tmp_write_ptr)
      nullify( tmp_write_ptr )
    end if

  end subroutine vorticity_diagnostic_alg

  !> @brief Computes the relative l2-norm between 2 fields.
  !> @details l2-norm=SQRT(SUM[(field-field_ref)**2])/SQRT(SUM[field_ref**2]).
  !>          If field_ref=0 l2-norm=SQRT(SUM[field**2])/SQRT(SUM[ones**2]).
  !>          This may be replaced with PSyclone built-in (PSyclone issue #892).
  !> @param[out] l2norm     L2-norm
  !> @param[in]  field      Field for which l2-norm diff is computed
  !> @param[in]  field_ref  Second field which is the reference against
  !>                        which the relative l2-norm is computed

  subroutine l2norm_diff_2fields(l2norm, field, field_ref )
    use field_mod,       only: field_type
    use constants_mod,   only: r_def, tiny_eps

    implicit none

    type(field_type), intent(in)  :: field, field_ref
    real(r_def), intent(out)      :: l2norm
    type(field_type)              :: field_diff
    real(r_def)                   :: f_min, f_max, fc_max
    real(r_def)                   :: num, deno

    call field_diff%initialise( vector_space = field%get_function_space())

    call field_ref%field_minmax(f_min, f_max)
    fc_max = max(abs(f_max),abs(f_min))

    if ( fc_max > tiny_eps ) then
        call invoke( X_innerproduct_X(deno, field_ref) )
     else
        ! This to avoid dividing by zero when the field_ref=0
        ! In this case l2norm=SQRT(SUM[field**2]/size(field))
        ! Tiny_eps has to be the smallest real possible.

        call invoke( setval_c(field_diff,1.0_r_def),    &
                     X_innerproduct_X(deno, field_diff) )
    end if

    call invoke( X_minus_Y(field_diff,field,field_ref),  &
                 X_innerproduct_X(num, field_diff)    )

    l2norm = sqrt(num)/sqrt(deno)

  end subroutine l2norm_diff_2fields

end module diagnostic_alg_mod
