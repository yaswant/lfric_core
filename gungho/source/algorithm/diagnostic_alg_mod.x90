!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief Algorithms to do field processing to produce generic and specific
!>        diagnostics for different I/O methods
module diagnostic_alg_mod
  use constants_mod,                    only: i_def, r_def, l_def, str_max_filename
  use finite_element_config_mod,        only: element_order
  use base_mesh_config_mod,             only: geometry, &
                                              geometry_spherical
  use planet_config_mod,                only: cp
  use mesh_mod,                         only: mesh_type
  use mesh_collection_mod,              only: mesh_collection
  use function_space_collection_mod,    only: function_space_collection
  use fs_continuity_mod,                only: W1, W2, W3, Wtheta, W2H
  use field_mod,                        only: field_type
  use operator_mod,                     only: operator_type
  use nodal_xyz_coordinates_kernel_mod, only: nodal_xyz_coordinates_kernel_type
  use psykal_lite_mod,                  only: invoke_compute_dof_level_kernel
  use psykal_builtin_light_mod,         only: invoke_convert_cart2sphere_vector, &
                                              invoke_pointwise_convert_xyz2llr
  use fem_constants_mod,                only: get_rmultiplicity
  use geometric_constants_mod,          only: get_coordinates,     &
                                              get_panel_id
  use project_output_mod,               only: project_output
  use log_mod,                          only: log_event,         &
                                              log_scratch_space, &
                                              LOG_LEVEL_INFO

  implicit none

  private
  public :: divergence_diagnostic_alg
  public :: hydbal_diagnostic_alg
  public :: split_wind_diagnostic_alg
  public :: scalar_nodal_diagnostic_alg
  public :: vector_nodal_diagnostic_alg
  public :: scalar_ugrid_diagnostic_alg
  public :: vorticity_diagnostic_alg
  public :: l2norm_diff_2fields
  public :: extract_w2h_diagnostic_alg
  public :: column_total_diagnostics_alg
  public :: calc_wbig_diagnostic_alg

contains

  !> @details Calculates the l2 error norm for wind divergence
  !> @param[in,out] divergence  Divergence field
  !> @param[in,out] l2          l2 norm
  !> @param[in] u               3D wind field
  !> @param[in] mesh_id         Mesh_id
  subroutine divergence_diagnostic_alg(divergence, l2, u, mesh_id)
    use dg_matrix_vector_kernel_mod,  only: dg_matrix_vector_kernel_type
    use fem_constants_mod,            only: get_inverse_w3_mass_matrix, &
                                            get_div
    use constants_mod,                only: pi

    implicit none
    type(field_type), intent(inout) :: divergence
    real(r_def), intent(inout)      :: l2
    type(field_type), intent(in)    :: u
    integer(i_def),   intent(in)    :: mesh_id

    type(field_type)             :: div_u
    type(operator_type), pointer :: div => null(), m3_inv => null()

    call divergence%initialise( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    call div_u%initialise( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div    => get_div(mesh_id)
    m3_inv => get_inverse_w3_mass_matrix(mesh_id)
    ! Compute l2 norm of area integrated quantity
    call invoke( dg_matrix_vector_kernel_type( div_u, u, div ),             &
                 dg_matrix_vector_kernel_type( divergence, div_u , m3_inv), &
                 X_innerproduct_Y( l2, div_u, divergence ) )
    l2 = sqrt(l2)

    ! Convert to pointwise W3 field for output
    call invoke( dg_matrix_vector_kernel_type( divergence, div_u , m3_inv ) )


  end subroutine divergence_diagnostic_alg

!=============================================================================!
  !> @details An algorithm for calculating the l2 norm for the hydrostatic
  !>          imbalance. It calculates the sum of pressure gradient and
  !>          gravity term at each timestep using the hydrostatic kernel.
  !> @param[in,out] l2        l2 norm
  !> @param[in]     theta     Potential temperature
  !> @param[in]     moist_dyn Moist dynamics factors
  !> @param[in]     exner     Exner pressure
  !> @param[in]     mesh_id   Mesh_id
  subroutine hydbal_diagnostic_alg(l2, theta, moist_dyn, exner, mesh_id)
    use field_mod,                   only: field_type
    use quadrature_xyoz_mod,         only: quadrature_xyoz_type
    use fs_continuity_mod,           only: W2V

    use moist_dyn_mod,               only: num_moist_factors

    ! PsyKAl PSYClone kernels
    use enforce_bc_kernel_mod,       only: enforce_bc_kernel_type
    use hydrostatic_kernel_mod,      only: hydrostatic_kernel_type
    use physical_op_constants_mod,   only: get_geopotential
    use fem_constants_mod,           only: get_qr


    implicit none
    type(field_type), intent(in) :: theta, moist_dyn(num_moist_factors), exner
    real(r_def), intent(inout)   :: l2
    type(field_type), pointer    :: geopotential => null()
    type(field_type)             :: hyd_imbal
    integer(i_def),   intent(in) :: mesh_id

    ! the quadrature object
    type( quadrature_xyoz_type ), pointer :: qr => null()

    call hyd_imbal%initialise( vector_space = function_space_collection%get_fs(mesh_id,element_order, W2V) )

    qr => get_qr()

    ! Get geopotential field from runtime_constants
    geopotential => get_geopotential(theta%get_mesh_id())

    call invoke( setval_c(hyd_imbal, 0.0_r_def), &
                 hydrostatic_kernel_type( hyd_imbal, exner, theta, moist_dyn, &
                                          geopotential, cp, qr ),             &
                 enforce_bc_kernel_type( hyd_imbal ),                         &
                 X_innerproduct_X(l2, hyd_imbal) )

    l2 = sqrt(l2)

    nullify( geopotential, qr )

  end subroutine hydbal_diagnostic_alg

  !> @details Splits a 3D wind field into Horizontal (on W2H) and Vertical (on W2V)
  !>          fields after projecting to physical space using the Piola transform
  !> @param[in,out] u1_wind  Meridional wind component
  !> @param[in,out] u2_wind  Zonal wind component
  !> @param[in,out] u3_wind  Vertical wind component
  !> @param[in] wind         3D wind field
  !> @param[in] mesh_id      Mesh_id
  subroutine split_wind_diagnostic_alg(u1_wind, u2_wind, u3_wind, &
                                       wind, mesh_id)

    use convert_hdiv_field_kernel_mod,       only: convert_hdiv_field_kernel_type
    use extract_w_kernel_mod,                only: extract_w_kernel_type
    use extract_uv_kernel_mod,               only: extract_uv_kernel_type



    implicit none

    type(field_type), intent(inout)  :: u1_wind, u2_wind, u3_wind
    type(field_type), intent(in)     :: wind
    integer(i_def),   intent(in)     :: mesh_id

    type(field_type), pointer    :: chi(:) => null(), &
                                    panel_id => null()
    type(field_type)             :: physical_wind(3)
    type(field_type)             :: physical_chi(3)
    type(field_type), pointer    :: w2_rmultiplicity

    integer(i_def)               :: i


    ! get chi field
    chi => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    ! Create intermediate fields
    do i = 1,3
      call wind%copy_field_properties(physical_wind(i))
      call wind%copy_field_properties(physical_chi(i))
      call invoke( setval_c(physical_wind(i), 0.0_r_def) )
    end do

    call u1_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, W2H) )

    call u2_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, W2H) )

    call u3_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, Wtheta) )

    w2_rmultiplicity => get_rmultiplicity( W2, mesh_id )

    call invoke( setval_c(u1_wind, 0.0_r_def), &
                 setval_c(u2_wind, 0.0_r_def), &
                 setval_c(u3_wind, 0.0_r_def) )

    ! Convert coordinate field to physical space

    call invoke( nodal_xyz_coordinates_kernel_type(physical_chi, chi, panel_id) )

    ! Convert 3D wind field to 3 components using the Piola transform

    call invoke( convert_hdiv_field_kernel_type(physical_wind, wind, chi, panel_id) )

    ! Scale fields by the reciprocal of multiplicity
    do i = 1,3
      call invoke( inc_X_times_Y(physical_wind(i), w2_rmultiplicity) )
    end do

    ! Convert to standard SI units (m/s) in orthogonal directions

    if ( geometry == geometry_spherical ) then
        call invoke_convert_cart2sphere_vector(physical_wind, physical_chi)
    end if

    ! Extract vertical wind into W2V and u,v winds into W2H

    call invoke( extract_w_kernel_type(u3_wind, physical_wind(3)),  &
                 extract_uv_kernel_type(u1_wind, physical_wind(1)), &
                 extract_uv_kernel_type(u2_wind, physical_wind(2)) )


  end subroutine split_wind_diagnostic_alg

  !> @details Generic diagnostic processing for a scalar field to nodal format
  !>          Allows optional projection to W3
  !> @param[in,out] output_field      The output field. A 1-element array to satisfy project_output API
  !> @param[in,out] nodal_coordinates Coordinates of the output field
  !> @param[in,out] level             Levels of the output field
  !> @param[in] field_name            Name of the field to be output
  !> @param[in] field                 The input field
  !> @param[in] mesh_id               Mesh_id
  !> @param[in] W3_project            Logical to allow projection to W3
  subroutine scalar_nodal_diagnostic_alg(output_field, nodal_coordinates, level, &
                                         field_name, field,                      &
                                         mesh_id, W3_project)

    implicit none

    type(field_type), intent(inout) :: nodal_coordinates(3)
    type(field_type), intent(inout) :: output_field(1)
    type(field_type), intent(inout) :: level
    character(len=*), intent(in)    :: field_name
    type(field_type), intent(in)    :: field
    integer(i_def),   intent(in)    :: mesh_id
    logical(l_def),   intent(in)    :: W3_project

    ! Local variables
    type(field_type), pointer       :: chi(:) => null()
    type(field_type), pointer       :: panel_id => null()
    integer(i_def)                  :: i

    ! get chi field
    chi => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    ! Check if projection required, setup output field and filename

    if (W3_project) then

      ! Projection to W3, but check if field is already W3

      if (field%which_function_space() == W3) then

        ! Already on W3, so log a warning but continue
        write( log_scratch_space, '(A,A,A)' )  'Diagnostics: ', &
                                  trim(field_name), &
                                  ' already on W3, no projection applied'
        call log_event( log_scratch_space, LOG_LEVEL_INFO )

        ! Setup output field the same as input
        call field%copy_field_properties(output_field(1))
        call invoke( setval_X(output_field(1), field) )

      else

        ! Project the field to the output field
        call project_output(field, output_field, 1, W3 , mesh_id)

      end if

    else

      ! No projection required

      ! Setup output field the same as input
      call field%copy_field_properties(output_field(1))
      call invoke( setval_X(output_field(1), field) )

    end if

    ! Create nodal coordinates and levels fields from the properties
    ! of the output field
    do i = 1,3
      call output_field(1)%copy_field_properties(nodal_coordinates(i))
    end do

    call output_field(1)%copy_field_properties(level)

    ! Convert field to physical nodal output & sample chi on nodal points
    call invoke( nodal_xyz_coordinates_kernel_type(nodal_coordinates, chi, panel_id) )

    ! If in spherical geometry,
    ! convert the coordinate field to (longitude, latitude, radius)
    if ( geometry == geometry_spherical ) then
      call invoke_pointwise_convert_xyz2llr(nodal_coordinates)
    end if

    ! Compute fractional level of every dof
    call invoke_compute_dof_level_kernel(level)


  end subroutine scalar_nodal_diagnostic_alg

  !> @details Generic diagnostic processing for a vector field to nodal format
  !> @param[in,out] output_field      The output field
  !> @param[in,out] output_dim        Dimension of the output field
  !> @param[in,out] nodal_coordinates Coordinates of the output field
  !> @param[in,out] level             Levels of the output field
  !> @param[in] field_name            Name of the field to be output
  !> @param[in] field                 The input field
  subroutine vector_nodal_diagnostic_alg(output_field, output_dim, &
                                         nodal_coordinates, level, &
                                         field_name, field)

    use convert_hdiv_field_kernel_mod,  only: convert_hdiv_field_kernel_type
    use convert_hcurl_field_kernel_mod, only: convert_hcurl_field_kernel_type

    implicit none

    integer(i_def), intent(inout)   :: output_dim
    type(field_type), intent(inout) :: nodal_coordinates(3)
    type(field_type), intent(inout) :: output_field(3)
    type(field_type), intent(inout) :: level
    character(len=*), intent(in)    :: field_name
    type(field_type), intent(in)    :: field

    ! Local variables
    type(field_type), pointer       :: chi(:) => null(), &
                                       panel_id => null()
    integer(i_def)                  :: i, mesh_id
    integer(i_def)                  :: output_fs
    type(field_type), pointer       :: rmultiplicity

    mesh_id = field%get_mesh_id()

    ! get chi field
    chi => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    ! Create nodal coordinates, nodal output and levels fields
    ! from the properties of the input field

    do i = 1,3
      call field%copy_field_properties(nodal_coordinates(i))
      call field%copy_field_properties(output_field(i))
      call invoke( setval_c(output_field(i), 0.0_r_def) )
    end do

    call field%copy_field_properties(level)

    ! Convert field to physical nodal output & sample chi on nodal points
    call invoke( nodal_xyz_coordinates_kernel_type(nodal_coordinates, chi, panel_id) )

    output_fs = field%which_function_space()

    ! Apply Piola transform to get collocated components

    if ( output_fs == W1 ) then
      call invoke( convert_hcurl_field_kernel_type(output_field, field, chi, panel_id) )
      output_dim = 3
    else if ( output_fs == W2 ) then
      call invoke( convert_hdiv_field_kernel_type(output_field, field, chi, panel_id) )
      output_dim = 3
    else
      ! If we didn't get a W1 or W2 field, just pass it through
      write( log_scratch_space, '(A,A,A)' )  'Diagnostics: ', &
                                 trim(field_name), &
                                 ' not W1 or W2, no conversion applied'
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      call invoke( setval_X(output_field(1), field) )
      output_dim = 1
    end if

    ! Scale by the reciprocal of multiplicity (number of shared dofs
    ! in a cell
    if ( output_fs == W1 .or. output_fs == W2) then
      rmultiplicity => get_rmultiplicity( output_fs, mesh_id )
      do i = 1,output_dim
        call invoke( inc_X_times_Y(output_field(i), rmultiplicity) )
      end do
    end if

    ! Convert the vector spaces to standard SI units
    ! (m/s) in orthogonal directions and, if in spherical geometry,
    !  convert the coordinate field to (longitude, latitude, radius)
    if ( geometry == geometry_spherical ) then
      if ( output_fs == W1 .or. output_fs == W2) then
        call invoke_convert_cart2sphere_vector(output_field, nodal_coordinates)
      end if
      call invoke_pointwise_convert_xyz2llr(nodal_coordinates)
    end if

    ! Compute fractional level of every dof
    call invoke_compute_dof_level_kernel(level)


  end subroutine vector_nodal_diagnostic_alg


  !> @details Generic diagnostic processing for a scalar field output in ugrid format
  !>          Allows optional projection to W3
  !> @param[in,out] output_field      The output field
  !> @param[in] field_name            The field name to use for output
  !> @param[in] field                 The input field
  !> @param[in] mesh_id               Mesh_id
  !> @param[in] W3_project            Logical to allow projection to W3
  subroutine scalar_ugrid_diagnostic_alg(output_field, field_name, field, &
                                         mesh_id, W3_project)

    implicit none
    type(field_type), intent(inout) :: output_field(1)
    character(len=*), intent(in)    :: field_name
    type(field_type), intent(in)    :: field
    integer(i_def),   intent(in)    :: mesh_id
    logical(l_def),   intent(in)    :: W3_project

    ! Local variables
    type(mesh_type), pointer        :: mesh => null()


    ! get pointer to local mesh
    mesh => mesh_collection%get_mesh( mesh_id )


    ! Check if projection required, setup output field and filename

    if (W3_project) then

      ! Projection to W3, but check if field is already W3

      if (field%which_function_space() == W3) then

        ! Already on W3, so log a warning but continue
        write( log_scratch_space, '(A,A,A)' )  'Diagnostics: ', &
                                  trim(field_name), &
                                  ' already on W3, no projection applied'
        call log_event( log_scratch_space, LOG_LEVEL_INFO )

      else

        ! Project the field to the output field
        call project_output(field, output_field, 1, W3 , mesh_id)

      end if

    else

      ! No projection required

      ! Setup output field the same as input
      call field%copy_field_properties(output_field(1))
      call invoke( setval_X(output_field(1), field) )

    end if

  end subroutine scalar_ugrid_diagnostic_alg

  !> @details Calculates the diagnostic vorticity from the wind
  !> @param[out] vorticity  Vorticity ( curl(u) ) to compute
  !> @param[in]  u          3D wind field
  !> @param[in]  timestep   Model timestep number
  subroutine vorticity_diagnostic_alg(vorticity, u)
    use io_config_mod,                  only: use_xios_io
    use fs_continuity_mod,              only: W1, W2
    use compute_vorticity_alg_mod,      only: compute_vorticity_alg
    use finite_element_config_mod,      only: element_order, &
                                              vorticity_in_w1
    use function_space_collection_mod,  only: function_space_collection
    use field_parent_mod,               only: write_interface
    use lfric_xios_write_mod,           only: write_field_face
    implicit none

    type(field_type), intent(out) :: vorticity
    type(field_type), intent(in)  :: u

    procedure(write_interface), pointer :: tmp_write_ptr => null()
    integer(i_def)                      :: mesh_id

    mesh_id = u%get_mesh_id()
    if ( vorticity_in_w1 ) then
      call vorticity%initialise( vector_space = &
          function_space_collection%get_fs(mesh_id, element_order, W1) )
    else
      call vorticity%initialise( vector_space = &
          function_space_collection%get_fs(mesh_id, element_order, W2) )
    end if
    call compute_vorticity_alg(vorticity, u, .false.)

    if ( use_xios_io ) then
      tmp_write_ptr => write_field_face
      ! Vector fields that are projected to scalar components
      call vorticity%set_write_behaviour(tmp_write_ptr)
      nullify( tmp_write_ptr )
    end if

  end subroutine vorticity_diagnostic_alg

  !> @brief Computes the relative l2-norm between 2 fields.
  !> @details l2-norm=SQRT(SUM[(field-field_ref)**2])/SQRT(SUM[field_ref**2]).
  !>          If field_ref=0 l2-norm=SQRT(SUM[field**2])/SQRT(SUM[ones**2]).
  !>          This may be replaced with PSyclone built-in (PSyclone issue #892).
  !> @param[out] l2norm     L2-norm
  !> @param[in]  field      Field for which l2-norm diff is computed
  !> @param[in]  field_ref  Second field which is the reference against
  !>                        which the relative l2-norm is computed

  subroutine l2norm_diff_2fields(l2norm, field, field_ref )
    use field_mod,       only: field_type
    use constants_mod,   only: r_def, tiny_eps

    implicit none

    type(field_type), intent(in)  :: field, field_ref
    real(r_def), intent(out)      :: l2norm
    type(field_type)              :: field_diff
    real(r_def)                   :: f_min, f_max, fc_max
    real(r_def)                   :: num, deno

    call field_diff%initialise( vector_space = field%get_function_space())

    call field_ref%field_minmax(f_min, f_max)
    fc_max = max(abs(f_max),abs(f_min))

    if ( fc_max > tiny_eps ) then
        call invoke( X_innerproduct_X(deno, field_ref) )
     else
        ! This to avoid dividing by zero when the field_ref=0
        ! In this case l2norm=SQRT(SUM[field**2]/size(field))
        ! Tiny_eps has to be the smallest real possible.

        call invoke( setval_c(field_diff,1.0_r_def),    &
                     X_innerproduct_X(deno, field_diff) )
    end if

    call invoke( X_minus_Y(field_diff,field,field_ref),  &
                 X_innerproduct_X(num, field_diff)    )

    l2norm = sqrt(num)/sqrt(deno)

  end subroutine l2norm_diff_2fields

  subroutine extract_w2h_diagnostic_alg( h_wind, v_wind, wind, mesh_id )
    use split_w2_field_kernel_mod,        only: split_w2_field_kernel_type

    implicit none

    type(field_type), intent(inout)  :: h_wind, v_wind
    type(field_type), intent(in)     :: wind
    integer(i_def),   intent(in)     :: mesh_id

    call h_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, W2H) )

    call v_wind%initialise( vector_space = &
              function_space_collection%get_fs(mesh_id,element_order, Wtheta) )

    call invoke( split_w2_field_kernel_type(h_wind, v_wind, wind) )

  end subroutine extract_w2h_diagnostic_alg

!=============================================================================!
  !> @brief Calculate column totals of dry and wet fields.
  !> @details Calculates column totals for wet + dry air, dry air only and each
  !!          of the different moisture spieces represented by LFRic.
  !> @param[in] rho_field 3D dry density field
  !> @param[in] mr Bundle of moisture mixing ratios (nummr is index for speices X)
  !> @param[in] mesh_id The identifier of the primary mesh
  !> @param[in] twod_mesh_id The identifier given to the current 2D mesh

  subroutine column_total_diagnostics_alg(rho_field, mr, mesh_id, twod_mesh_id)

    use compute_column_mass_kernel_mod,   only: compute_column_mass_kernel_type
    use geometric_constants_mod,          only: get_height
    use io_config_mod,                    only: write_diag, use_xios_io
    use lfric_xios_write_mod,             only: write_field_single_face
    use field_parent_mod,                 only: write_interface
    use mr_indices_mod,                   only: nummr, mr_names
    use function_space_mod,               only: function_space_type
    use physics_mappings_alg_mod,         only: map_physics_scalars
    use planet_config_mod,                only: radius

    implicit none

    type(field_type),  intent(in)    :: rho_field
    type(field_type),  intent(in)    :: mr(nummr)
    integer(i_def),    intent(in)    :: mesh_id
    integer(i_def),    intent(in)    :: twod_mesh_id

    ! Set up local fields
    ! 3D fields
    type( field_type ) :: mr_w3(nummr)         ! mixing ratio of moist species X
    type( field_type ) :: rho_moist_X(nummr)   ! moist mass per unit volume in cell (rho_field * mr_w3)

    ! 2D fields
    type( field_type ) :: tot_col_dry_air_mass      ! dry column mass
    type( field_type ) :: tot_col_moist_mass(nummr) ! moist column mass total for species X
    type( field_type ) :: tot_col_wetplusdry_mass   ! moist + dry mass column total

    integer(kind=i_def)  :: i_mr

    ! Set pointers
    type( field_type ), pointer :: height_w3 => null()
    type( field_type ), pointer :: height_wth => null()
    type(function_space_type), pointer :: w3_fs => null()
    procedure(write_interface), pointer :: write_diag_behaviour => null()

    height_w3 => get_height(W3, mesh_id)
    height_wth => get_height(Wtheta, mesh_id)
    w3_fs => rho_field%get_function_space()
    write_diag_behaviour => write_field_single_face

    ! Set up tot_col_dry_air_mass field and make it writeable
    call tot_col_dry_air_mass%initialise( vector_space = &
                    function_space_collection%get_fs(twod_mesh_id, 0, W3) )

    call tot_col_dry_air_mass%copy_field_properties(tot_col_wetplusdry_mass)

    ! Make the 2D column total fields write-enabled for diagnostic purposes
    call tot_col_dry_air_mass%set_write_behaviour(write_diag_behaviour)
    call tot_col_wetplusdry_mass%set_write_behaviour(write_diag_behaviour)

    call invoke( compute_column_mass_kernel_type(rho_field, height_w3, &
                                                height_wth, tot_col_dry_air_mass, &
                                                radius) )

    call invoke( setval_X(tot_col_wetplusdry_mass, tot_col_dry_air_mass) )

    do i_mr = 1, nummr

      ! Initialise the moisture fields
      call mr_w3(i_mr)%initialise( vector_space = w3_fs )

      call rho_moist_X(i_mr)%initialise( vector_space = w3_fs )

      call tot_col_moist_mass(i_mr)%initialise( vector_space = &
                      function_space_collection%get_fs(twod_mesh_id, 0, W3) )

      call tot_col_moist_mass(i_mr)%set_write_behaviour(write_diag_behaviour)

      ! Get mr field on w3
      call map_physics_scalars(mr_w3(i_mr), mr(i_mr))  ! argument order is target, source

      call invoke( X_times_Y(rho_moist_X(i_mr), rho_field, mr_w3(i_mr)) )

      call invoke( compute_column_mass_kernel_type(rho_moist_X(i_mr), height_w3, &
                                                  height_wth, tot_col_moist_mass(i_mr), &
                                                  radius) )

      if (write_diag .and. use_xios_io) then

        call tot_col_moist_mass(i_mr)%write_field('tot_col_'//trim(mr_names(i_mr)))

      end if

      ! Increment by each moisture species to get total wet + dry mass
      call invoke( inc_X_plus_Y(tot_col_wetplusdry_mass, tot_col_moist_mass(i_mr)) )

    end do

    if (write_diag .and. use_xios_io) then

      call tot_col_dry_air_mass%write_field('tot_col_dry_air_mass')
      call tot_col_wetplusdry_mass%write_field('tot_col_wetplusdry_mass')

    end if

  end subroutine column_total_diagnostics_alg

!=============================================================================!
  !> @brief Calculates Wbig: set 3D field to 1 where vertical velocity exceeds
  !!          1 m s-1 and output.
  !> @details Wbig is given a value of 1 if the value of w (vertical velocity)
  !!          at that location is larger than 1 m s-1, otherwise it is set to
  !!          zero. The diagnostic's primary use is in long, climate runs where
  !!          it is averaged in time to help indicate whether the model has any
  !!          stability problems.
  !> @param[in] w_physics 3D vertical velocity field seen by the model physics
  !> @param[in] mesh_id Mesh_id The identifier of the primary mesh

  subroutine calc_wbig_diagnostic_alg(w_physics, mesh_id)

    use calc_wbig_kernel_mod,             only: calc_wbig_kernel_type
    use io_config_mod,                    only: write_diag, use_xios_io
    use lfric_xios_write_mod,             only: write_field_single_face
    use field_parent_mod,                 only: write_interface

    implicit none

    ! Set up necessary fields
    type(field_type),  intent(in)    :: w_physics
    integer(i_def),    intent(in)    :: mesh_id

    type( field_type ) :: wbig

    ! Give wbig the same properties as w_physics (on WTHETA levels)
    call w_physics%copy_field_properties(wbig)

    call invoke( calc_wbig_kernel_type(w_physics, wbig) )

    if (write_diag .and. use_xios_io) then

      call wbig%write_field('wbig')

    end if

  end subroutine calc_wbig_diagnostic_alg

end module diagnostic_alg_mod
