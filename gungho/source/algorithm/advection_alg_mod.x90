!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Wrapper algorithm to compute the advection of the prognostic
!>       equations
module advection_alg_mod

  use constants_mod,                  only: r_def, i_def
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use runtime_constants_mod,          only: get_coordinates, &
                                            get_div, &
                                            get_curl, &
                                            get_mass_matrix, &
                                            get_mass_matrix_diagonal, &
                                            get_inverse_lumped_mass_matrix, &
                                            w1_id, w2_id, w3inv_id, &
                                            theta_space_id
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order, wtheta_on, supg, &
                                            vorticity_in_w1
  use function_space_mod,             only: function_space_type
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use operator_mod,                   only: operator_type
  use psykal_lite_mod,                only: invoke_sample_poly_flux,    &
                                            invoke_sample_poly_adv,     &
                                            invoke_rtheta_bd_kernel
  use quadrature_xyoz_mod,            only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,   only: quadrature_rule_gaussian_type

  use rtheta_kernel_mod,              only: rtheta_kernel_type
  use rtheta_wtheta_kernel_mod,       only: rtheta_wtheta_kernel_type
  use rtheta_supg_kernel_mod,         only: rtheta_supg_kernel_type
  use flux_rhs_kernel_mod,            only: flux_rhs_kernel_type
  use solver_mod,                     only: solver_algorithm
  use transpose_matrix_vector_kernel_mod, &
                                      only: transpose_matrix_vector_kernel_type
  use vorticity_advection_kernel_mod, only: vorticity_advection_kernel_type
  use vorticity_rhs_kernel_mod,       only: vorticity_rhs_kernel_type
  use derived_config_mod,             only: bundle_size 
  use w2_to_w1_projection_kernel_mod, only: w2_to_w1_projection_kernel_type
  use w2_vorticity_advection_kernel_mod, &
                                      only: w2_vorticity_advection_kernel_type

  use transport_config_mod,           only: operators,              &
                                            fv_flux_order,          &
                                            fv_advective_order,     &
                                            transport_operators_fv, &
                                            transport_operators_fem
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_INFO
  use mr_indices_mod,                 only: nummr
  use timestepping_config_mod,        only: dt
  use runge_kutta_init_mod,           only: num_rk_stage, ak
  use field_indices_mod,              only: igh_u, igh_t, igh_d, igh_p
  use output_config_mod,              only: subroutine_timers 
  use timer_mod,                      only: timer
  use timestepping_config_mod,        only: time_method => method, &
                                            timestepping_method_rk  
  use strong_curl_kernel_mod,         only: strong_curl_kernel_type
  implicit none

  private
  integer(i_def)                  :: flux_stencil_extent, &
                                     advective_stencil_extent
  type( field_type ), allocatable :: mr_prediction(:)
  integer(i_def)                  :: nstage_adv
  real(r_def),        allocatable :: ak_adv(:,:)
  type(function_space_type), pointer :: w1_fs => null()

  public  :: advection_alg
  public  :: advection_alg_init
  public  :: advection_mr_alg
  private :: mass_flux_alg
  private :: advective_inc_alg

contains

  !>@brief Initialisation routine to advection algorithm
  !>@param[in] mesh_id Identity of the mesh to create all fields on
  subroutine advection_alg_init(mesh_id)
    use mesh_mod,                          only: mesh_type
    use mesh_collection_mod,               only: mesh_collection
    use sample_poly_flux_kernel_mod,       only: sample_poly_flux_init
    use sample_poly_adv_kernel_mod,        only: sample_poly_adv_init
    use fs_continuity_mod,                 only: W1
    use function_space_collection_mod,     only: function_space_collection

    implicit none

    integer(i_def),  intent(in) :: mesh_id

    type(mesh_type), pointer :: mesh => null()

    if ( time_method == timestepping_method_rk ) then
      ! If using explicit timestepping then advection is called once per stage,
      ! therefore no further sub stages are needed, setting number of stages = 1
      ! and coeffs = 1 short cuts the rk advection scheme
      nstage_adv = 1
      allocate( ak_adv(nstage_adv,nstage_adv) )
      ak_adv(1,1) = 1.0_r_def
    else
      nstage_adv = num_rk_stage
      allocate( ak_adv(nstage_adv,nstage_adv) )
      ak_adv = ak
    end if

    if ( operators == transport_operators_fv ) then
      if ( element_order == 0 ) then
        mesh => mesh_collection%get_mesh( mesh_id )
        call sample_poly_flux_init(fv_flux_order, mesh%get_nlayers())
        call sample_poly_adv_init (fv_advective_order, mesh%get_nlayers())
        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high &
                         order elements", LOG_LEVEL_ERROR )
      end if

      allocate ( mr_prediction(nstage_adv) )
    end if

    if ( .not. vorticity_in_w1 ) &
      w1_fs => function_space_collection%get_fs( mesh_id, element_order, W1 )

  end subroutine advection_alg_init

  !=============================================================================!
  !>@details A wrapper algorithm for computing the advection of the prognostic
  !>         equations, namely:
  !>         \f[ \mathbf{R_u} = \xi \times \frac{\mathbf{F}}{\rho} \f]
  !>         \f[ R_\theta = \frac{\mathbf{F}}{\rho}.\nabla\theta \f]
  !>         \f[ R_\rho = \nabla.\mathbf{F} \f]
  !>         with diagnostic fields:
  !>
  !>         Mass flux: \f$ \mathbf{F} = \mathbf{u}\rho \f$
  !>         Vorticity: \f$ \xi = \nabla\times\mathbf{u} \f$
  !>
  !>         Using a method of lines algorithm
  !> @param[inout] advection Advective terms
  !> @param[in]    state Current state of the model prognostics
  !> @param[in]    xi Relative vorticity field
  !> @param[in]    advecting_wind Wind field used to advect all quantities
  subroutine advection_alg( advection, &
                            state, &
                            xi, advecting_wind)
  
  implicit none
  ! Form of state and advection is [u,theta,rho] & [r_u,r_theta,r_rho]
  type(field_type), intent(in),    target  :: state(bundle_size)
  type(field_type), intent(inout)          :: advection(bundle_size)
  type(field_type), intent(inout)          :: xi
  type(field_type), intent(in)             :: advecting_wind

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_wt => null(), mm_w3_inv => null(), &
                                  div => null(), curl => null()

  type(quadrature_xyoz_type)          :: qr
  type(quadrature_rule_gaussian_type) :: quadrature_rule

  type(field_type), pointer :: u => null() ,theta => null(), rho  => null()
  type(field_type)          :: r_xi, mass_flux, r_rho, rho_adv, mf, &
                               theta_adv, r_theta, u_grad_theta
  type(field_type), allocatable :: rrho_prediction(:), rtheta_prediction(:)

  type(function_space_type), pointer :: xi_fs => null(), u_fs => null(), &
                                        rho_fs => null(), theta_fs => null()
  type(field_type), pointer          :: mt_lumped_inv => null()
  type(field_type)                   :: u_in_w1, r_u
  integer(i_def)                     :: stage, st

  ! Auxiliary constants to group invokes
  real(kind=r_def), parameter  :: minus_one = -1.0_r_def

  if ( subroutine_timers ) call timer('advection_alg')
  chi    => get_coordinates()

  u     => state(igh_u)
  theta => state(igh_t)
  rho   => state(igh_d)

  u_fs     => u%get_function_space()
  xi_fs    => xi%get_function_space()
  rho_fs   => rho%get_function_space()
  theta_fs => theta%get_function_space()

  ! Advective time integrated mass flux = rho*u
  mass_flux = field_type( vector_space = u_fs  )

  
  r_rho     = field_type( vector_space = rho_fs )
  r_theta   = field_type( vector_space = theta_fs)

  qr = quadrature_xyoz_type(element_order+3, quadrature_rule)

  ! Predictor fields used to store the right hand side at each stage of the
  ! Runge-Kutta algorithm
  allocate ( rrho_prediction(nstage_adv), rtheta_prediction(nstage_adv) )
  do stage = 1,nstage_adv
    rrho_prediction(stage)   = field_type( vector_space = rho_fs )
    rtheta_prediction(stage) = field_type( vector_space = theta_fs )
  end do

  ! Compute advection terms
  ! 1) mass flux ( F = rho * u ) 
  !rho_np1 = rho_n - dt* mm_w3_inv * div * F
  call log_event( "Computing advective mass flux...", LOG_LEVEL_INFO)
  ! advected density field
  rho_adv = field_type( vector_space = rho_fs )
  ! mass flux at each stage of rk scheme
  mf      = field_type( vector_space = u_fs ) 
  mm_w3_inv => get_mass_matrix(w3inv_id)
  div       => get_div()

  ! Runge-Kutta algorithm
  call invoke( setval_X(rho_adv, rho), &
               setval_c(mass_flux, 0.0_r_def) )
  do stage = 1,nstage_adv
    ! Compute the mass flux using desired spatial reconstruction
    call mass_flux_alg(mf, rho_adv, advecting_wind)
    ! Compute m3^-1 * div * mass flux
    call invoke( name = "Compute mm_w3_inv and initialise r_rho", &
                 dg_matrix_vector_kernel_type(r_rho, mf, div),    &
                 dg_matrix_vector_kernel_type(rrho_prediction(stage), r_rho, &
                                              mm_w3_inv),         &
    ! Build the rhs of the RK scheme at this stage: sum_s -ak(s)*r_rho(s)
                 setval_c(r_rho, 0.0_r_def) )
    do st = 1, stage
      call invoke( inc_X_minus_bY(r_rho, ak_adv(stage,st), rrho_prediction(st)) )
    end do
    ! Increment the advected density field to obtain estimate at this stage
    call invoke( name = "Increment density",         &
                 aX_plus_Y(rho_adv, dt, r_rho, rho), &
    ! Add increment from this stage to the time integrated mass flux 
                 inc_X_plus_bY(mass_flux, ak_adv(nstage_adv,stage), mf) )
  end do

  ! 2) theta_advection ( u . grad(theta) )
  ! theta_np1 = theta_n - dt * u.grad(theta)
  call log_event( "Computing advective potential temperature increment...", &
                   LOG_LEVEL_INFO)
  ! Advected theta field
  theta_adv    = field_type( vector_space = theta_fs )
  ! time integrated update to theta state
  u_grad_theta = field_type( vector_space = theta_fs )

  ! Runge-Kutta algorithm  
  call invoke( setval_c(u_grad_theta, 0.0_r_def), &
               setval_X(theta_adv, theta) )
  do stage = 1,nstage_adv
    ! Compute u.grad(theta) using desired spatial reconstruction of gtad(theta)
    call advective_inc_alg(r_theta, theta_adv, advecting_wind)
    ! If using FEM operators and SUPG scheme add correction
    if ( supg ) call invoke( rtheta_supg_kernel_type(r_theta,     &
                             theta_adv, theta, mass_flux, rho, chi, qr) )   

    ! Obtain lumped inverse and full mass matrices for the correct space (Wtheta
    ! or W0) 
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)
    mm_wt         => get_mass_matrix(theta_space_id) 
    if ( wtheta_on ) then
      ! If using Wtheta use lumped approximation to inverse mass matrix
      call invoke( X_times_Y(rtheta_prediction(stage), r_theta, mt_lumped_inv) )
    else
      ! If using W0 use full mass matrix with iterative inverse
      ! (It would be possible to use the lumped inverse to speed things up)
      call solver_algorithm( rtheta_prediction(stage), r_theta)
    end if
    ! Build the rhs of the RK scheme at this stage: sum_s -ak(s)*r_theta(s)
    call invoke( setval_c(r_theta, 0.0_r_def) )
    do st = 1, stage
      call invoke( inc_X_minus_bY(r_theta, ak_adv(stage,st), rtheta_prediction(st)) )
    end do
    call invoke( aX_plus_Y(theta_adv, dt, r_theta, theta), &
    ! Add increment from this stage to the time integrated u.grad(theta)
                 inc_X_minus_bY(u_grad_theta, ak_adv(nstage_adv,stage), &
                         rtheta_prediction(stage)) )
  end do

  ! Return the advective increment in the correct form, this means for 
  ! si timestepping multiplying by Mtheta if fv operators are used to transform the pointwise field into a
  ! FEM field in the correct space.
  ! If FEM operators are used we need to cancel out the mt_lumped_inv factor
  ! used to update the theta_adv field.
  ! For RK timestepping with FV operators the full equation is solved in a
  ! pointwise fashion and so nothing needs to be done
  if ( operators == transport_operators_fv ) then   
    if ( time_method == timestepping_method_rk ) then
      ! Solve equation in pointwise form (fully fv equation)
      call invoke( setval_X(advection(igh_t), u_grad_theta) )
    else
      ! Solve equation weak pointwise form (fully fem equation)
      call invoke( setval_c(advection(igh_t), 0.0_r_def), &
                   matrix_vector_kernel_type(advection(igh_t), u_grad_theta, mm_wt) )
    end if
  else
    call invoke( X_divideby_Y(advection(igh_t), u_grad_theta, mt_lumped_inv) )
  end if

  ! 3) Vorticity computation ( xi = curl(u) )
  ! 4) Vorticity advection of u ( u \cross curl(u))
  ! Currently this is just a single stage approximation using xi = curl(u), it 
  ! should later be updated to use a RK scheme for the vorticity
  if ( vorticity_in_w1 ) then
    ! Compute the vorticity field xi in W1 using the weak curl and then
    ! project it into W2 as part of the advection kernel
    call log_event( "Computing advective vorticity in W1...", LOG_LEVEL_INFO)
    r_xi = field_type( vector_space = xi_fs  )
    curl => get_curl()
    call invoke( name = "Compute advective vorticity",                            &
                 setval_c(r_xi, 0.0_r_def),                                       &
                 transpose_matrix_vector_kernel_type(r_xi, advecting_wind, curl), &
                 enforce_bc_kernel_type(r_xi) )
    call solver_algorithm( xi, r_xi)
    call log_event( "Computing advective wind increment...", LOG_LEVEL_INFO)
    call invoke( name = "Compute advective wind increment",    &
                 setval_c(advection(igh_u), 0.0_r_def),        &
                 vorticity_advection_kernel_type(advection(igh_u), advecting_wind, &
                                                 xi, chi, qr), &
                 enforce_bc_kernel_type(advection(igh_u)) )
  else
    ! Compute the W1 representation of the wind field by galerkin projection and
    ! then compute the vorticity field xi in W2 using the strong curl
    call log_event( "Computing advective wind in W1...", LOG_LEVEL_INFO)
    u_in_w1 = field_type( vector_space = w1_fs )
    r_u     = field_type( vector_space = w1_fs )
    call invoke( name = "Compute advective wind in W1",                        &
                 setval_c(r_u, 0.0_r_def),                                     &
                 w2_to_w1_projection_kernel_type(r_u, advecting_wind, qr) )
    call solver_algorithm( u_in_w1, r_u, .false.)  
    call log_event( "Computing advective wind increment...", LOG_LEVEL_INFO)
    call invoke( name = "Compute advective wind increment using u in W1",      &
                 strong_curl_kernel_type(xi, u_in_w1),                         &
                 setval_c(advection(igh_u), 0.0_r_def),                        &
                 w2_vorticity_advection_kernel_type(advection(igh_u),          &
                                                    advecting_wind,            &
                                                    xi, chi, qr),              &
                 enforce_bc_kernel_type(advection(igh_u)) )
  end if

  ! 5) Advection update for the continuity equation divergence of mass flux: 
  !    M3^-1(div(F))
  call log_event( "Computing advective density increment...", LOG_LEVEL_INFO)
  call invoke( name = "Compute advective density increment",     &
               setval_c(r_rho, 0.0_r_def),                       &
               matrix_vector_kernel_type(r_rho, mass_flux, div), &
               inc_a_times_X(minus_one, r_rho),                  &
               dg_matrix_vector_kernel_type(advection(igh_d), r_rho, mm_w3_inv) )

  ! 6) Advection update for the equation of state, since this is diagnostic the
  ! increment is always zero
  call invoke( name = "Compute advective pressure increment",    &
               setval_c(advection(igh_p), 0.0_r_def) )


  deallocate ( rrho_prediction, rtheta_prediction )
  if ( subroutine_timers ) call timer('advection_alg')
  end subroutine advection_alg

  !>@details A wrapper algorithm for computing the advection of the moisture 
  !>         prognostic
  !> @param[inout] advection Field array containing the advective terms
  !> @param[in]    mr Field array. Mixing ratios
  !> @param[in]    wind Field array. Winds
  subroutine advection_mr_alg( mr, wind )
  
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type
    implicit none
    type(field_type), intent(inout),    target  :: mr(nummr)
    type(field_type), intent(in),       target  :: wind

    type(function_space_type), pointer :: theta_fs  => null()

    type(field_type)          :: mr_inc, mr_adv, mr_n
    type(field_type), pointer :: mt_lumped_inv => null()

    integer :: imr, stage, st

    if ( subroutine_timers ) call timer('advection_mr_alg')
    call log_event( "Computing moisture advection...", LOG_LEVEL_INFO)

    theta_fs => mr(1)%get_function_space()

    mr_inc = field_type( vector_space = theta_fs )
    mr_adv = field_type( vector_space = theta_fs )
    mr_n   = field_type( vector_space = theta_fs )
    do stage = 1,nstage_adv
      mr_prediction(stage) = field_type( vector_space = theta_fs )
    end do

    ! Runge-Kutta algorithm
    do imr = 1,nummr
      call invoke( setval_X(mr_n, mr(imr)) )
      do stage = 1,nstage_adv
        call advective_inc_alg(mr_prediction(stage), mr(imr), wind)
        call invoke( setval_c(mr_adv, 0.0_r_def) )
        do st = 1, stage
          call invoke( inc_X_minus_bY(mr_adv, ak_adv(stage,st), mr_prediction(st)) )
        end do
        ! Use lumped mass matrix     
        mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)
        call invoke( X_times_Y(mr_inc, mr_adv, mt_lumped_inv), &         
                     aX_plus_Y(mr(imr), dt, mr_inc, mr_n) )
      end do
    end do
    if ( subroutine_timers ) call timer('advection_mr_alg')

  end subroutine advection_mr_alg

  !>@brief Compute the mass flux, f = rho*u using desired spatial reconstruction
  !>@param[inout] mass_flux Mass flux field: f = density*wind
  !>@param[in]    density Field to advect
  !>@param[in]    wind Advecting wind field
  subroutine mass_flux_alg(mass_flux, density, wind)
  use sample_poly_flux_kernel_mod, only: sample_poly_flux_kernel_type

  implicit none
  
  type(field_type), intent(in)    :: density, wind
  type(field_type), intent(inout) :: mass_flux

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_w2 => null()
  type(field_type),    pointer :: mmd_w2 => null()

  type(quadrature_xyoz_type)          :: qr
  type(quadrature_rule_gaussian_type) :: quadrature_rule
  type(field_type)                    :: rhs_f 

  type(function_space_type), pointer :: u_fs  => null()

  u_fs     => wind%get_function_space()

  select case(operators)
    case(transport_operators_fv)
     ! Use pointwise fv operators compute mass flux with high-order polynomial
     ! interpolation of density
     call invoke_sample_poly_flux( mass_flux, wind, density, &
                                   flux_stencil_extent )
     ! Psyclone doesnt call the correct colouring routines yet
     !call invoke( sample_poly_flux_kernel_type( mass_flux, wind, density, &
     !                                           flux_stencil_extent ) )

    case(transport_operators_fem)  
      ! Project density*wind into the mass flux space    
      qr = quadrature_xyoz_type(element_order+3, quadrature_rule)

      mm_w2  => get_mass_matrix(w2_id)
      mmd_w2 => get_mass_matrix_diagonal(w2_id)
      chi    => get_coordinates()
      rhs_f = field_type( vector_space = u_fs )
      call invoke( name = "Transport operators fem",                    &
                   setval_c(rhs_f, 0.0_r_def),                          &
                   flux_rhs_kernel_type(rhs_f, wind, density, chi, qr), &
                   enforce_bc_kernel_type(rhs_f),                       &
                   setval_c(mass_flux, 0.0_r_def) )
      call solver_algorithm( mass_flux, rhs_f)
  end select

  end subroutine mass_flux_alg

  !>@brief Compute advective update u.grad(theta) using desired spatial 
  !>       reconstruction
  !>@param[inout] rtheta Advective increment
  !>@param[in]    theta Field to advect
  !>@param[in]    wind Advecting wind field
  subroutine advective_inc_alg(rtheta, theta, wind)
  use sample_poly_adv_kernel_mod, only: sample_poly_adv_kernel_type
  implicit none
  type(field_type), intent(in)        :: theta, wind
  type(field_type), intent(inout)     :: rtheta
  type(quadrature_xyoz_type)          :: qr
  type(quadrature_rule_gaussian_type) :: quadrature_rule
  type(field_type), pointer           :: chi(:) => null()
  type(field_type), pointer           :: mt_lumped_inv => null()

  mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)

  select case(operators)
    case(transport_operators_fv)
     ! Use pointwise fv operators compute u.grad(theta) with high-order 
     ! polynomial interpolation of theta
      chi => get_coordinates()
      call invoke_sample_poly_adv( rtheta, theta, wind, mt_lumped_inv, chi, &
                                   advective_stencil_extent )
      ! Psyclone doesnt call the correct colouring routines yet
      !chi_stencil_extent = advective_stencil_extent
      !call invoke( sample_poly_adv_kernel_type( rtheta, theta, advective_stencil_extent,&
      !                                          wind,  &
      !                                          chi(1),chi_stencil_extent, chi(2),chi(3)&
      !                                          ) )
         
    case(transport_operators_fem)
     ! Use project u.grad(theta) into the theta function space
      qr = quadrature_xyoz_type(element_order+3, quadrature_rule)
      call invoke( setval_c(rtheta, 0.0_r_def) )
      if ( wtheta_on ) then
        call invoke( rtheta_wtheta_kernel_type (rtheta, theta, wind, qr) )
        call invoke_rtheta_bd_kernel ( rtheta, theta, wind, qr )
      else
        call invoke( rtheta_kernel_type(rtheta, theta, wind, qr) )
      end if
   end select

  end subroutine advective_inc_alg

end module advection_alg_mod


