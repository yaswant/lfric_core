!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Wrapper algorithm to compute the advection of the prognostic
!>       equations
module advection_alg_mod

  use constants_mod,                  only: r_def, i_def
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use runtime_constants_mod,          only: get_coordinates, &
                                            get_div, &
                                            get_curl, &
                                            get_mass_matrix, &
                                            get_mass_matrix_diagonal, &
                                            get_inverse_lumped_mass_matrix, &
                                            w1_id, w2_id, w3inv_id, w3_id, &
                                            wt_id
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order, supg, &
                                            vorticity_in_w1, &
                                            nqp_exact
  use function_space_mod,             only: function_space_type
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use operator_mod,                   only: operator_type
  use psykal_lite_mod,                only: invoke_rtheta_bd_kernel
  use psykal_lite_mol_mod,            only: psykal_lite_mol_init,           &
                                            psykal_lite_mol_final,          &
                                            invoke_poly1d_flux,             &
                                            invoke_poly1d_flux_coeffs,      &
                                            invoke_poly1d_vert_flux,        &
                                            invoke_poly1d_vert_flux_coeffs, &
                                            invoke_poly2d_flux,             &
                                            invoke_poly2d_flux_coeffs,      &
                                            invoke_poly1d_adv_recon,        &
                                            invoke_poly1d_advective_coeffs, &
                                            invoke_poly2d_adv_recon,        &
                                            invoke_poly2d_advective_coeffs, &
                                            invoke_poly1d_vert_adv_coeffs,  &
                                            invoke_poly1d_vert_adv
  use quadrature_rule_gauss_lobatto_mod, &
                                      only: quadrature_rule_gauss_lobatto_type
  use quadrature_rule_gaussian_mod,   only: quadrature_rule_gaussian_type
  use quadrature_xyoz_mod,            only: quadrature_xyoz_type
  use quadrature_face_mod,            only: quadrature_face_type
  use quadrature_edge_mod,            only: quadrature_edge_type
  use rtheta_kernel_mod,              only: rtheta_kernel_type
  use rtheta_supg_kernel_mod,         only: rtheta_supg_kernel_type
  use flux_rhs_kernel_mod,            only: flux_rhs_kernel_type
  use mass_matrix_solver_alg_mod,     only: mass_matrix_solver_alg
  use transpose_matrix_vector_kernel_mod, &
                                      only: transpose_matrix_vector_kernel_type
  use vorticity_advection_kernel_mod, only: vorticity_advection_kernel_type
  use vorticity_rhs_kernel_mod,       only: vorticity_rhs_kernel_type
  use derived_config_mod,             only: bundle_size 
  use w2_to_w1_projection_kernel_mod, only: w2_to_w1_projection_kernel_type
  use w2_vorticity_advection_kernel_mod, &
                                      only: w2_vorticity_advection_kernel_type

  use transport_config_mod,           only: operators,            &
                                            fv_flux_order,        &
                                            fv_advective_order,   &
                                            operators_fv,         &
                                            operators_fem,        &
                                            oned_reconstruction,  &
                                            enforce_monotonicity, &
                                            consistent_metric
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_INFO
  use mr_indices_mod,                 only: nummr
  use timestepping_config_mod,        only: dt
  use runge_kutta_init_mod,           only: num_rk_stage, ak
  use field_indices_mod,              only: igh_u, igh_t, igh_d, igh_p
  use io_config_mod,                  only: subroutine_timers 
  use timer_mod,                      only: timer
  use timestepping_config_mod,        only: time_method => method, &
                                            method_rk  
  use strong_curl_kernel_mod,         only: strong_curl_kernel_type
  use poly_advective_kernel_mod,      only: poly_advective_kernel_type
  use cosmic_threed_alg_mod,          only: cosmic_threed_transport_step
  use calc_dep_pts_alg_mod,           only: calc_dep_pts
  use transport_config_mod,           only: scheme, &
                                            scheme_cosmic_3D, &
                                            scheme_method_of_lines
  use runtime_constants_mod,          only: get_detj_at_w2

  implicit none

  private
  integer(i_def)                  :: flux_stencil_extent, &
                                     advective_stencil_extent, &
                                     flux2d_stencil_size, &
                                     advective2d_stencil_size
  type( field_type ), allocatable :: mr_prediction(:)
  integer(i_def)                  :: nstage_adv
  real(r_def),        allocatable :: ak_adv(:,:)
  type(function_space_type), pointer :: w1_fs => null()
  ! Interpolation coefficients needed for nonuniform fv operators
  type( field_type ), allocatable :: flux_coeffs(:,:), vert_flux_coeffs(:,:), &
                                     adv_coeffs(:,:),  vert_adv_coeffs(:,:)
  type( field_type )              :: advective_av
  type( field_type )              :: advective_av_chi3, theta_metrics, chi3_at_wt
  integer(i_def)                  :: nfaces_h, nfaces_v


  public  :: advection_alg
  public  :: advection_alg_init
  public  :: advection_alg_final
  public  :: advection_mr_alg
  private :: mass_flux_alg
  private :: advective_inc_alg

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> @brief Initialises the system for running the advection algorithm.
  !>
  !> @param[in] mesh_id Identity of the mesh to create all fields on
  !>
  subroutine advection_alg_init( mesh_id )

    use fs_continuity_mod,                 only: W1, W3, Wtheta
    use function_space_collection_mod,     only: function_space_collection
    use multiplicity_kernel_mod,           only: multiplicity_kernel_type
    use sample_field_kernel_mod,           only: sample_field_kernel_type
    use reference_element_mod,             only: reference_element_type
    use mesh_mod,                          only: mesh_type
    implicit none

    integer(i_def),  intent(in) :: mesh_id

    integer(i_def)              :: flux_stencil_size,  &
                                   advective_stencil_size, &
                                   direction, polynomial
    type( field_type ), pointer :: chi(:) => null()
    type( field_type ), pointer :: md_w3 => null(), &
                                   md_wt => null()

    type( quadrature_rule_gaussian_type )      :: gaussian_quadrature
    type( quadrature_rule_gauss_lobatto_type ) :: gauss_lobatto_quadrature

    type( quadrature_xyoz_type )           :: qr
    type( quadrature_face_type )           :: qrf
    type( quadrature_edge_type )           :: qre
    type( function_space_type ), pointer   :: w3_fs => null(), &
                                              wt_fs => null()
    type( field_type )                     :: wt_field, w3_field
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type),               pointer :: mesh => null()
    integer(i_def)                         :: face_quad_order
    integer(i_def)                         :: nqp_xy, nqp_z, nqp_xyz

    if ( time_method == method_rk ) then
      ! If using explicit timestepping then advection is called once per stage,
      ! therefore no further sub stages are needed, setting number of stages = 1
      ! and coeffs = 1 short cuts the rk advection scheme
      nstage_adv = 1
      allocate( ak_adv(nstage_adv,nstage_adv) )
      ak_adv(1,1) = 1.0_r_def
    else
      nstage_adv = num_rk_stage
      allocate( ak_adv(nstage_adv,nstage_adv) )
      ak_adv = ak
    end if

    if ( operators == operators_fv ) then
      if ( element_order == 0 ) then

        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
        !======================================================================!
        ! Compute stencil for nonuniform polynomial fit   
        ! Initialise PSy layer arrays (this will not be needed when
        ! multi-dimensional field arrays are supported)
        ! This needs some temporary fields for computing undf in the PSy layer
        w3_fs => function_space_collection%get_fs( mesh_id, element_order, W3 )
        wt_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )                
        w3_field = field_type( vector_space = w3_fs )
        wt_field = field_type( vector_space = wt_fs )

        ! Get topology information from the reference element
        mesh              => wt_field%get_mesh()
        reference_element => mesh%get_reference_element()
        ! Number of horizontal neighbours
        nfaces_h = reference_element%get_number_horizontal_faces()
        ! Number of vertical neighbours is (and always will be) 2 
        nfaces_v = reference_element%get_number_vertical_faces()

        if ( oned_reconstruction ) then
          flux_stencil_size      = fv_flux_order      + 1
          advective_stencil_size = fv_advective_order + 1
        else
          ! Compute the maximum number of cells in the flux stencil 
          ! This occurs on a uniform mesh
          ! (this computation is only correct for quadrilateral meshes)
          flux2d_stencil_size = 1    
          do polynomial = 1, fv_flux_order
            if ( mod(polynomial, 2) == 0 ) then
              flux2d_stencil_size = flux2d_stencil_size + nfaces_h
            else
              flux2d_stencil_size = flux2d_stencil_size + nfaces_h*polynomial
            end if
          end do
          flux_stencil_size = flux2d_stencil_size
          ! Compute the maximum number of cells in the advective stencil 
          ! This occurs on a uniform mesh
          ! (this computation is only correct for quadrilateral meshes)
          advective2d_stencil_size = 1    
          do polynomial = 1, fv_advective_order
            if ( mod(polynomial, 2) == 0 ) then
              advective2d_stencil_size = advective2d_stencil_size + nfaces_h
            else
              advective2d_stencil_size = advective2d_stencil_size + nfaces_h*polynomial
            end if
          end do
          advective_stencil_size = advective2d_stencil_size
        end if  
        call psykal_lite_mol_init(wt_field, w3_field, &
                                  fv_flux_order, flux_stencil_size, &
                                  fv_advective_order, advective_stencil_size, &
                                  nfaces_h, nfaces_v)

        chi => get_coordinates()
        nqp_xyz = fv_flux_order+1
        qr = quadrature_xyoz_type(nqp_xyz, gaussian_quadrature)
        if ( oned_reconstruction ) then
          face_quad_order = 1
        else
          face_quad_order = fv_flux_order+1
        end if
        ! Quadrature rule on lateral faces with 1 point in the vertical
        nqp_xy = face_quad_order
        nqp_z  = 1
        qrf = quadrature_face_type(nqp_xy, nqp_z, .true., .false., &
                                   reference_element, gaussian_quadrature)

        call log_event( "Gungho: computing horizontal flux coeffs", LOG_LEVEL_INFO )
        md_w3 => get_mass_matrix_diagonal(w3_id)
        allocate( flux_coeffs(flux_stencil_size, nfaces_h), &
                   adv_coeffs(flux_stencil_size, nfaces_h) )
        do direction = 1, nfaces_h
          do polynomial = 1,flux_stencil_size
              flux_coeffs(polynomial, direction) = field_type( vector_space = w3_fs )
              adv_coeffs(polynomial, direction)  = field_type( vector_space = wt_fs )
          end do
        end do
        if ( oned_reconstruction ) then
          call invoke_poly1d_flux_coeffs( flux_coeffs, md_w3, chi, qr, qrf, &
                                          fv_flux_order,                    &
                                          flux_stencil_extent, nfaces_h )
        else
          call invoke_poly2d_flux_coeffs( flux_coeffs, md_w3, chi, qr, qrf, &
                                          fv_flux_order,                    &
                                          flux2d_stencil_size, nfaces_h )
        end if
        call log_event( "Gungho: computing vertical flux coeffs", LOG_LEVEL_INFO )
        ! Vertical flux coeffs
        allocate( vert_flux_coeffs(fv_flux_order+1, nfaces_v) )
        do direction = 1, nfaces_v
          do polynomial = 1,fv_flux_order+1
            vert_flux_coeffs(polynomial, direction) = field_type( vector_space = w3_fs )
          end do
        end do
        ! Quadrature rule on vertical faces with 1 point in both horizontal and
        ! vertical directions
        nqp_xyz = 1
        qrf = quadrature_face_type(nqp_xyz, .false., .true.,                   &
                                   reference_element, gaussian_quadrature)
        call invoke_poly1d_vert_flux_coeffs( vert_flux_coeffs, md_w3, chi,     &
                                             qr, qrf, fv_flux_order, nfaces_v )

        ! Compute advective coefficients       
        call log_event( "Gungho: computing horizontal advective coeffs", LOG_LEVEL_INFO )
        ! Quadrature rule which has enough points to exactly integrate
        ! fv_advective_order polynomials and is odd order horizontaly and has
        ! 2 vertical points such that it gives points on the vertical faces
        nqp_xy = fv_advective_order+3
        nqp_z  = 2
        qr = quadrature_xyoz_type(nqp_xy, nqp_xy, nqp_z, &
                                  gauss_lobatto_quadrature)
        ! Edge based quadrature rule on horizontal edges
        nqp_xyz = face_quad_order
        qre = quadrature_edge_type(nqp_xyz, .true., .false.,           &
                                   reference_element, gaussian_quadrature)

        md_wt => get_mass_matrix_diagonal(wt_id)
        w1_fs => function_space_collection%get_fs( mesh_id, element_order, W1 )
        advective_av = field_type( vector_space =  w1_fs )
        if ( oned_reconstruction ) then
          call invoke_poly1d_advective_coeffs( adv_coeffs, md_wt, chi, qr, qre,  &
                                               fv_advective_order,               &
                                               advective_stencil_extent, nfaces_h )
        else
          call invoke_poly2d_advective_coeffs( adv_coeffs, md_wt, chi, qr, qre, &
                                               fv_advective_order,              &
                                               advective2d_stencil_size,        &
                                               nfaces_h )
        end if
        ! Vertical advective coeffs
        call log_event( "Gungho: computing vertical advective coeffs", LOG_LEVEL_INFO )
        allocate( vert_adv_coeffs(fv_advective_order+2, nfaces_v) )
        do direction = 1, nfaces_v
          do polynomial = 1, fv_advective_order+2
            vert_adv_coeffs(polynomial, direction) = field_type( vector_space = wt_fs )
          end do
        end do
        call invoke_poly1d_vert_adv_coeffs( vert_adv_coeffs, md_wt, chi, & 
                                            fv_advective_order, nfaces_v )
        if ( consistent_metric ) then
          advective_av_chi3 = field_type(vector_space = w1_fs )
          theta_metrics     = field_type(vector_space = wt_fs )
          chi3_at_wt        = field_type(vector_space = wt_fs )
          call invoke( setval_c(wt_field, 0.0_r_def),       &
                       multiplicity_kernel_type(wt_field),  &
                       sample_field_kernel_type( chi3_at_wt, wt_field, chi(3)) )
        end if
        !======================================================================!
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high &
                         order elements", LOG_LEVEL_ERROR )
      end if

      allocate ( mr_prediction(nstage_adv) )
    end if

    if ( .not. vorticity_in_w1 ) &
      w1_fs => function_space_collection%get_fs( mesh_id, element_order, W1 )

    nullify( chi, md_w3, md_wt, w3_fs, wt_fs, reference_element, mesh )

  end subroutine advection_alg_init

  !=============================================================================
  !>@details Finalises allocatable arrays, nullifies pointer in module scope
  !>         and calls finalising routines for kernels that this algorithm
  !>         initialised.
  subroutine advection_alg_final()

    implicit none

    if (allocated(mr_prediction)) deallocate( mr_prediction )
    if (allocated(ak_adv))        deallocate( ak_adv )
    nullify (w1_fs)

    if ( operators == operators_fv .and. &
         element_order == 0 ) then
      deallocate( flux_coeffs, vert_flux_coeffs, &
                  adv_coeffs,  vert_adv_coeffs )
      ! Deallocate PSy layer arrays (this will not be needed when
      ! multi-dimensional field arrays are supported)
      call psykal_lite_mol_final()
    end if

  end subroutine advection_alg_final

  !=============================================================================!
  !>@details A wrapper algorithm for computing the advection of the prognostic
  !>         equations, namely:
  !>         \f[ \mathbf{R_u} = \xi \times \frac{\mathbf{F}}{\rho} \f]
  !>         \f[ R_\theta = \frac{\mathbf{F}}{\rho}.\nabla\theta \f]
  !>         \f[ R_\rho = \nabla.\mathbf{F} \f]
  !>         with diagnostic fields:
  !>
  !>         Mass flux: \f$ \mathbf{F} = \mathbf{u}\rho \f$
  !>         Vorticity: \f$ \xi = \nabla\times\mathbf{u} \f$
  !>
  !>         Using a method of lines algorithm
  !> @param[inout] advection Advective terms
  !> @param[in]    state Current state of the model prognostics
  !> @param[inout] xi Relative vorticity field
  !> @param[in]    advecting_wind Wind field used to advect all quantities
  subroutine advection_alg( advection, &
                            state, &
                            xi, advecting_wind)

  implicit none
  ! Form of state and advection is [u,theta,rho] & [r_u,r_theta,r_rho]
  type(field_type), intent(in),    target  :: state(bundle_size)
  type(field_type), intent(inout)          :: advection(bundle_size)
  type(field_type), intent(inout)          :: xi
  type(field_type), intent(in)             :: advecting_wind

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_wt => null(), mm_w3_inv => null(), &
                                  div => null(), curl => null()

  type(quadrature_xyoz_type)          :: qr
  type(quadrature_rule_gaussian_type) :: quadrature_rule

  type(field_type), pointer :: u => null() ,theta => null(), rho  => null()
  type(field_type)          :: r_xi, mass_flux, r_rho, rho_adv, mf, &
                               theta_adv, r_theta, u_grad_theta

  type(field_type)          :: dep_pts_x, dep_pts_y, dep_pts_z
  type(field_type)          :: wind_divergence
  type(field_type), pointer :: detj_at_w2 => null()

  type(field_type), allocatable :: rrho_prediction(:), rtheta_prediction(:)

  type(function_space_type), pointer :: xi_fs => null(), u_fs => null(), &
                                        rho_fs => null(), theta_fs => null()
  type(field_type), pointer          :: mt_lumped_inv => null()
  type(field_type)                   :: u_in_w1, r_u
  integer(i_def)                     :: stage, st
  integer(i_def)                     :: nqp_xyz

  ! Auxiliary constants to group invokes
  real(kind=r_def), parameter  :: minus_one = -1.0_r_def

  if ( subroutine_timers ) call timer('advection_alg')
  chi    => get_coordinates()

  u     => state(igh_u)
  theta => state(igh_t)
  rho   => state(igh_d)

  u_fs     => u%get_function_space()
  xi_fs    => xi%get_function_space()
  rho_fs   => rho%get_function_space()
  theta_fs => theta%get_function_space()

  ! Advective time integrated mass flux = rho*u
  mass_flux = field_type( vector_space = u_fs  )

  if (scheme == scheme_cosmic_3D) then
    dep_pts_x       = field_type( vector_space = u_fs )
    dep_pts_y       = field_type( vector_space = u_fs )
    dep_pts_z       = field_type( vector_space = u_fs )
    wind_divergence = field_type( vector_space = rho_fs )

    detj_at_w2 => get_detj_at_w2()
  end if

  r_rho     = field_type( vector_space = rho_fs )
  r_theta   = field_type( vector_space = theta_fs)

  qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

  ! Predictor fields used to store the right hand side at each stage of the
  ! Runge-Kutta algorithm
  allocate ( rrho_prediction(nstage_adv), rtheta_prediction(nstage_adv) )
  do stage = 1,nstage_adv
    rrho_prediction(stage)   = field_type( vector_space = rho_fs )
    rtheta_prediction(stage) = field_type( vector_space = theta_fs )
  end do

  ! Compute advection terms
  ! 1) mass flux ( F = rho * u ) 
  !rho_np1 = rho_n - dt* mm_w3_inv * div * F
  call log_event( "Computing advective mass flux...", LOG_LEVEL_INFO)
  ! advected density field
  rho_adv = field_type( vector_space = rho_fs )
  ! mass flux at each stage of rk scheme
  mf      = field_type( vector_space = u_fs ) 
  mm_w3_inv => get_mass_matrix(w3inv_id)
  div       => get_div()

  ! Runge-Kutta algorithm
  call invoke( setval_X(rho_adv, rho), &
               setval_c(mass_flux, 0.0_r_def) )
  do stage = 1,nstage_adv
    ! Compute the mass flux using desired spatial reconstruction
    call mass_flux_alg(mf, rho_adv, advecting_wind)
    ! Compute m3^-1 * div * mass flux
    call invoke( name = "Compute mm_w3_inv and initialise r_rho", &
                 dg_matrix_vector_kernel_type(r_rho, mf, div),    &
                 dg_matrix_vector_kernel_type(rrho_prediction(stage), r_rho, &
                                              mm_w3_inv),         &
    ! Build the rhs of the RK scheme at this stage: sum_s -ak(s)*r_rho(s)
                 setval_c(r_rho, 0.0_r_def) )
    do st = 1, stage
      call invoke( inc_X_minus_bY(r_rho, ak_adv(stage,st), rrho_prediction(st)) )
    end do
    ! Increment the advected density field to obtain estimate at this stage
    call invoke( name = "Increment density",         &
                 aX_plus_Y(rho_adv, dt, r_rho, rho), &
    ! Add increment from this stage to the time integrated mass flux 
                 inc_X_plus_bY(mass_flux, ak_adv(nstage_adv,stage), mf) )
  end do

  ! 2) theta_advection ( u . grad(theta) )
  ! theta_np1 = theta_n - dt * u.grad(theta)
  call log_event( "Computing advective potential temperature increment...", &
                   LOG_LEVEL_INFO)
  ! Advected theta field
  theta_adv    = field_type( vector_space = theta_fs )
  ! time integrated update to theta state
  u_grad_theta = field_type( vector_space = theta_fs )

  ! Runge-Kutta algorithm  
  call invoke( setval_c(u_grad_theta, 0.0_r_def), &
               setval_X(theta_adv, theta) )
  do stage = 1,nstage_adv
    ! Compute u.grad(theta) using desired spatial reconstruction of gtad(theta)
    call advective_inc_alg(r_theta, theta_adv, advecting_wind, dt)
    ! If using FEM operators and SUPG scheme add correction
    if ( supg ) call invoke( rtheta_supg_kernel_type(r_theta,     &
                             theta_adv, theta, mass_flux, rho, chi, qr) )   

    ! Obtain lumped inverse and full mass matrices for the correct space (Wtheta
    ! or W0) 
    mt_lumped_inv => get_inverse_lumped_mass_matrix(wt_id)
    mm_wt         => get_mass_matrix(wt_id) 
    call invoke( X_times_Y(rtheta_prediction(stage), r_theta, mt_lumped_inv), &
                 setval_c(r_theta, 0.0_r_def) )

    ! Build the rhs of the RK scheme at this stage: sum_s -ak(s)*r_theta(s)
    do st = 1, stage
      call invoke( inc_X_minus_bY(r_theta, ak_adv(stage,st), rtheta_prediction(st)) )
    end do
    call invoke( aX_plus_Y(theta_adv, dt, r_theta, theta), &
    ! Add increment from this stage to the time integrated u.grad(theta)
                 inc_X_minus_bY(u_grad_theta, ak_adv(nstage_adv,stage), &
                         rtheta_prediction(stage)) )
  end do

  ! Return the advective increment in the correct form, this means for 
  ! si timestepping multiplying by Mtheta if fv operators are used to transform the pointwise field into a
  ! FEM field in the correct space.
  ! If FEM operators are used we need to cancel out the mt_lumped_inv factor
  ! used to update the theta_adv field.
  ! For RK timestepping with FV operators the full equation is solved in a
  ! pointwise fashion and so nothing needs to be done
  if ( operators == operators_fv ) then   
    if ( time_method == method_rk ) then
      ! Solve equation in pointwise form (fully fv equation)
      call invoke( setval_X(advection(igh_t), u_grad_theta) )
    else
      ! Solve equation weak pointwise form (fully fem equation)
      call invoke( setval_c(advection(igh_t), 0.0_r_def), &
                   matrix_vector_kernel_type(advection(igh_t), u_grad_theta, mm_wt) )
    end if
  else
    call invoke( X_divideby_Y(advection(igh_t), u_grad_theta, mt_lumped_inv) )
  end if

  ! 3) Vorticity computation ( xi = curl(u) )
  ! 4) Vorticity advection of u ( u \cross curl(u))
  ! Currently this is just a single stage approximation using xi = curl(u), it 
  ! should later be updated to use a RK scheme for the vorticity
  if ( vorticity_in_w1 ) then
    ! Compute the vorticity field xi in W1 using the weak curl and then
    ! project it into W2 as part of the advection kernel
    call log_event( "Computing advective vorticity in W1...", LOG_LEVEL_INFO)
    r_xi = field_type( vector_space = xi_fs  )
    curl => get_curl()
    call invoke( name = "Compute advective vorticity",                            &
                 setval_c(r_xi, 0.0_r_def),                                       &
                 transpose_matrix_vector_kernel_type(r_xi, advecting_wind, curl), &
                 enforce_bc_kernel_type(r_xi) )
    call mass_matrix_solver_alg(xi, r_xi)
    call log_event( "Computing advective wind increment...", LOG_LEVEL_INFO)
    call invoke( name = "Compute advective wind increment",    &
                 setval_c(advection(igh_u), 0.0_r_def),        &
                 vorticity_advection_kernel_type(advection(igh_u), advecting_wind, &
                                                 xi, chi, qr), &
                 enforce_bc_kernel_type(advection(igh_u)) )
  else
    ! Compute the W1 representation of the wind field by galerkin projection and
    ! then compute the vorticity field xi in W2 using the strong curl
    call log_event( "Computing advective wind in W1...", LOG_LEVEL_INFO)
    u_in_w1 = field_type( vector_space = w1_fs )
    r_u     = field_type( vector_space = w1_fs )
    call invoke( name = "Compute advective wind in W1",                        &
                 setval_c(r_u, 0.0_r_def),                                     &
                 w2_to_w1_projection_kernel_type(r_u, advecting_wind, qr) )
    call mass_matrix_solver_alg( u_in_w1, r_u, .false.)  
    call log_event( "Computing advective wind increment...", LOG_LEVEL_INFO)
    call invoke( name = "Compute advective wind increment using u in W1",      &
                 strong_curl_kernel_type(xi, u_in_w1),                         &
                 setval_c(advection(igh_u), 0.0_r_def),                        &
                 w2_vorticity_advection_kernel_type(advection(igh_u),          &
                                                    advecting_wind,            &
                                                    xi, chi, qr),              &
                 enforce_bc_kernel_type(advection(igh_u)) )
  end if

  ! 5) Advection update for the continuity equation divergence of mass flux: 
  !    M3^-1(div(F))
  if (scheme == scheme_method_of_lines) then

    call log_event( "Computing advective density increment...", LOG_LEVEL_INFO)
    call invoke( name = "Compute advective density increment",     &
                 setval_c(r_rho, 0.0_r_def),                       &
                 matrix_vector_kernel_type(r_rho, mass_flux, div), &
                 inc_a_times_X(minus_one, r_rho),                  &
                 dg_matrix_vector_kernel_type(advection(igh_d), r_rho, mm_w3_inv) )

  elseif (scheme == scheme_cosmic_3D) then

    call calc_dep_pts( dep_pts_x, dep_pts_y, dep_pts_z, wind_divergence, advecting_wind, detj_at_w2, chi )
    call cosmic_threed_transport_step( advection(igh_d), rho, dep_pts_x, dep_pts_y, dep_pts_z, detj_at_w2 )
    call invoke( inc_a_times_X(-1.0_r_def, advection(igh_d)) )

  end if

  ! 6) Advection update for the equation of state, since this is diagnostic the
  ! increment is always zero
  call invoke( name = "Compute advective pressure increment",    &
               setval_c(advection(igh_p), 0.0_r_def) )


  deallocate ( rrho_prediction, rtheta_prediction )

  nullify( mm_wt, mm_w3_inv, div, curl, chi, u, theta, rho, &
           xi_fs, u_fs, rho_fs, theta_fs, mt_lumped_inv, detj_at_w2 )

  if ( subroutine_timers ) call timer('advection_alg')
  end subroutine advection_alg

  !>@details A wrapper algorithm for computing the advection of the moisture 
  !>         prognostic
  !> @param[inout] mr_inc Field array Increment to mixing ratios
  !> @param[in]    mr Field array. Mixing ratios
  !> @param[in]    wind Field array. Winds
  subroutine advection_mr_alg( mr_inc, mr, wind )

    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type
    implicit none
    type(field_type), intent(inout), target  :: mr_inc(nummr)
    type(field_type), intent(in),    target  :: mr(nummr)
    type(field_type), intent(in),    target  :: wind

    type(function_space_type), pointer :: theta_fs  => null()

    type(field_type)          :: mr_adv, mr_latest
    type(field_type), pointer :: mt_lumped_inv => null()

    integer :: imr, stage, st

    if ( subroutine_timers ) call timer('advection_mr_alg')
    call log_event( "Computing moisture advection...", LOG_LEVEL_INFO)

    theta_fs => mr(1)%get_function_space()

    mr_adv = field_type( vector_space = theta_fs )
    mr_latest = field_type( vector_space = theta_fs )
    do stage = 1,nstage_adv
      mr_prediction(stage) = field_type( vector_space = theta_fs )
    end do

    ! Runge-Kutta algorithm
    do imr = 1,nummr
      call invoke( setval_X(mr_latest, mr(imr)) )
      do stage = 1,nstage_adv
        call advective_inc_alg(mr_prediction(stage), mr_latest, wind, dt)
        call invoke( setval_c(mr_adv, 0.0_r_def) )
        do st = 1, stage
          call invoke( inc_X_minus_bY(mr_adv, ak_adv(stage,st), mr_prediction(st)) )
        end do
        ! Use lumped mass matrix     
        mt_lumped_inv => get_inverse_lumped_mass_matrix(wt_id)
        ! Here we: 
        !  (1) update mr_inc(imr) to be in strong form by multiplying by inverse MM,
        !  (2) then make this into an increment by multiplying by dt,
        !  (3) then update the mr_latest by adding this increment to mr(imr)
        call invoke( X_times_Y(mr_inc(imr), mr_adv, mt_lumped_inv) , &
                     inc_a_times_X(dt, mr_inc(imr)),                 &
                     X_plus_Y(mr_latest, mr_inc(imr), mr(imr)) )
      end do
    end do

    nullify( theta_fs, mt_lumped_inv )

    if ( subroutine_timers ) call timer('advection_mr_alg')

  end subroutine advection_mr_alg

  !>@brief Compute the mass flux, f = rho*u using desired spatial reconstruction
  !>@param[inout] mass_flux Mass flux field: f = density*wind
  !>@param[in]    density Field to advect
  !>@param[in]    wind Advecting wind field
  subroutine mass_flux_alg(mass_flux, density, wind)

  implicit none
  
  type(field_type), intent(in)    :: density, wind
  type(field_type), intent(inout) :: mass_flux

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_w2 => null()
  type(field_type),    pointer :: mmd_w2 => null()

  type(quadrature_xyoz_type)          :: qr
  type(quadrature_rule_gaussian_type) :: quadrature_rule
  type(field_type)                    :: rhs_f 

  type(function_space_type), pointer  :: u_fs  => null()

  select case(operators)
    case(operators_fv)
     if ( oned_reconstruction ) then
       ! Use 1d flux reconstruction
       call invoke_poly1d_flux( mass_flux, wind, density, flux_coeffs, &
                                fv_flux_order, flux_stencil_extent, nfaces_h )
     else
       ! Use 2d flux reconstruction
       call invoke_poly2d_flux( mass_flux, wind, density, flux_coeffs, &
                                fv_flux_order, flux2d_stencil_size, nfaces_h )
     end if
     ! Compute vertical components of mass flux
     call invoke_poly1d_vert_flux( mass_flux, wind, density, &
                                   vert_flux_coeffs, &
                                   fv_flux_order, nfaces_v)

    case(operators_fem)  
      ! Project density*wind into the mass flux space 
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

      mm_w2  => get_mass_matrix(w2_id)
      mmd_w2 => get_mass_matrix_diagonal(w2_id)
      chi    => get_coordinates()
      u_fs   => wind%get_function_space()
      rhs_f = field_type( vector_space = u_fs )
      call invoke( name = "Transport operators fem",                    &
                   setval_c(rhs_f, 0.0_r_def),                          &
                   flux_rhs_kernel_type(rhs_f, wind, density, chi, qr), &
                   enforce_bc_kernel_type(rhs_f),                       &
                   setval_c(mass_flux, 0.0_r_def) )
      call mass_matrix_solver_alg( mass_flux, rhs_f)
  end select

  nullify( mm_w2, chi, mmd_w2, u_fs )


  end subroutine mass_flux_alg

  !>@brief Compute advective update u.grad(theta) using desired spatial 
  !>       reconstruction
  !>@param[inout] rtheta Advective increment
  !>@param[in]    theta Field to advect
  !>@param[in]    wind Advecting wind field
  !>@param[in]    dt timestep  
  subroutine advective_inc_alg(rtheta, theta, wind, dt)
  use consistent_wind_kernel_mod,  only: consistent_wind_kernel_type
  use reference_element_mod,       only: reference_element_type
  use mesh_mod,                    only: mesh_type
  use monotonic_update_kernel_mod, only: monotonic_update_kernel_type
  implicit none

  type(field_type), intent(in)           :: theta, wind
  type(field_type), intent(inout)        :: rtheta
  real(r_def),      intent(in)           :: dt
  type(quadrature_xyoz_type)             :: qr
  type(quadrature_face_type)             :: qrf
  type(quadrature_rule_gaussian_type)    :: quadrature_rule
  type(field_type), pointer              :: chi(:) => null()
  type(field_type), pointer              :: mt_lumped_inv => null()
  class(reference_element_type), pointer :: reference_element =>null()
  type(mesh_type),               pointer :: mesh => null()
  integer(i_def)                         :: mono_stencil
  type(field_type)                       :: consistent_wind

  mt_lumped_inv => get_inverse_lumped_mass_matrix(wt_id)

  select case(operators)
    case(operators_fv)
      call invoke( setval_c(advective_av, 0.0_r_def) )
      if ( consistent_metric )  call invoke( setval_c(advective_av_chi3, 0.0_r_def) )
      if ( oned_reconstruction ) then
       ! Use 1d reconstruction
        call invoke_poly1d_adv_recon( advective_av, wind, theta, adv_coeffs, &
                                      fv_flux_order, flux_stencil_extent, nfaces_h )
        ! Horizontal advection of metric terms
        if ( consistent_metric ) & 
          call invoke_poly1d_adv_recon( advective_av_chi3, wind, chi3_at_wt, adv_coeffs, &
                                        fv_flux_order, flux_stencil_extent, nfaces_h )
      else
       ! Use 2d reconstruction
        call invoke_poly2d_adv_recon( advective_av, wind, theta, adv_coeffs, &
                                      fv_flux_order, flux2d_stencil_size,    &
                                      nfaces_h )
        ! Horizontal advection of metric terms
        if ( consistent_metric ) & 
          call invoke_poly2d_adv_recon( advective_av_chi3, wind, chi3_at_wt, adv_coeffs, &
                                        fv_flux_order, flux2d_stencil_size,              &
                                        nfaces_h )

      end if
      ! Compute horizontal advective update
      call invoke( poly_advective_kernel_type(rtheta, wind, advective_av) )
      consistent_wind = wind 
      if ( consistent_metric ) then
        chi => get_coordinates()
        call invoke( poly_advective_kernel_type(theta_metrics, wind, advective_av_chi3), &
        ! Modify advecting wind
                     consistent_wind_kernel_type(consistent_wind, wind, theta_metrics, chi) )
      end if
      ! Compute vertical component of advective update
      call invoke_poly1d_vert_adv( rtheta, consistent_wind, theta, &
                                   vert_adv_coeffs, fv_flux_order, nfaces_v )
    case(operators_fem)
      ! Use project u.grad(theta) into the theta function space
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)
      mesh              => rtheta%get_mesh()
      reference_element => mesh%get_reference_element()
      ! Quadrature rule on lateral faces only
      qrf = quadrature_face_type(nqp_exact, .true., .false., &
                                 reference_element, quadrature_rule)
      call invoke( setval_c(rtheta, 0.0_r_def),                    &
                   rtheta_kernel_type (rtheta, theta, wind, qr) )
      call invoke_rtheta_bd_kernel(rtheta, theta, wind, qrf)      
  end select

  ! Apply monotonicity (as if this a full timestep)
  if ( enforce_monotonicity ) then
    if ( operators == operators_fem ) then
      mono_stencil = 1
    else
      mono_stencil = fv_flux_order/2
    end if
    call invoke( monotonic_update_kernel_type(rtheta, theta, mono_stencil, mt_lumped_inv, dt, fv_flux_order) )
  end if

  nullify( chi, mt_lumped_inv, reference_element, mesh )

  end subroutine advective_inc_alg

end module advection_alg_mod


