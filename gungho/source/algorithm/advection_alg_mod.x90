!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> @brief Wrapper algorithm to compute the advection of the prognostic
!>        equations
module advection_alg_mod

  use constants_mod,                  only: r_def, i_def, l_def, str_def
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_INFO
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use runtime_constants_mod,          only: get_coordinates,                &
                                            get_div,                        &
                                            get_mass_matrix,                &
                                            get_inverse_lumped_mass_matrix, &
                                            w3inv_id,                       &
                                            wt_id
  use field_mod,                      only: field_type
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use operator_mod,                   only: operator_type
  use mass_matrix_solver_alg_mod,     only: mass_matrix_solver_alg
  use derived_config_mod,             only: bundle_size
  use transport_config_mod,           only: operators, &
                                            operators_fv
  use mr_indices_mod,                 only: nummr
  use timestepping_config_mod,        only: dt, beta
  use runge_kutta_init_mod,           only: num_rk_stage, ak
  use field_indices_mod,              only: igh_u, igh_t, igh_d, igh_p
  use io_config_mod,                  only: subroutine_timers
  use timer_mod,                      only: timer
  use timestepping_config_mod,        only: time_method => method,          &
                                            method_rk,                      &
                                            method_semi_implicit
  use cosmic_threed_alg_mod,          only: cosmic_threed_transport_step
  use calc_dep_pts_alg_mod,           only: calc_dep_pts
  use transport_config_mod,           only: scheme,                         &
                                            scheme_cosmic_3D,               &
                                            scheme_method_of_lines
  use runtime_constants_mod,          only: get_detj_at_w2,                 &
                                            get_cell_orientation
  use formulation_config_mod,         only: si_momentum_equation, &
                                            vector_invariant

  use advective_update_alg_mod,       only: advective_update_alg_init,      &
                                            advective_update_alg_final,     &
                                            advective_update_alg
  use flux_alg_mod,                   only: flux_alg_init,                  &
                                            flux_alg_final,                 &
                                            flux_alg
  implicit none

  private

  public  :: advection_alg
  public  :: advection_alg_init
  public  :: advection_alg_final
  public  :: advection_mr_alg
  public  :: advection_generic_field_alg
  public  :: advect_momentum_alg
  private :: advect_field
contains

  !===========================================================================!
  !> @brief Initialises the system for running the advection algorithm.
  !>
  !> @param[in] mesh_id Identity of the mesh to create all fields on
  !>
  subroutine advection_alg_init( mesh_id )

    implicit none

    integer(i_def),  intent(in) :: mesh_id

    ! Set up the mass flux spatial computation
    call flux_alg_init(mesh_id)
    ! Set up the advective update spatial computation
    call advective_update_alg_init(mesh_id)

  end subroutine advection_alg_init

  !=============================================================================
  !>@details Finalises allocatable arrays, nullifies pointer in module scope
  !>         and calls finalising routines for kernels that this algorithm
  !>         initialised.
  subroutine advection_alg_final()

    implicit none

    call flux_alg_final()
    call advective_update_alg_final()

  end subroutine advection_alg_final

  !=============================================================================!
  !>@details A wrapper algorithm for computing the advection of the prognostic
  !>         equations, namely:
  !>         \f[ R_\theta = \frac{\mathbf{F}}{\rho}.\nabla\theta \f]
  !>         \f[ R_\rho = \nabla.\mathbf{F} \f]
  !>         \f[ R_u    = \left(\mathbf{u}\cdot\nabla\right)\mathbf{u} \f]
  !>         with the diagnostic field:
  !>
  !>         Mass flux: \f$ \mathbf{F} = \mathbf{u}\rho \f$
  !>
  !>         Using a either the method of lines algorithm
  !>         or COSMIC
  !> @param[in,out] advection Advective terms
  !> @param[in]     state Current state of the model prognostics
  !> @param[in]     wind_n Wind field at timestep n
  !> @param[in]     wind_np1 Latest estimate of wind field at timestep n+1
  !> @param[in]     advected_wind predictor for the wind to be advected
  subroutine advection_alg( advection,           &
                            state,               &
                            wind_n,              &
                            wind_np1,            &
                            advected_wind )

  implicit none
  type(field_type), intent(inout) :: advection(bundle_size)
  type(field_type), intent(in)    :: state(bundle_size)
  type(field_type), intent(in)    :: wind_n
  type(field_type), intent(in)    :: wind_np1
  type(field_type), intent(in)    :: advected_wind

  type(operator_type), pointer :: mm_wt         => null(), &
                                  mm_w3_inv     => null(), &
                                  div           => null()
  type(field_type),    pointer :: mt_lumped_inv => null()
  type(field_type)             :: r_rho,                   &
                                  u_grad_theta,            &
                                  mass_flux,               &
                                  advecting_wind

  if ( subroutine_timers ) call timer('advection_alg')

  ! Construct fields needed for advection
  call advecting_wind%initialise( state(igh_u)%get_function_space() )
  call mass_flux%initialise( state(igh_u)%get_function_space() )
  call r_rho%initialise( state(igh_d)%get_function_space() )

  ! Set advecting velocity = 0.5(u_np1 + u_n)
  call invoke( aX_plus_bY(advecting_wind, 0.5_r_def, wind_n, &
                                          0.5_r_def, wind_np1) )

  ! Advect density field
  call log_event( "Advecting density...", LOG_LEVEL_INFO)
  call advect_field(mass_flux, state(igh_d), advecting_wind, &
                    scheme, wind_n, wind_np1, .true., dt, .false.)

  if ( scheme == scheme_method_of_lines ) then
    ! Reconstruct the advection increment from the mass flux
    mm_w3_inv => get_mass_matrix(w3inv_id)
    div       => get_div()
    call invoke( setval_c(r_rho, 0.0_r_def),                       &
                 matrix_vector_kernel_type(r_rho, mass_flux, div), &
                 inc_a_times_X(-1.0_r_def, r_rho),                 &
                 dg_matrix_vector_kernel_type(advection(igh_d),    &
                                              r_rho, mm_w3_inv) )
  else
    ! Cosmic computes the advection increment instead of the mass flux
    call invoke( setval_X(advection(igh_d), mass_flux) )
  end if

  ! Advect potential temperature field
  ! Cosmic is not yet implemented and so must use method of lines scheme
  call log_event( "Advecting potential temperature...", LOG_LEVEL_INFO)
  call u_grad_theta%initialise( state(igh_t)%get_function_space() )
  call advect_field(u_grad_theta, state(igh_t), advecting_wind, &
                    scheme_method_of_lines, wind_n, wind_np1, .false., dt, .false.)
  ! u_grad_theta now contains a pointwise incremente to theta,
  ! i.e. theta_np1 = theta_n - dt*u_grad_theta
  ! Depending upon what the temporal discretisation is this needs
  ! converting into the a weak form, either by cancelling out the
  ! lumped mass matrix used to advect it or by multiplying by the
  ! full mass matrix
  if ( operators == operators_fv ) then
    if ( time_method == method_rk ) then
      ! Solve equation in pointwise form (fully fv equation)
      call invoke( setval_X(advection(igh_t), u_grad_theta) )
    else
      ! Convert equation from pointwise form to weak form (fully fem equation)
      mm_wt => get_mass_matrix(wt_id)
      call invoke( setval_c(advection(igh_t), 0.0_r_def), &
                   matrix_vector_kernel_type(advection(igh_t), u_grad_theta, mm_wt) )
    end if
  else
    ! Cancel out the lumped mass matrix used to advect theta
    mt_lumped_inv => get_inverse_lumped_mass_matrix(wt_id)
    call invoke( X_divideby_Y(advection(igh_t), u_grad_theta, &
                              mt_lumped_inv) )
  end if

  if ( si_momentum_equation ) then
    ! Advection terms are handled by the semi-implicit scheme the increment is zero
    call invoke( setval_c(advection(igh_u), 0.0_r_def) )
  else
    ! Advect wind field
    call log_event( "Advecting wind...", LOG_LEVEL_INFO)
    call advect_momentum_alg(advection(igh_u), advected_wind, &
                             advecting_wind,&
                             wind_n, wind_np1, dt, .false.)
  end if

  ! Don't advect Exner pressure
  call invoke( setval_c(advection(igh_p), 0.0_r_def) )

  nullify(mm_wt, mm_w3_inv, div,  mt_lumped_inv)

  if ( subroutine_timers ) call timer('advection_alg')
  end subroutine advection_alg

  !===========================================================================!
  !> @details A wrapper algorithm for computing the advection of the moisture
  !>          prognostic
  !> @param[in,out] mr_inc Increment to mixing ratios
  !> @param[in]     mr Mixing ratios
  !> @param[in]     wind_n Time level n winds
  !> @param[in]     wind_np1 Time level n+1 winds
  subroutine advection_mr_alg( mr_inc, mr, wind_n, wind_np1 )
    implicit none
    type(field_type), intent(inout) :: mr_inc(nummr)
    type(field_type), intent(in)    :: mr(nummr)
    type(field_type), intent(in)    :: wind_n, wind_np1

    type(field_type) :: advecting_wind
    integer(i_def)   :: imr

    if ( subroutine_timers ) call timer('advection_mr_alg')
    call log_event( "Computing moisture advection...", LOG_LEVEL_INFO)
    ! Set advecting velocity = 0.5(u_np1 + u_n)
    call advecting_wind%initialise( wind_n%get_function_space() )
    call invoke( aX_plus_bY(advecting_wind, 0.5_r_def, wind_n, 0.5_r_def, wind_np1) )

    do imr = 1,nummr
      call advect_field( mr_inc(imr), mr(imr), advecting_wind, &
                         scheme_method_of_lines, wind_n, wind_np1, .false., &
                         dt, .false. )
      ! Make mr_inc into an increment by multiplying by dt
      call invoke( inc_a_times_X(dt, mr_inc(imr)) )
    end do
    if ( subroutine_timers ) call timer('advection_mr_alg')

  end subroutine advection_mr_alg

  !===========================================================================!
  !> @details A wrapper algorithm for advection a generic prognostic.
  !> @param[in] generic_fields            (in,out) collection which gets updated
  !> @param[in] generic_fields_after_slow (in)     collection to advect
  !> @param[in] wind_n                    (in)     Time level n winds
  !> @param[in] wind_np1                  (in)     Time level n+1 winds
  subroutine advection_generic_field_alg( generic_fields,                    &
                                          generic_fields_after_slow,         &
                                          wind_n, wind_np1 )

    use field_collection_mod,     only: field_collection_type,       &
                                        field_collection_real_iterator_type

    implicit none

    type(field_collection_type), intent(in) :: generic_fields
    type(field_collection_type), intent(in) :: generic_fields_after_slow
    type(field_type),            intent(in) :: wind_n, wind_np1

    type(field_type) :: advecting_wind
    type(field_type) :: gf_inc

    ! Iterator for field collection
    type(field_collection_real_iterator_type) :: iterator

    ! One of the single fields out of the generic_fields collection
    type(field_type), pointer :: single_generic_field => null()

    ! The saved version of single_generic_field after slow physics
    type(field_type), pointer :: after_slow_generic_field => null()

    if ( subroutine_timers ) call timer( 'advection_generic_field_alg' )

    call log_event( "Computing generic field advection...", LOG_LEVEL_INFO )

    ! Set advecting velocity = 0.5(u_np1 + u_n)
    call advecting_wind%initialise( wind_n%get_function_space() )
    call invoke( aX_plus_bY(advecting_wind, 0.5_r_def, wind_n, &
                                            0.5_r_def, wind_np1) )

    if ( generic_fields_after_slow%get_length() > 0 ) then

      iterator = generic_fields_after_slow%get_real_iterator()

      do
        if ( .not.iterator%has_next() ) exit

        after_slow_generic_field => iterator%next()

        ! N.B. no need to test on the advection flag because this has already
        ! been used to select the fields in generic_fields_after_slow

        call log_event( "Advecting "//                                        &
             trim(after_slow_generic_field%get_name()), LOG_LEVEL_INFO)
        call after_slow_generic_field%copy_field_properties(gf_inc)

        call advect_field( gf_inc, after_slow_generic_field, advecting_wind,  &
                           scheme_method_of_lines, wind_n, wind_np1, .false., &
                           dt, .false. )

        ! Get the field from the original collection which we want to update
        single_generic_field => generic_fields%get_field(                     &
             trim(after_slow_generic_field%get_name() ) )

        ! Make inc into an increment by multiplying by dt
        call invoke( inc_a_times_X(dt, gf_inc ) ,                             &
                     ! and add it on to the field
                     X_plus_Y(single_generic_field, after_slow_generic_field, &
                                                    gf_inc ) )

      end do

    end if

    if ( subroutine_timers ) call timer('advection_generic_field_alg')

  end subroutine advection_generic_field_alg

  !============================================================================!
  !> @brief Use MoL reconstruction to compute advective form update of momentum
  !!        equations by advecting each vector component as a scalar. Splits
  !!        the wind into 3 scalar components and then advects them separately.
  !> @param[in,out] rhs Momentum advection increment: [(u.grad) u]
  !> @param[in]     advected_wind Wind field to advect
  !> @param[in]     advecting_wind Advecting wind field
  !> @param[in]     wind_n Time level n wind field
  !> @param[in]     wind_np1 Time level n+1 wind field
  !> @param[in]     timestep delta t to advect field by
  !> @param[in]     from_si Flag if calling this routine from semi-implicit
  !!                (instead of advection) routines
  subroutine advect_momentum_alg( rhs, advected_wind, advecting_wind, &
                                  wind_n, wind_np1, timestep, from_si )

    use convert_hdiv_field_kernel_mod,  only: convert_hdiv_field_kernel_type
    use project_advective_update_kernel_mod, &
                                        only: project_advective_update_kernel_type
    use fs_continuity_mod,              only: W3, Wtheta
    use finite_element_config_mod,      only: element_order, &
                                              nqp_exact
    use function_space_collection_mod,  only: function_space_collection
    use function_space_mod,             only: function_space_type
    use quadrature_rule_gaussian_mod,   only: quadrature_rule_gaussian_type
    use quadrature_xyoz_mod,            only: quadrature_xyoz_type
    use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
    use runtime_constants_mod,          only: get_coordinates, &
                                              get_rmultiplicity
    implicit none

    type(field_type), intent(inout)     :: rhs
    type(field_type), intent(in)        :: advected_wind, advecting_wind
    type(field_type), intent(in)        :: wind_n, wind_np1
    real(r_def),      intent(in)        :: timestep
    logical,          intent(in)        :: from_si

    type(field_type), dimension(3)      :: u_scalar, adv_wind_update
    type( field_type ),        pointer  :: chi(:) => null()
    type(function_space_type), pointer  :: ws_fs => null()
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule
    integer(i_def)                      :: dir

    if ( subroutine_timers ) call timer('momentum advection')

    ws_fs => function_space_collection%get_fs( rhs%get_mesh_id(), &
                                               element_order, W3 )

    ! If not using vector invariant form then compute [ (u.grad)u ]
    ! Compute u in physical space and advect components in geocentric
    ! Cartesian coordinates and then map back to computational form
    qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)
    chi => get_coordinates()
    ! Compute updates on W3 points
    do dir = 1,3
      call u_scalar(dir)%initialise( ws_fs )
      call adv_wind_update(dir)%initialise( ws_fs )
    end do
    call advected_wind%log_minmax( LOG_LEVEL_INFO, 'advected u' )
    call invoke( setval_c(u_scalar(1), 0.0_r_def), &
                 setval_c(u_scalar(2), 0.0_r_def), &
                 setval_c(u_scalar(3), 0.0_r_def), &
                 convert_hdiv_field_kernel_type(u_scalar, advected_wind, chi) )
    call u_scalar(1)%log_minmax(LOG_LEVEL_INFO, 'xdot')
    call u_scalar(2)%log_minmax(LOG_LEVEL_INFO, 'ydot')
    call u_scalar(3)%log_minmax(LOG_LEVEL_INFO, 'zdot')

    ! Compute reconstruction of each velocity component
    ! Cosmic is not yet implemented and so must use method of lines scheme
    do dir = 1,3
      call advect_field(adv_wind_update(dir), u_scalar(dir),            &
                        advecting_wind,  scheme_method_of_lines, &
                        wind_n, wind_np1, .false., timestep, from_si)
    end do
    ! Compute the updates to the W2 wind field using the physical scalar
    ! update
    call invoke( setval_c(rhs, 0.0_r_def),                                  &
                 project_advective_update_kernel_type(rhs, adv_wind_update, &
                                                      chi, qr),             &
                 enforce_bc_kernel_type(rhs) )

    nullify( ws_fs, chi )
    if ( subroutine_timers ) call timer('momentum advection')

  end subroutine advect_momentum_alg

  !===========================================================================!
  !> @brief Advect a generic field and optionally return the flux used to
  !>        advect the field
  !> @param[in,out] advection_inc Update from advecting the field
  !> @param[in]     field Field to advect
  !> @param[in]     advecting_wind Advecting wind field
  !> @param[in]     adv_scheme Scheme used to advect this field
  !> @param[in]     wind_n Time level n wind field
  !> @param[in]     wind_np1 Time level n+1 wind field
  !> @param[in]     advect_density Flag for advecting the density and
  !>                              returning the mass flux
  !> @param[in]     timestep delta t to advect field by
  !> @param[in]     si_advective_terms Flag to avoid using Runge-Kutta
  !>                substepping

  subroutine advect_field( advection_inc, field, advecting_wind, adv_scheme, &
                           wind_n, wind_np1, advect_density, timestep,       &
                           si_advective_terms )


    use fs_continuity_mod,        only: W3, Wtheta, W2
    use psykal_builtin_light_mod, only: invoke_sign
    use advective_wind_update_kernel_mod, &
      only: advective_wind_update_kernel_type

    implicit none

    type(field_type), intent(inout) :: advection_inc
    type(field_type), intent(in)    :: field
    type(field_type), intent(in)    :: advecting_wind
    type(field_type), intent(in)    :: wind_n, wind_np1
    integer(i_def),   intent(in)    :: adv_scheme
    logical(l_def),   intent(in)    :: advect_density
    real(r_def),      intent(in)    :: timestep
    logical,          intent(in)    :: si_advective_terms

    ! For Method of Lines
    type(operator_type), pointer  :: div => null(),      &
                                     mm_w3_inv => null()
    type(field_type)              :: flux,               &
                                     rhs,                &
                                     field_new,          &
                                     field_inc,          &
                                     divergence_factor,  &
                                     unit_wind
    type(field_type), allocatable :: rk_rhs(:)
    integer(i_def)                :: stage, s, function_space
    real(r_def)                   :: minus_beta_dt

    integer(i_def)                :: nstage
    real(r_def), allocatable      :: ak_adv(:,:)

    ! For Cosmic
    type(field_type)          :: dep_pts_x, dep_pts_y, dep_pts_z
    type(field_type)          :: wind_divergence
    type(field_type), pointer :: detj_at_w2 => null()
    type(field_type), pointer :: cell_orientation => null()
    type(field_type), pointer :: chi(:) => null()

    ! Function space of the field to be advected
    function_space = field%which_function_space()

    select case(adv_scheme)

      case(scheme_method_of_lines)

        if ( time_method == method_rk .or. si_advective_terms ) then
        ! If using explicit timestepping then advection is called once per stage,
        ! therefore no further sub stages are needed, setting number of stages = 1
        ! and coeffs = 1 short cuts the rk advection scheme
          nstage = 1
          allocate( ak_adv( nstage, nstage ) )
          ak_adv(1,1) = 1.0_r_def
        else
          nstage = num_rk_stage
          allocate( ak_adv( nstage, nstage ) )
          ak_adv = ak
        end if

       ! Use Method of lines scheme to advect field
        call flux%initialise( advecting_wind%get_function_space() )
        call rhs%initialise( field%get_function_space() )
        call field_inc%initialise( field%get_function_space() )
        call field%copy_field(field_new)
        div       => get_div()
        mm_w3_inv => get_mass_matrix(w3inv_id)
        allocate( rk_rhs(nstage) )

        if ( time_method == method_semi_implicit &
             .and. advect_density                &
             .and. .not. si_momentum_equation ) then
          ! Advect predictor for the density: rho*divergence_factor with
          ! divergence_factor = [1-beta*dt*div(u)]
          ! This helps improve long timestep stability
          minus_beta_dt = -beta*timestep
          call divergence_factor%initialise( field%get_function_space() )
          call invoke( name = "compute_density_predictor",                     &
                       dg_matrix_vector_kernel_type(divergence_factor, wind_n, &
                                                    div),                      &
                       dg_matrix_vector_kernel_type(rhs, divergence_factor,    &
                                                    mm_w3_inv),                &
                       setval_c(divergence_factor, 1.0_r_def),                 &
                       inc_X_plus_bY(divergence_factor, minus_beta_dt, rhs),   &
                       inc_X_times_Y(field_new, divergence_factor) )
        end if

        if ( function_space == W3 .and. .not. advect_density ) then
          ! Compute unit wind to make flux alg return recontructed
          ! tracer instead of mass flux
          call unit_wind%initialise( advecting_wind%get_function_space() )
          call invoke_sign(unit_wind, 1.0_r_def, advecting_wind)
        end if

        ! Use Runge-Kutta timestepping to advect field and return either
        ! the advection increment or the flux used to advect the field
        call invoke( setval_c( advection_inc, 0.0_r_def) )
        do stage = 1,nstage
          call rk_rhs(stage)%initialise( field%get_function_space() )
          ! Build rhs depending upon type of field being advected
          select case(function_space)
            case(Wtheta)
              ! Compute: - u.grad(f)
              call advective_update_alg(rk_rhs(stage), field_new,              &
                                        advecting_wind, timestep )
            case(W3)
              ! Compute the flux using desired spatial reconstruction
              call invoke( setval_c( flux, 0.0_r_def ) )
              if ( advect_density ) then
                call flux_alg(flux, field_new, advecting_wind)
                ! Compute: -div(F)
                call invoke( dg_matrix_vector_kernel_type(rhs, flux, div),       &
                             dg_matrix_vector_kernel_type(rk_rhs(stage), rhs,    &
                                                          mm_w3_inv),            &
                             inc_X_plus_bY( advection_inc, ak_adv(nstage, stage),&
                                            flux ) )
              else
                 ! Compute the advective form increment, first the reconstructed tracer
                 call flux_alg(flux, field_new, unit_wind)
                 ! Remove unit_wind term from flux and
                 ! Compute the advective update u.grad(f)
                 call invoke( inc_X_divideby_Y(flux, unit_wind),                &
                              advective_wind_update_kernel_type(rhs,            &
                                                                flux,           &
                                                                advecting_wind),&
                              dg_matrix_vector_kernel_type(rk_rhs(stage), rhs,  &
                                                           mm_w3_inv) )
              end if
           case default
              call log_event("No advection rule for this function space", &
                             LOG_LEVEL_ERROR)
          end select

          ! Build rhs of Runge-Kutta scheme
          call invoke( setval_c(rhs, 0.0_r_def) )
          do s = 1, stage
            call invoke( inc_X_minus_bY(rhs, ak_adv(stage,s), rk_rhs(s)) )
          end do
          ! Update field: f = f^n + dt*rhs
          call invoke( setval_X(field_inc, rhs), &
                       aX_plus_Y( field_new, timestep, field_inc, field ) )

          ! Add increment from this stage to the advection increment
          if ( .not. advect_density) then
            call invoke( inc_X_minus_bY( advection_inc,         &
                                         ak_adv(nstage, stage), &
                                         rk_rhs(stage) ) )
          end if
        end do

        if ( associated( div ) ) nullify( div )
        if ( allocated( rk_rhs ) ) deallocate( rk_rhs )
        if ( allocated( ak_adv ) ) deallocate( ak_adv )

      case(scheme_cosmic_3D)
        ! Use Cosmic scheme to advect field
        select case(function_space)
          case(W3)
            call dep_pts_x%initialise( advecting_wind%get_function_space() )
            call dep_pts_y%initialise( advecting_wind%get_function_space() )
            call dep_pts_z%initialise( advecting_wind%get_function_space() )
            call wind_divergence%initialise( field%get_function_space() )

            chi        => get_coordinates()
            detj_at_w2 => get_detj_at_w2()
            cell_orientation => get_cell_orientation()
            call calc_dep_pts( dep_pts_x, dep_pts_y, dep_pts_z, wind_divergence,     &
                               wind_n, wind_np1, detj_at_w2, chi, cell_orientation )
            call cosmic_threed_transport_step( advection_inc, field, dep_pts_x,      &
                                               dep_pts_y, dep_pts_z, detj_at_w2,     &
                                               cell_orientation )
            call invoke( inc_a_times_X(-1.0_r_def, advection_inc) )
            nullify( chi, detj_at_w2 )
          case default
            call log_event("Cosmic only implemented for W3 fields", &
                           LOG_LEVEL_ERROR)
        end select

      case default
        call log_event("Invalid transport scheme", &
                       LOG_LEVEL_ERROR)

    end select

  end subroutine advect_field

end module advection_alg_mod


