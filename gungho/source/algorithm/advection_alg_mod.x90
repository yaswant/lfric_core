!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> @brief Wrapper algorithm to compute the advection of the prognostic
!>        equations
module advection_alg_mod

  use constants_mod,                  only: r_def, i_def, l_def, str_def, tiny_eps
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_INFO
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use geometric_constants_mod,        only: get_coordinates,                &
                                            get_panel_id,                   &
                                            get_cell_orientation,           &
                                            get_dA_at_w2,                   &
                                            get_height
  use runtime_constants_mod,          only: get_shifted_mesh_id,            &
                                            get_double_level_mesh_id
  use fem_constants_mod,              only: get_div,                        &
                                            get_mass_matrix,                &
                                            get_mass_matrix_diagonal,       &
                                            get_inverse_lumped_mass_matrix, &
                                            get_inverse_W3_mass_matrix,     &
                                            get_detj_at_w2
  use intermesh_constants_mod,        only: get_mr_to_sh_mass_integrals
  use field_mod,                      only: field_type
  use function_space_collection_mod,  only: function_space_collection
  use function_space_mod,             only: function_space_type
  use fs_continuity_mod,              only: W3, Wtheta, W2
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use operator_mod,                   only: operator_type
  use mass_matrix_solver_alg_mod,     only: mass_matrix_solver_alg
  use derived_config_mod,             only: bundle_size
  use transport_config_mod,           only: operators,    &
                                            operators_fv, &
                                            log_rho,      &
                                            log_theta
  use mr_indices_mod,                 only: nummr
  use runge_kutta_init_mod,           only: num_rk_stage, ak
  use field_indices_mod,              only: igh_u, igh_t, igh_d, igh_p
  use io_config_mod,                  only: subroutine_timers
  use timer_mod,                      only: timer
  use timestepping_config_mod,        only: time_method => method,          &
                                            method_rk,                      &
                                            method_semi_implicit, beta
  use cosmic_threed_alg_mod,          only: cosmic_threed_transport_step, &
                                            cosmic_threed_advective_step
  use calc_dep_pts_alg_mod,           only: calc_dep_pts
  use transport_config_mod,           only: scheme,                         &
                                            scheme_cosmic_3D,               &
                                            scheme_method_of_lines,         &
                                            rho_splitting,                  &
                                            rho_splitting_none,             &
                                            rho_splitting_vh,               &
                                            rho_splitting_hv,               &
                                            rho_splitting_strang,           &
                                            theta_splitting,                &
                                            theta_splitting_none,           &
                                            theta_splitting_vh,             &
                                            theta_splitting_hv,             &
                                            theta_splitting_strang,         &
                                            cfl_control_stab,               &
                                            use_density_predictor
  use formulation_config_mod,         only: moisture_conservation,          &
                                            si_momentum_equation,           &
                                            transport_only,                 &
                                            vector_invariant

  use advective_update_alg_mod,       only: advective_update_alg_init,      &
                                            advective_update_alg_final,     &
                                            advective_update_alg
  use flux_alg_mod,                   only: flux_alg_init,                  &
                                            flux_alg_final,                 &
                                            flux_alg
  use flux_shifted_alg_mod,           only: flux_shifted_alg_init,          &
                                            flux_shifted_alg_final,         &
                                            flux_shifted_alg
  use split_mol_cosmic_alg_mod,       only: split_transport_rho_step
  use rk_transport_rho_mod,           only: rk_transport_rho_init
  use rk_transport_theta_mod,         only: rk_transport_theta_init
  use split_transport_theta_mod,      only: split_transport_theta_step
  use split_slice_mol_alg_mod,        only: split_slice_mol_transport

  implicit none

  private

  integer(kind=i_def) :: nummr_to_advect

  public  :: advection_control
  public  :: advection_alg
  public  :: advection_alg_init
  public  :: advection_alg_final
  public  :: advection_mr_alg
  public  :: conservative_mr_adv_alg
  public  :: advection_generic_field_alg
  public  :: advect_momentum_alg
  public  :: advect_field
  integer(i_def)         :: advection_counter = 0_i_def
  integer(i_def)         :: switch_splitting = 0
  integer(i_def)         :: rho_splitting_var
  integer(i_def)         :: theta_splitting_var

contains

  !===========================================================================!
  !> @brief Initialises the system for running the advection algorithm.
  !>
  !> @param[in] mesh_id Identity of the mesh to create all fields on
  !>
  subroutine advection_alg_init( mesh_id )

    implicit none

    integer(i_def),  intent(in) :: mesh_id

    integer(i_def),     pointer :: shifted_mesh_id

    ! In transport_only mode we transport just a single moisture species
    if (transport_only) then
      nummr_to_advect = 1
    else
      nummr_to_advect = nummr
    end if

    ! Set up the mass flux spatial computation
    call flux_alg_init(mesh_id)
    if ( rho_splitting /= rho_splitting_none ) then
      call rk_transport_rho_init( mesh_id )
    end if
    if ( moisture_conservation ) then
      shifted_mesh_id => get_shifted_mesh_id()
      call flux_shifted_alg_init(shifted_mesh_id)
    end if

    ! Set up the advective update spatial computation
    call advective_update_alg_init(mesh_id)
    if ( theta_splitting /= theta_splitting_none   ) then
      call rk_transport_theta_init( mesh_id )
    end if

  end subroutine advection_alg_init

  !=============================================================================
  !>@details Finalises allocatable arrays, nullifies pointer in module scope
  !>         and calls finalising routines for kernels that this algorithm
  !>         initialised.
  subroutine advection_alg_final()

    implicit none

    call flux_alg_final()
    if ( moisture_conservation ) call flux_shifted_alg_final()
    call advective_update_alg_final()

  end subroutine advection_alg_final

  !=============================================================================!
  !>@details Control routine for the advection of ll fields needed for the model
  !> @param[in,out] rhs Advective terms
  !> @param[in]     state_after_slow Current state of the model prognostics with
  !>                slow physics forcings added
  !> @param[in]     wind_n Wind field at timestep n
  !> @param[in]     wind_np1 Latest estimate of wind field at timestep n+1
  !> @param[in]     advected_wind predictor for the wind to be advected
  !> @param[in]     mr_inc Increments to the moisture fields
  !> @param[in]     mr_after_slow Current moisture fields with
  !>                slow physics forcings added
  !> @param[in]     t_step The current model timestep
  !> @param[in]     outer Outer (advection) iteration number
  !> @param[in]     moist_dyn Factors for moist dynamics
  !> @param[in]     mr latest state of mixing ratios
  !> @param[in]     cloud_fields Fields for cloud scheme
  !> @param[in]     cloud_fields_after_slow Fields for cloud scheme with slow
  !>                physics forcings added
  !> @param[in]     rho_guess Estimate to new timestep density
  subroutine advection_control(rhs, state_after_slow,                   &
                               wind_n, wind_np1, advected_wind,         &
                               mr_inc, mr_after_slow,                   &
                               t_step, outer,                           &
                               moist_dyn, mr,                           &
                               cloud_fields, cloud_fields_after_slow,   &
                               rho_guess, dt )

  use formulation_config_mod,         only: use_moisture, &
                                            use_wavedynamics
  use timestepping_config_mod,        only: outer_iterations
  use derived_config_mod,             only: bundle_size
  use mr_indices_mod,                 only: nummr
  use field_indices_mod,              only: igh_d
  use io_config_mod,                  only: write_conservation_diag
  use moist_dyn_mod,                  only: num_moist_factors
  use moisture_conservation_alg_mod,  only: moisture_conservation_alg
  use field_bundle_mod,               only: add_bundle, &
                                            bundle_ax, &
                                            copy_bundle
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type
  use moist_dyn_factors_kernel_mod,   only: moist_dyn_factors_kernel_type
  use field_collection_mod,           only: field_collection_type

  implicit none

    type(field_type), dimension(bundle_size),       intent(inout) :: rhs
    type(field_type), dimension(nummr),             intent(inout) :: mr_inc, mr
    type(field_type), dimension(num_moist_factors), intent(inout) :: moist_dyn
    type(field_collection_type),                    intent(inout) :: cloud_fields
    type(field_collection_type),                    intent(inout) :: cloud_fields_after_slow
    type(field_type),                               intent(inout) :: rho_guess

    type(field_type), dimension(bundle_size), intent(in) :: state_after_slow
    type(field_type),                         intent(in) :: wind_n, wind_np1, advected_wind
    type(field_type), dimension(nummr),       intent(in) :: mr_after_slow

    integer(i_def), intent(in) :: t_step, outer
    real(r_def),    intent(in) :: dt

    logical                            :: do_moisture_diagnostics
    integer(i_def)                     :: imr
    ! Substepping variables
    type(field_type)                   :: cfl
    type(field_type), pointer          :: detj_at_w2 => null()
    real(r_def)                        :: cfl_min, cfl_max
    type(field_type)                   :: rho_in
    type(field_type), dimension(nummr) :: mr_tmp, mr_in
    integer(i_def)                     :: sub_step_count
    real(r_def)                        :: dt_substep, dt_fraction
    integer(i_def)                     :: n_control_substeps

    advection_counter = advection_counter + 1_i_def

    if (use_wavedynamics) then
      do_moisture_diagnostics = write_conservation_diag .and. &
                                outer == outer_iterations .and. &
                                use_moisture
      if ( do_moisture_diagnostics ) then
        call moisture_conservation_alg( t_step,                  &
                                        state_after_slow(igh_d), &
                                        mr_after_slow,           &
                                        'Before transport' )
      end if

      ! Advect dynamics prognostics
      call log_event("Advecting dynamics prognostic fields...", LOG_LEVEL_INFO)

      ! Calculate substepping timestep if needed for mol
      call cfl%initialise( wind_n%get_function_space() )
      detj_at_w2 => get_detj_at_w2(wind_n%get_mesh_id())
      ! Set advecting velocity = 0.5(u_np1 + u_n)
      call invoke( aX_plus_bY(cfl, 0.5_r_def, wind_n, &
                                   0.5_r_def, wind_np1), &
                   inc_X_divideby_Y(cfl, detj_at_w2), &
                   inc_a_times_X(dt, cfl )        &
                   )
      call cfl%field_minmax(cfl_min, cfl_max)
      cfl_max = max(abs(cfl_max),abs(cfl_min))
      n_control_substeps = int(cfl_max/(cfl_control_stab+tiny_eps),i_def) + 1_i_def
      dt_fraction = 1.0_r_def/real(n_control_substeps, r_def)
      dt_substep = dt*dt_fraction
      if (n_control_substeps > 1)then
        write( log_scratch_space, '(A,I3,2E16.8)' )  &
             'Advection will be substepped: n_control_substeps, cfl_max, dt_substep: ', &
             n_control_substeps, cfl_max, dt_substep
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
      end if

      call advection_alg(rhs, state_after_slow, wind_n, wind_np1, advected_wind, &
                         dt, n_control_substeps )
      call bundle_ax(dt, rhs, rhs, bundle_size)

      if ( use_moisture )then
        call log_event("Advecting moisture fields...", LOG_LEVEL_INFO)
        ! Advect mr_after_slow values with latest advecting velocity
        if ( moisture_conservation ) then
          call state_after_slow(igh_d)%copy_field(rho_in)
          do imr=1,nummr
            call mr_after_slow(imr)%copy_field(mr_in(imr))
            call mr_tmp(imr)%initialise( mr(imr)%get_function_space() )
            ! don't think I need this, but just as a check
            call invoke(setval_c(mr_tmp(imr), 0.0_r_def))
          end do
          do sub_step_count = 1, n_control_substeps
            call conservative_mr_adv_alg(mr_tmp, mr_in, wind_n, wind_np1, &
                                         rho_in, rho_guess, dt_substep)
            call copy_bundle(mr_tmp, mr_in, nummr)
            call rho_guess%copy_field(rho_in)
          end do
          call copy_bundle(mr_tmp, mr, nummr)
        else
          call advection_mr_alg(mr_inc, mr_after_slow, wind_n, wind_np1, &
                                dt, n_control_substeps)
          ! Update latest value for mr
          call add_bundle(mr_inc, mr_after_slow, mr, nummr)
        end if

        if (write_conservation_diag .and. outer == outer_iterations) then
          if (.not. moisture_conservation ) then
            ! Calculate guess of rho = state_after_slow + rhs_adv
            call invoke(X_plus_Y(rho_guess, state_after_slow(igh_d), &
                                 rhs(igh_d)))
          end if
          call moisture_conservation_alg( t_step, rho_guess, mr, &
                                          'Before clipping' )
        end if

        ! Clip moisture mixing ratios to remove negative values
        do imr = 1, nummr
          call invoke( enforce_lower_bound_kernel_type (mr(imr), 0.0_r_def) )
        end do
        call invoke(moist_dyn_factors_kernel_type(moist_dyn, mr))

        ! Call routine to advect some of the contents of cloud_fields.
        ! If not using PC2, nothing will be advected.
        ! If using PC2, some of these will be advected.
        !   * Cloud-fractions-after-slow values (held on cloud_fields)
        !     will get advected with advecting velocity.
        !   * The advected cloud fields variables get updated during this call
        call advection_generic_field_alg( cloud_fields,                   &
                                          cloud_fields_after_slow,        &
                                          wind_n, wind_np1,               &
                                          dt, n_control_substeps )

      end if
      if (do_moisture_diagnostics) then
        ! Calculate guess of rho = state_after_slow + rhs_adv
        if (.not. moisture_conservation ) &
          call invoke(X_plus_Y(rho_guess, state_after_slow(igh_d), rhs(igh_d)))
        call moisture_conservation_alg( t_step, rho_guess, mr, &
                                        'After transport' )
      end if
      call log_event("Finished advecting prognostic fields...", LOG_LEVEL_INFO)
    else
      ! No advection without wavedynamics at present
      if ( use_moisture ) call copy_bundle(mr_after_slow, mr, nummr)
    end if

  end subroutine advection_control

  !=============================================================================!
  !>@details A wrapper algorithm for computing the advection of the prognostic
  !>         equations, namely:
  !>         \f[ R_\theta = \frac{\mathbf{F}}{\rho}.\nabla\theta \f]
  !>         \f[ R_\rho = \nabla.\mathbf{F} \f]
  !>         \f[ R_u    = \left(\mathbf{u}\cdot\nabla\right)\mathbf{u} \f]
  !>         with the diagnostic field:
  !>
  !>         Mass flux: \f$ \mathbf{F} = \mathbf{u}\rho \f$
  !>
  !>         Using a either the method of lines algorithm
  !>         or COSMIC
  !> @param[in,out] advection Advective terms
  !> @param[in]     state Current state of the model prognostics
  !> @param[in]     wind_n Wind field at timestep n
  !> @param[in]     wind_np1 Latest estimate of wind field at timestep n+1
  !> @param[in]     advected_wind predictor for the wind to be advected
  !> @param[in]     dt_step Full length of model timestep
  !> @param[in]     n_substep number of steps
  subroutine advection_alg( advection,           &
                            state,               &
                            wind_n,              &
                            wind_np1,            &
                            advected_wind,       &
                            dt_step, n_substeps )

  implicit none
  type(field_type), intent(inout) :: advection(bundle_size)
  type(field_type), intent(in)    :: state(bundle_size)
  type(field_type), intent(in)    :: wind_n
  type(field_type), intent(in)    :: wind_np1
  type(field_type), intent(in)    :: advected_wind
  real(r_def),      intent(in)    :: dt_step
  integer(i_def),   intent(in)    :: n_substeps

  type(operator_type), pointer :: mm_wt         => null(), &
                                  mm_w3_inv     => null(), &
                                  div           => null()
  type(field_type),    pointer :: mt_lumped_inv => null()
  type(field_type)             :: r_rho,                   &
                                  u_grad_theta,            &
                                  mass_flux,               &
                                  advecting_wind
  type(field_type) :: field, field_inc, field_old, mass_flux_i
  integer(i_def)   :: sub_step_count
  integer(i_def)   :: mesh_id

  real(r_def) :: dt_substep, dt_fraction

  if ( subroutine_timers ) call timer('advection_alg')

  mesh_id = wind_n%get_mesh_id()

  ! substepping timesteps
  dt_fraction = 1.0_r_def/real(n_substeps, r_def)
  dt_substep = dt_step*dt_fraction

  ! Construct fields needed for advection
  call advecting_wind%initialise( state(igh_u)%get_function_space() )
  call mass_flux%initialise( state(igh_u)%get_function_space() )
  call r_rho%initialise( state(igh_d)%get_function_space() )

  ! Set advecting velocity = 0.5(u_np1 + u_n)
  call invoke( aX_plus_bY(advecting_wind, 0.5_r_def, wind_n, &
                                          0.5_r_def, wind_np1) )

  ! Advect density field
  call log_event( "Advecting density...", LOG_LEVEL_INFO)
  if ( scheme == scheme_method_of_lines ) then

    if ( rho_splitting /= rho_splitting_none  ) then
     call advect_field(advection(igh_d), state(igh_d), advecting_wind, &
                      scheme, wind_n, wind_np1, advect_density=.true., &
                      timestep=dt_step, si_advective_terms=.false.,    &
                      shifted=.false.,                                 &
                      density_predictor=use_density_predictor,         &
                      logspace=.false., dt=dt_step )
    else
      ! Reconstruct the advection increment from the mass flux
     call state(igh_d)%copy_field(field)
     call field_inc%initialise( field%get_function_space() )
     call mass_flux_i%initialise( state(igh_u)%get_function_space() )
     call invoke(setval_c(mass_flux, 0.0_r_def), &
                 setval_c(mass_flux_i, 0.0_r_def), &
                 setval_c(advection(igh_d), 0.0_r_def))
     mm_w3_inv => get_inverse_w3_mass_matrix(mesh_id)
     div       => get_div(mesh_id)
     do sub_step_count = 1, n_substeps
       call field%copy_field(field_old)
       call advect_field(mass_flux_i, field, advecting_wind,        &
          scheme, wind_n, wind_np1, advect_density=.true.,          &
          timestep=dt_substep, si_advective_terms=.false.,          &
          shifted=.false., density_predictor=use_density_predictor, &
          logspace=log_rho, dt=dt_step                              &
          )
       call invoke( setval_c(r_rho, 0.0_r_def),                         &
                    matrix_vector_kernel_type(r_rho, mass_flux_i, div), &
                    inc_a_times_X(-1.0_r_def, r_rho),                   &
                    dg_matrix_vector_kernel_type(field_inc,             &
                                                 r_rho, mm_w3_inv),     &
                    ! update the mass flux and increment
                    inc_X_plus_bY(mass_flux, dt_fraction, mass_flux_i),      &
                    inc_X_plus_bY(advection(igh_d), dt_fraction, field_inc), &
                    ! update the field
                    aX_plus_Y(field, dt_substep, field_inc, field_old)       &
                   )
     end do
   end if
  else
    ! Cosmic computes the advection increment instead of the mass flux
    call advect_field(advection(igh_d), state(igh_d), advecting_wind,  &
                      scheme, wind_n, wind_np1, advect_density=.true., &
                      timestep=dt_step, si_advective_terms=.false.,    &
                      shifted=.false.,                                 &
                      density_predictor=use_density_predictor,         &
                      logspace=.false., dt=dt_step )
  end if

  ! Advect potential temperature field
  ! Cosmic is not yet implemented and so must use method of lines scheme
  call log_event( "Advecting potential temperature...", LOG_LEVEL_INFO)
  call u_grad_theta%initialise( state(igh_t)%get_function_space() )

  call invoke(setval_c(u_grad_theta, 0.0_r_def))
  call state(igh_t)%copy_field(field)
  do sub_step_count = 1, n_substeps
    call field%copy_field(field_old)
    call field_inc%initialise( field%get_function_space() )
    call advect_field(field_inc, field, advecting_wind,            &
                    scheme_method_of_lines, wind_n, wind_np1,      &
                    advect_density=.false., timestep=dt_substep,   &
                    si_advective_terms=.false., shifted=.false.,   &
                    density_predictor=.false., logspace=log_theta, &
                    dt=dt_step )
    call invoke( aX_plus_Y(field, dt_substep, field_inc, field_old), &
                 inc_X_plus_bY(u_grad_theta, dt_fraction, field_inc) &
                 )
  end do
  ! u_grad_theta now contains a pointwise incremente to theta,
  ! i.e. theta_np1 = theta_n - dt*u_grad_theta
  ! Depending upon what the temporal discretisation is this needs
  ! converting into the a weak form, either by cancelling out the
  ! lumped mass matrix used to advect it or by multiplying by the
  ! full mass matrix
  if ( operators == operators_fv ) then
    if ( time_method == method_rk ) then
      ! Solve equation in pointwise form (fully fv equation)
      call invoke( setval_X(advection(igh_t), u_grad_theta) )
    else
      ! Convert equation from pointwise form to weak form (fully fem equation)
      mm_wt => get_mass_matrix(Wtheta, mesh_id)
      call invoke( setval_c(advection(igh_t), 0.0_r_def), &
                   matrix_vector_kernel_type(advection(igh_t), u_grad_theta, mm_wt) )
    end if
  else
    ! Cancel out the lumped mass matrix used to advect theta
    mt_lumped_inv => get_inverse_lumped_mass_matrix(Wtheta, mesh_id)
    call invoke( X_divideby_Y(advection(igh_t), u_grad_theta, &
                              mt_lumped_inv) )
  end if

  if ( si_momentum_equation ) then
    ! Advection terms are handled by the semi-implicit scheme the increment is zero
    call invoke( setval_c(advection(igh_u), 0.0_r_def) )
  else
    ! Advect wind field
    call log_event( "Advecting wind...", LOG_LEVEL_INFO)
    call advect_momentum_alg(advection(igh_u), advected_wind, &
                             advecting_wind,                  &
                             wind_n, wind_np1,                &
                             dt_step, n_substeps, .false.)
  end if

  ! Don't advect Exner pressure
  call invoke( setval_c(advection(igh_p), 0.0_r_def) )

  nullify(mm_wt, mm_w3_inv, div,  mt_lumped_inv)

  if ( subroutine_timers ) call timer('advection_alg')
end subroutine advection_alg

  !===========================================================================!
  !> @details A wrapper algorithm for computing the advection of the moisture
  !>          prognostic
  !> @param[in,out] mr_inc Increment to mixing ratios
  !> @param[in]     mr Mixing ratios
  !> @param[in]     wind_n Time level n winds
  !> @param[in]     wind_np1 Time level n+1 winds
  !> @param[in]     dt_step Full length of model timestep
  !> @param[in]     n_substep number of steps
  subroutine advection_mr_alg( mr_inc, mr, wind_n, wind_np1, dt_step, n_substeps )
    implicit none
    type(field_type), intent(inout) :: mr_inc(nummr)
    type(field_type), intent(in)    :: mr(nummr)
    type(field_type), intent(in)    :: wind_n, wind_np1
    real(r_def), intent(in)         :: dt_step
    integer(i_def), intent(in)      :: n_substeps

    type(field_type) :: advecting_wind
    integer(i_def)   :: imr

    type(field_type) :: field, field_inc, field_old
    integer(i_def)   :: sub_step_count

    real(r_def) :: dt_substep, dt_fraction

    if ( subroutine_timers ) call timer('advection_mr_alg')
    call log_event( "Computing moisture advection...", LOG_LEVEL_INFO)
    ! Set advecting velocity = 0.5(u_np1 + u_n)
    call advecting_wind%initialise( wind_n%get_function_space() )
    call invoke( aX_plus_bY(advecting_wind, 0.5_r_def, wind_n, 0.5_r_def, wind_np1) )

    ! substepping timesteps
    dt_fraction = 1.0_r_def/real(n_substeps, r_def)
    dt_substep = dt_step*dt_fraction

    do imr = 1, nummr_to_advect
      call mr(imr)%copy_field(field)
      call invoke(setval_c(mr_inc(imr), 0.0_r_def))
      do sub_step_count = 1, n_substeps
        call field%copy_field(field_old)
        call field_inc%initialise( field%get_function_space() )
        call advect_field( field_inc, field, advecting_wind,        &
                           scheme_method_of_lines, wind_n, wind_np1,    &
                           advect_density=.false., timestep=dt_substep, &
                           si_advective_terms=.false., shifted=.false., &
                           density_predictor=.false., logspace=.false., &
                           dt=dt_step )
        call invoke( aX_plus_Y(field, dt_substep, field_inc, field_old), &
                     inc_X_plus_bY(mr_inc(imr), dt_fraction, field_inc) &
                     )
      end do
      ! Make mr_inc into an increment by multiplying by dt
      call invoke( inc_a_times_X(dt_step, mr_inc(imr)) )
    end do
    if ( subroutine_timers ) call timer('advection_mr_alg')

  end subroutine advection_mr_alg

  !===========================================================================!
  !> @details A wrapper algorithm for performing conservative advection of
  !>          moisture prognostics
  !> @param[in,out] mr_out Mixing ratio bundle to be returned (after advection)
  !> @param[in]     mr Mixing ratio bundle (before advection)
  !> @param[in]     wind_n Time level n winds
  !> @param[in]     wind_np1 Time level n+1 winds
  !> @param[in]     rho_d_n Time level n dry density
  !> @param[in,out] rho_d_star Guess of transported rho_d to be calculated
  !> @param[in]     dt_step timestep length of step
  subroutine conservative_mr_adv_alg( mr_out, mr, wind_n, wind_np1,  &
                                      rho_d_n, rho_d_star, dt_step )

    ! Kernels for mappings used by conservative transport scheme
    use field_bundle_mod,                   only: bundle_ax, add_bundle
    use tri_mat_mr_to_sh_mass_kernel_mod,   only: tri_mat_mr_to_sh_mass_kernel_type
    use tri_solve_sh_mass_to_mr_kernel_mod, only: tri_solve_sh_mass_to_mr_kernel_type
    use w2_to_sh_w2_kernel_mod,             only: w2_to_sh_w2_kernel_type
    use tri_matrix_vector_kernel_mod,       only: tri_matrix_vector_kernel_type

    implicit none

    type(field_type), intent(inout)    :: mr_out(nummr)
    type(field_type), intent(in)       :: mr(nummr)
    type(field_type), intent(in)       :: wind_n, wind_np1
    type(field_type), intent(in)       :: rho_d_n
    type(field_type), intent(inout)    :: rho_d_star
    real(r_def),      intent(in)       :: dt_step

    ! Internal arguments
    integer(kind=i_def)                :: i, imr, primary_mesh_id
    integer(kind=i_def),       pointer :: shifted_mesh_id => null()
    integer(kind=i_def),       pointer :: double_level_mesh_id => null()
    type(function_space_type), pointer :: w3_shifted_fs => null()
    type(function_space_type), pointer :: w2_shifted_fs => null()
    type(function_space_type), pointer :: wt_shifted_fs => null()
    type(operator_type),       pointer :: div => null()
    type(operator_type),       pointer :: div_shifted => null()
    type(operator_type),       pointer :: mm_w3_inv => null()
    type(field_type),          pointer :: mm_w3_shifted_inv_diag => null()
    type(field_type),          pointer :: mm_w3_shifted_diag => null()
    type(field_type),          pointer :: mr_to_sh_mass_integrals(:) => null()
    type(field_type),          pointer :: dA_w2 => null()
    type(field_type),          pointer :: dA_w2_shifted => null()
    type(field_type),          pointer :: dA_w2_double_level => null()
    type(field_type),          pointer :: chi_sph(:) => null()
    type(field_type),          pointer :: chi_sph_shifted(:) => null()
    type(field_type),          pointer :: height_wt
    type(field_type),          pointer :: height_wt_shifted
    type(field_type)                   :: matrix_mr_to_sh_mass_n(3)
    type(field_type)                   :: matrix_mr_to_sh_mass_star(3)
    type(field_type)                   :: rho_X_n(nummr), rho_X_star(nummr)
    type(field_type)                   :: rho_X_inc(nummr), rho_d_inc
    type(field_type)                   :: advecting_wind, advecting_wind_shifted
    type(field_type)                   :: mass_flux_shifted, mass_flux
    type(field_type)                   :: r_rho_shifted, r_rho

    if ( subroutine_timers ) call timer('conservative_mr_adv_alg')
    call log_event( "Computing conservative moisture advection...", LOG_LEVEL_INFO)

    primary_mesh_id = rho_d_n%get_mesh_id()
    shifted_mesh_id => get_shifted_mesh_id()
    double_level_mesh_id => get_double_level_mesh_id()
    mr_to_sh_mass_integrals => get_mr_to_sh_mass_integrals()
    mm_w3_inv => get_inverse_W3_mass_matrix(primary_mesh_id)
    mm_w3_shifted_inv_diag => get_inverse_lumped_mass_matrix(W3, shifted_mesh_id)
    mm_w3_shifted_diag => get_mass_matrix_diagonal(W3, shifted_mesh_id)
    dA_w2 => get_dA_at_w2(primary_mesh_id)
    dA_w2_shifted => get_dA_at_w2(shifted_mesh_id)
    dA_w2_double_level => get_dA_at_w2(double_level_mesh_id)
    chi_sph => get_coordinates(primary_mesh_id)
    chi_sph_shifted => get_coordinates(shifted_mesh_id)
    div => get_div(primary_mesh_id)
    div_shifted => get_div(shifted_mesh_id)
    height_wt => get_height(WTHETA, primary_mesh_id)
    height_wt_shifted => get_height(WTHETA, shifted_mesh_id)

    ! Get function spaces
    w3_shifted_fs => function_space_collection%get_fs(shifted_mesh_id, 0, W3)
    w2_shifted_fs => function_space_collection%get_fs(shifted_mesh_id, 0, W2)
    wt_shifted_fs => function_space_collection%get_fs(shifted_mesh_id, 0, WTHETA)

    !> @todo A large number of fields are initialised here. It would be better do
    !> do this just the once by having an init routine. This should be dealt
    !> with by #2253 or #2223

    ! Initialise fields for transforming between mixing ratio and shifted density
    do i = 1, 3
      call matrix_mr_to_sh_mass_n(i)%initialise( vector_space=w3_shifted_fs )
      call matrix_mr_to_sh_mass_star(i)%initialise( vector_space=w3_shifted_fs )
    end do

    do imr = 1, nummr
      call rho_X_n(imr)%initialise( vector_space=w3_shifted_fs )
      call rho_X_star(imr)%initialise( vector_space=w3_shifted_fs )
      call rho_X_inc(imr)%initialise( vector_space=w3_shifted_fs )
    end do

    ! Initialise internal variables for calculating advective increments
    call mass_flux_shifted%initialise( vector_space = w2_shifted_fs )
    call r_rho_shifted%initialise( vector_space = w3_shifted_fs )
    call mass_flux%initialise( vector_space = wind_n%get_function_space() )
    call r_rho%initialise( vector_space = rho_d_n%get_function_space() )
    call rho_d_inc%initialise( rho_d_n%get_function_space() )

    ! Calculate shifted advecting wind
    call advecting_wind%initialise( vector_space=wind_n%get_function_space() )
    call advecting_wind_shifted%initialise( vector_space=w2_shifted_fs )
    call invoke( aX_plus_bY(advecting_wind, 0.5_r_def, wind_n,    &
                                            0.5_r_def, wind_np1) )
    call invoke( w2_to_sh_w2_kernel_type( advecting_wind_shifted, &
                                          advecting_wind,         &
                                          dA_w2_shifted,          &
                                          dA_w2,                  &
                                          dA_w2_double_level,     &
                                          height_wt_shifted,      &
                                          height_wt               &
                                        ) )

    ! Advect dry density
    call advect_field(mass_flux, rho_d_n, advecting_wind,                      &
                      scheme_method_of_lines, wind_n, wind_np1,                &
                      advect_density=.true., timestep=dt_step,                 &
                      si_advective_terms=.false., shifted=.false.,             &
                      density_predictor=.false., logspace=log_rho, dt=dt_step )

    call invoke( name = "Compute advected dry density",                        &
                 setval_c(r_rho, 0.0_r_def),                                   &
                 matrix_vector_kernel_type(r_rho, mass_flux, div),             &
                 inc_a_times_X(-1.0_r_def, r_rho),                             &
                 dg_matrix_vector_kernel_type(rho_d_inc, r_rho, mm_w3_inv),    &
                 aX_plus_Y(rho_d_star, dt_step, rho_d_inc, rho_d_n)            )


    ! Use dry densities to get tridiagonal matrices
    call invoke( name = "Calculate tridiagonal matrix values",                 &
                 tri_mat_mr_to_sh_mass_kernel_type( matrix_mr_to_sh_mass_n,    &
                                                    rho_d_n,                   &
                                                    mr_to_sh_mass_integrals    &
                                                  ),                           &
                 tri_mat_mr_to_sh_mass_kernel_type( matrix_mr_to_sh_mass_star, &
                                                    rho_d_star,                &
                                                    mr_to_sh_mass_integrals    &
                                                  ) )

    ! Obtain shifted moisture densities
    do imr = 1, nummr_to_advect
      call invoke( name = "Compute wet densities in shifted W3",               &
                   tri_matrix_vector_kernel_type(rho_X_n(imr),                 &
                                                 matrix_mr_to_sh_mass_n,       &
                                                 mr(imr)),                     &
                   inc_X_times_Y(rho_X_n(imr), mm_w3_shifted_inv_diag)         )

      call advect_field(mass_flux_shifted, rho_X_n(imr),                       &
                        advecting_wind_shifted,                                &
                        scheme_method_of_lines, wind_n, wind_np1,              &
                        advect_density=.true., timestep=dt_step,               &
                        si_advective_terms=.false., shifted=.true.,            &
                        density_predictor=.false., logspace=.false., dt=dt_step )

      ! Reconstruct the advection increment from the mass flux
      call invoke( setval_c(r_rho_shifted, 0.0_r_def),                         &
                   matrix_vector_kernel_type(r_rho_shifted, mass_flux_shifted, &
                                             div_shifted),                     &
                   inc_a_times_X(-1.0_r_def, r_rho_shifted),                   &
                   X_times_Y(rho_X_inc(imr), r_rho_shifted,                    &
                             mm_w3_shifted_inv_diag)                           &
                   )
    end do

    ! Add density increments to get advected densities
    call bundle_ax(dt_step, rho_X_inc, rho_X_inc, nummr)
    call add_bundle(rho_X_inc, rho_X_n, rho_X_star, nummr)

    ! Obtain mixing ratios back from wet densities
    do imr = 1, nummr_to_advect
      call invoke( name = "Compute mixing ratio from shifted density",  &
                   inc_X_times_Y(rho_X_star(imr), mm_w3_shifted_diag) )
      call invoke( tri_solve_sh_mass_to_mr_kernel_type(mr_out(imr),     &
                                                       rho_X_star(imr), &
                                                       matrix_mr_to_sh_mass_star) )
    end do

    if ( subroutine_timers ) call timer('conservative_mr_adv_alg')

  end subroutine conservative_mr_adv_alg


  !===========================================================================!
  !> @details A wrapper algorithm for advection a generic prognostic.
  !> @param[in]     generic_fields            collection which gets updated
  !> @param[in,out] generic_fields_after_slow collection to advect
  !> @param[in]     wind_n                    Time level n winds
  !> @param[in]     wind_np1                  Time level n+1 winds
  !> @param[in]     dt_step                   timestep length of step
  !> @param[in]     n_substep                 number of steps
  subroutine advection_generic_field_alg( generic_fields,                    &
                                          generic_fields_after_slow,         &
                                          wind_n, wind_np1,                  &
                                          dt_step, n_substeps)

    use field_collection_mod,     only: field_collection_type,       &
                                        field_collection_real_iterator_type

    implicit none

    type(field_collection_type), intent(in)    :: generic_fields
    type(field_collection_type), intent(inout) :: generic_fields_after_slow
    type(field_type),            intent(in)    :: wind_n, wind_np1
    real(r_def), intent(in)         :: dt_step
    integer(i_def), intent(in)      :: n_substeps

    type(field_type) :: advecting_wind
    type(field_type) :: gf_inc

    ! Iterator for field collection
    type(field_collection_real_iterator_type) :: iterator

    ! One of the single fields out of the generic_fields collection
    type(field_type), pointer :: single_generic_field => null()

    ! The saved version of single_generic_field after slow physics
    type(field_type), pointer :: after_slow_generic_field => null()

    ! Variables for substepping
    real(r_def)      :: dt_substep, dt_fraction
    type(field_type) :: field, field_inc, field_old
    integer(i_def)   :: sub_step_count


    if ( subroutine_timers ) call timer( 'advection_generic_field_alg' )

    call log_event( "Computing generic field advection...", LOG_LEVEL_INFO )

    ! substepping timesteps
    dt_fraction = 1.0_r_def/real(n_substeps, r_def)
    dt_substep = dt_step*dt_fraction

    ! Set advecting velocity = 0.5(u_np1 + u_n)
    call advecting_wind%initialise( wind_n%get_function_space() )
    call invoke( aX_plus_bY(advecting_wind, 0.5_r_def, wind_n, &
                                            0.5_r_def, wind_np1) )

    if ( generic_fields_after_slow%get_length() > 0 ) then

      iterator = generic_fields_after_slow%get_real_iterator()

      do
        if ( .not.iterator%has_next() ) exit

        after_slow_generic_field => iterator%next()

        ! N.B. no need to test on the advection flag because this has already
        ! been used to select the fields in generic_fields_after_slow

        call log_event( "Advecting "//                                        &
             trim(after_slow_generic_field%get_name()), LOG_LEVEL_INFO)
        call after_slow_generic_field%copy_field_properties(gf_inc)
        call after_slow_generic_field%copy_field(field)
        call invoke(setval_c(gf_inc, 0.0_r_def))
        do sub_step_count = 1, n_substeps
          call field%copy_field(field_old)
          call field_inc%initialise( field%get_function_space() )
          call advect_field( field_inc, field, advecting_wind,  &
                           scheme_method_of_lines, wind_n, wind_np1,          &
                           advect_density=.false., timestep=dt_substep,       &
                           si_advective_terms=.false., shifted=.false.,       &
                           density_predictor=.false., logspace=.false.,       &
                           dt=dt_step )
          call invoke( aX_plus_Y(field, dt_substep, field_inc, field_old), &
                       inc_X_plus_bY(gf_inc, dt_fraction, field_inc) &
                       )
        end do
        ! Get the field from the original collection which we want to update
        single_generic_field => generic_fields%get_field(                     &
             trim(after_slow_generic_field%get_name() ) )
        ! Make inc into an increment by multiplying by dt
        call invoke( inc_a_times_X(dt_step, gf_inc ) ,                        &
                     ! and add it on to the field
                     X_plus_Y(single_generic_field, after_slow_generic_field, &
                                                    gf_inc ) )
      end do

    end if

    if ( subroutine_timers ) call timer('advection_generic_field_alg')

  end subroutine advection_generic_field_alg

  !============================================================================!
  !> @brief Use MoL reconstruction to compute advective form update of momentum
  !!        equations by advecting each vector component as a scalar. Splits
  !!        the wind into 3 scalar components and then advects them separately.
  !> @param[in,out] rhs Momentum advection increment: [(u.grad) u]
  !> @param[in]     advected_wind Wind field to advect
  !> @param[in]     advecting_wind Advecting wind field
  !> @param[in]     wind_n Time level n wind field
  !> @param[in]     wind_np1 Time level n+1 wind field
  !> @param[in]     dt_step timestep length of step
  !> @param[in]     n_substep number of steps
  !> @param[in]     from_si Flag if calling this routine from semi-implicit
  !!                (instead of advection) routines
  subroutine advect_momentum_alg( rhs, advected_wind, advecting_wind, &
                                  wind_n, wind_np1, dt_step, n_substeps, from_si )

    use convert_hdiv_field_kernel_mod,  only: convert_hdiv_field_kernel_type
    use project_advective_update_kernel_mod, &
                                        only: project_advective_update_kernel_type
    use finite_element_config_mod,      only: element_order, &
                                              nqp_exact
    use quadrature_rule_gaussian_mod,   only: quadrature_rule_gaussian_type
    use quadrature_xyoz_mod,            only: quadrature_xyoz_type
    use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type

    implicit none

    type(field_type), intent(inout)     :: rhs
    type(field_type), intent(in)        :: advected_wind, advecting_wind
    type(field_type), intent(in)        :: wind_n, wind_np1
    real(r_def),      intent(in)        :: dt_step
    integer(i_def),   intent(in)        :: n_substeps
    logical,          intent(in)        :: from_si

    type(field_type), dimension(3)      :: u_scalar, adv_wind_update
    type( field_type ),        pointer  :: chi_sph(:) => null()
    type( field_type ),        pointer  :: panel_id => null()
    type(function_space_type), pointer  :: ws_fs => null()
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule
    integer(i_def)                      :: dir, mesh_id
    type(field_type)                    :: field, field_inc, field_old
    integer(i_def)                      :: sub_step_count

    ! Variables for substepping
    real(r_def)      :: dt_substep, dt_fraction

    if ( subroutine_timers ) call timer('momentum advection')

    mesh_id = wind_n%get_mesh_id()

    ! substepping timesteps
    dt_fraction = 1.0_r_def/real(n_substeps, r_def)
    dt_substep = dt_step*dt_fraction

    ws_fs => function_space_collection%get_fs( mesh_id, element_order, W3 )

    ! If not using vector invariant form then compute [ (u.grad)u ]
    ! Compute u in physical space and advect components in geocentric
    ! Cartesian coordinates and then map back to computational form
    qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)
    chi_sph => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)
    ! Compute updates on W3 points
    do dir = 1,3
      call u_scalar(dir)%initialise( ws_fs )
      call adv_wind_update(dir)%initialise( ws_fs )
    end do
    call advected_wind%log_minmax( LOG_LEVEL_INFO, 'advected u' )
    call invoke( setval_c(u_scalar(1), 0.0_r_def), &
                 setval_c(u_scalar(2), 0.0_r_def), &
                 setval_c(u_scalar(3), 0.0_r_def), &
                 convert_hdiv_field_kernel_type(u_scalar, advected_wind, &
                                                chi_sph, panel_id) )
    call u_scalar(1)%log_minmax(LOG_LEVEL_INFO, 'xdot')
    call u_scalar(2)%log_minmax(LOG_LEVEL_INFO, 'ydot')
    call u_scalar(3)%log_minmax(LOG_LEVEL_INFO, 'zdot')

    ! Compute reconstruction of each velocity component
    do dir = 1,3
      call u_scalar(dir)%copy_field(field)
      call invoke(setval_c(adv_wind_update(dir), 0.0_r_def))
      do sub_step_count = 1, n_substeps
        call field%copy_field(field_old)
        call field_inc%initialise( field%get_function_space() )
        call advect_field(field_inc, field, advecting_wind,                  &
                        scheme, wind_n, wind_np1,                            &
                        advect_density=.false., timestep=dt_substep,         &
                        si_advective_terms=from_si, shifted=.false.,         &
                        density_predictor=.false., logspace=.false.,         &
                        dt=dt_step )
        call invoke( aX_plus_Y(field, dt_substep, field_inc, field_old), &
                     inc_X_plus_bY(adv_wind_update(dir), dt_fraction, field_inc) &
                     )
      end do
    end do
    ! Compute the updates to the W2 wind field using the physical scalar
    ! update
    call invoke( setval_c(rhs, 0.0_r_def),                                    &
                 project_advective_update_kernel_type(rhs, adv_wind_update,   &
                                                      chi_sph, panel_id, qr), &
                 enforce_bc_kernel_type(rhs) )

    nullify( ws_fs, chi_sph, panel_id )
    if ( subroutine_timers ) call timer('momentum advection')

  end subroutine advect_momentum_alg

  !===========================================================================!
  !> @brief Advect a generic field and optionally return the flux used to
  !>        advect the field
  !> @param[in,out] advection_inc Update from advecting the field
  !> @param[in]     field Field to advect
  !> @param[in]     advecting_wind Advecting wind field
  !> @param[in]     adv_scheme Scheme used to advect this field
  !> @param[in]     wind_n Time level n wind field
  !> @param[in]     wind_np1 Time level n+1 wind field
  !> @param[in]     advect_density Flag for advecting the density and
  !>                              returning the mass flux
  !> @param[in]     timestep The length of time by which to advect by
  !> @param[in]     si_advective_terms Flag to avoid using Runge-Kutta
  !>                substepping
  !> @param[in]     shifted Flag for advection on the shifted mesh
  !> @param[in]     density_predictor Flag for advecting the density
  !>                                  predictor rho*[1-beta*dt*div(u)]
  !> @param[in]     logspace If true, then if scheme allows, do interpolation
  !>                                  in log space
  !> @param[in]     dt The length of the full model timestep
  subroutine advect_field( advection_inc, field, advecting_wind, adv_scheme, &
                           wind_n, wind_np1, advect_density, timestep,       &
                           si_advective_terms, shifted, density_predictor,   &
                           logspace, dt )

    use advective_wind_update_kernel_mod, &
      only: advective_wind_update_kernel_type
    use timestepping_config_mod, only: outer_iterations

    implicit none

    type(field_type), intent(inout) :: advection_inc
    type(field_type), intent(in)    :: field
    type(field_type), intent(in)    :: advecting_wind
    type(field_type), intent(in)    :: wind_n, wind_np1
    integer(i_def),   intent(in)    :: adv_scheme
    logical(l_def),   intent(in)    :: advect_density
    real(r_def),      intent(in)    :: timestep
    logical,          intent(in)    :: si_advective_terms
    logical,          intent(in)    :: shifted
    logical,          intent(in)    :: density_predictor
    logical,          intent(in)    :: logspace
    real(r_def),      intent(in)    :: dt

    integer(i_def)                  :: mesh_id

    ! For Method of Lines
    type(operator_type), pointer  :: div => null(),      &
                                     mm_w3_inv => null()
    type(field_type)              :: flux,               &
                                     rhs,                &
                                     field_new,          &
                                     field_inc,          &
                                     divergence_factor,  &
                                     unit_wind
    type(field_type), allocatable :: rk_rhs(:)
    integer(i_def)                :: stage, s, function_space
    real(r_def)                   :: minus_beta_dt

    integer(i_def)                :: nstage
    real(r_def), allocatable      :: ak_adv(:,:)

    ! For Cosmic
    type(field_type)          :: dep_pts_x, dep_pts_y, dep_pts_z
    type(field_type)          :: wind_divergence
    type(field_type), pointer :: detj_at_w2 => null()
    type(field_type), pointer :: cell_orientation => null()
    type(field_type)          :: field_old, field_unity
    real(r_def)               :: inv_dt
    integer(i_def)            :: time_step_number

    mesh_id = field%get_mesh_id()

    ! Function space of the field to be advected
    function_space = field%which_function_space()

     call flux%initialise( advecting_wind%get_function_space() )
     call rhs%initialise( field%get_function_space() )
     call field_inc%initialise( field%get_function_space() )
     call field_new%initialise( field%get_function_space() )
     call field%copy_field(field_new)

     div       => get_div(mesh_id)
     mm_w3_inv => get_inverse_w3_mass_matrix(mesh_id)

     if ( time_method == method_semi_implicit          &
          .and. advect_density                         &
          .and. .not. si_momentum_equation             &
          .and. (rho_splitting == rho_splitting_none)  &
          .and. density_predictor                      ) then
       ! Advect predictor for the density: rho*divergence_factor with
       ! divergence_factor = [1-beta*dt*div(u)]
      ! This helps improve long timestep stability
          minus_beta_dt = -beta*dt  ! Note this is dt, not the substep timestep
          call divergence_factor%initialise( field%get_function_space() )
          call invoke( name = "compute_density_predictor",                     &
                       dg_matrix_vector_kernel_type(divergence_factor, wind_n, &
                                                    div),                      &
                       dg_matrix_vector_kernel_type(rhs, divergence_factor,    &
                                                    mm_w3_inv),                &
                       setval_c(divergence_factor, 1.0_r_def),                 &
                       inc_X_plus_bY(divergence_factor, minus_beta_dt, rhs),   &
                       inc_X_times_Y(field_new, divergence_factor) )
     end if

     rho_splitting_var   = rho_splitting
     theta_splitting_var = theta_splitting

     if ( (  rho_splitting /= rho_splitting_none  ) .OR.  &
         (theta_splitting /= theta_splitting_none)       ) then
       time_step_number = int(real(advection_counter/outer_iterations,r_def),i_def) + 1_i_def

       if (switch_splitting == 1 ) then
        if ( mod(time_step_number,2_i_def) == 0 ) then
          rho_splitting_var = rho_splitting_vh
          theta_splitting_var = theta_splitting_vh
        else
          rho_splitting_var = rho_splitting_hv
          theta_splitting_var = theta_splitting_hv
        end if
       end if

       if (switch_splitting == 2 ) then
        if ( mod(advection_counter,2_i_def) == 0 ) then
          rho_splitting_var = rho_splitting_vh
          theta_splitting_var = theta_splitting_vh
        else
          rho_splitting_var = rho_splitting_hv
          theta_splitting_var = theta_splitting_hv
        end if
       end if
     end if

     inv_dt = 1.0_r_def/timestep

    if ( (rho_splitting /= rho_splitting_none) .AND. (function_space==W3) ) then
       !
       ! Use "split_slice_mol_transport" if the field is a conservative rho-type field
       !

      call field_old%initialise( field%get_function_space() )
      call field_new%copy_field(field_old)
      call invoke( setval_c(advection_inc, 0.0_r_def) )

      call split_slice_mol_transport( advecting_wind, field_new, rho_splitting_var, dt )

      if ( .not. advect_density ) then
        call field_unity%initialise( field%get_function_space() )
        call invoke( setval_c(field_unity, 1.0_r_def) )
        call split_slice_mol_transport( advecting_wind, field_unity, rho_splitting_var, dt )
        call invoke( inc_X_divideby_Y(field_new, field_unity) )
      end if

      call invoke( X_minus_Y(advection_inc, field_new, field_old), &
                   inc_a_times_X(inv_dt,advection_inc)             )

    else if( (theta_splitting /= theta_splitting_none) .AND. (function_space==Wtheta) ) then
       !
       ! Use "split_transport_theta_step" if the field is a advective theta-type field
       !

      call field_old%initialise( field%get_function_space() )
      call field_new%copy_field(field_old)
      call invoke( setval_c(advection_inc, 0.0_r_def) )

      call split_transport_theta_step( advecting_wind, field_new, theta_splitting_var, dt)

      call invoke( X_minus_Y(advection_inc, field_new, field_old), &
                   inc_a_times_X(inv_dt,advection_inc)             )

    else

       !
       ! Use the original MOL or Cosmic methods
       !
     select case(adv_scheme)

      case(scheme_method_of_lines)

        if ( ( time_method == method_rk .and. .not. transport_only ) &
              .or. si_advective_terms ) then
        ! If using explicit timestepping then advection is called once per stage,
        ! therefore no further sub stages are needed, setting number of stages = 1
        ! and coeffs = 1 short cuts the rk advection scheme
          nstage = 1
          allocate( ak_adv( nstage, nstage ) )
          ak_adv(1,1) = 1.0_r_def
        else
          nstage = num_rk_stage
          allocate( ak_adv( nstage, nstage ) )
          ak_adv = ak
        end if
        allocate( rk_rhs(nstage) )

        if ( function_space == W3 .and. .not. advect_density ) then
          ! Compute unit wind to make flux alg return recontructed
          ! tracer instead of mass flux
          call unit_wind%initialise( advecting_wind%get_function_space() )
          call invoke( sign_X(unit_wind, 1.0_r_def, advecting_wind) )
        end if

        ! Use Runge-Kutta timestepping to advect field and return either
        ! the advection increment or the flux used to advect the field
        call invoke( setval_c( advection_inc, 0.0_r_def) )
        do stage = 1,nstage
          call rk_rhs(stage)%initialise( field%get_function_space() )
          ! Build rhs depending upon type of field being advected
          select case(function_space)
            case(Wtheta)
              ! Compute: - u.grad(f)
              call advective_update_alg(rk_rhs(stage), field_new,              &
                                        advecting_wind, timestep, logspace=logspace )
            case(W3)
              ! Compute the flux using desired spatial reconstruction
              call invoke( setval_c( flux, 0.0_r_def ) )
              if ( advect_density ) then
                if ( shifted ) then
                  call flux_shifted_alg(flux, field_new, advecting_wind, logspace=logspace )
                else
                  call flux_alg(flux, field_new, advecting_wind, logspace=logspace )
                end if

                ! Compute: -div(F)
                call invoke( dg_matrix_vector_kernel_type(rhs, flux, div),       &
                             dg_matrix_vector_kernel_type(rk_rhs(stage), rhs,    &
                                                          mm_w3_inv),            &
                             inc_X_plus_bY( advection_inc, ak_adv(nstage, stage),&
                                            flux ) )
              else
                ! Compute the advective form increment, first the reconstructed tracer
                if ( shifted ) then
                  call flux_shifted_alg(flux, field_new, unit_wind, logspace=logspace)
                else
                  call flux_alg(flux, field_new, unit_wind, logspace=logspace)
                end if

                ! Remove unit_wind term from flux and
                ! Compute the advective update u.grad(f)
                call invoke( inc_X_divideby_Y(flux, unit_wind),                &
                             advective_wind_update_kernel_type(rhs,            &
                                                               flux,           &
                                                               advecting_wind),&
                             dg_matrix_vector_kernel_type(rk_rhs(stage), rhs,  &
                                                          mm_w3_inv) )
              end if
           case default
              call log_event("No advection rule for this function space", &
                             LOG_LEVEL_ERROR)
          end select

          ! Build rhs of Runge-Kutta scheme
          call invoke( setval_c(rhs, 0.0_r_def) )
          do s = 1, stage
            call invoke( inc_X_minus_bY(rhs, ak_adv(stage,s), rk_rhs(s)) )
          end do
          ! Update field: f = f^n + dt*rhs
          call invoke( setval_X(field_inc, rhs), &
                       aX_plus_Y( field_new, timestep, field_inc, field ) )

          ! Add increment from this stage to the advection increment
          if ( .not. advect_density) then
            call invoke( inc_X_minus_bY( advection_inc,         &
                                         ak_adv(nstage, stage), &
                                         rk_rhs(stage) ) )
          end if
        end do

        if ( associated( div ) ) nullify( div )
        if ( allocated( rk_rhs ) ) deallocate( rk_rhs )
        if ( allocated( ak_adv ) ) deallocate( ak_adv )

      case(scheme_cosmic_3D)
        ! Use Cosmic scheme to advect field
        select case(function_space)
          case(W3)
            call dep_pts_x%initialise( advecting_wind%get_function_space() )
            call dep_pts_y%initialise( advecting_wind%get_function_space() )
            call dep_pts_z%initialise( advecting_wind%get_function_space() )
            call wind_divergence%initialise( field%get_function_space() )

            cell_orientation => get_cell_orientation(mesh_id)
            detj_at_w2 => get_detj_at_w2(mesh_id)

            call calc_dep_pts( dep_pts_x, dep_pts_y, dep_pts_z, wind_divergence, &
                               wind_n, wind_np1, detj_at_w2, cell_orientation, dt )

            if ( advect_density ) then
              call cosmic_threed_transport_step( field, dep_pts_x, dep_pts_y, &
                                                 dep_pts_z, detj_at_w2,       &
                                                 cell_orientation, dt,        &
                                                 advection_inc )
            else
              call cosmic_threed_advective_step( field, dep_pts_x, dep_pts_y, &
                                                 dep_pts_z, detj_at_w2,       &
                                                 cell_orientation, dt,        &
                                                 advection_inc )
            end if
            call invoke( inc_a_times_X(-1.0_r_def, advection_inc) )
            nullify( detj_at_w2 )
          case default
            call log_event("Cosmic only implemented for W3 fields", &
                           LOG_LEVEL_ERROR)
        end select

      case default
        call log_event("Invalid transport scheme", &
                       LOG_LEVEL_ERROR)

      end select
    end if  !if splitting

  end subroutine advect_field

end module advection_alg_mod
