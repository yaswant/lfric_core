!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!> @brief   A General transport routine for the transport of any field using
!>          the main gungho transport routine "advect_field".
!> @details The routine "Advect_field" is used for transporting all variables
!>          in Gungho depending on space of the field-in and the various
!>          arguments. This is so we can have a consistent transport with the
!>          various apps.
!-----------------------------------------------------------------------------
module transport_general_mod

  implicit none

  private

  public :: transport_general

  contains

  !> @brief A general routine to transport a field, using a specified method,
  !>        a grid, and in conservative or advective forms.
  !> @param[in]     wind      3D advecting wind
  !> @param[in,out] field     field to be transported/advected
  !> @param[in] adv_scheme    Advection/transport scheme to be used
  !> @param[in] shifted_grid  True/False to specify if grid is shifted or not
  !> @param[in] conservative  True/False to specify if the transport problem is
  !>                          the conservative form (true) or advective form (false)

  subroutine transport_general(wind, field, adv_scheme, shifted_grid, conservative )

  use constants_mod,                 only: r_def, i_def, l_def, tiny_eps
  use field_mod,                     only: field_type
  use timer_mod,                     only: timer
  use io_config_mod,                 only: subroutine_timers
  use advection_alg_mod,             only: advect_field
  use timestepping_config_mod,       only: dt
  use function_space_mod,            only: function_space_type
  use transport_config_mod,          only: scheme_method_of_lines,     &
                                            cfl_mol_3d_stab
  use runtime_constants_mod,         only: get_detj_at_w2, w3inv_id,   &
                                            get_mass_matrix, get_div
  use operator_mod,                  only: operator_type
  use fs_continuity_mod,             only: W3, Wtheta
  use dg_matrix_vector_kernel_mod,   only: dg_matrix_vector_kernel_type
  use matrix_vector_kernel_mod,      only: matrix_vector_kernel_type

  implicit none

  type(field_type), intent(in)      :: wind
  type(field_type), intent(inout)   :: field
  integer(i_def),   intent(in)      :: adv_scheme
  logical(l_def),   intent(in)      :: conservative, shifted_grid

  type(function_space_type), pointer :: w2_fs => null()
  type(field_type),          pointer :: detj_at_w2 => null()
  type(field_type)                   :: comp_wind
  type(field_type)                   :: field_old, field_inc
  real(r_def)            :: dt_substep
  real(r_def)            :: cfl_min, cfl_max
  integer(i_def)         :: sub_step_count, mol_substeps
  integer(i_def)         :: function_space
  logical(l_def)         :: advect_density, si_advective_terms, &
                             shifted, density_predictor
  type(operator_type), pointer :: mm_w3_inv     => null(), &
                                   div           => null()
  type(field_type)             :: r_rho, mass_flux


  if ( subroutine_timers ) call timer('transport_general')

  function_space = field%which_function_space()
  call field_old%initialise( field%get_function_space() )
  call field_inc%initialise( field%get_function_space() )

  call invoke( name = "Set_temporary_fields_to_zero", &
               setval_c(field_old, 0.0_r_def),        &
               setval_c(field_inc, 0.0_r_def)         )

  advect_density = conservative
  shifted = shifted_grid
  si_advective_terms = .false.
  density_predictor = .false.
  mol_substeps  = 1_i_def
  dt_substep = dt

  if ( adv_scheme == scheme_method_of_lines ) then

    w2_fs =>  wind%get_function_space()
    call comp_wind%initialise( vector_space = w2_fs )
    detj_at_w2 => get_detj_at_w2()

    call invoke( X_divideby_Y(comp_wind, wind, detj_at_w2), &
                 inc_a_times_X(dt, comp_wind )              )
    call comp_wind%field_minmax(cfl_min, cfl_max)

    cfl_max = max(abs(cfl_max),abs(cfl_min))
    mol_substeps = int(cfl_max/(cfl_mol_3d_stab+tiny_eps),i_def) + 1_i_def
    dt_substep = dt/real(mol_substeps, r_def)

    if ( advect_density ) then

      call mass_flux%initialise( wind%get_function_space() )
      call r_rho%initialise( field%get_function_space() )
      mm_w3_inv => get_mass_matrix(w3inv_id)
      div       => get_div()

      do sub_step_count = 1, mol_substeps

         call field%copy_field(field_old)
         call advect_field(mass_flux, field, wind,                          &
                           scheme_method_of_lines, wind, wind,              &
                           advect_density, dt_substep, si_advective_terms,  &
                           shifted, density_predictor                       )

         call invoke( setval_c(r_rho, 0.0_r_def),                              &
                      matrix_vector_kernel_type(r_rho, mass_flux, div),        &
                      inc_a_times_X(-1.0_r_def, r_rho),                        &
                      dg_matrix_vector_kernel_type(field_inc,r_rho, mm_w3_inv),&
                      aX_plus_Y(field, dt_substep, field_inc, field_old)       )

      end do

     else

      do sub_step_count = 1, mol_substeps

         call field%copy_field(field_old)
         call advect_field(field_inc, field, wind,                          &
                           scheme_method_of_lines, wind, wind,              &
                           advect_density, dt_substep, si_advective_terms,  &
                           shifted, density_predictor                       )

         call invoke( aX_plus_Y(field, dt_substep, field_inc, field_old) )

       end do
      end if

  else

      call field%copy_field(field_old)
      call advect_field(field_inc, field, wind,                 &
                        adv_scheme, wind, wind,                 &
                        advect_density, dt, si_advective_terms, &
                        shifted, density_predictor              )

       call invoke( setval_c(field, 0.0_r_def),                 &
                     aX_plus_Y(field, dt, field_inc, field_old) )

   end if

   if ( adv_scheme == scheme_method_of_lines ) then
      nullify( w2_fs, detj_at_w2 )
      if ( advect_density ) then
         nullify( mm_w3_inv, div )
      end if
   end if

   if ( subroutine_timers ) call timer('transport_general')

  end subroutine transport_general

end module transport_general_mod
