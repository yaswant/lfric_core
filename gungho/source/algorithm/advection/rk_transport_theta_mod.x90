!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief To solve the advection equation of a theta-type tracer using a
!>        split-approach with a semi-Lagrangian in the vertical and a
!>        multi-step RK method in the horizontal.
!>
module rk_transport_theta_mod

  use constants_mod,                     only: r_def, i_def, tiny_eps
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_ERROR
  use fs_continuity_mod,                 only: W1, W2, Wtheta
  ! Configuration options
  use finite_element_config_mod,         only: element_order
  use timestepping_config_mod,           only: dt
  use runge_kutta_init_mod,              only: num_rk_stage, ak
  use runtime_constants_mod,             only: get_mass_matrix,                &
                                               get_mass_matrix_diagonal,       &
                                               get_inverse_lumped_mass_matrix, &
                                               get_qr,                         &
                                               w2_id, w3_id, w3inv_id,         &
                                               wt_id, theta_space_id,          &
                                               get_coordinates_xyz,            &
                                               get_detj_at_w2

  use transport_config_mod,              only: operators,                      &
                                               fv_flux_order,                  &
                                               fv_advective_order,             &
                                               operators_fv,                   &
                                               operators_fem,                  &
                                               oned_reconstruction,            &
                                               consistent_metric,              &
                                               theta_splitting_vh,             &
                                               theta_splitting_hv,             &
                                               theta_splitting_strang,         &
                                               cfl_mol_2d_stab

  ! PsyKAl-lite kernels
  use psykal_lite_mol_mod,               only: psykal_lite_mol_adv_init,       &
                                               invoke_poly1d_adv_recon,        &
                                               invoke_poly1d_advective_coeffs, &
                                               invoke_poly2d_adv_recon,        &
                                               invoke_poly2d_advective_coeffs, &
                                               invoke_poly1d_vert_adv_coeffs,  &
                                               invoke_poly1d_vert_adv

  ! PsyKAl PSYClone kernels
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use poly_advective_kernel_mod,         only: poly_advective_kernel_type
  use consistent_wind_kernel_mod,        only: consistent_wind_kernel_type

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use operator_mod,                      only: operator_type

  ! Algorithms
  use mass_matrix_solver_alg_mod,        only: mass_matrix_solver_alg
  ! Log
  use io_config_mod,                     only: subroutine_timers
  use timer_mod,                         only: timer
  use advective_update_alg_mod,          only: adv_coeffs, vert_adv_coeffs, &
                                               advective_av,                &
                                               advective_av_chi3,           &
                                               chi3_at_wt,                  &
                                               nfaces_re_h, nfaces_re_v,    &
                                               advective_stencil_extent,    &
                                               advective2d_stencil_size

  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type )              :: theta, theta_n, r_theta, theta_inc
  type( field_type ), allocatable :: rt_prediction(:)
  type( field_type )              :: mt_lumped
  type( field_type )              :: theta0
  type( field_type )              :: ones
  type( field_type )              :: theta_av
  type( field_type )              :: theta_metrics

  ! Needed for nonuniform FV operators

  integer(i_def) :: nfaces_h, nfaces_v

  public :: rk_transport_theta_step
  public :: rk_transport_theta_init
  public :: rk_transport_theta_final

contains

  !===========================================================================
  !> @brief A Runge-Kutta time-discretisation of the advection equation.
  !> @details An algorithm for timstepping the advection equation using the
  !>          Runge-Kutta method.
  !> @param[in]     u 3D wind field
  !> @param[in,out] theta A theta/tracer type field
  !> @param[in]     dts Local timestep
  !===========================================================================

  subroutine rk_transport_theta_step( u, theta, dts)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( in    ) :: u
    type( field_type ), intent( inout ) :: theta
    real( r_def),        intent( in   ) :: dts

    ! The quadrature object
    type( quadrature_xyoz_type ), pointer :: qr => null()
    ! Coordinate fields
    type( field_type ), pointer         :: chi_xyz(:) => null()
    type( field_type )                  :: theta_n

    integer(i_def) :: stage, st

    ! Temps for retrieving objects back from runtime constants
    type(operator_type), pointer :: mm_w3_inv => null()
    type(field_type), pointer    :: mt_lumped_inv => null()
    type(field_type)             :: consistent_wind


    mm_w3_inv => get_mass_matrix(w3inv_id)
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)

    if ( subroutine_timers ) call timer('rk_transport_theta_alg')

    qr => get_qr()
    chi_xyz => get_coordinates_xyz()
    call theta_n%initialise( vector_space = theta%get_function_space() )
    call theta%copy_field(theta_n)

    ! Runge-Kutta algorithm
    do stage = 1,num_rk_stage
      ! Compute advection terms
      select case(operators)
        case(operators_fv)
          ! Use polynomial reconstruction
          call invoke( setval_c(theta_av, 0.0_r_def) )
          if ( oned_reconstruction ) then
            call invoke_poly1d_adv_recon( theta_av, u, theta, adv_coeffs,               &
                                          fv_advective_order, advective_stencil_extent, &
                                          nfaces_h                                      )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) then
              call invoke( setval_c(advective_av_chi3, 0.0_r_def) )
              call invoke_poly1d_adv_recon( advective_av_chi3, u,                         &
                                            chi3_at_wt, adv_coeffs,                       &
                                            fv_advective_order, advective_stencil_extent, &
                                            nfaces_h                                      )
            end if
          else
            ! Use 2d flux code
            call invoke_poly2d_adv_recon( theta_av, u, theta, adv_coeffs,               &
                                          fv_advective_order, advective2d_stencil_size, &
                                          nfaces_h                                      )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) then
              call invoke( setval_c(advective_av_chi3, 0.0_r_def) )
              call invoke_poly2d_adv_recon( advective_av_chi3, u,                         &
                                            chi3_at_wt, adv_coeffs,                       &
                                            fv_advective_order, advective2d_stencil_size, &
                                            nfaces_h                                      )
            end if
          end if
          call invoke( poly_advective_kernel_type( rt_prediction(stage), u, theta_av) )

          ! Compute vertical components of advective update
          call u%copy_field(consistent_wind)
          if ( consistent_metric ) then
            call invoke( poly_advective_kernel_type(theta_metrics, u, advective_av_chi3), &
            ! Modify advecting wind
                       consistent_wind_kernel_type(consistent_wind, u, theta_metrics, chi_xyz) )
          end if
          call invoke_poly1d_vert_adv( rt_prediction(stage), consistent_wind, theta,  &
                                       vert_adv_coeffs, fv_advective_order, nfaces_v  )
        case(operators_fem)
          ! Use FEM projection
          ! Initialise fields
          call invoke( name = "FEM advection of theta",                       &
                       setval_c(rt_prediction(stage), 0.0_r_def),             &
          ! Theta advection
                       rtheta_kernel_type( rt_prediction(stage), theta, u, qr) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select

      call invoke( setval_c(r_theta, 0.0_r_def) )

      do st = 1, stage
        call invoke( inc_X_plus_bY(r_theta, ak(stage,st), rt_prediction(st)) )
      end do

      ! Theta
      select case(operators)
        case(operators_fv) ! theta in Wtheta
          call invoke( inc_X_divideby_Y(r_theta, mt_lumped),    &
                       X_minus_bY(theta, theta_n, dts, r_theta) )
        case(operators_fem)
          call mass_matrix_solver_alg( theta_inc, r_theta)
          call invoke( X_minus_bY(theta, theta_n, dts, theta_inc) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select
    end do

    nullify( mm_w3_inv, mt_lumped_inv, chi_xyz, qr )
    if ( subroutine_timers ) call timer('rk_transport_theta_alg')

  end subroutine rk_transport_theta_step

  !===========================================================================
  !> @brief Init routine for RK transport timestepping algorithm.
  !> @param[in] Mesh_id Mesh id of mesh on which the model runs
  !===========================================================================

  subroutine rk_transport_theta_init( mesh_id )
    use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
    use sample_field_kernel_mod,           only: sample_field_kernel_type
    use quadrature_edge_mod,               only: quadrature_edge_type
    use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type
    use quadrature_rule_gauss_lobatto_mod,  &
                                           only: quadrature_rule_gauss_lobatto_type
    use multiplicity_kernel_mod,           only: multiplicity_kernel_type
    use reference_element_mod,             only: reference_element_type
    use mesh_mod,                          only: mesh_type

    implicit none

    ! Mesh id
    integer(i_def),  intent(in)        :: mesh_id

    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: theta_fs => null()

    ! Timestepping variables
    integer(i_def)               :: stage
    type(operator_type), pointer :: mm_wt => null()

    type( field_type ), pointer :: chi_xyz(:) => null()
    type( field_type ), pointer :: md_wt => null()
    type( field_type )          :: wt_multiplicity

    type( quadrature_xyoz_type )           :: qr
    type( quadrature_edge_type )           :: qre
    type( quadrature_rule_gaussian_type )  :: gaussian_quadrature
    type( quadrature_rule_gauss_lobatto_type )  :: gauss_lobatto_quadrature
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type),               pointer :: mesh => null()
    integer(i_def)                         :: face_quad_order
    integer(i_def)                         :: nqp_xy, nqp_z

    if ( subroutine_timers ) call timer('rk_transport_theta_init')

    allocate ( rt_prediction(num_rk_stage) )

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    u_fs    => function_space_collection%get_fs( mesh_id, element_order, W2      )
    theta_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )

    call theta%initialise( vector_space = theta_fs )
    call theta0%initialise( vector_space = theta_fs )
    call theta_n%initialise( vector_space = theta_fs )
    call r_theta%initialise( vector_space = theta_fs )
    call theta_inc%initialise( vector_space = theta_fs )

    do stage = 1,num_rk_stage
      call rt_prediction(stage)%initialise( vector_space = theta_fs )
    end do

    nfaces_h = nfaces_re_h
    nfaces_v = nfaces_re_v

    if ( operators == operators_fv ) then
      if ( element_order == 0 ) then
        ! Get topology information from the reference element
        mesh              => theta_n%get_mesh()
        reference_element => mesh%get_reference_element()
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high order elements", LOG_LEVEL_ERROR )
      end if
      mm_wt => get_mass_matrix(wt_id)
      call ones%initialise( vector_space = theta_fs )
      call mt_lumped%initialise( vector_space = theta_fs )
      call invoke( name = "Compute mt_lumped",     &
                   setval_c(ones,      1.0_r_def), &
                   setval_c(mt_lumped, 0.0_r_def), &
                   matrix_vector_kernel_type(mt_lumped, ones, mm_wt) )

      chi_xyz => get_coordinates_xyz()
      nqp_xy = fv_advective_order+3_i_def
      nqp_z = 2
      if ( oned_reconstruction ) then
        face_quad_order = 1_i_def
      else
        face_quad_order = fv_flux_order+1_i_def
      end if
      qr = quadrature_xyoz_type(nqp_xy, nqp_xy, nqp_z, gauss_lobatto_quadrature)
      qre = quadrature_edge_type(face_quad_order, .true., .false.,      &
                                 reference_element, gaussian_quadrature )
      md_wt => get_mass_matrix_diagonal(wt_id)
      call theta_av%initialise( vector_space =                         &
          function_space_collection%get_fs(mesh_id, element_order, W1) )
      if ( oned_reconstruction ) then
        call invoke_poly1d_advective_coeffs( adv_coeffs, md_wt, chi_xyz, qr, qre, &
                                             fv_advective_order,                  &
                                             advective_stencil_extent, nfaces_h   )
      else
        call invoke_poly2d_advective_coeffs( adv_coeffs, md_wt, chi_xyz, qr, &
                                             qre, fv_advective_order,        &
                                             advective2d_stencil_size,       &
                                             nfaces_h                        )
      end if
      call log_event( "Gungho: computing vertical advective coeffs", LOG_LEVEL_INFO )
      call invoke_poly1d_vert_adv_coeffs( vert_adv_coeffs, chi_xyz,    &
                                          fv_advective_order, nfaces_v )

      if ( consistent_metric ) then
        call advective_av_chi3%initialise(vector_space = theta_av%get_function_space() )
        call theta_metrics%initialise(vector_space = theta_fs )
        call chi3_at_wt%initialise(vector_space = theta_fs )
        call wt_multiplicity%initialise(vector_space = theta_fs )
        call invoke( setval_c(wt_multiplicity, 0.0_r_def),                              &
                     multiplicity_kernel_type(wt_multiplicity),                         &
                     sample_field_kernel_type( chi3_at_wt, wt_multiplicity, chi_xyz(3)) )
      end if

    else
      call invoke( setval_c(ones, 1.0_r_def) )
    end if

    ! Store initial values for computing errors

    call theta%copy_field(theta0)

    nullify( mm_wt, md_wt, chi_xyz, u_fs, theta_fs, mesh, reference_element )

    if ( subroutine_timers ) call timer('rk_transport_theta_init')

  end subroutine rk_transport_theta_init

  !===========================================================================
  !> @@brief Deallocate arrays used in transport.
  !===========================================================================
  subroutine rk_transport_theta_final()

    implicit none

    if (allocated(adv_coeffs)     )     deallocate(adv_coeffs     )
    if (allocated(vert_adv_coeffs))     deallocate(vert_adv_coeffs)
    if (allocated(rt_prediction)  )     deallocate(rt_prediction  )

  end subroutine rk_transport_theta_final

end module rk_transport_theta_mod
