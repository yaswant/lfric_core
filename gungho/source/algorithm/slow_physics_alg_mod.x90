!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Calls to the slow physics schemes
module slow_physics_alg_mod

  use constants_mod,             only: i_def,r_def
  use log_mod,                   only: log_event,         &
                                       LOG_LEVEL_WARNING, LOG_LEVEL_INFO, &
                                       LOG_LEVEL_ERROR
  use physics_config_mod,        only: heldsuarez_thermo_placement, &
                                       heldsuarez_wind_placement, &
                                       boundary_layer_placement,  &
                                       convection_placement, &
                                       microphysics_placement
  ! PsyKAl PSYClone kernels
  use held_suarez_fv_kernel_mod,      only: held_suarez_fv_kernel_type
  use held_suarez_fv_wind_kernel_mod, only: held_suarez_fv_wind_kernel_type
  
  ! Derived Types
  use field_mod,                 only: field_type
  use field_collection_mod,      only: field_collection_type

  ! Moisture species
  use mr_indices_mod,            only: nummr

  use fs_continuity_mod,         only: W2

  use runtime_constants_mod,     only: get_rmultiplicity

  use field_bundle_mod,          only: clone_bundle, set_bundle_scalar,  &
                                       add_bundle

  use formulation_config_mod,    only: use_moisture

#ifdef UM_PHYSICS
  ! UM Microphysics scheme
  use mphys_alg_mod,  only: mphys_alg_step
#endif

  implicit none

contains

  !> @details Collection of procedures for subgrid physics that act
  !>          before the outer loop of the solver
  !> @param[in,out] du             Increment to wind field 
  !> @param[in,out] dtheta         Increment to theta field 
  !> @param[in]     theta          Theta field 
  !> @param[in]     rho            Rho on w3 space
  !> @param[in]     exner          Exner pressure on w3 space
  !> @param[in]     mr_n           Mixing ratios at start of timestep
  !> @param[in,out] mr             Mixing ratios to be updated
  !> @param[in]     derived_fields Group of derived fields
  !> @param[in,out] cloud_fields   Group of cloud fields
  !> @param[in,out] twod_fields    Group of 2D fields
  !> @param[in,out] physics_incs   Group of physics increments
  !> @param[in]     height_w3      Height in w3
  !> @param[in]     height_wth     Height in wth
  !> @param[in]     chi            Coordinate array
  subroutine slow_physics(du, dtheta, theta, rho, exner, mr_n, mr,   &
                          derived_fields, cloud_fields, twod_fields, &
                          physics_incs, height_w3, height_wth,  chi)

    implicit none

    ! Fields    
    type( field_type ), intent( inout ) :: du, dtheta
    type( field_type ), intent( inout ) :: mr(nummr) ! To be modified by physics
    type( field_type ), intent( in )    :: theta, rho, exner

    ! Field bundles
    type( field_type ), intent( in )    :: mr_n(nummr) ! Start of timestep
                                                       ! Do not alter

    ! Field groups
    type( field_collection_type ), intent(inout) :: derived_fields
    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: twod_fields
    type( field_collection_type ), intent(inout) :: physics_incs
    
    ! Coordinate fields
    type( field_type ), intent( in )    :: height_w3, height_wth
    type( field_type ), intent( in )    :: chi(3)

    ! Local fields (should be created at initialization, but done here for the time being)
    type( field_type ) :: dtheta_hs
    type( field_type ) :: du_hs
    type( field_type ) :: dmr_mphys(nummr)
    type( field_type ) :: dtheta_mphys

    type(field_type),   pointer  :: w2_rmultiplicity => null() ! 1/multiplicity of w2

    ! Temporary field to unpack from field collection
    type( field_type ), pointer :: u_physics => null()
    type( field_type ), pointer :: exner_in_wth => null()

    !Flags to indicate completed actions
    logical :: held_suarez_thermo_done ! Flag to indicate that held_suarez has been calculated
    logical :: held_suarez_wind_done ! Flag to indicate that held_suarez has been calculated
    logical :: microphysics_done ! Flag to indicate that microphysics has been calculated

    w2_rmultiplicity => get_rmultiplicity( W2 ) ! 1/multiplicity of w2

    held_suarez_thermo_done=.false.
    held_suarez_wind_done=.false.
    microphysics_done=.false.

    ! Some unpacking
    u_physics => derived_fields%get_field('u_physics')
    exner_in_wth => derived_fields%get_field('exner_in_wth')

    if (heldsuarez_thermo_placement < 0)then
      dtheta_hs = field_type( vector_space = theta%get_function_space() )
      call invoke( setval_c(dtheta_hs, 0.0_r_def) )
      call log_event( &
         'slow_physics: Running Held-Suarez theta forcing', &
         LOG_LEVEL_INFO )
      call invoke(held_suarez_fv_kernel_type(dtheta_hs, theta, exner_in_wth, chi))
      held_suarez_thermo_done=.true. ! We've done it, so need to collect this term later on
    end if

    if (heldsuarez_wind_placement < 0)then
      du_hs = field_type( vector_space = u_physics%get_function_space() )
      call invoke( setval_c(du_hs, 0.0_r_def) )
      call log_event( &
         'slow_physics: Running Held-Suarez wind forcing', &
         LOG_LEVEL_INFO )
      call invoke(held_suarez_fv_wind_kernel_type(du_hs, u_physics, w2_rmultiplicity, &
         exner_in_wth, chi))
      held_suarez_wind_done=.true. ! We've done it, so need to collect this term later on
    end if

#ifdef UM_PHYSICS
    if (microphysics_placement < 0) then
      if (use_moisture) then
        ! Algorithm which calls the UM microphysics scheme
        call log_event( 'slow_physics: Running Microphysics', LOG_LEVEL_INFO )

        call clone_bundle(mr, dmr_mphys, nummr)
        call set_bundle_scalar(0.0_r_def, dmr_mphys, nummr)
    
        dtheta_mphys = field_type( vector_space = theta%get_function_space() )
        call invoke( setval_c(dtheta_mphys, 0.0_r_def) )

        call mphys_alg_step( mr_n, theta,  exner, height_w3, height_wth,       &
                             derived_fields, cloud_fields, dmr_mphys,          &
                             dtheta_mphys, physics_incs )

        ! N.B. Call to microphysics passes in mr_n, which is intent(in) and
        !      represents the start of the timestep value of the mixing 
        !      ratios. The equivalent variable mr is just a copy of this and
        !      is passed into slow physics as intent(inout). Variable mr is
        !      then updated by microphysics and used to generate the slow
        !      physics increment.

        microphysics_done=.true. ! Microphysics completed

      else ! not use moisture
        ! throw an error: this is just plain daft and user has made a mistake.
        call log_event( &
        'slow_physics: Microphysics cannot be run without moisture. Please correct', &
         LOG_LEVEL_ERROR )
      end if ! use moisture

      if (microphysics_done) then
        call invoke(inc_X_plus_Y(dtheta, dtheta_mphys))
        call add_bundle(dmr_mphys, mr, mr, nummr)
      end if

    end if   ! microphysics placement > 0
#endif

    if (boundary_layer_placement < 0) then       
      call log_event( &
         'slow_physics: Boundary layer is not currently available in slow physics.', &
         LOG_LEVEL_ERROR )
    end if

    if (convection_placement < 0) then
      call log_event( &
         'slow_physics: Convection is not currently available in slow physics.', &
         LOG_LEVEL_ERROR )
    end if

    !=====================================
    ! collect individual terms in parallel
    !=====================================
    if (held_suarez_thermo_done)then
      call invoke(inc_X_plus_Y(dtheta, dtheta_hs))
    end if

    if (held_suarez_wind_done)then
      call invoke(inc_X_plus_Y(du, du_hs))
    end if

    call dtheta%log_minmax(LOG_LEVEL_INFO, 'slow physics: dtheta' )
    call du%log_minmax(LOG_LEVEL_INFO, 'slow physics: du' )

    nullify( w2_rmultiplicity )

  end subroutine slow_physics

end module slow_physics_alg_mod
