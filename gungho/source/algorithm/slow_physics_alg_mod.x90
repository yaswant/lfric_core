!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Calls to the slow physics schemes
module slow_physics_alg_mod

  use section_choice_config_mod, only: microphysics,       &
                                       microphysics_um,    &
                                       radiation,          &
                                       radiation_socrates, &
                                       spectral_gwd,       &
                                       spectral_gwd_um

  use constants_mod,    only: i_def,r_def
  use log_mod,          only: log_event,                         &
                              LOG_LEVEL_WARNING, LOG_LEVEL_INFO, &
                              LOG_LEVEL_ERROR

  use physics_config_mod, only: heldsuarez_thermo_placement, &
                                heldsuarez_wind_placement,   &
                                microphysics_placement,      &
                                radiation_placement,         &
                                spectral_gwd_placement,      &
                                microphysics_placement_slow, &
                                radiation_placement_slow,    &
                                spectral_gwd_placement_slow

  ! PsyKAl PSYClone kernels
  use held_suarez_fv_kernel_mod,      only: held_suarez_fv_kernel_type
  use held_suarez_fv_wind_kernel_mod, only: held_suarez_fv_wind_kernel_type

  ! Derived Types
  use field_mod,                 only: field_type
  use field_collection_mod,      only: field_collection_type
  use function_space_collection_mod, only: function_space_collection
  use function_space_mod,            only: function_space_type

  ! Moisture species
  use mr_indices_mod,            only: nummr

  use fs_continuity_mod,         only: W2, W3

  use runtime_constants_mod,     only: get_rmultiplicity

  use field_bundle_mod,          only: clone_bundle, set_bundle_scalar,  &
                                       add_bundle

  use formulation_config_mod,    only: use_moisture

#ifdef UM_PHYSICS
  use mphys_alg_mod,             only: mphys_alg_step
  use illuminate_alg_mod,        only: illuminate_alg_step
  use rad_tile_alg_mod,          only: rad_tile_alg_step
  use radiation_alg_mod,         only: radiation_alg_step
  use radiation_config_mod,      only: l_planet_grey_surface
  use spectral_gwd_alg_mod,      only: spectral_gwd_alg_step
#endif

  implicit none

contains

  !> @details Collection of procedures for subgrid physics that act
  !>          before the outer loop of the solver
  !> @param[in,out] du                Increment to wind field
  !> @param[in,out] dtheta            Increment to theta field
  !> @param[in]     theta             Theta field
  !> @param[in]     rho               Rho on w3 space
  !> @param[in]     exner             Exner pressure on w3 space
  !> @param[in]     mr_n              Mixing ratios at start of timestep
  !> @param[in,out] mr                Mixing ratios to be updated
  !> @param[in]     derived_fields    Group of derived fields
  !> @param[in,out] cloud_fields      Group of cloud fields
  !> @param[in,out] twod_fields       Group of 2D fields
  !> @param[in,out] physics_incs      Group of physics increments
  !> @param[in,out] jules_ancils      Ancillary fields for Jules
  !> @param[in,out] jules_prognostics Prognostic fields for Jules
  !> @param[in]     height_w3         Height in w3
  !> @param[in]     height_wth        Height in wth
  !> @param[in]     chi               Coordinate array
  !> @param[in]     twod_mesh_id      Identifier given to the current 2d mesh
  subroutine slow_physics(du, dtheta, theta, rho, exner, mr_n, mr,       &
                          derived_fields, cloud_fields, twod_fields,     &
                          physics_incs, jules_ancils, jules_prognostics, &
                          height_w3, height_wth, chi, twod_mesh_id)

    implicit none

    ! Fields
    type( field_type ), intent( inout ) :: du, dtheta
    type( field_type ), intent( inout ) :: mr(nummr) ! To be modified by physics
    type( field_type ), intent( in )    :: theta, rho, exner

    ! Field bundles
    type( field_type ), intent( in )    :: mr_n(nummr) ! Start of timestep
                                                       ! Do not alter

    ! Field groups
    type( field_collection_type ), intent(inout) :: derived_fields
    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: twod_fields
    type( field_collection_type ), intent(inout) :: physics_incs

    ! Surface fields
    type( field_collection_type ), intent(inout) :: jules_ancils
    type( field_collection_type ), intent(inout) :: jules_prognostics

    ! Coordinate fields
    type( field_type ), intent( in )    :: height_w3, height_wth
    type( field_type ), intent( in )    :: chi(3)

    integer, intent(in) :: twod_mesh_id

    ! Local fields (should be created at initialization, but done here for the time being)
    type( field_type ) :: dtheta_hs, dtheta_rad
    type( field_type ) :: du_hs
    type( field_type ) :: dmr_mphys(nummr)
    type( field_type ) :: dtheta_mphys
    type( field_type ) :: du_tot_spectral_gwd, dtheta_spectral_gwd
    type( field_type ) :: tile_lw_albedo
    type( field_type ) :: tile_sw_diffuse_albedo
    type( field_type ) :: tile_sw_direct_albedo

    type(field_type),   pointer  :: w2_rmultiplicity => null() ! 1/multiplicity of w2

    ! pointers to vector spaces
    type(function_space_type), pointer :: vector_space => null()

    ! Temporary field to unpack from field collection
    type( field_type ), pointer :: u_physics => null()
    type( field_type ), pointer :: exner_in_wth => null()

    ! Each column of a higher-order discontinuous field will be used to
    ! represent multi-dimensional quantities. Set parameters for the order
    ! required:
    integer(i_def) :: alb_order = 4 ! Enough space for 125 spectral tiles
                                    ! (spectral bands * surface tiles)

    !Flags to indicate completed actions
    logical :: held_suarez_thermo_done ! Flag to indicate that held_suarez has been calculated
    logical :: held_suarez_wind_done ! Flag to indicate that held_suarez has been calculated
    logical :: microphysics_done ! Flag to indicate that microphysics has been calculated
    logical :: radiation_done ! Flag to indicate that radiation has been calculated
    logical :: spectral_gwd_done ! Flag to indicate that spectral gravity wave drag has been calculated

    w2_rmultiplicity => get_rmultiplicity( W2 ) ! 1/multiplicity of w2

    held_suarez_thermo_done=.false.
    held_suarez_wind_done=.false.
    microphysics_done=.false.
    radiation_done=.false.
    spectral_gwd_done=.false.

    ! Some unpacking
    u_physics => derived_fields%get_field('u_physics')
    exner_in_wth => derived_fields%get_field('exner_in_wth')

    if (heldsuarez_thermo_placement < 0)then
      dtheta_hs = field_type( vector_space = theta%get_function_space() )
      call invoke( setval_c(dtheta_hs, 0.0_r_def) )
      call log_event( &
         'slow_physics: Running Held-Suarez theta forcing', &
         LOG_LEVEL_INFO )
      call invoke(held_suarez_fv_kernel_type(dtheta_hs, theta, exner_in_wth, chi))
      held_suarez_thermo_done=.true. ! We've done it, so need to collect this term later on
    end if

    if (heldsuarez_wind_placement < 0)then
      du_hs = field_type( vector_space = u_physics%get_function_space() )
      call invoke( setval_c(du_hs, 0.0_r_def) )
      call log_event( &
         'slow_physics: Running Held-Suarez wind forcing', &
         LOG_LEVEL_INFO )
      call invoke(held_suarez_fv_wind_kernel_type(du_hs, u_physics, w2_rmultiplicity, &
         exner_in_wth, chi))
      held_suarez_wind_done=.true. ! We've done it, so need to collect this term later on
    end if

#ifdef UM_PHYSICS
    if ( microphysics == microphysics_um .and. &
         microphysics_placement == microphysics_placement_slow) then
      if (use_moisture) then
        ! Algorithm which calls the UM microphysics scheme
        call log_event( 'slow_physics: Running Microphysics', LOG_LEVEL_INFO )

        call clone_bundle(mr, dmr_mphys, nummr)
        call set_bundle_scalar(0.0_r_def, dmr_mphys, nummr)

        dtheta_mphys = field_type( vector_space = theta%get_function_space() )
        call invoke( setval_c(dtheta_mphys, 0.0_r_def) )

        call mphys_alg_step( mr_n, theta,  exner, height_w3, height_wth,   &
                             derived_fields, cloud_fields, twod_fields,    &
                             dmr_mphys, dtheta_mphys, physics_incs )

        ! N.B. Call to microphysics passes in mr_n, which is intent(in) and
        !      represents the start of the timestep value of the mixing
        !      ratios. The equivalent variable mr is just a copy of this and
        !      is passed into slow physics as intent(inout). Variable mr is
        !      then updated by microphysics and used to generate the slow
        !      physics increment.

        microphysics_done=.true. ! Microphysics completed

      else ! not use moisture
        ! throw an error: this is just plain daft and user has made a mistake.
        call log_event( &
        'slow_physics: Microphysics cannot be run without moisture. Please correct', &
         LOG_LEVEL_ERROR )
      end if ! use moisture

    end if   ! microphysics placement slow

    if (radiation == radiation_socrates .and. &
        radiation_placement == radiation_placement_slow) then
      call log_event( 'slow_physics: Running Radiation', LOG_LEVEL_INFO )
      call illuminate_alg_step(twod_fields, chi)

      ! Use a temporary treatment for multi-dimensional fields using
      ! higher-order fields
      vector_space=>function_space_collection%get_fs(twod_mesh_id,alb_order,W3)
      tile_sw_direct_albedo  = field_type(vector_space)
      tile_sw_diffuse_albedo = field_type(vector_space)
      tile_lw_albedo         = field_type(vector_space)
      if (.not.l_planet_grey_surface) then
        call rad_tile_alg_step(tile_sw_direct_albedo, tile_sw_diffuse_albedo,  &
                               tile_lw_albedo, jules_ancils, jules_prognostics,&
                               derived_fields, twod_fields, height_w3)
      end if

      dtheta_rad = field_type( vector_space = theta%get_function_space() )
      call radiation_alg_step(dtheta_rad, theta, exner, mr_n,                &
                              jules_ancils, jules_prognostics,               &
                              derived_fields, cloud_fields, twod_fields,     &
                              physics_incs, height_w3, height_wth,           &
                              tile_sw_direct_albedo, tile_sw_diffuse_albedo, &
                              tile_lw_albedo)
      radiation_done=.true.
      call dtheta_rad%log_minmax(LOG_LEVEL_INFO, 'slow physics: dtheta_rad')
    end if

    ! Algorithm which calls the UM spectral gravity wave drag scheme
    if (spectral_gwd == spectral_gwd_um .and. &
        spectral_gwd_placement == spectral_gwd_placement_slow) then
      call log_event( 'slow_physics: Running spectral gravity wave drag', LOG_LEVEL_INFO )
      ! copy field properties
      call du%copy_field_properties(du_tot_spectral_gwd)
      call dtheta%copy_field_properties(dtheta_spectral_gwd)
      call spectral_gwd_alg_step(du_tot_spectral_gwd, dtheta_spectral_gwd, derived_fields, twod_fields,      &
                             theta, height_w3, height_wth)
      spectral_gwd_done=.true.
    end if
#endif

    !=====================================
    ! collect individual terms in parallel
    !=====================================
    if (held_suarez_thermo_done)then
      call invoke(inc_X_plus_Y(dtheta, dtheta_hs))
    end if

    if (held_suarez_wind_done)then
      call invoke(inc_X_plus_Y(du, du_hs))
    end if

    if (microphysics_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_mphys))
      call add_bundle(dmr_mphys, mr, mr, nummr)
    end if

    if (radiation_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_rad))
    end if

    if (spectral_gwd_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_spectral_gwd))
    end if

    call dtheta%log_minmax(LOG_LEVEL_INFO, 'slow physics: dtheta' )
    call du%log_minmax(LOG_LEVEL_INFO, 'slow physics: du' )

    nullify( w2_rmultiplicity )

  end subroutine slow_physics

end module slow_physics_alg_mod
