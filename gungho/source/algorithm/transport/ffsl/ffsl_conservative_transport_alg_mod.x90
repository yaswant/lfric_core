!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief   Algorithms for 2D and 3D FFSL conservative transport scheme step.
!> @details The algorithms solve the 2D or 3D conservative transport equation
!!          \f$\frac{\partial \rho}{\partial t} + \nabla \cdot (\mathbf{u} \rho) = 0)\f$,
!!          using the flux-form semi-Lagrangian (FFSL) transport scheme and a
!!          choice of splitting methods. The output increment is
!!          \f$\nabla \cdot (\mathbf{u} \rho)\f$
!!          and so the transport equation can be updated as
!!          \f$rho^{n+1} = rho^{n} - \Delta{t}\times \mbox{increment}\f$.
module ffsl_conservative_transport_alg_mod

  ! Constants and types
  use constants_mod,          only: r_tran, i_def, l_def
  use field_mod,              only: field_type
  use r_tran_field_mod,       only: r_tran_field_type
  use function_space_mod,     only: function_space_type
  use timer_mod,              only: timer
  use flux_direction_mod,     only: x_direction, y_direction
  use log_mod,                only: log_event, &
                                    LOG_LEVEL_ERROR
  ! Algorithms
  use ffsl_1d_advect_alg_mod, only: ffsl_1d_advect_vert
  use ffsl_2d_advect_alg_mod, only: ffsl_2d_advect_first, &
                                    ffsl_2d_advect_final
  use ffsl_1d_flux_alg_mod,   only: ffsl_1d_flux_vert
  use ffsl_2d_flux_alg_mod,   only: ffsl_2d_flux_final
  use ffsl_2d_advect_then_flux_alg_mod, &
                              only: ffsl_2d_advect_then_flux_final

  ! Kernels
  use combine_w2_field_kernel_mod, only: combine_w2_field_kernel_type

  ! Configuration options
  use io_config_mod,          only: subroutine_timers
  use subgrid_config_mod,     only: inner_order, &
                                    outer_order

  implicit none

  private

  public :: ffsl_conservative_transport_alg
  public :: ffsl_conservative_horizontal_alg

contains


  !> @brief   Algorithm for 3D FFSL conservative transport scheme step.
  !> @details The algorithm solves the 3D conservative transport equation,
  !!          giving increment = div(u field). One-dimensional flux differences
  !!          denoted F, G, H (and advective differences, f, g, h) are computed
  !!          and used with the chosen option for splitting. The transport equation
  !!          can be updated as field_np1 = field_n - dt*increment.
  !> @param[in]     field             Transported field
  !> @param[in]     dep_pts_x         Departure points in x direction
  !> @param[in]     dep_pts_y         Departure points in y direction
  !> @param[in]     dep_pts_z         Departure points in z direction
  !> @param[in]     detj_at_w2h       Det(J) at W2h dofs
  !> @param[in]     detj_at_w2v       Det(J) at W2v dofs
  !> @param[in]     panel_id          Panel ID of the cells
  !> @param[in]     dt                Time step
  !> @param[in]     log_space         Switch to use natural logarithmic space
  !!                                  for edge interpolation
  !> @param[in]     hori_monotone     Horizontal monotone option for FFSL
  !> @param[in]     vert_monotone     Vertical monotone option for FFSL
  !> @param[in]     reversible        Vertical reversibility option for FFSL
  !> @param[in,out] mass_flux         Mass flux
  !> @param[in,out] increment         Conservative transport increment
  subroutine ffsl_conservative_transport_alg( field,         &
                                              dep_pts_x,     &
                                              dep_pts_y,     &
                                              dep_pts_z,     &
                                              detj_at_w2h,   &
                                              detj_at_w2v,   &
                                              panel_id,      &
                                              dt,            &
                                              log_space,     &
                                              hori_monotone, &
                                              vert_monotone, &
                                              reversible,    &
                                              mass_flux,     &
                                              increment )

    implicit none

    type(r_tran_field_type), intent(in)    :: field
    type(r_tran_field_type), intent(in)    :: dep_pts_x
    type(r_tran_field_type), intent(in)    :: dep_pts_y
    type(r_tran_field_type), intent(in)    :: dep_pts_z
    type(r_tran_field_type), intent(in)    :: detj_at_w2h
    type(r_tran_field_type), intent(in)    :: detj_at_w2v
    type(field_type),        intent(in)    :: panel_id
    real(kind=r_tran),       intent(in)    :: dt
    logical(kind=l_def),     intent(in)    :: log_space
    integer(kind=i_def),     intent(in)    :: hori_monotone
    integer(kind=i_def),     intent(in)    :: vert_monotone
    logical(kind=l_def),     intent(in)    :: reversible
    type(r_tran_field_type), intent(inout) :: mass_flux
    type(r_tran_field_type), intent(inout) :: increment

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'ffsl_conservative_transport_alg'

    ! Density substeps in given direction
    type(r_tran_field_type) :: field_x
    type(r_tran_field_type) :: field_y
    type(r_tran_field_type) :: field_z
    type(r_tran_field_type) :: field_f
    type(r_tran_field_type) :: field_g
    type(r_tran_field_type) :: field_h
    type(r_tran_field_type) :: field_xy

    ! Field increments and fluxes in given direction
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y
    type(r_tran_field_type) :: increment_z
    type(r_tran_field_type) :: half_increment_x
    type(r_tran_field_type) :: half_increment_y
    type(r_tran_field_type) :: half_increment_z
    type(r_tran_field_type) :: half_increment_xy
    type(r_tran_field_type) :: half_increment_yx
    type(r_tran_field_type) :: half_increment_zx
    type(r_tran_field_type) :: half_increment_xz
    type(r_tran_field_type) :: half_increment_yz
    type(r_tran_field_type) :: half_increment_zy
    type(r_tran_field_type) :: flux_x
    type(r_tran_field_type) :: flux_y
    type(r_tran_field_type) :: flux_z
    type(r_tran_field_type) :: mass_flux_h

    ! Useful constants
    real(kind=r_tran)   :: half_dt
    real(kind=r_tran)   :: third_dt
    logical(kind=l_def) :: half_flag

    ! Coordinate fields
    type(function_space_type), pointer :: dep_fs_h => null()
    type(function_space_type), pointer :: dep_fs_v => null()
    type(function_space_type), pointer :: field_fs => null()

    if ( subroutine_timers ) call timer(routine_name)

    ! Function space for departure points
    dep_fs_h => dep_pts_x%get_function_space()
    dep_fs_v => dep_pts_z%get_function_space()
    ! Function space for field
    field_fs => field%get_function_space()

    ! Initialise fields used by all splitting options
    call increment_x%initialise( vector_space = field_fs )
    call increment_y%initialise( vector_space = field_fs )
    call increment_z%initialise( vector_space = field_fs )
    call half_increment_x%initialise( vector_space = field_fs )
    call half_increment_y%initialise( vector_space = field_fs )
    call half_increment_z%initialise( vector_space = field_fs )
    call field_x%initialise( vector_space = field_fs )
    call field_y%initialise( vector_space = field_fs )
    call field_z%initialise( vector_space = field_fs )
    call field_xy%initialise( vector_space = field_fs )
    call flux_x%initialise( vector_space = dep_fs_h )
    call flux_y%initialise( vector_space = dep_fs_h )
    call flux_z%initialise( vector_space = dep_fs_v )
    call mass_flux_h%initialise( vector_space = dep_fs_h )

    ! Set fluxes to zero
    call invoke( setval_c( flux_x, 0.0_r_tran ), &
                 setval_c( flux_y, 0.0_r_tran ), &
                 setval_c( flux_z, 0.0_r_tran ), &
                 setval_c( mass_flux, 0.0_r_tran ) )

    ! Set constants
    half_dt = 0.5_r_tran * dt
    third_dt = 1.0_r_tran / 3.0_r_tran * dt
    ! Half step flag only true for Strang splitting
    half_flag = .false.

    ! Full COSMIC splitting (from Leonard et al. 1996).
    ! It has the form
    !
    !   rho_x = rho - dt/3 * f(rho)  |
    !   rho_y = rho - dt/3 * g(rho)  | First advective step terms
    !   rho_z = rho - dt/3 * h(rho)  |
    !
    !   rho_xy = rho - dt * f(rho_y) |
    !   rho_yz = rho - dt * g(rho_z) |
    !   rho_zx = rho - dt * h(rho_x) | Second advective step terms
    !   rho_xz = rho - dt * f(rho_z) |
    !   rho_yx = rho - dt * g(rho_x) |
    !   rho_zy = rho - dt * h(rho_y) |
    !
    ! Output: F( (rho_yz + rho_yz)/2 ) + G( (rho_xz + rho_zx)/2 )
    !                                  + H( (rho_xy + rho_yx)/2 )

    ! Initialise fields for FULL splitting
    call half_increment_xy%initialise( vector_space = field_fs )
    call half_increment_xz%initialise( vector_space = field_fs )
    call half_increment_yx%initialise( vector_space = field_fs )
    call half_increment_yz%initialise( vector_space = field_fs )
    call half_increment_zx%initialise( vector_space = field_fs )
    call half_increment_zy%initialise( vector_space = field_fs )
    call field_f%initialise( vector_space = field_fs )
    call field_g%initialise( vector_space = field_fs )
    call field_h%initialise( vector_space = field_fs )

    ! 1st advective step
    call ffsl_2d_advect_first( field, dep_pts_x, dep_pts_y, detj_at_w2h, &
                               dt, panel_id, inner_order,                &
                               hori_monotone, half_flag,                 &
                               half_increment_x, half_increment_y )
    call ffsl_1d_advect_vert( field, dep_pts_z, detj_at_w2v, inner_order, &
                              dt, log_space, vert_monotone, half_flag,  &
                              reversible, half_increment_z )
    call invoke( X_minus_bY( field_x, field, third_dt, half_increment_x ), &
                 X_minus_bY( field_y, field, third_dt, half_increment_y ), &
                 X_minus_bY( field_z, field, third_dt, half_increment_z ) )

    ! 2nd advective step
    call ffsl_2d_advect_final( field_x, field_y, dep_pts_x, dep_pts_y, &
                               detj_at_w2h, dt, panel_id, inner_order, &
                               hori_monotone, half_flag,               &
                               half_increment_xy, half_increment_yx )
    call ffsl_2d_advect_first( field_z, dep_pts_x, dep_pts_y, detj_at_w2h, &
                               dt, panel_id, inner_order,                  &
                               hori_monotone, half_flag,                   &
                               half_increment_xz, half_increment_yz )
    call ffsl_1d_advect_vert( field_x, dep_pts_z, detj_at_w2v, inner_order, &
                              dt, log_space, vert_monotone, half_flag,      &
                              reversible, half_increment_zx )
    call ffsl_1d_advect_vert( field_y, dep_pts_z, detj_at_w2v, inner_order, &
                              dt, log_space, vert_monotone, half_flag,      &
                              reversible, half_increment_zy )
    call invoke( X_minus_bY( field_f, field, half_dt, half_increment_yz ), &
                 X_minus_bY( field_g, field, half_dt, half_increment_xz ), &
                 X_minus_bY( field_h, field, half_dt, half_increment_xy ), &
                 inc_X_minus_bY( field_f, half_dt, half_increment_zy ),    &
                 inc_X_minus_bY( field_g, half_dt, half_increment_zx ),    &
                 inc_X_minus_bY( field_h, half_dt, half_increment_yx ) )

    ! Final conservative step
    call ffsl_2d_flux_final( field_g, field_f, dep_pts_x, dep_pts_y, &
                             detj_at_w2h, outer_order, dt, panel_id, &
                             hori_monotone, flux_x, increment_x,     &
                             flux_y, increment_y )
    call ffsl_1d_flux_vert( field_h, dep_pts_z, detj_at_w2v, outer_order, &
                            dt, log_space, vert_monotone, reversible,     &
                            flux_z, increment_z )

    ! Collect the increments
    call invoke( X_plus_Y( increment, increment_x, increment_y ), &
                 inc_X_plus_Y( increment, increment_z ) )

    ! Collect the fluxes
    call invoke( X_minus_Y( mass_flux_h, flux_x, flux_y ), &
                 combine_w2_field_kernel_type(mass_flux, mass_flux_h, flux_z) )

    if ( subroutine_timers ) call timer(routine_name)

    nullify( field_fs, dep_fs_h, dep_fs_v )

  end subroutine ffsl_conservative_transport_alg


  !> @brief   Algorithm for horizontal FFSL conservative transport scheme step.
  !> @details The algorithm solves the 2D conservative transport equation,
  !!          giving increment = div(u field). One-dimensional flux differences
  !!          denoted F, G (and advective differences, f, g) are computed
  !!          and used with COSMIC splitting. The transport equation
  !!          can be updated as field_np1 = field_n - dt*increment. In addition,
  !!          if the advective_flux flag is true, the algorithm will also return
  !!          the advective increment, u dot grad field, used for advective_then_flux
  !!          with the split scheme.
  !> @param[in]     field             Transported field
  !> @param[in]     dep_pts_x         Departure points in x direction
  !> @param[in]     dep_pts_y         Departure points in y direction
  !> @param[in]     detj_at_w2h       Det(J) at W2h dofs
  !> @param[in]     panel_id          Panel ID of the cells
  !> @param[in]     dt                Time step
  !> @param[in]     hori_monotone     Horizontal monotone option for FFSL
  !> @param[in]     strang            Logical flag to do half step in unity transport
  !> @param[in]     advect_flux       Flag to also compute advective update
  !> @param[in,out] mass_flux         Horizontal mass flux
  !> @param[in,out] increment_con     Conservative transport increment
  !> @param[in,out] increment_adv     Advective increment
  subroutine ffsl_conservative_horizontal_alg( field,         &
                                               dep_pts_x,     &
                                               dep_pts_y,     &
                                               detj_at_w2h,   &
                                               panel_id,      &
                                               dt,            &
                                               hori_monotone, &
                                               strang,        &
                                               advect_flux,   &
                                               mass_flux,     &
                                               increment_con, &
                                               increment_adv )

    implicit none

    type(r_tran_field_type), intent(in)    :: field
    type(r_tran_field_type), intent(in)    :: dep_pts_x
    type(r_tran_field_type), intent(in)    :: dep_pts_y
    type(r_tran_field_type), intent(in)    :: detj_at_w2h
    type(field_type),        intent(in)    :: panel_id
    real(kind=r_tran),       intent(in)    :: dt
    integer(kind=i_def),     intent(in)    :: hori_monotone
    logical(l_def),          intent(in)    :: strang
    logical(kind=l_def),     intent(in)    :: advect_flux
    type(r_tran_field_type), intent(inout) :: mass_flux
    type(r_tran_field_type), intent(inout) :: increment_con
    type(r_tran_field_type), intent(inout) :: increment_adv

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'ffsl_conservative_horizontal_alg'

    ! Density substeps in given direction
    type(r_tran_field_type) :: field_x
    type(r_tran_field_type) :: field_y

    ! Field increments in given direction
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y
    type(r_tran_field_type) :: increment_adv_x
    type(r_tran_field_type) :: increment_adv_y
    type(r_tran_field_type) :: half_increment_x
    type(r_tran_field_type) :: half_increment_y

    type(r_tran_field_type) :: flux_x
    type(r_tran_field_type) :: flux_y

    ! Useful constants
    real(kind=r_tran) :: half_dt

    ! Coordinate fields
    type(function_space_type), pointer :: dep_fs => null()
    type(function_space_type), pointer :: field_fs => null()

    if ( subroutine_timers ) call timer(routine_name)

    ! Function space for departure points
    dep_fs => dep_pts_x%get_function_space()
    ! Function space for field
    field_fs => field%get_function_space()

    call increment_x%initialise( vector_space = field_fs )
    call increment_y%initialise( vector_space = field_fs )
    call increment_adv_x%initialise( vector_space = field_fs )
    call increment_adv_y%initialise( vector_space = field_fs )
    call half_increment_x%initialise( vector_space = field_fs )
    call half_increment_y%initialise( vector_space = field_fs )
    call field_x%initialise( vector_space = field_fs )
    call field_y%initialise( vector_space = field_fs )
    call flux_x%initialise( vector_space = dep_fs )
    call flux_y%initialise( vector_space = dep_fs )

    ! Set fluxes to zero
    call invoke( setval_c( flux_x, 0.0_r_tran ), &
                 setval_c( flux_y, 0.0_r_tran ), &
                 setval_c( mass_flux, 0.0_r_tran ) )

    ! Set constants
    half_dt = 0.5_r_tran * dt

    ! COSMIC/Lin-Rood splitting (Leonard et al. 1996, Lin and Rood 1996).
    ! It has the form
    !
    !   rho_x = rho - dt/2 * f(rho)
    !   rho_y = rho - dt/2 * g(rho)
    !
    ! Output: F(rho_y) + G(rho_x)

    ! First advective step
    call ffsl_2d_advect_first( field, dep_pts_x, dep_pts_y, detj_at_w2h, &
                               dt, panel_id, inner_order, hori_monotone, &
                               strang, half_increment_x, half_increment_y )
    call invoke( X_minus_bY( field_x, field, half_dt, half_increment_x ), &
                 X_minus_bY( field_y, field, half_dt, half_increment_y ) )

    ! Final conservative step
    if (advect_flux) then
      call ffsl_2d_advect_then_flux_final( field_x, field_y,                      &
                                           dep_pts_x, dep_pts_y, detj_at_w2h, dt, &
                                           panel_id, outer_order,                 &
                                           hori_monotone, strang,                 &
                                           flux_x, increment_x, increment_adv_x,  &
                                           flux_y, increment_y, increment_adv_y )
      ! Collect the advective increments
      call invoke( X_plus_Y( increment_adv, increment_adv_x, increment_adv_y ) )
    else
      call ffsl_2d_flux_final( field_x, field_y, dep_pts_x, dep_pts_y, &
                               detj_at_w2h, outer_order, dt, panel_id, &
                               hori_monotone, flux_x, increment_x,     &
                               flux_y, increment_y )
      ! Set advective increment to zero
      call invoke( setval_c(increment_adv, 0.0_r_tran) )
    end if

    ! Collect the conservative increments and fluxes
    call invoke( X_plus_Y( increment_con, increment_x, increment_y ), &
                 X_minus_Y( mass_flux, flux_x, flux_y ) )

    if ( subroutine_timers ) call timer(routine_name)

    nullify( field_fs, dep_fs )

  end subroutine ffsl_conservative_horizontal_alg

end module ffsl_conservative_transport_alg_mod
