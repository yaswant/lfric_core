!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief   One-dimensional operators for the FFSL advective transport scheme.
!> @details These routines are required for the flux-form semi-Lagrangian (FFSL)
!!          splittings. They provide the calculation of one-dimensional advective
!!          differences. The advective increment f(q) is calculated using the
!!          flux F(q) following Putman and Lin, JCP, 2007. As
!!          \f$q - dt f (q)  = (q - dt F(q)) / (1 - dt F(1))\f$
!!          therefore
!!          \f$f(q) = (q - (q - dt F(q)) / (1 - dt F(1)) )/dt\f$
!!          There are three routines: 'first'; 'final'; 'vert'.
!!          'first' is used for the first step where the direction of the input
!!                  field is not important.
!!          'final' is used for later steps where the direction of the previous
!!                  step is important at the edges of cubed sphere panels.
!!          'vert' is used for vertical advective differences.

module ffsl_1d_advect_alg_mod

  use constants_mod,                    only: r_def, i_def, l_def
  use ffsl_1d_flux_alg_mod,             only: ffsl_1d_flux_first, &
                                              ffsl_1d_flux_final, &
                                              ffsl_1d_flux_vert
  use field_mod,                        only: field_type
  use flux_direction_mod,               only: x_direction, y_direction
  use function_space_mod,               only: function_space_type
  use mesh_mod,                         only: mesh_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  implicit none

  private

  public :: ffsl_1d_advect_first
  public :: ffsl_1d_advect_final
  public :: ffsl_1d_advect_vert

contains


  !===========================================================================!
  !> @brief   Algorithm to calculate the first advective form FFSL increment
  !!          in one horizontal dimension.
  !> @details The algorithm calculates the advective difference in the given direction.
  !!          The advective difference is calculated to give the increment,
  !!          v_i * dq/dx_i, at the cell centre. This is used to compute the first
  !!          step of the FFSL transport scheme.
  !!
  !> @param[in]     direction         Direction (x/y)
  !> @param[in]     field             Input field
  !> @param[in]     dep_pts           Departure points in the chosen direction
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     dt                The model timestep length
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     strang            Logical flag to do half step in unity transport
  !> @param[in,out] increment         Advective increment
  subroutine ffsl_1d_advect_first( direction,  &
                                   field,      &
                                   dep_pts,    &
                                   detj_at_w2, &
                                   dt,         &
                                   order,      &
                                   strang,     &
                                   increment )

    implicit none

    ! Arguments
    integer(i_def),   intent(in)    :: direction
    type(field_type), intent(in)    :: field
    type(field_type), intent(in)    :: dep_pts
    type(field_type), intent(in)    :: detj_at_w2
    real(r_def),      intent(in)    :: dt
    integer(i_def),   intent(in)    :: order
    logical(l_def),   intent(in)    :: strang
    type(field_type), intent(inout) :: increment

    ! Fields and increments
    type(field_type) :: inc_rho
    type(field_type) :: flux
    type(field_type) :: adv_rho
    type(field_type) :: divide_part
    type(field_type) :: inc_part

    ! Transport runtime, mesh, and unity transport pointers
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(field_type),             pointer :: adv_one => null()

    ! Constant
    real(r_def)      :: one_over_dt

    ! Get transport_runtime
    mesh => field%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Initialise fields
    call inc_rho%initialise( vector_space=field%get_function_space() )
    call flux%initialise( vector_space=dep_pts%get_function_space() )
    call adv_rho%initialise( vector_space=field%get_function_space() )
    call inc_part%initialise( vector_space=field%get_function_space() )
    call divide_part%initialise( vector_space=field%get_function_space() )
    call invoke( setval_c(inc_rho, 0.0_r_def),  &
                 setval_c(flux, 0.0_r_def),     &
                 setval_c(adv_rho, 0.0_r_def),  &
                 setval_c(inc_part, 0.0_r_def), &
                 setval_c(divide_part, 0.0_r_def) )

    ! Set constant value
    one_over_dt = 1.0_r_def / dt

    ! Compute the increment of the field, F(q)
    call ffsl_1d_flux_first( direction,  &
                             field,      &
                             dep_pts,    &
                             detj_at_w2, &
                             order,      &
                             dt,         &
                             flux,       &
                             inc_rho )
    call invoke( X_minus_bY( adv_rho, field, dt, inc_rho) )

    ! Get unity transport
    if ( direction == x_direction ) then
      if ( strang ) then
        adv_one => transport_runtime%get_adv_unity_half_x(field%get_mesh_id())
      else
        adv_one => transport_runtime%get_adv_unity_x(field%get_mesh_id())
      end if
    else if ( direction == y_direction ) then
      if ( strang ) then
        adv_one => transport_runtime%get_adv_unity_half_y(field%get_mesh_id())
      else
        adv_one => transport_runtime%get_adv_unity_y(field%get_mesh_id())
      end if
    end if

    ! Get the advective increment from these conservative increments
    ! adv_rho   = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - adv_rho / adv_one
    ! increment = inc_part / dt
    call invoke( X_divideby_Y(divide_part, adv_rho, adv_one), &
                 X_minus_Y(inc_part, field, divide_part),     &
                 a_times_X(increment, one_over_dt, inc_part) )

    nullify(transport_runtime, mesh, adv_one)

  end subroutine ffsl_1d_advect_first


  !===========================================================================!
  !> @brief   Algorithm to calculate the subsequent advective form FFSL increment
  !!          in one horizontal dimension.
  !> @details The algorithm calculates the advective difference in the given direction.
  !!          The advective difference is calculated to give the increment,
  !!          v_i * dq/dx_i, at the cell centre. This is used to compute the final
  !!          advective steps of the FFSL transport scheme. As it depends on previous
  !!          steps it requires the field from both x and y so that it uses the
  !!          correct values at cubed sphere panel edges.
  !!
  !> @param[in]     direction         Direction (x/y)
  !> @param[in]     field_x           Input field in x
  !> @param[in]     field_y           Input field in y
  !> @param[in]     dep_pts           Departure points in the chosen direction
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     dt                The model timestep length
  !> @param[in]     panel_id          Panel ID of the cells
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     strang            Logical flag to do half step in unity transport
  !> @param[in,out] increment         Advective increment
  subroutine ffsl_1d_advect_final( direction,  &
                                   field_x,    &
                                   field_y,    &
                                   dep_pts,    &
                                   detj_at_w2, &
                                   dt,         &
                                   panel_id,   &
                                   order,      &
                                   strang,     &
                                   increment )

    implicit none

    ! Arguments
    integer(i_def),   intent(in)    :: direction
    type(field_type), intent(in)    :: field_x
    type(field_type), intent(in)    :: field_y
    type(field_type), intent(in)    :: dep_pts
    type(field_type), intent(in)    :: detj_at_w2
    real(r_def),      intent(in)    :: dt
    type(field_type), intent(in)    :: panel_id
    integer(i_def),   intent(in)    :: order
    logical(l_def),   intent(in)    :: strang
    type(field_type), intent(inout) :: increment

    ! Fields and increments
    type(field_type) :: inc_rho
    type(field_type) :: flux
    type(field_type) :: adv_rho
    type(field_type) :: divide_part
    type(field_type) :: inc_part
    type(field_type) :: field_n

    ! Transport runtime, mesh and unity transport pointers
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(field_type),             pointer :: adv_one => null()

    ! Constant
    real(r_def)      :: one_over_dt

    ! Get transport_runtime
    mesh => field_x%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Initialise fields
    call inc_rho%initialise( vector_space=field_x%get_function_space() )
    call flux%initialise( vector_space=dep_pts%get_function_space() )
    call adv_rho%initialise( vector_space=field_x%get_function_space() )
    call inc_part%initialise( vector_space=field_x%get_function_space() )
    call divide_part%initialise( vector_space=field_x%get_function_space() )
    call field_n%initialise( vector_space=field_x%get_function_space() )
    call invoke( setval_c(inc_rho, 0.0_r_def),  &
                 setval_c(flux, 0.0_r_def),     &
                 setval_c(adv_rho, 0.0_r_def),  &
                 setval_c(inc_part, 0.0_r_def), &
                 setval_c(divide_part, 0.0_r_def) )

    ! Set constant
    one_over_dt = 1.0_r_def / dt

    ! Get correct field to update based on direction
    if (direction == x_direction) then
      call invoke( setval_X(field_n, field_y) )
    else if (direction == y_direction) then
      call invoke( setval_X(field_n, field_x) )
    end if

    ! Compute the increment of the field, F(q)
    call ffsl_1d_flux_final( direction,  &
                             field_x,    &
                             field_y,    &
                             dep_pts,    &
                             detj_at_w2, &
                             order,      &
                             dt,         &
                             panel_id,   &
                             flux,       &
                             inc_rho )
    call invoke( X_minus_bY( adv_rho, field_n, dt, inc_rho) )

    ! Get unity transport
    if ( direction == x_direction ) then
      if ( strang ) then
        adv_one => transport_runtime%get_adv_unity_half_x(field_x%get_mesh_id())
      else
        adv_one => transport_runtime%get_adv_unity_x(field_x%get_mesh_id())
      end if
    else if ( direction == y_direction ) then
      if ( strang ) then
        adv_one => transport_runtime%get_adv_unity_half_y(field_y%get_mesh_id())
      else
        adv_one => transport_runtime%get_adv_unity_y(field_y%get_mesh_id())
      end if
    end if

    ! Get the advective increment from these conservative increments
    ! adv_rho   = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - adv_rho / adv_one
    ! increment = inc_part / dt
    call invoke( X_divideby_Y(divide_part, adv_rho, adv_one), &
                 X_minus_Y(inc_part, field_n, divide_part),   &
                 a_times_X(increment, one_over_dt, inc_part) )

    nullify(transport_runtime, mesh, adv_one)

  end subroutine ffsl_1d_advect_final


  !===========================================================================!
  !> @brief   Algorithm to calculate the advective form FFSL increment in the vertical.
  !> @details The algorithm calculates the advective difference in the vertical
  !!          to give the increment, w * dq/dz, at the cell centre.
  !!
  !> @param[in]     field             Input field
  !> @param[in]     dep_pts           Departure points in the chosen direction
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     dt                The model timestep length
  !> @param[in]     strang            Logical flag to do half step in unity transport
  !> @param[in,out] increment         Advective increment
  subroutine ffsl_1d_advect_vert( field,      &
                                  dep_pts,    &
                                  detj_at_w2, &
                                  order,      &
                                  dt,         &
                                  strang,     &
                                  increment )

    implicit none

    ! Arguments
    type(field_type), intent(in)    :: field
    type(field_type), intent(in)    :: dep_pts
    type(field_type), intent(in)    :: detj_at_w2
    integer(i_def),   intent(in)    :: order
    real(r_def),      intent(in)    :: dt
    logical(l_def),   intent(in)    :: strang
    type(field_type), intent(inout) :: increment

    ! Fields and increments
    type(field_type) :: inc_rho
    type(field_type) :: flux
    type(field_type) :: adv_rho
    type(field_type) :: divide_part
    type(field_type) :: inc_part

    ! Transport runtime, mesh and unity transport pointers
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(field_type),             pointer :: adv_one => null()

    ! Constant
    real(r_def)      :: one_over_dt

    ! Get transport_runtime
    mesh => field%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Initialise fields
    call inc_rho%initialise( vector_space=field%get_function_space() )
    call flux%initialise( vector_space=dep_pts%get_function_space() )
    call adv_rho%initialise( vector_space=field%get_function_space() )
    call inc_part%initialise( vector_space=field%get_function_space() )
    call divide_part%initialise( vector_space=field%get_function_space() )
    call invoke( setval_c(inc_rho, 0.0_r_def),  &
                 setval_c(flux, 0.0_r_def),     &
                 setval_c(adv_rho, 0.0_r_def),  &
                 setval_c(inc_part, 0.0_r_def), &
                 setval_c(divide_part, 0.0_r_def)  )

    ! Set constant
    one_over_dt = 1.0_r_def / dt

    ! Compute the increment of the field, F(q)
    call ffsl_1d_flux_vert( field, dep_pts, detj_at_w2, order, &
                            dt, flux, inc_rho )
    call invoke( X_minus_bY( adv_rho, field, dt, inc_rho ) )

    ! Get unity transport
    if ( strang ) then
      adv_one => transport_runtime%get_adv_unity_half_z(field%get_mesh_id())
    else
      adv_one => transport_runtime%get_adv_unity_z(field%get_mesh_id())
    end if

    ! Get the advective increment from these conservative increments
    ! adv_rho   = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - adv_rho / adv_one
    ! increment = inc_part / dt
    call invoke( X_divideby_Y(divide_part, adv_rho, adv_one), &
                 X_minus_Y(inc_part, field, divide_part),     &
                 a_times_X(increment, one_over_dt, inc_part) )

    nullify(transport_runtime, mesh, adv_one)

  end subroutine ffsl_1d_advect_vert

end module ffsl_1d_advect_alg_mod
