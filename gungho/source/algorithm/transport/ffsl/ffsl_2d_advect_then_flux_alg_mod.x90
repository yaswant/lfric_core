!-----------------------------------------------------------------------------
! (c) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief   Combination of X and Y one-dimensional horizontal operators
!!          for the horizontal FFSL advective-then-flux transport scheme
!!          to compute the full 2D horizontal update.
!> @details These routines are required for the horizontal flux-form semi-Lagrangian (FFSL) scheme.
!!          They provide the calculation of
!!          one-dimensional advective and flux differences. The advective increment
!!          f(q) is calculated using the flux F(q) following Putman and Lin, JCP, 2007. As
!!          \f$q - dt f (q)  = (q - dt F(q)) / (1 - dt F(1))\f$
!!          therefore
!!          \f$f(q) = (q - (q - dt F(q)) / (1 - dt F(1)) )/dt\f$

module ffsl_2d_advect_then_flux_alg_mod

  use constants_mod,                    only: r_tran, i_def, l_def
  use ffsl_2d_flux_alg_mod,             only: ffsl_2d_flux_final
  use r_tran_field_mod,                 only: r_tran_field_type
  use field_mod,                        only: field_type
  use function_space_mod,               only: function_space_type
  use mesh_mod,                         only: mesh_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  implicit none

  private

  public :: ffsl_2d_advect_then_flux_final

contains


  !===========================================================================!
  !> @brief   Algorithm to calculate the advective and flux form FFSL increments
  !!          in one horizontal dimension.
  !> @details The algorithm calculates the advective and flux differences in the
  !!          given direction. The advective difference is calculated to give the
  !!          increment v_i * dq/dx_i, and the flux difference is calculated to
  !!          give the increment d(v_i q)/dx_i, at the cell centre.
  !!          This is used to compute the final advective and flux steps of the
  !!          FFSL transport scheme when used with the split scheme. As it depends
  !!          on previous steps it requires the field from both x and y so that
  !!          it uses the correct values at cubed sphere panel edges.
  !!
  !> @param[in]     field_x           Input field in x
  !> @param[in]     field_y           Input field in y
  !> @param[in]     dep_pts_x         Departure points in the x direction
  !> @param[in]     dep_pts_y         Departure points in the y direction
  !> @param[in]     detj_at_w2        Det(J) at W2h dofs
  !> @param[in]     dt                The model timestep length
  !> @param[in]     panel_id          Panel ID of the cells
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     monotone          Horizontal monotone option for FFSL
  !> @param[in]     strang            Logical flag to do half step in unity transport
  !> @param[in,out] flux_x            Horizontal flux in the x direction
  !> @param[in,out] increment_con_x   Conservative transport increment in the x direction
  !> @param[in,out] increment_adv_x   Advective increment in the x direction
  !> @param[in,out] flux_y            Horizontal flux in the y direction
  !> @param[in,out] increment_con_y   Conservative transport increment in the y direction
  !> @param[in,out] increment_adv_y   Advective increment in the y direction
  subroutine ffsl_2d_advect_then_flux_final( field_x,         &
                                             field_y,         &
                                             dep_pts_x,       &
                                             dep_pts_y,       &
                                             detj_at_w2,      &
                                             dt,              &
                                             panel_id,        &
                                             order,           &
                                             monotone,        &
                                             strang,          &
                                             flux_x,          &
                                             increment_con_x, &
                                             increment_adv_x, &
                                             flux_y,          &
                                             increment_con_y, &
                                             increment_adv_y )

    implicit none

    ! Arguments
    type(r_tran_field_type), intent(in)    :: field_x
    type(r_tran_field_type), intent(in)    :: field_y
    type(r_tran_field_type), intent(in)    :: dep_pts_x, dep_pts_y
    type(r_tran_field_type), intent(in)    :: detj_at_w2
    real(r_tran),            intent(in)    :: dt
    type(field_type),        intent(in)    :: panel_id
    integer(i_def),          intent(in)    :: order
    integer(kind=i_def),     intent(in)    :: monotone
    logical(l_def),          intent(in)    :: strang
    type(r_tran_field_type), intent(inout) :: flux_x
    type(r_tran_field_type), intent(inout) :: increment_con_x
    type(r_tran_field_type), intent(inout) :: increment_adv_x
    type(r_tran_field_type), intent(inout) :: flux_y
    type(r_tran_field_type), intent(inout) :: increment_con_y
    type(r_tran_field_type), intent(inout) :: increment_adv_y

    ! Fields and increments
    type(r_tran_field_type) :: adv_rho_x, adv_rho_y
    type(r_tran_field_type) :: divide_part
    type(r_tran_field_type) :: inc_part

    ! Transport runtime, mesh and unity transport pointers
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: adv_one_x => null()
    type(r_tran_field_type),      pointer :: adv_one_y => null()

    ! Constant
    real(r_tran) :: one_over_dt

    ! Get transport_runtime
    mesh => field_x%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Initialise fields
    call adv_rho_x%initialise( vector_space=field_x%get_function_space() )
    call adv_rho_y%initialise( vector_space=field_y%get_function_space() )
    call inc_part%initialise( vector_space=field_x%get_function_space() )
    call divide_part%initialise( vector_space=field_x%get_function_space() )

    ! Set constant
    one_over_dt = 1.0_r_tran / dt

    ! Compute the conservative increment of the field, F(q)
    call ffsl_2d_flux_final( field_x,         &
                             field_y,         &
                             dep_pts_x,       &
                             dep_pts_y,       &
                             detj_at_w2,      &
                             order,           &
                             dt,              &
                             panel_id,        &
                             monotone,        &
                             flux_x,          &
                             increment_con_x, &
                             flux_y,          &
                             increment_con_y )
    call invoke( X_minus_bY( adv_rho_x, field_y, dt, increment_con_x), &
                 X_minus_bY( adv_rho_y, field_x, dt, increment_con_y) )

    ! Get unity transport
    if ( strang ) then
      adv_one_x => transport_runtime%get_adv_unity_half_x(field_x%get_mesh_id())
      adv_one_y => transport_runtime%get_adv_unity_half_y(field_y%get_mesh_id())
    else
      adv_one_x => transport_runtime%get_adv_unity_x(field_x%get_mesh_id())
      adv_one_y => transport_runtime%get_adv_unity_y(field_y%get_mesh_id())
    end if

    ! Get the advective increment from these conservative increments
    ! adv_rho   = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - adv_rho / adv_one
    ! increment = inc_part / dt
    call invoke( X_divideby_Y(divide_part, adv_rho_x, adv_one_x), &
                 X_minus_Y(inc_part, field_y, divide_part),       &
                 a_times_X(increment_adv_x, one_over_dt, inc_part) )
    call invoke( X_divideby_Y(divide_part, adv_rho_y, adv_one_y), &
                 X_minus_Y(inc_part, field_x, divide_part),       &
                 a_times_X(increment_adv_y, one_over_dt, inc_part) )

  end subroutine ffsl_2d_advect_then_flux_final

end module ffsl_2d_advect_then_flux_alg_mod
