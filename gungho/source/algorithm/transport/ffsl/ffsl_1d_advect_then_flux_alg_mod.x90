!-----------------------------------------------------------------------------
! (c) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief   One-dimensional operators for the vertical FFSL advective-then-flux transport scheme.
!> @details This routine is required for the flux-form semi-Lagrangian (FFSL) scheme
!!          in the vertical. It provides the calculation of
!!          one-dimensional advective and flux differences. The advective increment
!!          f(q) is calculated using the flux F(q) following Putman and Lin, JCP, 2007. As
!!          \f$q - dt f (q)  = (q - dt F(q)) / (1 - dt F(1))\f$
!!          therefore
!!          \f$f(q) = (q - (q - dt F(q)) / (1 - dt F(1)) )/dt\f$

module ffsl_1d_advect_then_flux_alg_mod

  use constants_mod,                    only: r_tran, i_def, l_def
  use ffsl_1d_flux_alg_mod,             only: ffsl_1d_flux_vert
  use r_tran_field_mod,                 only: r_tran_field_type
  use mesh_mod,                         only: mesh_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  implicit none

  private

  public :: ffsl_1d_advect_then_flux_vert

contains

  !===========================================================================!
  !> @brief   Algorithm to calculate the advective and flux form FFSL increments
  !!          in the vertical.
  !> @details The algorithm calculates the advective and flux differences in the vertical
  !!          to give the increments, w * dq/dz and d(wq)/dz, at the cell centre.
  !!
  !> @param[in]     field             Input field
  !> @param[in]     dep_pts           Departure points in the chosen direction
  !> @param[in]     detj_at_w2        Det(J) at W2v dofs
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     dt                The model timestep length
  !> @param[in]     log_space         Switch to use natural logarithmic space
  !!                                  for edge interpolation
  !> @param[in]     monotone          Vertical monotone option for FFSL
  !> @param[in]     strang            Logical flag to do half step in unity transport
  !> @param[in]     reversible        Reversibility option for FFSL
  !> @param[in,out] flux              Vertical flux
  !> @param[in,out] increment_con     Conservative transport increment
  !> @param[in,out] increment_adv     Advective increment
  subroutine ffsl_1d_advect_then_flux_vert( field,         &
                                            dep_pts,       &
                                            detj_at_w2,    &
                                            order,         &
                                            dt,            &
                                            log_space,     &
                                            monotone,      &
                                            strang,        &
                                            reversible,    &
                                            flux,          &
                                            increment_con, &
                                            increment_adv )

    implicit none

    ! Arguments
    type(r_tran_field_type), intent(in)    :: field
    type(r_tran_field_type), intent(in)    :: dep_pts
    type(r_tran_field_type), intent(in)    :: detj_at_w2
    integer(i_def),          intent(in)    :: order
    real(r_tran),            intent(in)    :: dt
    logical(l_def),          intent(in)    :: log_space
    integer(i_def),          intent(in)    :: monotone
    logical(l_def),          intent(in)    :: strang
    logical(kind=l_def),     intent(in)    :: reversible
    type(r_tran_field_type), intent(inout) :: flux
    type(r_tran_field_type), intent(inout) :: increment_con
    type(r_tran_field_type), intent(inout) :: increment_adv

    ! Fields and increments
    type(r_tran_field_type) :: adv_rho
    type(r_tran_field_type) :: divide_part
    type(r_tran_field_type) :: inc_part

    ! Transport runtime, mesh and unity transport pointers
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: adv_one => null()

    ! Constant
    real(r_tran)      :: one_over_dt

    ! Get transport_runtime
    mesh => field%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Initialise fields
    call adv_rho%initialise( vector_space=field%get_function_space() )
    call inc_part%initialise( vector_space=field%get_function_space() )
    call divide_part%initialise( vector_space=field%get_function_space() )
    call invoke( setval_c(adv_rho, 0.0_r_tran),   &
                 setval_c(inc_part, 0.0_r_tran),  &
                 setval_c(divide_part, 0.0_r_tran)  )

    ! Set constant
    one_over_dt = 1.0_r_tran / dt

    ! Compute the conservative increment of the field, F(q)
    call ffsl_1d_flux_vert( field, dep_pts, detj_at_w2, order,   &
                            dt, log_space, monotone, reversible, &
                            flux, increment_con )
    call invoke( X_minus_bY( adv_rho, field, dt, increment_con ) )

    ! Get unity transport
    if ( strang ) then
      adv_one => transport_runtime%get_adv_unity_half_z(field%get_mesh_id())
    else
      adv_one => transport_runtime%get_adv_unity_z(field%get_mesh_id())
    end if

    ! Get the advective increment from these conservative increments
    ! adv_rho   = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - adv_rho / adv_one
    ! increment = inc_part / dt
    call invoke( X_divideby_Y(divide_part, adv_rho, adv_one), &
                 X_minus_Y(inc_part, field, divide_part),     &
                 a_times_X(increment_adv, one_over_dt, inc_part) )

  end subroutine ffsl_1d_advect_then_flux_vert

end module ffsl_1d_advect_then_flux_alg_mod
