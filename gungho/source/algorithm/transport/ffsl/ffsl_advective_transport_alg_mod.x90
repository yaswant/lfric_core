!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief   Algorithms for 2D and 3D FFSL advective transport scheme step.
!> @details The algorithms solve the 2D or 3D advective transport equation
!!          \f$\frac{\partial \rho}{\partial t} + \mathbf{u} \cdot \nabla \rho = 0)\f$,
!!          using the flux-form semi-Lagrangian (FFSL) transport scheme and a
!!          choice of splitting methods. The output increment is
!!          \f$\mathbf{u} \cdot \nabla \rho\f$,
!!          and so the transport equation can be updated as
!!          \f$rho^{n+1} = rho^{n} - \Delta{t}\times \mbox{increment}\f$.
module ffsl_advective_transport_alg_mod

  ! Constants and types
  use constants_mod,          only: r_tran, i_def, l_def
  use field_mod,              only: field_type
  use r_tran_field_mod,       only: r_tran_field_type
  use function_space_mod,     only: function_space_type
  use timer_mod,              only: timer
  use flux_direction_mod,     only: x_direction, y_direction
  use log_mod,                only: log_event, &
                                    LOG_LEVEL_ERROR

  ! Algorithms
  use ffsl_1d_advect_alg_mod, only: ffsl_1d_advect_vert
  use ffsl_2d_advect_alg_mod, only: ffsl_2d_advect_first, &
                                    ffsl_2d_advect_final

  ! Configuration options
  use io_config_mod,          only: subroutine_timers
  use subgrid_config_mod,     only: inner_order, &
                                    outer_order

  implicit none

  private

  public :: ffsl_advective_transport_alg
  public :: ffsl_advective_horizontal_alg

contains


  !> @brief   Algorithm for 3D FFSL advective transport scheme step.
  !> @details The algorithm solves the 3D advective transport equation,
  !!          giving increment = u dot grad rho. One-dimensional advective
  !!          differences denoted f, g, h, are computed and used with the
  !!          chosen option for splitting. The transport equation can be
  !!          updated as rho_np1 = rho_n - dt*increment.
  !> @param[in]     field             Advected field
  !> @param[in]     dep_pts_x         Departure points in x direction
  !> @param[in]     dep_pts_y         Departure points in y direction
  !> @param[in]     dep_pts_z         Departure points in z direction
  !> @param[in]     detj_at_w2h       Det(J) at W2h dofs
  !> @param[in]     detj_at_w2v       Det(J) at W2v dofs
  !> @param[in]     panel_id          Panel ID of the cells
  !> @param[in]     dt                Time step
  !> @param[in]     log_space         Switch to use natural logarithmic space
  !!                                  for edge interpolation
  !> @param[in]     hori_monotone     Horizontal monotone option for FFSL
  !> @param[in]     vert_monotone     Vertical monotone option for FFSL
  !> @param[in]     reversible        Vertical reversibility option for FFSL
  !> @param[in,out] increment         Density increment
  subroutine ffsl_advective_transport_alg( field,         &
                                           dep_pts_x,     &
                                           dep_pts_y,     &
                                           dep_pts_z,     &
                                           detj_at_w2h,   &
                                           detj_at_w2v,   &
                                           panel_id,      &
                                           dt,            &
                                           log_space,     &
                                           hori_monotone, &
                                           vert_monotone, &
                                           reversible,    &
                                           increment )

    implicit none

    type(r_tran_field_type), intent(in)    :: field
    type(r_tran_field_type), intent(in)    :: dep_pts_x
    type(r_tran_field_type), intent(in)    :: dep_pts_y
    type(r_tran_field_type), intent(in)    :: dep_pts_z
    type(r_tran_field_type), intent(in)    :: detj_at_w2h
    type(r_tran_field_type), intent(in)    :: detj_at_w2v
    type(field_type),        intent(in)    :: panel_id
    real(kind=r_tran),       intent(in)    :: dt
    logical(kind=l_def),     intent(in)    :: log_space
    integer(kind=i_def),     intent(in)    :: hori_monotone
    integer(kind=i_def),     intent(in)    :: vert_monotone
    logical(kind=l_def),     intent(in)    :: reversible
    type(r_tran_field_type), intent(inout) :: increment

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'ffsl_advective_transport_alg'

    ! Field substeps in given direction
    type(r_tran_field_type) :: field_x
    type(r_tran_field_type) :: field_y
    type(r_tran_field_type) :: field_z
    type(r_tran_field_type) :: field_xy
    type(r_tran_field_type) :: field_f
    type(r_tran_field_type) :: field_g
    type(r_tran_field_type) :: field_h

    ! Field increments (advective differences) in given direction
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y
    type(r_tran_field_type) :: increment_z
    type(r_tran_field_type) :: half_increment_x
    type(r_tran_field_type) :: half_increment_y
    type(r_tran_field_type) :: half_increment_z
    type(r_tran_field_type) :: half_increment_xy
    type(r_tran_field_type) :: half_increment_yx
    type(r_tran_field_type) :: half_increment_zx
    type(r_tran_field_type) :: half_increment_xz
    type(r_tran_field_type) :: half_increment_yz
    type(r_tran_field_type) :: half_increment_zy

    ! Useful constants
    real(kind=r_tran)    :: half_dt
    real(kind=r_tran)    :: third_dt
    logical(kind=l_def)  :: half_flag

    ! Coordinate fields
    type(function_space_type), pointer :: field_fs => null()

    if ( subroutine_timers ) call timer(routine_name)

    ! Function space for the field
    field_fs => field%get_function_space()

    ! Initialise fields used by all splitting options
    call increment_x%initialise( field_fs )
    call increment_y%initialise( field_fs )
    call increment_z%initialise( field_fs )
    call half_increment_x%initialise( field_fs )
    call half_increment_y%initialise( field_fs )
    call half_increment_z%initialise( field_fs )
    call field_x%initialise( field_fs )
    call field_y%initialise( field_fs )
    call field_z%initialise( field_fs )
    call field_xy%initialise( field_fs )

    ! Set constants
    half_dt = 0.5_r_tran * dt
    third_dt = 1.0_r_tran / 3.0_r_tran * dt
    ! Half step flag only true for Strang splitting
    half_flag = .false.

    ! Full COSMIC splitting (from Leonard et al. 1996).
    ! It has the form
    !
    !   rho_x = rho - dt/3 * f(rho)  |
    !   rho_y = rho - dt/3 * g(rho)  | First advective step terms
    !   rho_z = rho - dt/3 * h(rho)  |
    !
    !   rho_xy = rho - dt * f(rho_y) |
    !   rho_yz = rho - dt * g(rho_z) |
    !   rho_zx = rho - dt * h(rho_x) | Second advective step terms
    !   rho_xz = rho - dt * f(rho_z) |
    !   rho_yx = rho - dt * g(rho_x) |
    !   rho_zy = rho - dt * h(rho_y) |
    !
    ! Output: f( (rho_yz+rho_yz)/2 ) + g( (rho_xz+rho_zx)/2 )
    !                                + h( (rho_xy+rho_yx)/2 )

    ! Initialise fields for FULL splitting
    call half_increment_xy%initialise( field_fs )
    call half_increment_yx%initialise( field_fs )
    call half_increment_zx%initialise( field_fs )
    call half_increment_xz%initialise( field_fs )
    call half_increment_yz%initialise( field_fs )
    call half_increment_zy%initialise( field_fs )
    call field_f%initialise( field_fs )
    call field_g%initialise( field_fs )
    call field_h%initialise( field_fs )

    ! 1st advective step
    call ffsl_2d_advect_first( field, dep_pts_x, dep_pts_y, detj_at_w2h, &
                               dt, panel_id, inner_order,                &
                               hori_monotone, half_flag,                 &
                               half_increment_x, half_increment_y )
    call ffsl_1d_advect_vert( field, dep_pts_z, detj_at_w2v, inner_order, &
                              dt, log_space, vert_monotone, half_flag,    &
                              reversible, half_increment_z )
    call invoke( X_minus_bY( field_x, field, third_dt, half_increment_x ), &
                 X_minus_bY( field_y, field, third_dt, half_increment_y ), &
                 X_minus_bY( field_z, field, third_dt, half_increment_z ) )

    ! 2nd advective step
    call ffsl_2d_advect_final( field_x, field_y, dep_pts_x, dep_pts_y,  &
                               detj_at_w2h, dt, panel_id, inner_order,  &
                               hori_monotone, half_flag,                &
                               half_increment_xy, half_increment_yx )
    call ffsl_2d_advect_first( field_z, dep_pts_x, dep_pts_y, detj_at_w2h, &
                               dt, panel_id, inner_order,                  &
                               hori_monotone,  half_flag,                  &
                               half_increment_xz, half_increment_yz )
    call ffsl_1d_advect_vert( field_x, dep_pts_z, detj_at_w2v, inner_order, &
                              dt, log_space, vert_monotone, half_flag,      &
                              reversible, half_increment_zx )
    call ffsl_1d_advect_vert( field_y, dep_pts_z, detj_at_w2v, inner_order, &
                              dt, log_space, vert_monotone, half_flag,      &
                              reversible, half_increment_zy )
    call invoke( X_minus_bY( field_f, field, half_dt, half_increment_yz ), &
                 X_minus_bY( field_g, field, half_dt, half_increment_xz ), &
                 X_minus_bY( field_h, field, half_dt, half_increment_xy ), &
                 inc_X_minus_bY( field_f, half_dt, half_increment_zy ),    &
                 inc_X_minus_bY( field_g, half_dt, half_increment_zx ),    &
                 inc_X_minus_bY( field_h, half_dt, half_increment_yx ) )

    ! Final advective step
    call ffsl_2d_advect_final( field_g, field_f, dep_pts_x, dep_pts_y, &
                               detj_at_w2h, dt, panel_id, outer_order, &
                               hori_monotone, half_flag,               &
                               increment_x, increment_y )
    call ffsl_1d_advect_vert( field_h, dep_pts_z, detj_at_w2v, outer_order, &
                              dt, log_space, vert_monotone, half_flag,      &
                              reversible, increment_z )

    ! Collect increments
    call invoke( X_plus_Y( increment, increment_x, increment_y ), &
                 inc_X_plus_Y( increment, increment_z ) )

    if ( subroutine_timers ) call timer(routine_name)

    nullify( field_fs )

  end subroutine ffsl_advective_transport_alg


  !> @brief   Algorithm for horizontal FFSL advective transport scheme step.
  !> @details The algorithm solves the 2D advective transport equation,
  !!          giving increment = u dot grad rho. One-dimensional advective
  !!          differences, denoted f and g are computed and used with
  !!          with COSMIC splitting. The transport equation can be
  !!          updated as rho_np1 = rho_n - dt*increment.
  !> @param[in]     field             Advected field
  !> @param[in]     dep_pts_x         Departure points in x direction
  !> @param[in]     dep_pts_y         Departure points in y direction
  !> @param[in]     detj_at_w2h       Det(J) at W2h dofs
  !> @param[in]     panel_id          Panel ID of the cells
  !> @param[in]     dt                Time step
  !> @param[in]     hori_monotone     Horizontal monotone option for FFSL
  !> @param[in]     strang            Logical flag to do half step
  !> @param[in,out] increment         Density increment
  subroutine ffsl_advective_horizontal_alg( field,         &
                                            dep_pts_x,     &
                                            dep_pts_y,     &
                                            detj_at_w2h,   &
                                            panel_id,      &
                                            dt,            &
                                            hori_monotone, &
                                            strang,        &
                                            increment )

    implicit none

    type(r_tran_field_type), intent(in)    :: field
    type(r_tran_field_type), intent(in)    :: dep_pts_x
    type(r_tran_field_type), intent(in)    :: dep_pts_y
    type(r_tran_field_type), intent(in)    :: detj_at_w2h
    type(field_type),        intent(in)    :: panel_id
    real(kind=r_tran),       intent(in)    :: dt
    integer(kind=i_def),     intent(in)    :: hori_monotone
    logical(l_def),          intent(in)    :: strang
    type(r_tran_field_type), intent(inout) :: increment

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'ffsl_advective_horizontal_alg'

    ! Field substeps in given direction
    type(r_tran_field_type) :: field_x
    type(r_tran_field_type) :: field_y

    ! Field increments (advective differences) in given direction
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y
    type(r_tran_field_type) :: half_increment_x
    type(r_tran_field_type) :: half_increment_y

    ! Useful constants
    real(kind=r_tran) :: half_dt

    ! Coordinate fields
    type(function_space_type), pointer :: field_fs => null()

    if ( subroutine_timers ) call timer(routine_name)

    ! Function space for the field
    field_fs => field%get_function_space()

    call increment_x%initialise( field_fs )
    call increment_y%initialise( field_fs )
    call half_increment_x%initialise( field_fs )
    call half_increment_y%initialise( field_fs )
    call field_x%initialise( field_fs )
    call field_y%initialise( field_fs )

    ! Set constants
    half_dt = 0.5_r_tran * dt

    ! COSMIC/Lin-Rood splitting (Leonard et al. 1996, Lin and Rood 1996).
    ! It has the form
    !
    !   rho_x = rho - dt/2 * f(rho)
    !   rho_y = rho - dt/2 * g(rho)
    !
    ! Output: F(rho_y) + G(rho_x)

    ! First advective step
    call ffsl_2d_advect_first( field, dep_pts_x, dep_pts_y, detj_at_w2h, &
                               dt, panel_id, inner_order, hori_monotone, &
                               strang, half_increment_x, half_increment_y )
    call invoke( X_minus_bY( field_x, field, half_dt, half_increment_x ), &
                 X_minus_bY( field_y, field, half_dt, half_increment_y ) )

    ! Final advective step
    call ffsl_2d_advect_final( field_x, field_y, dep_pts_x, dep_pts_y, &
                               detj_at_w2h, dt, panel_id, outer_order, &
                               hori_monotone, strang,                  &
                               increment_x, increment_y )

    ! Collect the increments
    call invoke( X_plus_Y( increment, increment_x, increment_y ) )

    if ( subroutine_timers ) call timer(routine_name)

    nullify( field_fs )

  end subroutine ffsl_advective_horizontal_alg

end module ffsl_advective_transport_alg_mod
