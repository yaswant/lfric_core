!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
!> @brief   One-dimensional operators for the FFSL transport scheme.
!> @details These routines are required for the flux-form semi-Lagrangian (FFSL)
!!          splittings. They provide the calculation of one dimensional flux
!!          differences. There are three routines: 'first'; 'final'; 'vert'.
!!          'first' is used for the first step where the direction of the input
!!                  field is not important.
!!          'final' is used for later steps where the direction of the previous
!!                  step is important at the edges of cubed sphere panels.
!!          'vert' is used for vertical flux differences.

module ffsl_1d_flux_alg_mod

  ! Constants and types
  use constants_mod,                  only: r_def, i_def
  use fem_constants_mod,              only: get_inverse_w3_mass_matrix
  use field_mod,                      only: field_type
  use flux_direction_mod,             only: x_direction, y_direction, z_direction
  use geometric_constants_mod,        only: get_dz_w3
  use operator_mod,                   only: operator_type

  ! Kernels
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use ffsl_flux_final_x_kernel_mod,   only: ffsl_flux_final_x_kernel_type
  use ffsl_flux_final_y_kernel_mod,   only: ffsl_flux_final_y_kernel_type
  use ffsl_flux_first_x_kernel_mod,   only: ffsl_flux_first_x_kernel_type
  use ffsl_flux_first_y_kernel_mod,   only: ffsl_flux_first_y_kernel_type
  use ffsl_vertical_flux_kernel_mod,  only: ffsl_vertical_flux_kernel_type
  use ffsl_vert_constant_flux_kernel_mod, &
                                      only: ffsl_vert_constant_flux_kernel_type
  use fv_divergence_x_kernel_mod,     only: fv_divergence_x_kernel_type
  use fv_divergence_y_kernel_mod,     only: fv_divergence_y_kernel_type
  use fv_divergence_z_kernel_mod,     only: fv_divergence_z_kernel_type
  use vert_ppm_no_limiter_kernel_mod, only: vert_ppm_no_limiter_kernel_type

  implicit none

  private

  public :: ffsl_1d_flux_first
  public :: ffsl_1d_flux_final
  public :: ffsl_1d_flux_vert

contains


  !===========================================================================!
  !> @brief   Algorithm to calculate the first conservative form FFSL
  !!          increment in one horizontal dimension.
  !> @details The algorithm calculates the flux difference in the given direction.
  !!          The mass flux is calculated, then the difference taken to give the
  !!          increment. Only one field input is required as this routine is used
  !!          for the first step.
  !!
  !> @param[in]     direction         Direction (x/y)
  !> @param[in]     field             Input field
  !> @param[in]     dep_pts           Departure points in the chosen direction
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     dt                The model timestep length
  !> @param[in,out] flux              Horizontal flux. Included here to be
  !!                                  ready for #2997
  !> @param[in,out] increment         Conservative transport increment
  subroutine ffsl_1d_flux_first( direction,      &
                                 field,          &
                                 dep_pts,        &
                                 detj_at_w2,     &
                                 order,          &
                                 dt,             &
                                 flux,           &
                                 increment )

    implicit none

    integer(i_def),   intent(in)    :: direction
    type(field_type), intent(in)    :: field
    type(field_type), intent(in)    :: dep_pts
    type(field_type), intent(in)    :: detj_at_w2
    integer(i_def),   intent(in)    :: order
    real(r_def),      intent(in)    :: dt
    type(field_type), intent(inout) :: flux
    type(field_type), intent(inout) :: increment

    ! Mass flux variables
    type(field_type) :: mass_flux
    type(field_type) :: difference

    ! Inverse mass matrix and stencil extent
    type(operator_type), pointer :: m3_inv => null()
    integer(kind=i_def)          :: stencil_extent
    integer(kind=i_def)          :: cfl_stencil_extent
    real(kind=r_def)             :: cfl_min, cfl_max

    call dep_pts%field_minmax(cfl_min, cfl_max)
    stencil_extent     = int( max( abs(cfl_max), abs(cfl_min) ) ) &
                         + 1 + order
    cfl_stencil_extent = int(stencil_extent)

    ! Get inverse mass matrix
    m3_inv => get_inverse_w3_mass_matrix(increment%get_mesh_id())

    call mass_flux%initialise( vector_space=dep_pts%get_function_space() )
    call difference%initialise( vector_space=field%get_function_space() )
    call invoke( setval_c(mass_flux,  0.0_r_def), &
                 setval_c(difference, 0.0_r_def) )

    ! Compute the flux, multiply by Det(J) to get the mass flux,
    ! take the difference and multiply by inverse mass matrix to get increment
    if (direction == x_direction) then
      call invoke( ffsl_flux_first_x_kernel_type( flux, field, stencil_extent,              &
                                                  dep_pts, order, cfl_stencil_extent, dt ), &
                   X_times_Y( mass_flux, flux, detj_at_w2 ),                                &
                   fv_divergence_x_kernel_type( difference, mass_flux ),                    &
                   dg_matrix_vector_kernel_type( increment, difference, m3_inv ) )
    else if (direction == y_direction) then
      call invoke( ffsl_flux_first_y_kernel_type( flux, field, stencil_extent, &
                                                  dep_pts, order, cfl_stencil_extent, dt ), &
                   X_times_Y( mass_flux, flux, detj_at_w2 ),                                &
                   fv_divergence_y_kernel_type( difference, mass_flux ),                    &
                   dg_matrix_vector_kernel_type( increment, difference, m3_inv ) )
    end if

    nullify( m3_inv )

  end subroutine ffsl_1d_flux_first


  !===========================================================================!
  !> @brief   Algorithm to calculate the final conservative form FFSL
  !!          increment in one horizontal dimension.
  !> @details The algorithm calculates the flux difference in the given direction.
  !!          The mass flux is calculated, then the difference taken to give the
  !!          increment. Inputs from steps in both x and y are required to get the
  !!          correct direction at cubed sphere panel edges.
  !!
  !> @param[in]     direction         Direction (x/y)
  !> @param[in]     field_x           Input field from steps in x
  !> @param[in]     field_y           Input field from steps in y
  !> @param[in]     dep_pts           Departure points in the chosen direction
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     dt                The model timestep length
  !> @param[in]     panel_id          Panel ID of the cells
  !> @param[in,out] flux              Horizontal flux. Included here to be
  !!                                  ready for #2997
  !> @param[in,out] increment         Conservative transport increment
  subroutine ffsl_1d_flux_final( direction,  &
                                 field_x,    &
                                 field_y,    &
                                 dep_pts,    &
                                 detj_at_w2, &
                                 order,      &
                                 dt,         &
                                 panel_id,   &
                                 flux,       &
                                 increment )

    implicit none

    integer(i_def),   intent(in)    :: direction
    type(field_type), intent(in)    :: field_x
    type(field_type), intent(in)    :: field_y
    type(field_type), intent(in)    :: dep_pts
    type(field_type), intent(in)    :: detj_at_w2
    integer(i_def),   intent(in)    :: order
    real(r_def),      intent(in)    :: dt
    type(field_type), intent(in)    :: panel_id
    type(field_type), intent(inout) :: flux
    type(field_type), intent(inout) :: increment

    ! Mass flux variables
    type(field_type) :: mass_flux
    type(field_type) :: difference

    ! Inverse mass matrix and stencil extent
    type(operator_type), pointer :: m3_inv => null()
    integer(kind=i_def)          :: stencil_extent
    integer(kind=i_def)          :: cfl_stencil_extent
    real(kind=r_def)             :: cfl_min, cfl_max

    call dep_pts%field_minmax(cfl_min, cfl_max)
    stencil_extent = int( max( abs(cfl_max), abs(cfl_min) ) ) &
                     + 1 + order
    cfl_stencil_extent = int(stencil_extent)

    ! Get inverse mass matrix
    m3_inv => get_inverse_w3_mass_matrix(increment%get_mesh_id())

    call mass_flux%initialise( vector_space=dep_pts%get_function_space() )
    call difference%initialise( vector_space=field_x%get_function_space() )
    call invoke( setval_c(mass_flux,  0.0_r_def), &
                 setval_c(difference, 0.0_r_def) )

    ! Compute the flux, multiply by Det(J) to get the mass flux,
    ! take the difference and multiply by inverse mass matrix to get increment
    if (direction == x_direction) then
      call invoke( ffsl_flux_final_x_kernel_type( flux, field_x, stencil_extent,            &
                                                  field_y, stencil_extent,                  &
                                                  panel_id, stencil_extent,                 &
                                                  dep_pts, order, cfl_stencil_extent, dt ), &
                   X_times_Y( mass_flux, flux, detj_at_w2 ),                                &
                   fv_divergence_x_kernel_type( difference, mass_flux ),                    &
                   dg_matrix_vector_kernel_type( increment, difference, m3_inv ) )
    else if (direction == y_direction) then
      call invoke( ffsl_flux_final_y_kernel_type( flux, field_x, stencil_extent,            &
                                                  field_y, stencil_extent,                  &
                                                  panel_id, stencil_extent,                 &
                                                  dep_pts, order, cfl_stencil_extent, dt ), &
                   X_times_Y( mass_flux, flux, detj_at_w2 ),                                &
                   fv_divergence_y_kernel_type( difference, mass_flux ),                    &
                   dg_matrix_vector_kernel_type( increment, difference, m3_inv ) )
    end if

    nullify( m3_inv )

  end subroutine ffsl_1d_flux_final


  !===========================================================================!
  !> @brief   Algorithm to calculate the conservative form FFSL increment in the vertical.
  !> @details The algorithm calculates the flux difference in the vertical,
  !!          giving a conservative increment d(w * q)/dz at the cell centre.
  !!
  !> @param[in]     field             Input tracer field
  !> @param[in]     dep_pts           Departure points in the chosen direction
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     dt                The model timestep length
  !> @param[in,out] flux              Vertical flux. Included here to be
  !!                                  ready for #2997
  !> @param[in,out] increment         Conservative transport increment
  subroutine ffsl_1d_flux_vert( field,          &
                                dep_pts,        &
                                detj_at_w2,     &
                                order,          &
                                dt,             &
                                flux,           &
                                increment )

    implicit none

    type(field_type), intent(in)    :: field
    type(field_type), intent(in)    :: dep_pts
    type(field_type), intent(in)    :: detj_at_w2
    integer(i_def),   intent(in)    :: order
    real(r_def),      intent(in)    :: dt
    type(field_type), intent(inout) :: flux
    type(field_type), intent(inout) :: increment

    ! Variables needed for reconstruction and flux
    type(field_type) :: mass_flux
    type(field_type) :: difference
    type(field_type) :: a0, a1, a2

    ! Pointers
    type(operator_type), pointer :: m3_inv => null()
    type(field_type),    pointer :: dz_w3 => null()

    ! Initialise variables
    call mass_flux%initialise( vector_space=flux%get_function_space() )
    call difference%initialise( vector_space=field%get_function_space() )
    call a0%initialise( vector_space=field%get_function_space() )
    call a1%initialise( vector_space=field%get_function_space() )
    call a2%initialise( vector_space=field%get_function_space() )
    call invoke( setval_c(mass_flux,  0.0_r_def), &
                 setval_c(difference, 0.0_r_def), &
                 setval_c(a0, 0.0_r_def),         &
                 setval_c(a1, 0.0_r_def),         &
                 setval_c(a2, 0.0_r_def) )

    ! Get inverse mass matrix and vertical spacing
    m3_inv => get_inverse_w3_mass_matrix(field%get_mesh_id())
    dz_w3 => get_dz_w3(field%get_mesh_id())

    ! Compute subgrid coefficients and compute the flux
    if (order == 0) then
      ! Constant reconstruction and flux
      call invoke( ffsl_vert_constant_flux_kernel_type(flux, dep_pts, field, dt) )
    else
      ! Compute PPM coefficients for reconstruction and compute flux
      call invoke( vert_ppm_no_limiter_kernel_type(a0, a1, a2, field, dz_w3), &
                   ffsl_vertical_flux_kernel_type(flux, dep_pts, field, a0, a1, a2, dt) )
    end if
    ! Multiply by Det(J) to get mass flux, take difference and multiply by inverse
    ! mass matrix to get increment
    call invoke( X_times_Y(mass_flux, flux, detj_at_w2),             &
                 fv_divergence_z_kernel_type(difference, mass_flux), &
                 dg_matrix_vector_kernel_type(increment, difference, m3_inv) )

    nullify( m3_inv, dz_w3 )

  end subroutine ffsl_1d_flux_vert

end module ffsl_1d_flux_alg_mod
