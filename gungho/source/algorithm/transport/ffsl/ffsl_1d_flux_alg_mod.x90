!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
!> @brief   One-dimensional vertical operator for the FFSL transport scheme.
!> @details This routine is required for the vertical flux-form semi-Lagrangian (FFSL)
!!          splitting. It provides the calculation of one dimensional flux
!!          differences.

module ffsl_1d_flux_alg_mod

  ! Constants and types
  use constants_mod,                  only: r_tran, i_def, l_def
  use fem_constants_mod,              only: get_inverse_w3_mass_matrix_r_tran
  use field_mod,                      only: field_type
  use r_tran_field_mod,               only: r_tran_field_type
  use geometric_constants_mod,        only: get_dz_w3
  use r_tran_operator_mod,            only: r_tran_operator_type
  use transport_enumerated_types_mod, only: vertical_monotone_none,      &
                                            vertical_monotone_strict,    &
                                            vertical_monotone_relaxed


  ! Kernels
  use ffsl_vertical_flux_kernel_mod,  only: ffsl_vertical_flux_kernel_type
  use ffsl_vert_constant_flux_kernel_mod, &
                                      only: ffsl_vert_constant_flux_kernel_type
  use fv_divergence_z_kernel_mod,     only: fv_divergence_z_kernel_type
  use vert_nirvana_kernel_mod,        only: vert_nirvana_kernel_type
  use vert_nirvana_reversible_kernel_mod, &
                                      only: vert_nirvana_reversible_kernel_type
  use vert_ppm_limiter_kernel_mod,    only: vert_ppm_limiter_kernel_type
  use vert_ppm_no_limiter_kernel_mod, only: vert_ppm_no_limiter_kernel_type
  use vert_ppm_strict_limiter_kernel_mod, &
                                      only: vert_ppm_strict_limiter_kernel_type

  use psykal_lite_mod,                only: invoke_dg_matrix_vector_rtran

  implicit none

  private

  public :: ffsl_1d_flux_vert

contains

  !===========================================================================!
  !> @brief   Algorithm to calculate the conservative form FFSL increment in the vertical.
  !> @details The algorithm calculates the flux difference in the vertical,
  !!          giving a conservative increment d(w * q)/dz at the cell centre.
  !!
  !> @param[in]     field             Input tracer field
  !> @param[in]     dep_pts           Departure points in the vertical direction
  !> @param[in]     detj_at_w2        Det(J) at W2v dofs
  !> @param[in]     order             Order of the reconstruction
  !> @param[in]     dt                The model timestep length
  !> @param[in]     log_space         Switch to use natural logarithmic space
  !!                                  for edge interpolation
  !> @param[in]     monotone          Vertical monotone option for FFSL
  !> @param[in]     reversible        Reversibility option for FFSL
  !> @param[in,out] mass_flux         Vertical mass flux
  !> @param[in,out] increment         Conservative transport increment
  subroutine ffsl_1d_flux_vert( field,      &
                                dep_pts,    &
                                detj_at_w2, &
                                order,      &
                                dt,         &
                                log_space,  &
                                monotone,   &
                                reversible, &
                                mass_flux,  &
                                increment )

    use psykal_lite_mod,               only: invoke_copy_to_rtran
    implicit none

    type(r_tran_field_type), intent(in)    :: field
    type(r_tran_field_type), intent(in)    :: dep_pts
    type(r_tran_field_type), intent(in)    :: detj_at_w2
    integer(i_def),          intent(in)    :: order
    real(r_tran),            intent(in)    :: dt
    logical(l_def),          intent(in)    :: log_space
    integer(i_def),          intent(in)    :: monotone
    logical(kind=l_def),     intent(in)    :: reversible
    type(r_tran_field_type), intent(inout) :: mass_flux
    type(r_tran_field_type), intent(inout) :: increment

    ! Variables needed for reconstruction and flux
    type(r_tran_field_type) :: flux
    type(r_tran_field_type) :: difference
    type(r_tran_field_type) :: a0, a1, a2

    ! Pointers
    type(r_tran_operator_type), pointer :: m3_inv => null()
    type(field_type),           pointer :: dz_w3_rdef => null()
    type(r_tran_field_type)             :: dz_w3

    ! Initialise variables
    call flux%initialise( vector_space=mass_flux%get_function_space() )
    call difference%initialise( vector_space=field%get_function_space() )
    call a0%initialise( vector_space=field%get_function_space() )
    call a1%initialise( vector_space=field%get_function_space() )
    call a2%initialise( vector_space=field%get_function_space() )
    call invoke( setval_c(flux, 0.0_r_tran),       &
                 setval_c(difference, 0.0_r_tran), &
                 setval_c(a0, 0.0_r_tran),         &
                 setval_c(a1, 0.0_r_tran),         &
                 setval_c(a2, 0.0_r_tran) )

    ! Get inverse mass matrix and vertical spacing
    m3_inv => get_inverse_w3_mass_matrix_r_tran(field%get_mesh_id())
    dz_w3_rdef => get_dz_w3(field%get_mesh_id())
    call dz_w3%initialise(vector_space = dz_w3_rdef%get_function_space() )
    call invoke_copy_to_rtran(dz_w3, dz_w3_rdef)

    ! Compute subgrid coefficients and compute the flux
    if (order == 0) then
      ! Constant reconstruction and flux
      call invoke( ffsl_vert_constant_flux_kernel_type(flux, dep_pts, field, dt) )
    else if (order == 1) then
      if (reversible) then
        ! Reversible Nirvana reconstruction
        call invoke( vert_nirvana_reversible_kernel_type( a0, a1, a2, field, &
                                                          dz_w3, monotone,   &
                                                          log_space ),       &
                     ffsl_vertical_flux_kernel_type( flux, dep_pts, field,   &
                                                     a0, a1, a2, dt ) )
      else
        ! Standard Nirvana reconstruction
        call invoke( vert_nirvana_kernel_type( a0, a1, a2, field, dz_w3,   &
                                               monotone ),                 &
                     ffsl_vertical_flux_kernel_type( flux, dep_pts, field, &
                                                     a0, a1, a2, dt) )
      end if
    else
      if ( monotone == vertical_monotone_none) then
        ! Compute unlimited PPM coefficients for reconstruction and compute flux
        call invoke( vert_ppm_no_limiter_kernel_type(a0, a1, a2, field,   &
                                                     dz_w3, log_space),   &
                     ffsl_vertical_flux_kernel_type(flux, dep_pts, field, &
                                                    a0, a1, a2, dt) )
      else if ( monotone == vertical_monotone_strict ) then
        ! Compute strict monotonic PPM coefficients for reconstruction and compute flux
        call invoke( vert_ppm_strict_limiter_kernel_type(a0, a1, a2, field, &
                                                         dz_w3, log_space), &
                     ffsl_vertical_flux_kernel_type(flux, dep_pts, field,   &
                                                    a0, a1, a2, dt) )
      else
        ! Compute relaxed monotonic PPM coefficients for reconstruction and compute flux
        call invoke( vert_ppm_limiter_kernel_type(a0, a1, a2, field,      &
                                                  dz_w3, log_space),      &
                     ffsl_vertical_flux_kernel_type(flux, dep_pts, field, &
                                                    a0, a1, a2, dt) )
      end if
    end if
    ! Multiply by Det(J) to get mass flux, take difference and multiply by inverse
    ! mass matrix to get increment
    call invoke( X_times_Y(mass_flux, flux, detj_at_w2), &
                 fv_divergence_z_kernel_type( difference, mass_flux ))
    call invoke_dg_matrix_vector_rtran(increment, difference, m3_inv)

    nullify( m3_inv, dz_w3_rdef )

  end subroutine ffsl_1d_flux_vert

end module ffsl_1d_flux_alg_mod
