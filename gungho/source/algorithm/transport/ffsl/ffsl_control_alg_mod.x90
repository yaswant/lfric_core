!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routines for managing FFSL transport schemes.

module ffsl_control_alg_mod

  ! Constants and types
  use constants_mod,                    only: i_def, r_tran, l_def
  use extrusion_mod,                    only: SHIFTED
  use field_mod,                        only: field_type
  use r_tran_field_mod,                 only: r_tran_field_type
  use function_space_collection_mod,    only: function_space_collection
  use function_space_mod,               only: function_space_type
  use fs_continuity_mod,                only: W2, W3, Wtheta, W2H, W2V
  use geometric_constants_mod,          only: get_panel_id
  use log_mod,                          only: log_event,       &
                                              LOG_LEVEL_INFO,  &
                                              LOG_LEVEL_ERROR, &
                                              LOG_LEVEL_WARNING
  use mesh_mod,                         only: mesh_type
  use mesh_collection_mod,              only: mesh_collection

  ! Algorithms
  use end_of_transport_step_alg_mod,    only: end_of_advective_step_alg, &
                                              end_of_conservative_step_alg
  use ffsl_1d_flux_alg_mod,             only: ffsl_1d_flux_vert
  use ffsl_1d_advect_alg_mod,           only: ffsl_1d_advect_vert
  use ffsl_1d_advect_then_flux_alg_mod, only: ffsl_1d_advect_then_flux_vert
  use ffsl_advective_transport_alg_mod, only: ffsl_advective_transport_alg, &
                                              ffsl_advective_horizontal_alg
  use ffsl_conservative_transport_alg_mod,                                     &
                                        only: ffsl_conservative_transport_alg, &
                                              ffsl_conservative_horizontal_alg

  ! Kernels
  use inject_sh_w3_to_wt_kernel_mod,    only: inject_sh_w3_to_wt_kernel_type
  use inject_wt_to_sh_w3_kernel_mod,    only: inject_wt_to_sh_w3_kernel_type
  use split_w2_field_kernel_mod,        only: split_w2_field_kernel_type

  ! Configs
  use finite_element_config_mod,        only: element_order
  use subgrid_config_mod,               only: outer_order
  use transport_config_mod,             only: dry_field_name

  ! Transport runtime
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_enumerated_types_mod,   only: direction_v,                 &
                                              direction_h,                 &
                                              direction_3d,                &
                                              horizontal_monotone_none,    &
                                              horizontal_monotone_strict,  &
                                              horizontal_monotone_relaxed, &
                                              splitting_strang_vhv,        &
                                              splitting_strang_hvh,        &
                                              vertical_monotone_none,      &
                                              vertical_monotone_strict,    &
                                              vertical_monotone_relaxed

  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  implicit none

  private

  public :: ffsl_conservative_control
  public :: ffsl_advective_control
  public :: ffsl_consistent_control

contains

  !=============================================================================
  !> @brief Controls 3D/vertical/horizontal conservative FFSL transport.
  !> @details Calls the conservative flux form semi-Lagrangian (FFSL) transport
  !!          scheme step after getting data from transport_metadata and
  !!          transport_runtime.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     direction          Either 3D/vertical/horizontal FFSL transport
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine ffsl_conservative_control(field_np1, field_n, direction, &
                                       step_dt, transport_metadata)

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    integer(kind=i_def),           intent(in)    :: direction
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    type(r_tran_field_type)          :: increment_con
    type(r_tran_field_type)          :: increment_adv
    type(r_tran_field_type), pointer :: detj_at_w2 => null()
    type(r_tran_field_type)          :: detj_at_w2h, &
                                        detj_at_w2v
    type(r_tran_field_type), pointer :: dep_pts_x_get => null()
    type(r_tran_field_type), pointer :: dep_pts_y_get => null()
    type(r_tran_field_type), pointer :: dep_pts_z_get => null()
    type(r_tran_field_type)          :: dep_pts_z, &
                                        dep_pts_x, &
                                        dep_pts_y
    type(r_tran_field_type)          :: flux_3d
    integer(kind=i_def)              :: mesh_id
    type(r_tran_field_type)          :: mass_flux
    logical(kind=l_def)              :: hori_half_flag
    logical(kind=l_def)              :: log_space
    logical(kind=l_def)              :: reversibility
    type(mesh_type),         pointer :: mesh => null()
    type(field_type),        pointer :: panel_id => null()
    integer(kind=i_def)              :: hori_monotone, vert_monotone
    type(function_space_type),    pointer :: w2_fs => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    call log_event('Conservative FFSL transport', LOG_LEVEL_INFO)

    ! Get Mesh ID and Panel ID
    mesh_id = field_n%get_mesh_id()
    panel_id => get_panel_id(mesh_id)

    ! Get transport_runtime and reversible option
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    log_space = transport_metadata%get_log_space()
    reversibility = transport_metadata%get_reversible()

    ! Get Det(J) and departure points
    detj_at_w2    => transport_runtime%get_detj_at_w2_transport(mesh_id)
    dep_pts_x_get => transport_runtime%get_departure_points_x_w2(mesh_id)
    dep_pts_y_get => transport_runtime%get_departure_points_y_w2(mesh_id)
    dep_pts_z_get => transport_runtime%get_departure_points_z_w2(mesh_id)
    call detj_at_w2h%initialise( vector_space = dep_pts_x_get%get_function_space() )
    call detj_at_w2v%initialise( vector_space = dep_pts_z_get%get_function_space() )
    call invoke( split_w2_field_kernel_type(detj_at_w2h, detj_at_w2v, detj_at_w2) )

    ! Copy departure points so they can be corrected if Strang splitting is used
    call dep_pts_x%initialise( vector_space = dep_pts_x_get%get_function_space() )
    call dep_pts_y%initialise( vector_space = dep_pts_y_get%get_function_space() )
    call dep_pts_z%initialise( vector_space = dep_pts_z_get%get_function_space() )
    call invoke( setval_X(dep_pts_z, dep_pts_z_get), &
                 setval_X(dep_pts_x, dep_pts_x_get), &
                 setval_X(dep_pts_y, dep_pts_y_get) )

    ! Set horizontal and vertical monotone options
    hori_monotone = transport_metadata%get_horizontal_monotone()
    vert_monotone = transport_metadata%get_vertical_monotone()
    ! Check that a valid monotone option has been selected based on direction
    if ( hori_monotone /= horizontal_monotone_none    .and. &
         hori_monotone /= horizontal_monotone_strict  .and. &
         hori_monotone /= horizontal_monotone_relaxed .and. &
         (direction == direction_3d .OR. direction == direction_h) ) then
      call log_event( "ffsl_control_alg: Invalid horizontal monotone option", LOG_LEVEL_ERROR )
    end if
    if ( vert_monotone /= vertical_monotone_none    .and. &
         vert_monotone /= vertical_monotone_strict  .and. &
         vert_monotone /= vertical_monotone_relaxed .and. &
         (direction == direction_3d .OR. direction == direction_v) ) then
      call log_event( "ffsl_control_alg: Invalid vertical monotone option", LOG_LEVEL_ERROR )
    end if

    call flux_3d%initialise( vector_space = dep_pts_x_get%get_function_space() )
    call increment_con%initialise( vector_space=field_n%get_function_space() )
    call increment_adv%initialise( vector_space=field_n%get_function_space() )
    call invoke( setval_c(increment_con, 0.0_r_tran), &
                 setval_c(increment_adv, 0.0_r_tran), &
                 setval_c(flux_3d,       0.0_r_tran) )

    ! Call routine based on direction: vertical; horizontal; or 3D.
    select case (direction)

      case (direction_v)
        w2_fs => function_space_collection%get_fs( mesh, element_order, W2V )
        call mass_flux%initialise( w2_fs )
        call invoke( setval_C(mass_flux, 0.0_r_tran) )
        ! If vertical scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_z) )
          hori_half_flag = .true.
        else
          hori_half_flag = .false.
        end if

        if (transport_runtime%get_tracer_step_ctr() /=  &
            transport_runtime%get_num_dry_steps()) then
          ! Not the last split step so do both advective and flux form
          call ffsl_1d_advect_then_flux_vert( field_n, dep_pts_z, detj_at_w2v, &
                                              outer_order, step_dt, log_space, &
                                              vert_monotone, hori_half_flag,   &
                                              reversibility, mass_flux,        &
                                              increment_con, increment_adv )
          ! Save advective as field_np1 for use in next split step
          call invoke( X_minus_bY( field_np1, field_n, step_dt, increment_adv) )
        else
          ! If not advective_then_flux just need flux increment
          call ffsl_1d_flux_vert( field_n, dep_pts_z, detj_at_w2v, outer_order, &
                                  step_dt, log_space, vert_monotone,            &
                                  reversibility, mass_flux, increment_con )
        end if

      case (direction_h)
        w2_fs => function_space_collection%get_fs( mesh, element_order, W2H )
        call mass_flux%initialise( w2_fs )
        call invoke( setval_C(mass_flux, 0.0_r_tran) )
        ! If horizontal scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_hvh ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_x), &
                       inc_a_times_X(0.5_r_tran, dep_pts_y) )
          hori_half_flag = .true.
        else
          hori_half_flag = .false.
        end if
        ! 2D FFSL
        if (transport_runtime%get_tracer_step_ctr() /=  &
            transport_runtime%get_num_dry_steps()) then
          ! Not the last split step so do both advective and flux form
          call ffsl_conservative_horizontal_alg( field_n, dep_pts_x, dep_pts_y,  &
                                                 detj_at_w2h, panel_id, step_dt, &
                                                 hori_monotone, hori_half_flag,  &
                                                 .true., mass_flux,              &
                                                 increment_con, increment_adv )
          ! Save advective as field_np1 for use in next split step
          call invoke( X_minus_bY( field_np1, field_n, step_dt, increment_adv) )
        else
          ! Last split step just requires flux form
          call ffsl_conservative_horizontal_alg( field_n, dep_pts_x, dep_pts_y,  &
                                                 detj_at_w2h, panel_id, step_dt, &
                                                 hori_monotone, hori_half_flag,  &
                                                 .false., mass_flux,             &
                                                 increment_con, increment_adv )

        end if

      case (direction_3d)
        ! 3D FFSL
        w2_fs => function_space_collection%get_fs( mesh, element_order, W2 )
        call mass_flux%initialise( w2_fs )
        call invoke( setval_C(mass_flux, 0.0_r_tran) )
        call ffsl_conservative_transport_alg( field_n, dep_pts_x, dep_pts_y,       &
                                              dep_pts_z, detj_at_w2h, detj_at_w2v, &
                                              panel_id, step_dt, log_space,        &
                                              hori_monotone, vert_monotone,        &
                                              reversibility, mass_flux, increment_con )

      case default
        call log_event( "Gungho: Unrecognized direction for transport.", LOG_LEVEL_ERROR )

    end select

    ! Include dt in the mass flux
    call invoke( inc_a_times_X(step_dt, mass_flux) )

    ! If this is the final step, field_np1 will be computed here from the fluxes
    ! over the whole transport step
    ! If this is not the final step, field_np1 already includes the *advective*
    ! increment, and may be adjusted to enforce min value or in blending zone
    call end_of_conservative_step_alg(field_np1, field_n, mass_flux, transport_metadata)

    nullify(transport_runtime, mesh, detj_at_w2, panel_id, &
            dep_pts_x_get, dep_pts_y_get, dep_pts_z_get, w2_fs)

  end subroutine ffsl_conservative_control


  !=============================================================================
  !> @brief Controls 3D/vertical/horizontal advective FFSL transport.
  !> @details Calls the advective flux form semi-Lagrangian (FFSL) transport
  !!          scheme step after getting data from transport_metadata and
  !!          transport_runtime.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     direction          Either 3D/vertical/horizontal FFSL transport
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine ffsl_advective_control(field_np1, field_n, direction, step_dt, &
                                    transport_metadata)

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    integer(kind=i_def),           intent(in)    :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    type(r_tran_field_type)          :: increment
    type(r_tran_field_type)          :: adv_increment
    type(r_tran_field_type)          :: field_to_adv
    type(r_tran_field_type), pointer :: detj_at_w2 => null()
    type(r_tran_field_type)          :: detj_at_w2h, &
                                        detj_at_w2v
    type(r_tran_field_type), pointer :: dep_pts_x_get => null()
    type(r_tran_field_type), pointer :: dep_pts_y_get => null()
    type(r_tran_field_type), pointer :: dep_pts_z_get => null()
    type(r_tran_field_type)          :: dep_pts_z, &
                                        dep_pts_x, &
                                        dep_pts_y
    integer(kind=i_def)       :: hori_monotone, vert_monotone
    logical(kind=l_def)       :: vert_half_flag
    logical(kind=l_def)       :: hori_half_flag
    logical(kind=l_def)       :: log_space
    logical(kind=l_def)       :: reversibility
    type(mesh_type),  pointer :: mesh => null()
    type(field_type), pointer :: panel_id => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    ! Mesh ID
    integer(kind=i_def) :: mesh_id

    ! Function Spaces
    integer(kind=i_def)                :: function_space
    type(function_space_type), pointer :: w3_shifted_fs => null()
    type(mesh_type),           pointer :: shifted_mesh => null()

    call log_event('Advective FFSL transport', LOG_LEVEL_INFO)

    ! Function space of the field to be advected
    function_space = field_n%which_function_space()

    if (function_space == Wtheta) then
      ! If Wtheta variable move onto shifted W3 mesh
      shifted_mesh => mesh_collection%get_mesh(field_n%get_mesh(), SHIFTED)
      w3_shifted_fs   => function_space_collection%get_fs(shifted_mesh, 0_i_def, W3)
      call field_to_adv%initialise( vector_space = w3_shifted_fs )
      call invoke( inject_wt_to_sh_w3_kernel_type(field_to_adv, field_n) )
    else
      ! Stay on current mesh
      call field_to_adv%initialise( field_n%get_function_space() )
      call invoke( setval_X(field_to_adv, field_n) )
    end if

    ! Mesh ID and Panel ID
    mesh_id = field_to_adv%get_mesh_id()
    panel_id => get_panel_id(mesh_id)

    ! Get transport_runtime and reversible option
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    log_space = transport_metadata%get_log_space()
    reversibility = transport_metadata%get_reversible()

    ! Get Det(J) and departure points
    detj_at_w2    => transport_runtime%get_detj_at_w2_transport(mesh_id)
    dep_pts_x_get => transport_runtime%get_departure_points_x_w2(mesh_id)
    dep_pts_y_get => transport_runtime%get_departure_points_y_w2(mesh_id)
    dep_pts_z_get => transport_runtime%get_departure_points_z_w2(mesh_id)
    call detj_at_w2h%initialise( vector_space = dep_pts_x_get%get_function_space() )
    call detj_at_w2v%initialise( vector_space = dep_pts_z_get%get_function_space() )
    call invoke( split_w2_field_kernel_type(detj_at_w2h, detj_at_w2v, detj_at_w2) )

    ! Copy departure points so they can be corrected if Strang splitting is used
    call dep_pts_x%initialise( vector_space = dep_pts_x_get%get_function_space() )
    call dep_pts_y%initialise( vector_space = dep_pts_y_get%get_function_space() )
    call dep_pts_z%initialise( vector_space = dep_pts_z_get%get_function_space() )
    call invoke( setval_X(dep_pts_z, dep_pts_z_get), &
                 setval_X(dep_pts_x, dep_pts_x_get), &
                 setval_X(dep_pts_y, dep_pts_y_get) )

    ! Set horizontal and vertical monotone options, checking that a valid option has been selected
    hori_monotone = transport_metadata%get_horizontal_monotone()
    vert_monotone = transport_metadata%get_vertical_monotone()
    if ( hori_monotone /= horizontal_monotone_none    .and. &
         hori_monotone /= horizontal_monotone_strict  .and. &
         hori_monotone /= horizontal_monotone_relaxed .and. &
         (direction == direction_3d .OR. direction == direction_h) ) then
      call log_event( "ffsl_control_alg: Invalid horizontal monotone option", LOG_LEVEL_ERROR )
    end if
    if ( vert_monotone /= vertical_monotone_none    .and. &
         vert_monotone /= vertical_monotone_strict  .and. &
         vert_monotone /= vertical_monotone_relaxed .and. &
         (direction == direction_3d .OR. direction == direction_v) ) then
      call log_event( "ffsl_control_alg: Invalid vertical monotone option", LOG_LEVEL_ERROR )
    end if

    call increment%initialise( vector_space=field_to_adv%get_function_space() )
    call invoke( setval_c(increment, 0.0_r_tran) )

    ! Call routine based on direction: vertical; horizontal; or 3D.
    select case (direction)

      case (direction_v)
        ! If vertical scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_z) )
          vert_half_flag = .true.
        else
          vert_half_flag = .false.
        end if
        ! Vertical PPM scheme
        call ffsl_1d_advect_vert( field_to_adv, dep_pts_z, detj_at_w2v, outer_order, &
                                  step_dt, log_space, vert_monotone, vert_half_flag, &
                                  reversibility, increment )

      case (direction_h)
        ! If horizontal scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_hvh ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_x), &
                       inc_a_times_X(0.5_r_tran, dep_pts_y) )
          hori_half_flag = .true.
        else
          hori_half_flag = .false.
        end if
        ! 2D FFSL
        call ffsl_advective_horizontal_alg( field_to_adv, dep_pts_x, dep_pts_y, &
                                            detj_at_w2h, panel_id, step_dt,     &
                                            hori_monotone, hori_half_flag, increment )

      case (direction_3d)
        ! 3D FFSL
        call ffsl_advective_transport_alg( field_to_adv, dep_pts_x, dep_pts_y,  &
                                           dep_pts_z, detj_at_w2h, detj_at_w2v, &
                                           panel_id, step_dt, log_space,        &
                                           hori_monotone, vert_monotone,        &
                                           reversibility, increment )

      case default
        call log_event( "Gungho: Unrecognized direction for transport.", LOG_LEVEL_ERROR )

    end select

    if (function_space == Wtheta) then
      ! If Wtheta variable move back to Wtheta mesh
      call adv_increment%initialise( field_n%get_function_space() )
      call invoke( inject_sh_w3_to_wt_kernel_type(adv_increment, increment) )
    else
      ! Stay on current mesh
      call adv_increment%initialise( field_n%get_function_space() )
      call invoke( setval_X(adv_increment, increment) )
    end if

    call invoke( X_minus_bY( field_np1, field_n, step_dt, adv_increment) )

    ! End of step: if necessary enforce min val and overwrite in blending zone
    call end_of_advective_step_alg(field_np1, field_n, transport_metadata)

    nullify(transport_runtime, mesh, detj_at_w2, panel_id, &
            dep_pts_x_get, dep_pts_y_get, dep_pts_z_get)

  end subroutine ffsl_advective_control

  !=============================================================================
  !> @brief Controls consistent and conservative FFSL transport.
  !> @details Calls the transport step for the consistent and conservative flux
  !!          form semi-Lagrangian (FFSL), based on options in the
  !!          transport_metadata.
  !!          NOTE: The proper consistent scheme has not yet been implemented,
  !!          so this is currently a wrapper around standard conservative FFSL.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     direction          Either 3D/vertical/horizontal FFSL transport
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine ffsl_consistent_control(field_np1, field_n, direction, &
                                     step_dt, transport_metadata)

    use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    integer(kind=i_def),           intent(in)    :: direction
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    integer(kind=i_def)                   :: split_step
    real(kind=r_tran)                     :: min_value
    type(r_tran_field_type)               :: field_sh_w3_n, field_sh_w3_np1
    type(r_tran_field_type)               :: rho_X_n, rho_X_np1
    type(r_tran_field_type),      pointer :: rho_d_n => null()
    type(r_tran_field_type),      pointer :: rho_d_np1 => null()
    type(mesh_type),              pointer :: primary_mesh => null()
    type(mesh_type),              pointer :: shifted_mesh => null()
    type(function_space_type),    pointer :: w3_shifted_fs => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    call log_event('Consistent FFSL not yet implemented. ' // &
                   'Defaulting to conservative FFSL', LOG_LEVEL_WARNING)

    ! Check field is in Wtheta
    if (field_n%which_function_space() /= Wtheta) then
      call log_event('Consistent FFSL only implemented for Wtheta variables', &
                     LOG_LEVEL_ERROR)
    end if

    primary_mesh => field_n%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)

    w3_shifted_fs => function_space_collection%get_fs(shifted_mesh, 0, W3)

    ! Get transport runtime
    transport_runtime => get_transport_runtime(primary_mesh)

    call field_sh_w3_n%initialise( w3_shifted_fs )
    call field_sh_w3_np1%initialise( w3_shifted_fs )
    call rho_X_n%initialise( w3_shifted_fs )
    call rho_X_np1%initialise( w3_shifted_fs )

    ! Get dry density from transport runtime, for this split step
    split_step = transport_runtime%get_tracer_step_ctr()
    rho_d_n => transport_runtime%get_rho_d_n(shifted_mesh%get_id(), split_step)
    rho_d_np1 => transport_runtime%get_rho_d_np1(shifted_mesh%get_id(), split_step)

    ! ------------------------------------------------------------------------ !
    ! Turn field into density on shifted mesh
    ! ------------------------------------------------------------------------ !

    call invoke( inject_wt_to_sh_w3_kernel_type(field_sh_w3_n, field_n), &
                 X_times_Y(rho_X_n, field_sh_w3_n, rho_d_n) )

    ! We need the density at the start of the whole transport step, for the
    ! final call to end_of_conservative_step_alg. The mixing ratio is stored by
    ! default, so need to overwrite this. So if this is the first split step
    ! we do this here.
    if (transport_runtime%get_tracer_step_ctr() == 1) then
      call transport_runtime%set_field_n(rho_X_n)
    end if

    ! ------------------------------------------------------------------------ !
    ! Actually transport density using standard conservative FFSL
    ! ------------------------------------------------------------------------ !

    call ffsl_conservative_control(rho_X_np1, rho_X_n, direction, &
                                   step_dt, transport_metadata)

    ! -------------------------------------------------------------------- !
    ! Return from density on shifted mesh to field in Wtheta
    ! -------------------------------------------------------------------- !

    call invoke( X_divideby_Y(field_sh_w3_np1, rho_X_np1, rho_d_np1) )
    ! Turn back to Wtheta. This kernel needs to be in a separate invoke as
    ! the target field is on different mesh to that in previous kernel, so
    ! needs to extract a different "nlayers"
    call invoke( inject_sh_w3_to_wt_kernel_type(field_np1, field_sh_w3_np1) )
    ! This could lead to negative values at top so enforce lower bound
    if ( transport_metadata%get_enforce_min_value() ) then
      min_value = transport_metadata%get_min_value()
      call invoke( enforce_lower_bound_kernel_type(field_np1, min_value) )
    end if

    nullify(transport_runtime, primary_mesh, shifted_mesh, rho_d_n, rho_d_np1)

  end subroutine ffsl_consistent_control

end module ffsl_control_alg_mod
