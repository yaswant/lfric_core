!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routines for managing FFSL transport schemes.

module ffsl_control_alg_mod

  ! Constants and types
  use constants_mod,                    only: i_def, r_tran, l_def
  use extrusion_mod,                    only: SHIFTED
  use field_mod,                        only: field_type
  use r_tran_field_mod,                 only: r_tran_field_type
  use function_space_collection_mod,    only: function_space_collection
  use function_space_mod,               only: function_space_type
  use fs_continuity_mod,                only: W2, W3, Wtheta
  use geometric_constants_mod,          only: get_panel_id
  use log_mod,                          only: log_event,      &
                                              LOG_LEVEL_INFO, &
                                              LOG_LEVEL_ERROR
  use mesh_mod,                         only: mesh_type
  use mesh_collection_mod,              only: mesh_collection

  ! Algorithms
  use ffsl_1d_flux_alg_mod,             only: ffsl_1d_flux_vert
  use ffsl_1d_advect_alg_mod,           only: ffsl_1d_advect_vert
  use ffsl_1d_advect_then_flux_alg_mod, only: ffsl_1d_advect_then_flux_vert
  use ffsl_advective_transport_alg_mod, only: ffsl_advective_transport_alg, &
                                              ffsl_advective_horizontal_alg
  use ffsl_conservative_transport_alg_mod,                                     &
                                        only: ffsl_conservative_transport_alg, &
                                              ffsl_conservative_horizontal_alg

  ! Kernels
  use inject_sh_w3_to_wt_kernel_mod,    only: inject_sh_w3_to_wt_kernel_type
  use inject_wt_to_sh_w3_kernel_mod,    only: inject_wt_to_sh_w3_kernel_type

  ! Configs
  use finite_element_config_mod,        only: element_order
  use subgrid_config_mod,               only: outer_order
  use transport_config_mod,             only: dry_field_name, &
                                              advective_then_flux

  ! Transport runtime
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_enumerated_types_mod,   only: direction_v,          &
                                              direction_h,          &
                                              direction_3d,         &
                                              splitting_strang_vhv, &
                                              splitting_strang_hvh

  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  implicit none

  private

  public :: ffsl_conservative_control
  public :: ffsl_advective_control

contains

  !=============================================================================
  !> @brief Controls 3D/vertical/horizontal conservative FFSL transport.
  !> @details Calls the conservative flux form semi-Lagrangian (FFSL) transport
  !!          scheme step after getting data from transport_metadata and
  !!          transport_runtime.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     direction          Either 3D/vertical/horizontal FFSL transport
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine ffsl_conservative_control(field_np1, field_n, direction, &
                                       step_dt, transport_metadata)

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    integer(kind=i_def),           intent(in)    :: direction
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    type(r_tran_field_type)          :: increment
    type(r_tran_field_type)          :: increment_con
    type(r_tran_field_type)          :: increment_adv
    type(r_tran_field_type)          :: flux_z
    type(r_tran_field_type)          :: flux_inc
    type(r_tran_field_type), pointer :: detj_at_w2 => null()
    type(r_tran_field_type), pointer :: dep_pts_x_get => null()
    type(r_tran_field_type), pointer :: dep_pts_y_get => null()
    type(r_tran_field_type), pointer :: dep_pts_z_get => null()
    type(r_tran_field_type)          :: dep_pts_z, &
                                        dep_pts_x, &
                                        dep_pts_y
    type(r_tran_field_type)          :: flux
    logical(kind=l_def)              :: hori_half_flag
    integer(kind=i_def)              :: step, mesh_id
    real(kind=r_tran)                :: minus_step_dt
    type(r_tran_field_type), pointer :: field_start => null()
    type(r_tran_field_type), pointer :: old_flux_inc => null()
    type(mesh_type),         pointer :: mesh => null()
    type(field_type),        pointer :: panel_id => null()
    type(function_space_type),    pointer :: w2_fs => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    call log_event('Conservative FFSL transport', LOG_LEVEL_INFO)

    ! Get Mesh ID and Panel ID
    mesh_id = field_n%get_mesh_id()
    panel_id => get_panel_id(mesh_id)

    ! Get transport_runtime
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Get Det(J) and departure points
    detj_at_w2    => transport_runtime%get_detj_at_w2_transport(mesh_id)
    dep_pts_x_get => transport_runtime%get_departure_points_x_w2(mesh_id)
    dep_pts_y_get => transport_runtime%get_departure_points_y_w2(mesh_id)
    dep_pts_z_get => transport_runtime%get_departure_points_z_w2(mesh_id)

    ! Copy departure points so they can be corrected if Strang splitting is used
    call dep_pts_x%initialise( vector_space = dep_pts_x_get%get_function_space() )
    call dep_pts_y%initialise( vector_space = dep_pts_y_get%get_function_space() )
    call dep_pts_z%initialise( vector_space = dep_pts_z_get%get_function_space() )
    ! Use copy instead of setval_X for horizontal as we need to preserve halo values
    call invoke( setval_X(dep_pts_z, dep_pts_z_get) )
    call dep_pts_x_get%copy_field(dep_pts_x)
    call dep_pts_y_get%copy_field(dep_pts_y)

    call increment%initialise( vector_space=field_n%get_function_space() )
    call increment_con%initialise( vector_space=field_n%get_function_space() )
    call increment_adv%initialise( vector_space=field_n%get_function_space() )
    call invoke( setval_c(increment, 0.0_r_tran),     &
                 setval_c(increment_con, 0.0_r_tran), &
                 setval_c(increment_adv, 0.0_r_tran) )
    call invoke( setval_c(increment, 0.0_r_tran) )

    ! Call routine based on direction: vertical; horizontal; or 3D.
    select case (direction)

      case (direction_v)
        ! If vertical scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_z) )
          hori_half_flag = .true.
        else
          hori_half_flag = .false.
        end if
        ! Vertical PPM routine requires a flux output to be ready for #2997
        call flux_z%initialise( vector_space=dep_pts_z%get_function_space() )
        call invoke( setval_c(flux_z, 0.0_r_tran) )

        if (advective_then_flux) then
          ! Set up flux_inc and -dt
          minus_step_dt = -1.0_r_tran * step_dt
          call flux_inc%initialise( increment%get_function_space() )

          if (transport_runtime%get_tracer_step_ctr() /=  &
              transport_runtime%get_num_dry_steps()) then
            ! Not the last split step so do both advective and flux form
            call ffsl_1d_advect_then_flux_vert( field_n, dep_pts_z, detj_at_w2,       &
                                                outer_order, step_dt, hori_half_flag, &
                                                flux_z, increment_con, increment_adv )
            ! Save advective as field_np1 for use in next split step
            call invoke( X_minus_bY( field_np1, field_n, step_dt, increment_adv) )
            ! Save flux_inc for final splitting step
            call invoke( a_times_X(flux_inc, minus_step_dt, increment_con) )
          else
            ! Last split step just requires flux form
            call ffsl_1d_flux_vert( field_n, dep_pts_z, detj_at_w2, outer_order, &
                                    step_dt, flux_z, increment )
            call invoke( a_times_X(flux_inc, minus_step_dt, increment) )
            ! Add all the flux increments together
            field_start => transport_runtime%get_field_n(mesh_id)
            call invoke( X_plus_Y(field_np1, field_start, flux_inc) )
            do step = 1, transport_runtime%get_num_dry_steps() - 1
              old_flux_inc => transport_runtime%get_flux_inc(mesh_id, step)
              call invoke( inc_X_plus_Y(field_np1, old_flux_inc) )
            end do
          end if
          call transport_runtime%set_flux_inc(flux_inc)

        else
          ! If not advective_then_flux just need flux increment
          call ffsl_1d_flux_vert( field_n, dep_pts_z, detj_at_w2, outer_order, &
                                  step_dt, flux_z, increment )
          ! Get field_np1 from field_n and conservative increment
          call invoke( X_minus_bY( field_np1, field_n, step_dt, increment) )
        end if

      case (direction_h)
        ! If horizontal scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_hvh ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_x), &
                       inc_a_times_X(0.5_r_tran, dep_pts_y) )
          hori_half_flag = .true.
        else
          hori_half_flag = .false.
        end if
        ! 2D FFSL
        if (advective_then_flux) then
          ! Set up flux_inc and -dt
          minus_step_dt = -1.0_r_tran * step_dt
          call flux_inc%initialise( increment%get_function_space() )

          if (transport_runtime%get_tracer_step_ctr() /=  &
              transport_runtime%get_num_dry_steps()) then
            ! Not the last split step so do both advective and flux form
            call ffsl_conservative_horizontal_alg( field_n, dep_pts_x, dep_pts_y, &
                                                   detj_at_w2, panel_id, step_dt, &
                                                   hori_half_flag, .true.,        &
                                                   increment_con, increment_adv )
            ! Save advective as field_np1 for use in next split step
            call invoke( X_minus_bY( field_np1, field_n, step_dt, increment_adv) )
            ! Save flux_inc for final splitting step
            call invoke( a_times_X(flux_inc, minus_step_dt, increment_con) )
          else
            ! Last split step just requires flux form
            call ffsl_conservative_horizontal_alg( field_n, dep_pts_x, dep_pts_y, &
                                                   detj_at_w2, panel_id, step_dt, &
                                                   hori_half_flag, .false.,       &
                                                   increment, increment_adv )
            call invoke( a_times_X(flux_inc, minus_step_dt, increment) )
            ! Add all the flux increments together
            field_start => transport_runtime%get_field_n(mesh_id)
            call invoke( X_plus_Y(field_np1, field_start, flux_inc) )
            do step = 1, transport_runtime%get_num_dry_steps() - 1
              old_flux_inc => transport_runtime%get_flux_inc(mesh_id, step)
              call invoke( inc_X_plus_Y(field_np1, old_flux_inc) )
            end do
          end if
          call transport_runtime%set_flux_inc(flux_inc)

        else
          ! If not advective_then_flux just need flux increment
          call ffsl_conservative_horizontal_alg( field_n, dep_pts_x, dep_pts_y, &
                                                 detj_at_w2, panel_id, step_dt, &
                                                 hori_half_flag, .false.,       &
                                                 increment, increment_adv )
          ! Get field_np1 from field_n and conservative increment
          call invoke( X_minus_bY( field_np1, field_n, step_dt, increment) )
        end if

      case (direction_3d)
        ! 3D FFSL
        call ffsl_conservative_transport_alg( field_n, dep_pts_x, dep_pts_y, &
                                              dep_pts_z, detj_at_w2,         &
                                              panel_id, step_dt,             &
                                              increment )

        ! Get field_np1 from field_n and increment
        call invoke( X_minus_bY( field_np1, field_n, step_dt, increment) )

      case default
        call log_event( "Gungho: Unrecognized direction for transport.", LOG_LEVEL_ERROR )

    end select

    ! Store field in transport_runtime for conservative transport
    ! if this is the underlying dry field
    if (trim(transport_metadata%get_name()) == trim(dry_field_name)) then
      ! TODO: #2997 compute flux and set dry fields in transport runtime
      ! Initialise flux -- following #2997 this should be done earlier
      ! in this algorithm
      w2_fs => function_space_collection%get_fs( mesh, element_order, W2 )
      call flux%initialise( w2_fs )
      call invoke( setval_c(flux, 0.0_r_tran) )
      call transport_runtime%set_dry_fields(field_n, field_np1, flux)
      nullify(w2_fs)
    end if

    call transport_runtime%inc_tracer_step_ctr()

    nullify(transport_runtime, mesh, detj_at_w2, panel_id, &
            dep_pts_x_get, dep_pts_y_get, dep_pts_z_get)

  end subroutine ffsl_conservative_control


  !=============================================================================
  !> @brief Controls 3D/vertical/horizontal advective FFSL transport.
  !> @details Calls the advective flux form semi-Lagrangian (FFSL) transport
  !!          scheme step after getting data from transport_metadata and
  !!          transport_runtime.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     direction          Either 3D/vertical/horizontal FFSL transport
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine ffsl_advective_control(field_np1, field_n, direction, step_dt, &
                                    transport_metadata)

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    integer(kind=i_def),           intent(in)    :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    type(r_tran_field_type)          :: increment
    type(r_tran_field_type)          :: adv_increment
    type(r_tran_field_type)          :: field_to_adv
    type(r_tran_field_type), pointer :: detj_at_w2 => null()
    type(r_tran_field_type), pointer :: dep_pts_x_get => null()
    type(r_tran_field_type), pointer :: dep_pts_y_get => null()
    type(r_tran_field_type), pointer :: dep_pts_z_get => null()
    type(r_tran_field_type)          :: dep_pts_z, &
                                        dep_pts_x, &
                                        dep_pts_y
    logical(kind=l_def)       :: vert_half_flag
    logical(kind=l_def)       :: hori_half_flag
    type(mesh_type),  pointer :: mesh => null()
    type(field_type), pointer :: panel_id => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    ! Mesh ID
    integer(kind=i_def) :: mesh_id

    ! Function Spaces
    integer(kind=i_def)                :: function_space
    type(function_space_type), pointer :: w3_shifted_fs => null()
    type(mesh_type),           pointer :: shifted_mesh => null()

    call log_event('Advective FFSL transport', LOG_LEVEL_INFO)

    ! Function space of the field to be advected
    function_space = field_n%which_function_space()

    if (function_space == Wtheta) then
      ! If Wtheta variable move onto shifted W3 mesh
      shifted_mesh => mesh_collection%get_mesh(field_n%get_mesh(), SHIFTED)
      w3_shifted_fs   => function_space_collection%get_fs(shifted_mesh, 0_i_def, W3)
      call field_to_adv%initialise( vector_space = w3_shifted_fs )
      call invoke( inject_wt_to_sh_w3_kernel_type(field_to_adv, field_n) )
    else
      ! Stay on current mesh
      call field_to_adv%initialise( field_n%get_function_space() )
      call invoke( setval_X(field_to_adv, field_n) )
    end if

    ! Mesh ID and Panel ID
    mesh_id = field_to_adv%get_mesh_id()
    panel_id => get_panel_id(mesh_id)

    ! Get transport_runtime
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Get Det(J) and departure points
    detj_at_w2    => transport_runtime%get_detj_at_w2_transport(mesh_id)
    dep_pts_x_get => transport_runtime%get_departure_points_x_w2(mesh_id)
    dep_pts_y_get => transport_runtime%get_departure_points_y_w2(mesh_id)
    dep_pts_z_get => transport_runtime%get_departure_points_z_w2(mesh_id)

    ! Copy departure points so they can be corrected if Strang splitting is used
    call dep_pts_x%initialise( vector_space = dep_pts_x_get%get_function_space() )
    call dep_pts_y%initialise( vector_space = dep_pts_y_get%get_function_space() )
    call dep_pts_z%initialise( vector_space = dep_pts_z_get%get_function_space() )
    ! Use copy instead of setval_X for horizontal as we need to preserve halo values
    call invoke( setval_X(dep_pts_z, dep_pts_z_get) )
    call dep_pts_x_get%copy_field(dep_pts_x)
    call dep_pts_y_get%copy_field(dep_pts_y)

    call increment%initialise( vector_space=field_to_adv%get_function_space() )
    call invoke( setval_c(increment, 0.0_r_tran) )

    ! Call routine based on direction: vertical; horizontal; or 3D.
    select case (direction)

      case (direction_v)
        ! If vertical scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_z) )
          vert_half_flag = .true.
        else
          vert_half_flag = .false.
        end if
        ! Vertical PPM scheme
        call ffsl_1d_advect_vert( field_to_adv, dep_pts_z, detj_at_w2, outer_order, &
                                  step_dt, vert_half_flag, increment )

      case (direction_h)
        ! If horizontal scheme for Strang splitting divide departure distance by 2
        if ( transport_metadata%get_splitting() ==  splitting_strang_hvh ) then
          call invoke( inc_a_times_X(0.5_r_tran, dep_pts_x), &
                       inc_a_times_X(0.5_r_tran, dep_pts_y) )
          hori_half_flag = .true.
        else
          hori_half_flag = .false.
        end if
        ! 2D FFSL
        call ffsl_advective_horizontal_alg( field_to_adv, dep_pts_x, dep_pts_y, &
                                            detj_at_w2, panel_id, step_dt,      &
                                            hori_half_flag, increment )

      case (direction_3d)
        ! 3D FFSL
        call ffsl_advective_transport_alg( field_to_adv, dep_pts_x, dep_pts_y, &
                                           dep_pts_z, detj_at_w2, panel_id,    &
                                           step_dt, increment )

      case default
        call log_event( "Gungho: Unrecognized direction for transport.", LOG_LEVEL_ERROR )

    end select

    if (function_space == Wtheta) then
      ! If Wtheta variable move back to Wtheta mesh
      call adv_increment%initialise( field_n%get_function_space() )
      call invoke( inject_sh_w3_to_wt_kernel_type(adv_increment, increment) )
    else
      ! Stay on current mesh
      call adv_increment%initialise( field_n%get_function_space() )
      call invoke( setval_X(adv_increment, increment) )
    end if

    call invoke( X_minus_bY( field_np1, field_n, step_dt, adv_increment) )

    nullify(transport_runtime, mesh, detj_at_w2, panel_id, &
            dep_pts_x_get, dep_pts_y_get, dep_pts_z_get)

  end subroutine ffsl_advective_control

end module ffsl_control_alg_mod
