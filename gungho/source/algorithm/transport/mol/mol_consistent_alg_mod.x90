!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains MOL routine for consistent conservative transport equation.

module mol_consistent_alg_mod

  use constants_mod,                  only: r_tran, i_def, l_def
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use end_of_transport_step_alg_mod,  only: end_of_consistent_step_alg
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type
  use extrusion_mod,                  only: SHIFTED
  use advective_and_flux_alg_mod,     only: advective_and_flux_alg
  use field_mod,                      only: field_type
  use r_tran_field_mod,               only: r_tran_field_type
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W3, Wtheta
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use io_config_mod,                  only: subroutine_timers
  use inject_sh_w3_to_wt_kernel_mod,  only: inject_sh_w3_to_wt_kernel_type
  use inject_wt_to_sh_w3_kernel_mod,  only: inject_wt_to_sh_w3_kernel_type
  use log_mod,                        only: log_event, LOG_LEVEL_ERROR, &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use r_tran_operator_mod,            only: r_tran_operator_type
  use runge_kutta_init_mod,           only: get_rk_transport_weights
  use timer_mod,                      only: timer
  use transport_config_mod,           only: runge_kutta_method
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_runtime_alg_mod,      only: transport_runtime_type
  use transport_runtime_collection_mod,   &
                                      only: get_transport_runtime
  use boundaries_config_mod,          only: limited_area, transport_boundary_depth
  use limited_area_lbc_alg_mod,       only: overwrite_blending_zone_rtran
  use base_mesh_config_mod,           only: topology, topology_non_periodic
  use psykal_lite_mod,                only: invoke_dg_matrix_vector_rtran

  implicit none

  public  :: mol_consistent_alg

  contains

  !> @brief Transporting (consistent-form) of a field with the MOL scheme.
  !> @details Performs a whole time step transport, solving the consistent,
  !!          conservative transport equation for a mixing ratio field. This
  !!          involves computing the density corresponding to the mixing ratio
  !!          on a shifted mesh, but using the pre-computed dry mass flux and
  !!          the mixing ratio to build the flux for the new density field.
  !> @param[in,out] mr_np1     Mixing ratio on prime mesh at end of time step
  !> @param[in]     mr_in      Mixing ratio on prime mesh at start of transport step
  !> @param[in]     direction  Direction of advection (vertical, horizontal, or 3d)
  !> @param[in]     transport_metadata
  !!                           Contains the configuration options for
  !!                           transporting these fields
  subroutine mol_consistent_alg( mr_np1, mr_in, direction, transport_metadata )

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: mr_np1
    type(r_tran_field_type),       intent(in)    :: mr_in
    integer(kind=i_def),           intent(in)    :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! ------------------------------------------------------------------------ !
    ! Internal variables
    ! ------------------------------------------------------------------------ !
    integer(kind=i_def)                :: prime_extrusion_mesh_id
    integer(kind=i_def)                :: shifted_mesh_id
    integer(kind=i_def)                :: mr_function_space
    integer(kind=i_def)                :: stage, s
    integer(kind=i_def)                :: substep, transport_step
    integer(kind=i_def)                :: nstage_this_substep
    integer(kind=i_def)                :: nstage, number_substeps
    logical(kind=l_def)                :: enforce_min_value
    logical(kind=l_def)                :: final_rk_stage
    logical(kind=l_def)                :: final_substep
    logical(kind=l_def)                :: final_split_step
    real(kind=r_tran)                  :: dt_substep, scaling
    real(kind=r_tran),     allocatable :: rk_weights(:,:)
    type(function_space_type), pointer :: w3_sh_fs => null()
    type(function_space_type), pointer :: w2_sh_fs => null()
    type(function_space_type), pointer :: wt_fs => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(r_tran_field_type),          pointer :: prime_advecting_wind => null()
    type(r_tran_field_type),          pointer :: dry_flux => null()
    type(r_tran_field_type)                   :: flux_X
    type(r_tran_field_type)                   :: mr_sh_w3_for_flux, mr_for_flux
    type(r_tran_field_type)                   :: mr_n
    type(r_tran_field_type)                   :: rhs_adv, rhs_flux, rhs_field
    type(r_tran_field_type),      allocatable :: rk_field(:)
    type(mesh_type),                  pointer :: prime_extrusion_mesh => null()
    type(mesh_type),                  pointer :: shifted_mesh => null()
    type(transport_runtime_type),     pointer :: transport_runtime => null()
    type(r_tran_field_type)                   :: dummy

    ! ------------------------------------------------------------------------ !
    if ( subroutine_timers ) call timer('mol_consistent_alg')
    ! ------------------------------------------------------------------------ !
    ! Get all the stuff needed by the transport algorithm
    ! ------------------------------------------------------------------------ !

    prime_extrusion_mesh => mr_in%get_mesh()
    prime_extrusion_mesh_id = prime_extrusion_mesh%get_id()
    mr_function_space = mr_in%which_function_space()

    transport_runtime => get_transport_runtime(prime_extrusion_mesh)
    transport_step = transport_runtime%get_tracer_step_ctr()
    prime_advecting_wind => transport_runtime%get_directional_advecting_wind(prime_extrusion_mesh_id, direction)

    call get_rk_transport_weights( nstage, rk_weights, runge_kutta_method )
    allocate( rk_field(nstage) )

    ! Set up variables depending on mixing ratio space
    select case ( mr_function_space )
    case ( W3 )
      ! No need for shifted mesh
      w3_fs => mr_in%get_function_space()
      dry_flux => transport_runtime%get_dry_flux(prime_extrusion_mesh_id, transport_step)
      w2_fs => dry_flux%get_function_space()

      call flux_X%initialise( vector_space = w2_fs )
      call mr_n%initialise( vector_space = w3_fs )
      call mr_for_flux%initialise( vector_space = w3_fs )
      call rhs_flux%initialise( vector_space = w3_fs )
      call rhs_adv%initialise( vector_space = w3_fs )
      call rhs_field%initialise( vector_space = w3_fs )
      do stage = 1, nstage
        call rk_field(stage)%initialise( vector_space = w3_fs )
      end do

    case ( Wtheta )
      ! We need the shifted mesh
      shifted_mesh => mesh_collection%get_mesh(prime_extrusion_mesh, SHIFTED)
      shifted_mesh_id = shifted_mesh%get_id()
      wt_fs => mr_in%get_function_space()
      w3_sh_fs => function_space_collection%get_fs(shifted_mesh, element_order, W3)
      dry_flux => transport_runtime%get_dry_flux(shifted_mesh_id, transport_step)
      w2_sh_fs => dry_flux%get_function_space()

      call flux_X%initialise( vector_space = w2_sh_fs )
      call mr_n%initialise( vector_space = wt_fs )
      call mr_sh_w3_for_flux%initialise( vector_space = w3_sh_fs )
      call mr_for_flux%initialise( vector_space = wt_fs )
      call rhs_flux%initialise( vector_space = w3_sh_fs )
      call rhs_adv%initialise( vector_space = wt_fs )
      call rhs_field%initialise( vector_space = wt_fs )
      do stage = 1, nstage
        call rk_field(stage)%initialise( vector_space = wt_fs )
      end do

    case default
      call log_event('MoL consistent: transported variable not in appropriate space', LOG_LEVEL_ERROR)
    end select

    ! Set initial values of Wtheta mixing ratios
    call mr_in%copy_field_properties(mr_n)
    call mr_in%copy_field_properties(mr_np1)

    call invoke( setval_X(mr_n, mr_in),  &
                 setval_X(mr_np1, mr_in) )

    ! Get transport runtime settings
    number_substeps = transport_runtime%get_number_substeps(prime_extrusion_mesh_id, direction, &
                                                            transport_metadata%get_splitting())
    dt_substep = transport_runtime%get_dt_substep(prime_extrusion_mesh_id, direction, &
                                                  transport_metadata%get_splitting())
    enforce_min_value = transport_metadata%get_enforce_min_value()

    ! Initialise the mixing ratio used for the flux to zero
    call invoke( setval_c( mr_for_flux, 0.0_r_tran ) )

    final_split_step = ( transport_step == transport_runtime%get_num_dry_steps() )

    ! ------------------------------------------------------------------------ !
    ! Do advective form until last stage of last substep
    ! ------------------------------------------------------------------------ !
    substep_loop: do substep = 1, number_substeps

      final_substep = ( substep == number_substeps )

      ! On the last substep of the last split step, we don't do advective form,
      ! so loop over fewer stages
      if ( final_substep .and. final_split_step ) then
        nstage_this_substep = nstage - 1
      else
        nstage_this_substep = nstage
      end if

      ! Set initial value for mr used in flux calculation
      call mr_np1%copy_field_properties(mr_n)
      call invoke( setval_X(mr_n, mr_np1), &
                   inc_X_plus_bY(mr_for_flux, rk_weights(nstage, 1), mr_n) )

      stage_loop: do stage = 1, nstage_this_substep

        final_rk_stage = ( stage == nstage )

        ! Compute the field for this stage:
        ! rhs_field = sum(s=1,stage): a(stage,s)*field^(s)
        call invoke( setval_X( rk_field(stage), mr_np1 ), &
                     setval_c( rhs_field, 0.0_r_tran ) )
        do s = 1, stage
          call invoke( inc_X_plus_bY( rhs_field, rk_weights(stage,s), rk_field(s) ) )
        end do

        ! Compute update: rhs_adv = u.grad(rhs_field)
        call advective_and_flux_alg(dummy, rhs_adv, rhs_field, mr_n,    &
                                    prime_advecting_wind, direction,    &
                                    transport_metadata, final_rk_stage, &
                                    dt_substep, .false., .true.)

        ! Update field: f = f^n - dt_substep*rhs
        call invoke( X_minus_bY(mr_np1, mr_n, dt_substep, rhs_adv) )

        ! Increment mixing ratio used for flux in last step
        if ( .not. final_rk_stage ) then
          call invoke( inc_X_plus_bY(mr_for_flux, &
                                     rk_weights(nstage, stage+1), mr_np1) )
        end if

        if ( limited_area .and. topology == topology_non_periodic ) then
          ! This code is required while LAMs loop over cells right up to
          ! the edge of a limited area domain.  It can be removed if
          ! we only loop over columns in the interior domain.

          ! Don't update the field near the edge of the domain. A depth of 1 is chosen
          ! here to avoid problems right at the lateral boundary edge,
          ! but ticket #3112 will investigate further options.
          call overwrite_blending_zone_rtran(mr_np1, mr_n, depth=1)
        end if

      end do stage_loop

      ! ---------------------------------------------------------------------- !
      ! Blending zone update
      ! ---------------------------------------------------------------------- !
      if ( limited_area .and. topology == topology_non_periodic ) then
        ! This code is required while LAMs loop over cells right up to
        ! the edge of a limited area domain.  It can be removed if
        ! we only loop over columns in the interior domain.

        ! Don't update the field near the edge of the domain. A configurable depth of using
        ! the transport_boundary_depth is chosen here.  This will depend
        ! on the number of RK stages and spatial reconstruction order.
        ! Ticket #3112 will investigate further options.
        call overwrite_blending_zone_rtran(mr_np1, mr_n, depth=transport_boundary_depth)
      end if

    end do substep_loop

    ! ------------------------------------------------------------------------ !
    ! End of split step: transporting moisture density (possibly in shifted W3)
    ! ------------------------------------------------------------------------ !
    final_rk_stage = .true.

    select case (mr_function_space)

    case ( W3 )
      call invoke( setval_c(flux_X, 0.0_r_tran) )

      ! In all cases, compute flux to rho_X
      call advective_and_flux_alg(flux_X, dummy, mr_for_flux, dummy,         &
                                  dry_flux, direction, transport_metadata,   &
                                  final_rk_stage, dt_substep, .true., .false.)
    case ( Wtheta )
      ! Obtain mixing ratio used for reconstruction in shifted W3
      call invoke( inject_wt_to_sh_w3_kernel_type(mr_sh_w3_for_flux, &
                                                  mr_for_flux),   &
                  setval_c(flux_X, 0.0_r_tran) )

      ! In all cases, compute flux to rho_X
      call advective_and_flux_alg(flux_X, dummy, mr_sh_w3_for_flux, dummy,   &
                                  dry_flux, direction, transport_metadata,   &
                                  final_rk_stage, dt_substep, .true., .false.)
    end select

    ! Need to scale flux to get correct time step
    scaling = 1.0_r_tran / real(number_substeps, r_tran)
    call invoke( inc_a_times_X(scaling, flux_X) )

    ! ------------------------------------------------------------------------ !
    ! End of time step
    ! ------------------------------------------------------------------------ !

    ! If this is the final step, mr_np1 will be computed here from the fluxes
    ! over the whole transport step
    ! If this is not the final step, mr_np1 already includes the *advective*
    ! increment, and may be adjusted to enforce min value or in blending zone
    call end_of_consistent_step_alg(mr_np1, flux_X, transport_metadata)

    if ( allocated( rk_field ) ) deallocate( rk_field )
    if ( allocated( rk_weights ) ) deallocate( rk_weights )

    nullify( w3_fs, w2_fs, wt_fs, w3_sh_fs, w2_sh_fs, &
             dry_flux, prime_advecting_wind,          &
             prime_extrusion_mesh, shifted_mesh )

    if ( subroutine_timers ) call timer('mol_consistent_alg')

  end subroutine mol_consistent_alg

end module mol_consistent_alg_mod
