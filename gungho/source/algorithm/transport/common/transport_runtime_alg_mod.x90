!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief A module that controls set-up of various transport objects.
!> @details This module controls the set-up of various objects that are
!!          created at the start of (or during) the transport process, and
!!          are needed throughout the transport routines.

module transport_runtime_alg_mod

  use check_configuration_mod,        only: check_any_scheme_mol,   &
                                            check_any_scheme_ffsl,  &
                                            check_any_scheme_split, &
                                            check_any_shifted,      &
                                            check_horz_dep_pts,     &
                                            check_vert_dep_pts
  use constants_mod,                  only: r_def, r_second, i_def, l_def,  &
                                            str_def, tiny_eps, imdi, r_tran
  use extrusion_mod,                  only: SHIFTED
  use r_tran_field_mod,               only: r_tran_field_type
  use integer_field_mod,              only: integer_field_type
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W2, W2h, W2v, W3
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use local_mesh_mod,                 only: local_mesh_type
  use log_mod,                        only: log_event,            &
                                            log_scratch_space,    &
                                            LOG_LEVEL_ERROR,      &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use model_clock_mod,                only: model_clock_type
  use runtime_tools_mod,              only: check_initialised_field
  use transport_enumerated_types_mod, only: scheme_split
  use psykal_lite_mod,                only: invoke_copy_to_rtran

  implicit none

  private

  ! Public types
  ! TODO #3008: this should be based on a linked_list_item type
  type, public :: transport_runtime_type

    private

    integer(kind=i_def)                              :: n_meshes
    integer(kind=i_def)                              :: local_mesh_id
    integer(kind=i_def)                              :: num_dry_steps
    integer(kind=i_def)                              :: dry_step_ctr
    integer(kind=i_def)                              :: tracer_step_ctr
    integer(kind=i_def), allocatable, dimension(:)   :: mesh_ids
    type(r_tran_field_type),    allocatable, dimension(:)   :: advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)   :: horizontal_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)   :: vertical_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)   :: detj_at_w2_transport
    type(r_tran_field_type),    allocatable, dimension(:)   :: departure_points_x_w2
    type(r_tran_field_type),    allocatable, dimension(:)   :: departure_points_y_w2
    type(r_tran_field_type),    allocatable, dimension(:)   :: departure_points_z_w2
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_x
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_y
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_z
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_half_x
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_half_y
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_half_z
    type(r_tran_field_type),    allocatable, dimension(:)   :: field_n
    type(r_tran_field_type),    allocatable, dimension(:,:) :: rho_d_n
    type(r_tran_field_type),    allocatable, dimension(:,:) :: rho_d_np1
    type(r_tran_field_type),    allocatable, dimension(:,:) :: flux
    type(r_tran_field_type),    allocatable, dimension(:,:) :: dry_flux
    real(kind=r_tran),    allocatable, dimension(:)   :: horizontal_cfl_max
    real(kind=r_tran),    allocatable, dimension(:)   :: vertical_cfl_max
    real(kind=r_tran),    allocatable, dimension(:)   :: total_cfl_max
    class(model_clock_type), pointer                 :: model_clock

    contains

    procedure, private :: idx_from_mesh_id
    procedure, private :: compute_num_dry_steps
    procedure, public  :: direction_w2_fs
    procedure, public  :: get_local_mesh_id
    procedure, public  :: get_prime_extrusion_mesh_id
    procedure, public  :: set_dry_fields
    procedure, public  :: set_field_n
    procedure, public  :: set_flux
    procedure, public  :: copy_all_dry_fields
    procedure, public  :: get_number_substeps
    procedure, public  :: get_dt_substep
    procedure, public  :: get_advecting_wind
    procedure, public  :: get_directional_advecting_wind
    procedure, public  :: get_horizontal_advecting_wind
    procedure, public  :: get_vertical_advecting_wind
    procedure, public  :: get_detj_at_w2_transport
    procedure, public  :: get_departure_points_x_w2
    procedure, public  :: get_departure_points_y_w2
    procedure, public  :: get_departure_points_z_w2
    procedure, public  :: get_adv_unity_x
    procedure, public  :: get_adv_unity_y
    procedure, public  :: get_adv_unity_z
    procedure, public  :: get_adv_unity_half_x
    procedure, public  :: get_adv_unity_half_y
    procedure, public  :: get_adv_unity_half_z
    procedure, public  :: get_field_n
    procedure, public  :: get_rho_d_n
    procedure, public  :: get_rho_d_np1
    procedure, public  :: get_flux
    procedure, public  :: get_dry_flux
    procedure, public  :: adjust_dry_flux
    procedure, public  :: get_num_dry_steps
    procedure, public  :: get_tracer_step_ctr
    procedure, public  :: inc_tracer_step_ctr
    procedure, public  :: reset_tracer_step_ctr
    procedure, public  :: initialise => transport_runtime_initialiser
    final              :: destroy_transport_runtime

  end type transport_runtime_type

  !-----------------------------------------------------------------------------
  ! Constructors
  !-----------------------------------------------------------------------------

contains

  !> @brief Constructs the transport_runtime object
  !> @param[in,out] self                  Transport runtime object to set
  !> @param[in]     primal_wind_n_rdef    Wind field at start of current time step on the
  !!                                      prime extrusion
  !> @param[in]     primal_wind_np1_rdef  Predictor of wind field at next time step on
  !!                                      the prime extrusion
  !> @param[in]     model_clock           Time within the model
  !> @param[in]     outer                 Outer (advection) iteration number
  !> @param[in]     cheap_update          Logical flag for cheap transport update
  !> @param[in]     shifted_mesh          (Optional) Shifted mesh
  !>
  subroutine transport_runtime_initialiser( self,                 &
                                            primal_wind_n_rdef,   &
                                            primal_wind_np1_rdef, &
                                            model_clock,          &
                                            outer,                &
                                            cheap_update,         &
                                            shifted_mesh)

    use calc_dep_pts_alg_mod,          only: calc_vert_dep_pts, &
                                             calc_hori_dep_pts, &
                                             select_detj_at_w2
    use ffsl_unity_transport_alg_mod,  only: ffsl_unity_transport_alg
    use split_w2_field_kernel_mod,     only: split_w2_field_kernel_type
    use transport_config_mod,          only: max_vert_cfl_calc,           &
                                             max_vert_cfl_calc_dep_point, &
                                             max_vert_cfl_calc_uniform
    use map_w2_to_sh_w2_alg_mod,       only: sample_w2_to_sh_w2_alg
    use calc_max_cfl_kernel_mod,       only: calc_max_cfl_kernel_type
    use dg_matrix_vector_kernel_mod,   only: dg_matrix_vector_kernel_type
    use fem_constants_mod,             only: get_div_r_tran, &
                                             get_inverse_W3_mass_matrix_r_tran
    use r_tran_operator_mod,           only: r_tran_operator_type
    use psykal_lite_mod,               only: invoke_copy_to_rtran

    implicit none

    class(transport_runtime_type), intent(inout) :: self

    type(field_type),        target, intent(in) :: primal_wind_n_rdef
    type(field_type),        target, intent(in) :: primal_wind_np1_rdef
    class(model_clock_type), target, intent(in) :: model_clock
    integer(kind=i_def),             intent(in) :: outer
    logical(kind=l_def),             intent(in) :: cheap_update

    type(mesh_type),  pointer, intent(in), optional :: shifted_mesh

    type(r_tran_field_type)          :: cfl, vertical_cfl, horizontal_cfl, cfl_dep
    type(r_tran_field_type)          :: sum_cfl, sum_horizontal_cfl, hori_cfl_dep
    type(r_tran_field_type)          :: dep_pt_wind_n, dep_pt_wind_np1
    integer(kind=i_def)              :: mesh_idx, i, fs_idx, num_compute_meshes
    type(mesh_type),         pointer :: mesh => null()
    type(local_mesh_type),   pointer :: local_mesh => null()
    type(r_tran_field_type), pointer :: wind_n   => null()
    type(r_tran_field_type), pointer :: wind_np1 => null()
    type(r_tran_field_type), target  :: shifted_wind_n
    type(r_tran_field_type), target  :: shifted_wind_np1
    type(field_type),        target  :: shifted_wind_n_rdef
    type(field_type),        target  :: shifted_wind_np1_rdef
    real(kind=r_tran)                :: cfl_min, cfl_max
    real(kind=r_tran)                :: h_cfl_min, h_cfl_max
    real(kind=r_tran)                :: v_cfl_min, v_cfl_max
    real(r_tran)                     :: cast_dt
    logical(kind=l_def)              :: any_scheme_mol, any_scheme_split
    logical(kind=l_def)              :: any_scheme_ffsl, any_shifted
    logical(kind=l_def)              :: any_horz_dep_pts, any_vert_dep_pts

    type(mesh_type),           pointer :: tmp_mesh => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()

    ! r_tran type fields
    type(r_tran_field_type), target :: primal_wind_n
    type(r_tran_field_type), target :: primal_wind_np1

    write(log_scratch_space, '(A,I4)') 'Setting up transport_runtime on mesh: ', &
                                       primal_wind_n_rdef%get_mesh_id()
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    ! Transfer r_def input to r_tran fields
    call primal_wind_n%initialise(vector_space = primal_wind_n_rdef%get_function_space() )
    call primal_wind_np1%initialise(vector_space = primal_wind_np1_rdef%get_function_space() )
    call invoke_copy_to_rtran(primal_wind_n,primal_wind_n_rdef)
    call invoke_copy_to_rtran(primal_wind_np1,primal_wind_np1_rdef)

    ! ======================================================================== !
    ! Checks for what schemes we have

    any_scheme_mol = check_any_scheme_mol()
    any_scheme_ffsl = check_any_scheme_ffsl()
    any_scheme_split = check_any_scheme_split()
    any_horz_dep_pts = check_horz_dep_pts()
    any_vert_dep_pts = check_vert_dep_pts()
    any_shifted = check_any_shifted()

    ! ======================================================================== !
    ! Determine number of meshes

    ! By default only compute auxiliary fields on prime extrusion mesh
    num_compute_meshes = 1

    if ( present(shifted_mesh) ) then
      self%n_meshes = 2
      ! Only compute things on the shifted mesh if we need to
      if (any_shifted) then
        num_compute_meshes = 2
      end if
    else
      self%n_meshes = 1
    end if

    !> @todo This is almost certainly the wrong thing to do but I want to get
    !>       something done.
    !>
    self%model_clock => model_clock
    cast_dt = real( model_clock%get_seconds_per_step(), r_tran )

    mesh => primal_wind_n_rdef%get_mesh()
    local_mesh => mesh%get_local_mesh()
    self%local_mesh_id = local_mesh%get_id()

    if (.not. allocated( self%mesh_ids ) ) then
      allocate( self%mesh_ids(self%n_meshes),                  &
                self%advecting_wind(self%n_meshes),            &
                self%horizontal_advecting_wind(self%n_meshes), &
                self%vertical_advecting_wind(self%n_meshes),   &
                self%detj_at_w2_transport(self%n_meshes),      &
                self%departure_points_x_w2(self%n_meshes),     &
                self%departure_points_y_w2(self%n_meshes),     &
                self%departure_points_z_w2(self%n_meshes),     &
                self%adv_unity_x(self%n_meshes),               &
                self%adv_unity_y(self%n_meshes),               &
                self%adv_unity_z(self%n_meshes),               &
                self%adv_unity_half_x(self%n_meshes),          &
                self%adv_unity_half_y(self%n_meshes),          &
                self%adv_unity_half_z(self%n_meshes),          &
                self%horizontal_cfl_max(self%n_meshes),        &
                self%vertical_cfl_max(self%n_meshes),          &
                self%total_cfl_max(self%n_meshes),             &
                self%field_n(self%n_meshes) )
    end if
    ! Get mesh ID and element order
    self%mesh_ids(1) = primal_wind_n_rdef%get_mesh_id()

    ! If asked for compute objects on the shifted mesh
    if ( present(shifted_mesh ) ) then
      self%mesh_ids(2) = shifted_mesh%get_id()
      write(log_scratch_space, '(A,I4)') '... and shifted mesh: ', &
                                         shifted_mesh%get_id()
      call log_event(log_scratch_space, LOG_LEVEL_INFO)
    end if

    ! ======================================================================== !
    ! Create winds on shifted mesh
    if ( present(shifted_mesh) ) then

      ! TODO #3008: only initialise these if they will be used
      ! For now we need to initialise them for copying the transport runtime
      call shifted_wind_n_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_np1_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_n%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_np1%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )

      if (num_compute_meshes == 2) then
        ! Rather than duplicating a lot of mapping code for different field types,
        ! we go by intermediate r_def fields before copying to r_tran fields
        call sample_w2_to_sh_w2_alg(shifted_wind_n_rdef,   primal_wind_n_rdef)
        call sample_w2_to_sh_w2_alg(shifted_wind_np1_rdef, primal_wind_np1_rdef)
        call invoke_copy_to_rtran(shifted_wind_n,shifted_wind_n_rdef)
        call invoke_copy_to_rtran(shifted_wind_np1,shifted_wind_np1_rdef)
      end if
    end if

    ! ======================================================================== !
    ! Initialise fields
    ! TODO #3008: we should only initialise fields that we actually use
    do mesh_idx = 1, self%n_meshes
      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
      w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2)
      w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2h)
      w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2v)
      w3_fs => function_space_collection%get_fs(tmp_mesh, element_order, W3)

      call self%advecting_wind(mesh_idx)%initialise( w2_fs )
      call self%horizontal_advecting_wind(mesh_idx)%initialise( w2h_fs )
      call self%vertical_advecting_wind(mesh_idx)%initialise( w2v_fs )
      call self%detj_at_w2_transport(mesh_idx)%initialise( w2_fs )
      call self%departure_points_z_w2(mesh_idx)%initialise( w2v_fs )
      call self%departure_points_x_w2(mesh_idx)%initialise( w2h_fs )
      call self%departure_points_y_w2(mesh_idx)%initialise( w2h_fs )
      call self%adv_unity_x(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_y(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_z(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_half_x(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_half_y(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_half_z(mesh_idx)%initialise( w3_fs )
      call self%field_n(mesh_idx)%initialise( w3_fs  )
    end do

    ! ======================================================================== !
    ! Compute auxiliary transport fields

    do mesh_idx = 1, num_compute_meshes

      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))

      !=======================================================================!
      ! Create advecting winds

      if ( mesh_idx == 1 ) then
        ! First pass, make wind_n & wind_np1 point to the primal mesh fields
        wind_n   => primal_wind_n
        wind_np1 => primal_wind_np1
      else
        ! For second pass (if needed) set wind_n & wind_np1 to point to
        ! shifted mesh versions
        wind_n   => shifted_wind_n
        wind_np1 => shifted_wind_np1
      end if

      if ( cheap_update .AND. outer > 1 ) then
        ! Set advecting wind = (wind^{n+1}-wind^{n})/2
        ! For outer>2 this becomes (wind^{n+1}-wind^prev)/2
        call invoke( aX_minus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_np1, &
                                                                0.5_r_tran, wind_n) )
      else
        ! Set advecting wind = (wind^{n}+wind^{n+1})/2
        call invoke( aX_plus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_n, &
                                                               0.5_r_tran, wind_np1) )
      end if

      ! Split into horizontal and vertical advecting winds
      call invoke( setval_c(self%horizontal_advecting_wind(mesh_idx), 0.0_r_tran),      &
                   setval_c(self%vertical_advecting_wind(mesh_idx), 0.0_r_tran),        &
                   split_w2_field_kernel_type(self%horizontal_advecting_wind(mesh_idx), &
                                              self%vertical_advecting_wind(mesh_idx),   &
                                              self%advecting_wind(mesh_idx)) )

      !=======================================================================!
      ! Compute departure points

      ! Get detj_at_w2 using wind_n
      call select_detj_at_w2( wind_n, self%detj_at_w2_transport(mesh_idx) )

      ! Set winds for computing departure points based on cheap update flag
      if (any_vert_dep_pts .OR. any_horz_dep_pts) then
        call dep_pt_wind_n%initialise( wind_n%get_function_space() )
        call dep_pt_wind_np1%initialise( wind_np1%get_function_space() )
        if ( cheap_update .AND. outer > 1 ) then
          ! Set up winds for cheap update with FFSL/SL
          call invoke( aX_minus_bY(dep_pt_wind_n, 0.5_r_tran, wind_np1,   &
                                                  0.5_r_tran, wind_n),    &
                       aX_minus_bY(dep_pt_wind_np1, 0.5_r_tran, wind_np1, &
                                                    0.5_r_tran, wind_n) )
        else
          ! Use wind_n and wind_np1
          call invoke( setval_X(dep_pt_wind_n, wind_n), &
                       setval_X(dep_pt_wind_np1, wind_np1) )
        end if
      end if

      ! If any vertical scheme is ffsl/sl compute vertical departure points
      if (any_vert_dep_pts) then
        call cfl_dep%initialise( vector_space = &
                function_space_collection%get_fs(tmp_mesh, element_order, W2) )

        call calc_vert_dep_pts( self%departure_points_z_w2(mesh_idx), &
                                cfl_dep,                              &
                                dep_pt_wind_n,                        &
                                dep_pt_wind_np1,                      &
                                self%detj_at_w2_transport(mesh_idx),  &
                                cast_dt )
      end if

      ! If any horizontal scheme is ffsl compute horizontal departure points
      if (any_horz_dep_pts) then
        call calc_hori_dep_pts( self%departure_points_x_w2(mesh_idx),  &
                                self%departure_points_y_w2(mesh_idx),  &
                                dep_pt_wind_n,                         &
                                dep_pt_wind_np1,                       &
                                self%detj_at_w2_transport(mesh_idx),   &
                                cast_dt )
      end if

      !=======================================================================!
      ! Compute cfls for use in substepping
      call cfl%initialise( wind_n%get_function_space() )
      call horizontal_cfl%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
      call vertical_cfl%initialise( self%vertical_advecting_wind(mesh_idx)%get_function_space() )
      call sum_horizontal_cfl%initialise( vector_space = &
                function_space_collection%get_fs(tmp_mesh, element_order, W3) )
      call sum_cfl%initialise( vector_space = &
                function_space_collection%get_fs(tmp_mesh, element_order, W3) )

      call invoke( setval_X(cfl, self%advecting_wind(mesh_idx)),               &
                   inc_X_divideby_Y(cfl, self%detj_at_w2_transport(mesh_idx)), &
                   inc_a_times_X(cast_dt, cfl),                                &
                   setval_c(horizontal_cfl, 0.0_r_tran),                       &
                   setval_c(vertical_cfl, 0.0_r_tran),                         &
                   setval_c(sum_horizontal_cfl, 0.0_r_tran),                   &
                   setval_c(sum_cfl, 0.0_r_tran),                              &
                   split_w2_field_kernel_type(horizontal_cfl,                  &
                                              vertical_cfl,                    &
                                              cfl) )

      select case(max_vert_cfl_calc)
      ! Calculate the maximum vertical cfl for substepping
      case(max_vert_cfl_calc_uniform)
        call vertical_cfl%field_minmax(v_cfl_min, v_cfl_max)
      case(max_vert_cfl_calc_dep_point)
        call hori_cfl_dep%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
        call invoke( split_w2_field_kernel_type(hori_cfl_dep, &
                                                vertical_cfl, &
                                                cfl_dep) )
        call cfl_dep%field_minmax(v_cfl_min, v_cfl_max)
      case default
        write(log_scratch_space, '(A)') &
          'transport_runtime: maximum vertical CFL method not defined '
        call log_event(log_scratch_space, LOG_LEVEL_ERROR)
      end select

      ! Get the total CFL at each cell - this only works for element_order = 0
      if (element_order == 0_i_def) then
        call invoke( calc_max_cfl_kernel_type(sum_cfl, sum_horizontal_cfl, &
                                              horizontal_cfl, vertical_cfl) )
        call sum_horizontal_cfl%field_minmax(h_cfl_min, h_cfl_max)
        call sum_cfl%field_minmax(cfl_min, cfl_max)
        self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
        self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
        self%total_cfl_max(mesh_idx) = max(abs(cfl_max), abs(cfl_min))
      else
        call horizontal_cfl%field_minmax(h_cfl_min, h_cfl_max)
        self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
        self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
        self%total_cfl_max(mesh_idx) = max( self%horizontal_cfl_max(mesh_idx), &
                                            self%vertical_cfl_max(mesh_idx) )
      end if

      write( log_scratch_space, '(A, E16.8)') &
          'Transport: maximum horizontal CFL ', self%horizontal_cfl_max(mesh_idx)
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      write( log_scratch_space, '(A, E16.8)') &
          'Transport: maximum vertical CFL ', self%vertical_cfl_max(mesh_idx)
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      write( log_scratch_space, '(A, E16.8)') &
          'Transport: maximum total CFL ', self%total_cfl_max(mesh_idx)
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      !==========================================================================!
      ! For FFSL schemes we require the transport of a unity field to get
      ! the advective FFSL transport
      if (any_scheme_ffsl) then
        call ffsl_unity_transport_alg( self%departure_points_x_w2(mesh_idx), &
                                       self%departure_points_y_w2(mesh_idx), &
                                       self%departure_points_z_w2(mesh_idx), &
                                       self%detj_at_w2_transport(mesh_idx),  &
                                       cast_dt,                              &
                                       self%adv_unity_x(mesh_idx),           &
                                       self%adv_unity_y(mesh_idx),           &
                                       self%adv_unity_z(mesh_idx),           &
                                       self%adv_unity_half_x(mesh_idx),      &
                                       self%adv_unity_half_y(mesh_idx),      &
                                       self%adv_unity_half_z(mesh_idx) )
      end if

    end do

    !==========================================================================!
    ! Dry fields stored for consistent transport of scalars
    self%num_dry_steps = self%compute_num_dry_steps()

    ! Allocate arrays for dry fields
    if ( .not. allocated( self%rho_d_n ) )                             &
      allocate( self%rho_d_n(self%n_meshes, self%num_dry_steps),       &
                self%rho_d_np1(self%n_meshes, self%num_dry_steps),     &
                self%flux(self%n_meshes, self%num_dry_steps),          &
                self%dry_flux(self%n_meshes, self%num_dry_steps) )

    ! Initialise these fields
    ! TODO: #3008 can we avoid initialised unused fields?
    ! Dry fluxes only needed if something is transported 'consistently'
    do mesh_idx = 1, self%n_meshes
      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
      w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2h)
      w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2v)
      w3_fs => function_space_collection%get_fs(tmp_mesh, element_order, W3)
      do i = 1, self%num_dry_steps
        call self%rho_d_n(mesh_idx, i)%initialise( vector_space = w3_fs )
        call self%rho_d_np1(mesh_idx, i)%initialise( vector_space = w3_fs )
        ! Dry flux could be 3D, horizontal or vertical
        ! Determine what it is for this dry transport step
        fs_idx = self%direction_w2_fs(i)
        w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, fs_idx)
        call self%dry_flux(mesh_idx, i)%initialise( vector_space = w2_fs )
        ! this hard-codes that any conservative variable will have the
        ! same splitting structure as the dry density
        call self%flux(mesh_idx, i)%initialise( vector_space = w2_fs )
      end do
    end do

    ! Set dry substep counter to be 1
    self%dry_step_ctr = 1
    self%tracer_step_ctr = 1

    nullify(mesh, local_mesh, w2_fs, w3_fs, tmp_mesh, w2h_fs, w2v_fs)

  end subroutine transport_runtime_initialiser

  !> Finalizer for the transport runtime
  !> @param [in,out] self The transport runtime object
  subroutine destroy_transport_runtime(self)
    implicit none
    type(transport_runtime_type), intent(inout) :: self

    if ( allocated( self%mesh_ids ) )                  deallocate( self%mesh_ids )
    if ( allocated( self%advecting_wind ) )            deallocate( self%advecting_wind )
    if ( allocated( self%horizontal_advecting_wind ) ) deallocate( self%horizontal_advecting_wind )
    if ( allocated( self%vertical_advecting_wind ) )   deallocate( self%vertical_advecting_wind )
    if ( allocated( self%detj_at_w2_transport ) )      deallocate( self%detj_at_w2_transport )
    if ( allocated( self%departure_points_x_w2 ) )     deallocate( self%departure_points_x_w2 )
    if ( allocated( self%departure_points_y_w2 ) )     deallocate( self%departure_points_y_w2 )
    if ( allocated( self%departure_points_z_w2 ) )     deallocate( self%departure_points_z_w2 )
    if ( allocated( self%adv_unity_x ) )               deallocate( self%adv_unity_x )
    if ( allocated( self%adv_unity_y ) )               deallocate( self%adv_unity_y )
    if ( allocated( self%adv_unity_z ) )               deallocate( self%adv_unity_z )
    if ( allocated( self%adv_unity_half_x ) )          deallocate( self%adv_unity_half_x )
    if ( allocated( self%adv_unity_half_y ) )          deallocate( self%adv_unity_half_y )
    if ( allocated( self%adv_unity_half_z ) )          deallocate( self%adv_unity_half_z )
    if ( allocated( self%field_n ) )                   deallocate( self%field_n )
    if ( allocated( self%rho_d_n ) )                   deallocate( self%rho_d_n )
    if ( allocated( self%rho_d_np1 ) )                 deallocate( self%rho_d_np1 )
    if ( allocated( self%flux ) )                      deallocate( self%flux )
    if ( allocated( self%dry_flux ) )                  deallocate( self%dry_flux )
    if ( allocated( self%horizontal_cfl_max ) )        deallocate( self%horizontal_cfl_max )
    if ( allocated( self%vertical_cfl_max ) )          deallocate( self%vertical_cfl_max )
    if ( allocated( self%total_cfl_max ) )             deallocate( self%total_cfl_max )

  end subroutine destroy_transport_runtime

  !> @brief Sets dry fields for use in conservative mixing ratio transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     rho_d_n   Dry density field at start of time step
  !> @param[in]     rho_d_np1 Dry density field at end of time step
  !> @param[in]     dry_flux  Flux field used to transport dry density
  subroutine set_dry_fields(self, rho_d_n, rho_d_np1, dry_flux)

    use apply_w3_to_sh_w3_kernel_mod,   only: apply_w3_to_sh_w3_kernel_type
    use consist_w2_to_sh_w2_kernel_mod, only: consist_w2_to_sh_w2_kernel_type
    use consist_w2h_to_sh_w2h_kernel_mod, &
                                        only: consist_w2h_to_sh_w2h_kernel_type
    use consist_w2v_to_sh_w2v_kernel_mod, &
                                        only: consist_w2v_to_sh_w2v_kernel_type
    use fem_constants_mod,              only: get_rmultiplicity
    use intermesh_constants_mod,        only: get_consist_w3_to_sh_w3_rtran
    use check_configuration_mod,        only: check_any_eqn_consistent, &
                                              check_any_wt_eqn_conservative

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d_n
    type(r_tran_field_type),               intent(in)    :: rho_d_np1
    type(r_tran_field_type),               intent(in)    :: dry_flux

    integer(kind=i_def)       :: fs_idx
    logical(kind=l_def)       :: any_eqn_consistent, any_wt_eqn_conservative
    type(field_type), pointer :: rmultiplicity_w2 => null()
    type(mesh_type),  pointer :: prime_extrusion_mesh => null()
    type(mesh_type),  pointer :: shifted_mesh => null()
    type(r_tran_field_type), pointer :: consist_w3_to_sh_w3_rtran(:) => null()

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => dry_flux%get_mesh()
    fs_idx = dry_flux%which_function_space()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    ! ------------------------------------------------------------------------ !
    ! Copy across fields for prime extrusion mesh
    ! ------------------------------------------------------------------------ !

    call rho_d_n%copy_field_properties(self%rho_d_n(1,self%dry_step_ctr))
    call rho_d_np1%copy_field_properties(self%rho_d_np1(1,self%dry_step_ctr))
    call dry_flux%copy_field_properties(self%dry_flux(1,self%dry_step_ctr))

    call invoke( setval_X(self%rho_d_n(1,self%dry_step_ctr), rho_d_n), &
                 setval_X(self%rho_d_np1(1,self%dry_step_ctr), rho_d_np1), &
                 setval_X(self%dry_flux(1,self%dry_step_ctr), dry_flux) )

    ! ------------------------------------------------------------------------ !
    ! Shift variables if required
    ! ------------------------------------------------------------------------ !

    any_eqn_consistent = check_any_eqn_consistent()
    any_wt_eqn_conservative = check_any_wt_eqn_conservative()

    if (self%n_meshes > 1 .and. (any_eqn_consistent .or. any_wt_eqn_conservative)) then
      ! Transform these densities and dry fluxes to the shifted mesh
      shifted_mesh => mesh_collection%get_mesh(prime_extrusion_mesh, SHIFTED)
      consist_w3_to_sh_w3_rtran => get_consist_w3_to_sh_w3_rtran(prime_extrusion_mesh)

      call invoke( name='shift_dry_densities',                                 &
          apply_w3_to_sh_w3_kernel_type(self%rho_d_n(2,self%dry_step_ctr),     &
                                        self%rho_d_n(1,self%dry_step_ctr),     &
                                        consist_w3_to_sh_w3_rtran),               &
          apply_w3_to_sh_w3_kernel_type(self%rho_d_np1(2,self%dry_step_ctr),   &
                                        self%rho_d_np1(1,self%dry_step_ctr),   &
                                        consist_w3_to_sh_w3_rtran) )

      ! Transform dry fluxes to the shifted mesh, with case depending on fs_idx
      select case (fs_idx)
      case (W2)
        ! Shift and then split
        rmultiplicity_w2 => get_rmultiplicity(W2, dry_flux%get_mesh_id())
        call invoke(                                                           &
          setval_c(self%dry_flux(2,self%dry_step_ctr), 0.0_r_tran),            &
          consist_w2_to_sh_w2_kernel_type(self%dry_flux(2,self%dry_step_ctr),  &
                                          self%dry_flux(1,self%dry_step_ctr),  &
                                          rmultiplicity_w2) )
      case (W2h)
        ! Flux is already horizontal so just shift
        rmultiplicity_w2 => get_rmultiplicity(W2h, dry_flux%get_mesh_id())
        call invoke(                                                            &
          setval_c(self%dry_flux(2,self%dry_step_ctr), 0.0_r_tran),             &
          consist_w2h_to_sh_w2h_kernel_type(self%dry_flux(2,self%dry_step_ctr), &
                                            self%dry_flux(1,self%dry_step_ctr), &
                                            rmultiplicity_w2) )
      case (W2v)
        ! Flux is alread vertical so just shift
        call invoke(                                                            &
          consist_w2v_to_sh_w2v_kernel_type(self%dry_flux(2,self%dry_step_ctr), &
                                            self%dry_flux(1,self%dry_step_ctr)) )
      case default
        call log_event( "Can only store dry flux for W2, W2h and W2v spaces", LOG_LEVEL_ERROR )
      end select

      nullify( rmultiplicity_w2, consist_w3_to_sh_w3_rtran )
    end if

    ! Increment counter for dry substep
    self%dry_step_ctr = self%dry_step_ctr + 1

    nullify( prime_extrusion_mesh, shifted_mesh )

  end subroutine set_dry_fields

  !> @brief Stores a W3 field at the start of the whole transport step
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     field_n   W3 field at start of whole transport step
  subroutine set_field_n(self, field_n)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: field_n

    integer(kind=i_def) :: idx

    idx = self%idx_from_mesh_id(field_n%get_mesh_id())
    call field_n%copy_field_properties(self%field_n(idx))
    call invoke( setval_X(self%field_n(idx), field_n) )

  end subroutine set_field_n

  !> @brief Sets fluxes for use in conservative transport
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     flux      Mass flux for a particular split step
  subroutine set_flux(self, flux)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: flux

    integer(kind=i_def) :: idx

    idx = self%idx_from_mesh_id(flux%get_mesh_id())
    call flux%copy_field_properties(self%flux(idx,self%tracer_step_ctr))
    call invoke( setval_X(self%flux(idx,self%tracer_step_ctr), flux) )

  end subroutine set_flux

  !> @brief Copies across all the dry fields from one transport runtime to
  !!        another, restricting the fields if the target mesh is coarser
  !> @param[in,out] self                       Target transport_runtime object
  !> @param[in]     source_transport_runtime   Source transport_runtime object
  subroutine copy_all_dry_fields(self, source_transport_runtime)

    use intermesh_constants_mod,   only: get_intermesh_weights_w3_rtran
    use mesh_collection_mod,       only: mesh_collection
    use restrict_scalar_weighted_kernel_mod, &
                                   only: restrict_scalar_weighted_kernel_type
    use restrict_w2_kernel_mod,    only: restrict_w2_kernel_type
    use restrict_w2h_kernel_mod,   only: restrict_w2h_kernel_type
    use restrict_w2v_kernel_mod,   only: restrict_w2v_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    class(transport_runtime_type),         intent(in)    :: source_transport_runtime
    type(function_space_type),             pointer       :: w2_fs => null()
    type(function_space_type),             pointer       :: w3_fs => null()
    type(mesh_type),                       pointer       :: source_mesh => null()
    type(mesh_type),                       pointer       :: target_mesh => null()
    type(r_tran_field_type),               pointer       :: source_rho_d_n => null()
    type(r_tran_field_type),               pointer       :: source_rho_d_np1 => null()
    type(r_tran_field_type),               pointer       :: source_dry_flux => null()
    type(r_tran_field_type)                              :: target_rho_d_n
    type(r_tran_field_type)                              :: target_rho_d_np1
    type(r_tran_field_type)                              :: target_dry_flux
    type(r_tran_field_type),               pointer       :: weights_w3 => null()
    integer(kind=i_def)                                  :: source_ncells
    integer(kind=i_def)                                  :: target_ncells
    integer(kind=i_def)                                  :: source_mesh_id
    integer(kind=i_def)                                  :: target_mesh_id
    integer(kind=i_def)                                  :: i, fs_idx

    ! N.B. The meshes should not be the same as one another, otherwise the
    ! transport_runtime objects will be the same

    source_mesh_id = source_transport_runtime%get_prime_extrusion_mesh_id()
    target_mesh_id = self%get_prime_extrusion_mesh_id()
    ! Obtain meshes to check that we can coarsen
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)
    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    ! Initialise target fields
    w3_fs => function_space_collection%get_fs(target_mesh, element_order, W3)
    call target_rho_d_n%initialise( vector_space = w3_fs )
    call target_rho_d_np1%initialise( vector_space = w3_fs )

    if (source_ncells > target_ncells) then
      ! Loop through fields for each step for prime extrusion
      do i = 1, source_transport_runtime%get_num_dry_steps()
        source_rho_d_n => source_transport_runtime%get_rho_d_n(source_mesh_id, i)
        source_rho_d_np1 => source_transport_runtime%get_rho_d_np1(source_mesh_id, i)
        source_dry_flux => source_transport_runtime%get_dry_flux(source_mesh_id, i)

        ! Restrict flux, which depends on split direction
        fs_idx = source_dry_flux%which_function_space()
        w2_fs => function_space_collection%get_fs(target_mesh, element_order, fs_idx)
        call target_dry_flux%initialise( vector_space = w2_fs )

        select case ( source_dry_flux%which_function_space() )
        case ( W2 )
          call invoke(                                                   &
              restrict_w2_kernel_type(target_dry_flux, source_dry_flux) )
        case ( W2H )
          call invoke(                                                   &
              restrict_w2h_kernel_type(target_dry_flux, source_dry_flux) )
        case ( W2V )
          call invoke(                                                   &
              restrict_w2v_kernel_type(target_dry_flux, source_dry_flux) )
        case default
          call log_event('Dry flux space not recognised', LOG_LEVEL_ERROR)
        end select

        ! Restrict densities conservatively
        weights_w3 => get_intermesh_weights_w3_rtran(source_mesh, target_mesh)
        call invoke(restrict_scalar_weighted_kernel_type(target_rho_d_n,   &
                                                         source_rho_d_n,   &
                                                         weights_w3),      &
                    restrict_scalar_weighted_kernel_type(target_rho_d_np1, &
                                                         source_rho_d_np1, &
                                                         weights_w3) )

        ! Set dry fields
        call self%set_dry_fields(target_rho_d_n, target_rho_d_np1, target_dry_flux)

      end do

    else
      call log_event( 'Can only call copy_all_dry_fields when ' // &
                      'target mesh is coarser than source mesh', LOG_LEVEL_ERROR)
    end if

    nullify( source_mesh, target_mesh, source_rho_d_n, &
             source_rho_d_np1, source_dry_flux, w3_fs, w2_fs, weights_w3 )

  end subroutine copy_all_dry_fields

  !> @brief Private function for getting array index corresponding to mesh_id
  !> @param[in] self      The transport_runtime object
  !> @param[in] mesh_id   Identifier of mesh to find
  function idx_from_mesh_id(self, mesh_id) result(idx)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def)                               :: idx
    integer(kind=i_def)                               :: i

    idx = imdi
    do i = 1, self%n_meshes
      if ( mesh_id == self%mesh_ids(i) ) idx = i
    end do

    if ( idx == imdi ) then
      write(log_scratch_space, '(A,I4)') 'transport_runtime does not contain mesh: ', &
                                          mesh_id
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

  end function idx_from_mesh_id

  !> @brief Computes number of MoL substeps for a splitting step
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @param[in] cfl_arg    CFL to use. Optional, and if not provided defaults
  !!                       to namelist options.
  !> @return number_substeps  Number of substeps
  function get_number_substeps(self, mesh_id, direction, splitting, cfl_arg) result(number_substeps)
    use transport_config_mod,           only: cfl_mol_3d_stab, &
                                              cfl_mol_2d_stab, &
                                              cfl_mol_1d_stab
    use transport_enumerated_types_mod, only: direction_h,          &
                                              direction_v,          &
                                              direction_3d,         &
                                              splitting_strang_vhv, &
                                              splitting_strang_hvh
    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    real(kind=r_def),   optional,  intent(in) :: cfl_arg
    integer(kind=i_def)                       :: number_substeps
    integer(kind=i_def)                       :: idx
    real(kind=r_def)                          :: cfl_to_use

    idx = self%idx_from_mesh_id(mesh_id)

    if (present(cfl_arg)) then
      cfl_to_use = cfl_arg + tiny_eps
    else
      select case (direction)
      case (direction_v)
        cfl_to_use = cfl_mol_1d_stab + tiny_eps
      case (direction_h)
        cfl_to_use = cfl_mol_2d_stab+tiny_eps
      case (direction_3d)
        cfl_to_use = cfl_mol_3d_stab+tiny_eps
      case default
        call log_event('Direction not recognised', LOG_LEVEL_ERROR)
      end select
    end if

    select case (direction)

      case (direction_v)
        number_substeps = int( self%vertical_cfl_max(idx) / cfl_to_use, i_def) &
                         + 1_i_def
        ! Strang_vhv splitting uses half timestep for the vertical stage
        if ( splitting == splitting_strang_vhv ) then
          number_substeps = int( self%vertical_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if
      case (direction_h)
        number_substeps = int( self%horizontal_cfl_max(idx)      &
                              / cfl_to_use, i_def) &
                        + 1_i_def
        ! Strang_hvh splitting uses half timestep for the horizontal stage
        if ( splitting == splitting_strang_hvh ) then
          number_substeps = int( self%horizontal_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if

      case (direction_3d)
        number_substeps = int( self%total_cfl_max(idx)            &
                              / cfl_to_use, i_def)  &
                         + 1_i_def
      case default
        number_substeps = 1_i_def
    end select

  end function get_number_substeps

  !> @brief Get the MoL dt for substeps for this mesh / direction / splitting
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @return dt_substep  The dt for MoL substeps
  function get_dt_substep(self, mesh_id, direction, splitting) result(dt_substep)
    use transport_enumerated_types_mod, only: direction_v,          &
                                              direction_h,          &
                                              splitting_strang_vhv, &
                                              splitting_strang_hvh

    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    integer(kind=i_def)                       :: number_substeps
    real(kind=r_tran)                         :: dt_substep

    number_substeps = self%get_number_substeps(mesh_id, direction, splitting)
    dt_substep = real(self%model_clock%get_seconds_per_step(), r_tran) &
                 / real(number_substeps, r_tran)
    if ( splitting  == splitting_strang_vhv .and. direction == direction_v ) then
        dt_substep = dt_substep / 2.0_r_tran
    else if ( splitting  == splitting_strang_hvh .and. direction == direction_h ) then
        dt_substep = dt_substep / 2.0_r_tran
    end if

  end function get_dt_substep

  !> @brief Returns the local mesh id for the transport_runtime
  !> @return The identifier for the underlying local mesh
  function get_local_mesh_id(self) result(local_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: local_mesh_id

    local_mesh_id = self%local_mesh_id

  end function get_local_mesh_id

  !> @brief Returns the mesh id for the transport_runtime prime extrusion mesh
  !> @return The identifier for the prime extrusion mesh
  function get_prime_extrusion_mesh_id(self) result(prime_extrusion_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: prime_extrusion_mesh_id

    prime_extrusion_mesh_id = self%mesh_ids(1)

  end function get_prime_extrusion_mesh_id

  !> @brief Returns a pointer to the advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The advecting wind for that mesh
  function get_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'advecting_wind'
    advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_advecting_wind

  !> @brief Returns a pointer to the advecting wind associated with a direction
  !> @param[in] mesh_id    The ID of the mesh to get the object for
  !> @param[in] direction  The enumerator for the direction
  !> @return The advecting wind for that mesh and specified direction
  function get_directional_advecting_wind(self, mesh_id, direction) result(advecting_wind)

    use transport_enumerated_types_mod, only: direction_h,          &
                                              direction_v,          &
                                              direction_3d

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: direction
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'directional_advecting_wind'

    select case (direction)
    case (direction_3d)
      advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_h)
      advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_v)
      advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case default
      call log_event('get_directional_advecting_wind: Direction not recognised', LOG_LEVEL_ERROR)
    end select

    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_directional_advecting_wind

   !> @brief Returns a pointer to the horizontal advecting wind
   !> @param[in] mesh_id The ID of the mesh to get the object for
   !> @return The horizontal part of the advecting wind
  function get_horizontal_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'horizontal_advecting_wind'
    advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_horizontal_advecting_wind

  !> @brief Returns a pointer to the vertical advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The vertical part of the advecting wind
  function get_vertical_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'vertical_advecting_wind'
    advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_vertical_advecting_wind

  !> @brief Returns a pointer to det(J) at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return det(J) evaluated at W2 DoFs
  function get_detj_at_w2_transport(self, mesh_id) result(detj_at_w2_transport)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: detj_at_w2_transport
    character(str_def)                                :: field_name

    field_name = 'detj_at_w2_transport'
    detj_at_w2_transport => self%detj_at_w2_transport(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(detj_at_w2_transport, field_name, mesh_id)

  end function get_detj_at_w2_transport

  !> @brief Returns a pointer to the x departure points at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the x direction at W2 DoFs
  function get_departure_points_x_w2(self, mesh_id) result(departure_points_x_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: departure_points_x_w2
    character(str_def)                                :: field_name

    field_name = 'departure_points_x_w2'
    departure_points_x_w2 => self%departure_points_x_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_x_w2, field_name, mesh_id)

  end function get_departure_points_x_w2

  !> @brief Returns a pointer to the y departure points at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the y direction at W2 DoFs
  function get_departure_points_y_w2(self, mesh_id) result(departure_points_y_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: departure_points_y_w2
    character(str_def)                                :: field_name

    field_name = 'departure_points_y_w2'
    departure_points_y_w2 => self%departure_points_y_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_y_w2, field_name, mesh_id)

  end function get_departure_points_y_w2

  !> @brief Returns a pointer to the z departure points at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the z direction at W2 DoFs
  function get_departure_points_z_w2(self, mesh_id) result(departure_points_z_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: departure_points_z_w2
    character(str_def)                                :: field_name

    field_name = 'get_departure_points_z_w2'
    departure_points_z_w2 => self%departure_points_z_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_z_w2, field_name, mesh_id)

  end function get_departure_points_z_w2

  !> @brief Returns a pointer to the transport of unity in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of transport of unity in x
  function get_adv_unity_x(self, mesh_id) result(adv_unity_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),                      pointer    :: adv_unity_x
    character(str_def)                                :: field_name

    field_name = 'adv_unity_x'
    adv_unity_x => self%adv_unity_x(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_x, field_name, mesh_id)

  end function get_adv_unity_x

  !> @brief Returns a pointer to the transport of unity in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of transport of unity in y
  function get_adv_unity_y(self, mesh_id) result(adv_unity_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),                      pointer    :: adv_unity_y
    character(str_def)                                :: field_name

    field_name = 'adv_unity_y'
    adv_unity_y => self%adv_unity_y(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_y, field_name, mesh_id)

  end function get_adv_unity_y

  !> @brief Returns a pointer to the transport of unity in z
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of transport of unity in z
  function get_adv_unity_z(self, mesh_id) result(adv_unity_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),                      pointer    :: adv_unity_z
    character(str_def)                                :: field_name

    field_name = 'adv_unity_z'
    adv_unity_z => self%adv_unity_z(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_z, field_name, mesh_id)

  end function get_adv_unity_z

  !> @brief Returns a pointer to the half time step transport of unity in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of half time step transport of unity in x
  function get_adv_unity_half_x(self, mesh_id) result(adv_unity_half_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),                      pointer    :: adv_unity_half_x
    character(str_def)                                :: field_name

    field_name = 'adv_unity_half_x'
    adv_unity_half_x => self%adv_unity_half_x(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_half_x, field_name, mesh_id)

  end function get_adv_unity_half_x

  !> @brief Returns a pointer to the half time step transport of unity in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of half time step transport of unity in y
  function get_adv_unity_half_y(self, mesh_id) result(adv_unity_half_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),                      pointer    :: adv_unity_half_y
    character(str_def)                                :: field_name

    field_name = 'adv_unity_half_y'
    adv_unity_half_y => self%adv_unity_half_y(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_half_y, field_name, mesh_id)

  end function get_adv_unity_half_y

  !> @brief Returns a pointer to the half time step transport of unity in z
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of half time step transport of unity in z
  function get_adv_unity_half_z(self, mesh_id) result(adv_unity_half_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),                      pointer    :: adv_unity_half_z
    character(str_def)                                :: field_name

    field_name = 'adv_unity_half_z'
    adv_unity_half_z => self%adv_unity_half_z(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_half_z, field_name, mesh_id)

  end function get_adv_unity_half_z

  !> @brief Returns number of split transport steps for the dry density
  !> @return The number of split transport steps for the dry density
  function get_num_dry_steps(self) result(num_dry_steps)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: num_dry_steps

    num_dry_steps = self%num_dry_steps

  end function get_num_dry_steps

  !> @brief Returns a pointer stored field at the start of the time step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The field at the start of the time step
  function get_field_n(self, mesh_id) result(field_n)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: field_n

    field_n => self%field_n(self%idx_from_mesh_id(mesh_id))

  end function get_field_n

  !> @brief Returns a pointer to the dry density field at start of transport step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The step from which to return the density
  !> @return The dry density field before its transport
  function get_rho_d_n(self, mesh_id, step) result(rho_d_n)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: rho_d_n
    character(str_def)                                :: field_name

    field_name = 'rho_d_n'
    rho_d_n => self%rho_d_n(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d_n, field_name, mesh_id)

  end function get_rho_d_n

  !> @brief Returns a pointer to the dry density field after transport
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_rho_d_np1(self, mesh_id, step) result(rho_d_np1)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: rho_d_np1
    character(str_def)                                :: field_name

    field_name = 'rho_d_np1'
    rho_d_np1 => self%rho_d_np1(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d_np1, field_name, mesh_id)

  end function get_rho_d_np1

  !> @brief Returns a pointer to a mass flux for a particular step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the mass flux
  !> @return The mass flux
  function get_flux(self, mesh_id, step) result(flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: flux

    flux => self%flux(self%idx_from_mesh_id(mesh_id), step)

  end function get_flux

  !> @brief Returns a pointer to the flux from transporting dry density
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the dry flux
  !> @return The dry density flux
  function get_dry_flux(self, mesh_id, step) result(dry_flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_flux
    character(str_def)                                :: field_name

    field_name = 'dry_flux'
    dry_flux => self%dry_flux(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_flux, field_name, mesh_id)

  end function get_dry_flux

  !> @brief Adjusts an existing dry flux field stored in the transport runtime
  !> @param[in] mesh_id   The ID of the mesh for the dry flux
  !> @param[in] step      The step for which to adjust the flux
  !> @param[in] new_flux  The new dry mass flux field to store
  subroutine adjust_dry_flux(self, mesh_id, step, new_flux)

    use consist_w2_to_sh_w2_kernel_mod, only: consist_w2_to_sh_w2_kernel_type
    use consist_w2h_to_sh_w2h_kernel_mod, &
                                        only: consist_w2h_to_sh_w2h_kernel_type
    use consist_w2v_to_sh_w2v_kernel_mod, &
                                        only: consist_w2v_to_sh_w2v_kernel_type
    use fem_constants_mod,              only: get_rmultiplicity
    use check_configuration_mod,        only: check_any_eqn_consistent

    implicit none

    class(transport_runtime_type), intent(inout) :: self
    integer(kind=i_def),           intent(in)    :: mesh_id
    integer(kind=i_def),           intent(in)    :: step
    type(r_tran_field_type),       intent(in)    :: new_flux
    integer(kind=i_def)       :: idx, fs_idx
    logical(kind=l_def)       :: any_eqn_consistent
    type(field_type), pointer :: rmultiplicity_w2 => null()

    idx = self%idx_from_mesh_id(mesh_id)
    call invoke( setval_X(self%dry_flux(idx, step), new_flux))

    ! ------------------------------------------------------------------------ !
    ! May need to adjust the fluxes on the shifted mesh
    ! ------------------------------------------------------------------------ !

    any_eqn_consistent = check_any_eqn_consistent()
    fs_idx = new_flux%which_function_space()

    if (self%n_meshes > 1 .and. idx == 1 .and. any_eqn_consistent) then

      ! Transform dry fluxes to the shifted mesh, with case depending on fs_idx
      select case (fs_idx)
      case (W2)
        rmultiplicity_w2 => get_rmultiplicity(W2, new_flux%get_mesh_id())
        call invoke(                                              &
          setval_c(self%dry_flux(2,step), 0.0_r_tran),            &
          consist_w2_to_sh_w2_kernel_type(self%dry_flux(2,step),  &
                                          self%dry_flux(1,step),  &
                                          rmultiplicity_w2) )

      case (W2h)
        rmultiplicity_w2 => get_rmultiplicity(W2h, new_flux%get_mesh_id())
        call invoke(                                               &
          setval_c(self%dry_flux(2,step), 0.0_r_tran),             &
          consist_w2h_to_sh_w2h_kernel_type(self%dry_flux(2,step), &
                                            self%dry_flux(1,step), &
                                            rmultiplicity_w2) )
      case (W2v)
        call invoke(                                               &
          consist_w2v_to_sh_w2v_kernel_type(self%dry_flux(2,step), &
                                            self%dry_flux(1,step)) )
      case default
        call log_event( "Can only store dry flux for W2, W2h and W2v spaces", LOG_LEVEL_ERROR )
      end select
    end if

  end subroutine adjust_dry_flux

  !> @brief Returns the counter of tracer transport steps
  !> @return The tracer step counter
  function get_tracer_step_ctr(self) result(tracer_step_ctr)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def) :: tracer_step_ctr

    tracer_step_ctr = self%tracer_step_ctr

  end function get_tracer_step_ctr

  !> @brief Increments the counter of tracer transport steps
  subroutine inc_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = self%tracer_step_ctr + 1

  end subroutine inc_tracer_step_ctr

  !> @brief Resets the counter of tracer transport steps
  subroutine reset_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = 1

  end subroutine reset_tracer_step_ctr

  !> @brief Computes the total number of rho transport steps
  !> @result    num_dry_steps    Total number of transport steps for rho
  function compute_num_dry_steps(self) result(num_dry_steps)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name
    use transport_enumerated_types_mod, only: splitting_strang_hvh,   &
                                              splitting_strang_vhv,   &
                                              splitting_hv,           &
                                              splitting_vh,           &
                                              splitting_none

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    ! Internal variables
    integer(kind=i_def) :: num_dry_steps
    integer(kind=i_def) :: config, dry_config
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up consistent tracer transport ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh, splitting_strang_vhv)
      num_dry_steps = 3
    case(splitting_hv, splitting_vh)
      num_dry_steps = 2
    case(splitting_none)
      num_dry_steps = 1
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented with ' // &
        'consistent tracer transport'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function compute_num_dry_steps

  !> @brief Returns the function space for the direction of the dry step
  !> @param[in] step  Index of the dry density splitting step
  !> @result    fs    Enumerator for the W2 function space
  function direction_w2_fs(self, step) result(fs)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name
    use transport_enumerated_types_mod, only: splitting_strang_hvh,   &
                                              splitting_strang_vhv,   &
                                              splitting_hv,           &
                                              splitting_vh,           &
                                              splitting_none

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: step
    ! Internal variables
    integer(kind=i_def) :: config, dry_config, fs
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up compute dry steps ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      end select
    case(splitting_strang_vhv)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      end select
    case(splitting_hv)
      select case(step)
      case(1_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      end select
    case(splitting_vh)
      select case(step)
      case(1_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      end select
    case(splitting_none)
      fs = W2
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function direction_w2_fs

end module transport_runtime_alg_mod
