!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief A module that controls set-up of various transport objects.
!> @details This module controls the set-up of various objects that are
!!          created at the start of (or during) the transport process, and
!!          are needed throughout the transport routines.

module transport_runtime_alg_mod

  use check_configuration_mod,        only: check_any_scheme_mol,            &
                                            check_any_scheme_ffsl,           &
                                            check_any_scheme_split,          &
                                            check_any_scheme_slice,          &
                                            check_any_horizontal_method_mol, &
                                            check_any_hori_scheme_sl,        &
                                            check_any_vert_scheme_sl,        &
                                            check_any_reversible_sl,         &
                                            check_any_shifted,               &
                                            check_horz_dep_pts,              &
                                            check_vert_dep_pts,              &
                                            check_any_splitting_vhv,         &
                                            check_any_eqn_consistent,        &
                                            check_any_consistent_swift,      &
                                            check_any_consistent_cosmic,     &
                                            get_required_stencil_depth

  use constants_mod,                  only: r_def, r_second, i_def, l_def,  &
                                            str_def, tiny_eps, imdi, r_tran
  use cosmic_index_alg_mod,           only: cosmic_index_alg
  use extrusion_mod,                  only: SHIFTED, TWOD
  use r_tran_field_mod,               only: r_tran_field_type
  use integer_field_mod,              only: integer_field_type
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W2, W2h, W2v, W3, Wtheta
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use io_config_mod,                  only: subroutine_timers
  use local_mesh_mod,                 only: local_mesh_type
  use log_mod,                        only: log_event,            &
                                            log_scratch_space,    &
                                            LOG_LEVEL_ERROR,      &
                                            LOG_LEVEL_INFO,       &
                                            log_level
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use model_clock_mod,                only: model_clock_type
  use runtime_tools_mod,              only: check_initialised_field
  use subgrid_config_mod,             only: dep_pt_stencil_extent, &
                                            outer_order,           &
                                            inner_order
  use timer_mod,                      only: timer
  use transport_config_mod,           only: extended_mesh,        &
                                            special_edges_treatment
  use transport_enumerated_types_mod, only: scheme_split,         &
                                            direction_h,          &
                                            direction_v,          &
                                            direction_3d,         &
                                            splitting_strang_hvh, &
                                            splitting_strang_vhv, &
                                            splitting_hv,         &
                                            splitting_vh,         &
                                            splitting_none

  use psykal_lite_mod,                only: invoke_copy_to_rtran
  use field_minmax_alg_mod,           only: get_field_minmax
  use remap_on_extended_mesh_alg_mod, only: initialise_remap_on_extended_mesh, &
                                            remap_field_on_extended_mesh,      &
                                            linear_remap

  implicit none

  private

  ! Public types
  ! TODO #3008: this should be based on a linked_list_item type
  type, public :: transport_runtime_type

    private

    integer(kind=i_def)                                     :: n_meshes
    integer(kind=i_def)                                     :: local_mesh_id
    integer(kind=i_def)                                     :: num_dry_steps
    integer(kind=i_def)                                     :: tracer_step_ctr
    integer(kind=i_def),        allocatable, dimension(:)   :: mesh_ids
    integer(kind=i_def),        allocatable, dimension(:)   :: dep_stencil_extent_x
    integer(kind=i_def),        allocatable, dimension(:)   :: dep_stencil_extent_y
    integer(kind=i_def),        allocatable, dimension(:,:) :: tracer_stencil_extent_ix
    integer(kind=i_def),        allocatable, dimension(:,:) :: tracer_stencil_extent_iy
    integer(kind=i_def),        allocatable, dimension(:,:) :: tracer_stencil_extent_ox
    integer(kind=i_def),        allocatable, dimension(:,:) :: tracer_stencil_extent_oy
    type(r_tran_field_type),    allocatable, dimension(:)   :: advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)   :: horizontal_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)   :: vertical_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)   :: departure_points_x_w2
    type(r_tran_field_type),    allocatable, dimension(:)   :: departure_points_y_w2
    type(r_tran_field_type),    allocatable, dimension(:)   :: departure_points_z_w2
    type(r_tran_field_type),    allocatable, dimension(:)   :: departure_points_z_half_w2
    type(r_tran_field_type),    allocatable, dimension(:)   :: frac_wind_z
    type(r_tran_field_type),    allocatable, dimension(:)   :: frac_wind_z_half
    type(r_tran_field_type),    allocatable, dimension(:,:) :: tracer_dep_pts_ix
    type(r_tran_field_type),    allocatable, dimension(:,:) :: tracer_dep_pts_iy
    type(r_tran_field_type),    allocatable, dimension(:,:) :: tracer_dep_pts_ox
    type(r_tran_field_type),    allocatable, dimension(:,:) :: tracer_dep_pts_oy
    type(r_tran_field_type),    allocatable, dimension(:,:) :: tracer_dep_pts_z
    type(r_tran_field_type),    allocatable, dimension(:,:) :: dry_frac_flux_ix
    type(r_tran_field_type),    allocatable, dimension(:,:) :: dry_frac_flux_iy
    type(r_tran_field_type),    allocatable, dimension(:,:) :: dry_frac_flux_ox
    type(r_tran_field_type),    allocatable, dimension(:,:) :: dry_frac_flux_oy
    type(r_tran_field_type),    allocatable, dimension(:,:) :: dry_frac_flux_z
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_x
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_y
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_z
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_half_x
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_half_y
    type(r_tran_field_type),    allocatable, dimension(:)   :: adv_unity_half_z
    type(r_tran_field_type)                                 :: field_n
    type(r_tran_field_type),    allocatable, dimension(:,:) :: rho_d
    type(r_tran_field_type),    allocatable, dimension(:,:) :: rho_d_ffsl_x
    type(r_tran_field_type),    allocatable, dimension(:,:) :: rho_d_ffsl_y
    type(r_tran_field_type),    allocatable, dimension(:,:) :: flux
    type(r_tran_field_type),    allocatable, dimension(:,:) :: dry_flux
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_cubic_coef_w3
    type(integer_field_type),   allocatable, dimension(:)   :: vert_cubic_index_w3
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_hermite_coef_w3
    type(integer_field_type),   allocatable, dimension(:)   :: vert_hermite_index_w3
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_quintic_coef_w3
    type(integer_field_type),   allocatable, dimension(:)   :: vert_quintic_index_w3
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_linear_coef_w3
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_cubic_coef_wt
    type(integer_field_type),   allocatable, dimension(:)   :: vert_cubic_index_wt
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_hermite_coef_wt
    type(integer_field_type),   allocatable, dimension(:)   :: vert_hermite_index_wt
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_quintic_coef_wt
    type(integer_field_type),   allocatable, dimension(:)   :: vert_quintic_index_wt
    type(r_tran_field_type),    allocatable, dimension(:)   :: vert_linear_coef_wt
    type(integer_field_type),   allocatable, dimension(:)   :: cosmic_istart_x
    type(integer_field_type),   allocatable, dimension(:)   :: cosmic_iend_x
    type(integer_field_type),   allocatable, dimension(:)   :: cosmic_istart_y
    type(integer_field_type),   allocatable, dimension(:)   :: cosmic_iend_y
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_istart_ix
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_iend_ix
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_istart_iy
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_iend_iy
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_istart_ox
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_iend_ox
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_istart_oy
    type(integer_field_type),   allocatable, dimension(:,:) :: tracer_iend_oy
    real(kind=r_tran),          allocatable, dimension(:)   :: horizontal_cfl_max
    real(kind=r_tran),          allocatable, dimension(:)   :: vertical_cfl_max
    real(kind=r_tran),          allocatable, dimension(:)   :: total_cfl_max
    class(model_clock_type),    pointer                     :: model_clock
    logical(kind=l_def)                                     :: rho_monotone_remap
    logical(kind=l_def)                                     :: rho_enforce_minvalue
    real(kind=r_tran)                                       :: rho_minvalue
    type(r_tran_field_type)                                 :: remap_weights
    type(integer_field_type)                                :: remap_indices
    logical(kind=l_def)                                     :: computed_remapping
    logical(kind=l_def)                                     :: computed_dep_pt_idxs
    type(integer_field_type)                                :: dep_pt_istart_x
    type(integer_field_type)                                :: dep_pt_iend_x
    type(integer_field_type)                                :: dep_pt_istart_y
    type(integer_field_type)                                :: dep_pt_iend_y

    contains

    procedure, private :: idx_from_mesh_id
    procedure, private :: compute_num_dry_steps
    procedure, public  :: direction_w2_fs
    procedure, public  :: get_local_mesh_id
    procedure, public  :: get_prime_extrusion_mesh_id
    procedure, public  :: restrict_dry_fields
    procedure, public  :: shift_dry_fields
    procedure, public  :: compute_consistent_quantities
    procedure, public  :: get_number_substeps
    procedure, public  :: get_dt_substep
    procedure, public  :: get_advecting_wind
    procedure, public  :: get_directional_advecting_wind
    procedure, public  :: get_horizontal_advecting_wind
    procedure, public  :: get_vertical_advecting_wind
    procedure, public  :: get_departure_points_x_w2
    procedure, public  :: get_departure_points_y_w2
    procedure, public  :: get_departure_points_z_w2
    procedure, public  :: get_frac_wind_z
    procedure, public  :: get_frac_wind_z_half
    procedure, public  :: get_tracer_dep_pts_x
    procedure, public  :: get_tracer_dep_pts_y
    procedure, public  :: get_tracer_dep_pts_z
    procedure, public  :: get_dry_frac_flux_x
    procedure, public  :: get_dry_frac_flux_y
    procedure, public  :: get_dry_frac_flux_z
    procedure, public  :: get_dep_stencil_extent_x
    procedure, public  :: get_dep_stencil_extent_y
    procedure, public  :: get_tracer_stencil_extent_x
    procedure, public  :: get_tracer_stencil_extent_y
    procedure, public  :: get_adv_unity_x
    procedure, public  :: get_adv_unity_y
    procedure, public  :: get_adv_unity_z
    procedure, public  :: get_adv_unity_half_x
    procedure, public  :: get_adv_unity_half_y
    procedure, public  :: get_adv_unity_half_z
    procedure, public  :: get_vert_sl_coef
    procedure, public  :: get_vert_sl_index
    procedure, public  :: get_cosmic_istart_x
    procedure, public  :: get_cosmic_iend_x
    procedure, public  :: get_cosmic_istart_y
    procedure, public  :: get_cosmic_iend_y
    procedure, public  :: get_tracer_istart_x
    procedure, public  :: get_tracer_iend_x
    procedure, public  :: get_tracer_istart_y
    procedure, public  :: get_tracer_iend_y
    procedure, public  :: get_field_n
    procedure, public  :: set_field_n
    procedure, public  :: get_rho_d
    procedure, public  :: set_rho_d
    procedure, public  :: get_rho_d_ffsl_x
    procedure, public  :: set_rho_d_ffsl_x
    procedure, public  :: get_rho_d_ffsl_y
    procedure, public  :: set_rho_d_ffsl_y
    procedure, public  :: get_flux
    procedure, public  :: set_flux
    procedure, public  :: get_dry_flux
    procedure, public  :: set_dry_flux
    procedure, public  :: get_num_dry_steps
    procedure, public  :: get_tracer_step_ctr
    procedure, public  :: inc_tracer_step_ctr
    procedure, public  :: reset_tracer_step_ctr
    procedure, public  :: remap_on_extended_mesh
    procedure, public  :: initialise => transport_runtime_initialiser
    final              :: destroy_transport_runtime

  end type transport_runtime_type

  !-----------------------------------------------------------------------------
  ! Constructors
  !-----------------------------------------------------------------------------

contains

  !> @brief Constructs the transport_runtime object
  !> @param[in,out] self                  Transport runtime object to set
  !> @param[in]     primal_wind_n_rdef    Wind field at start of current time step on the
  !!                                      prime extrusion
  !> @param[in]     primal_wind_np1_rdef  Predictor of wind field at next time step on
  !!                                      the prime extrusion
  !> @param[in]     model_clock           Time within the model
  !> @param[in]     outer                 Outer (advection) iteration number
  !> @param[in]     cheap_update          Logical flag for cheap transport update
  !> @param[in]     shifted_mesh          (Optional) Shifted mesh
  !>
  subroutine transport_runtime_initialiser( self,                 &
                                            primal_wind_n_rdef,   &
                                            primal_wind_np1_rdef, &
                                            model_clock,          &
                                            outer,                &
                                            cheap_update,         &
                                            shifted_mesh)

    use calc_dep_pts_alg_mod,          only: calc_vert_dep_pts, &
                                             calc_hori_dep_pts, &
                                             select_detj_at_w2, &
                                             calc_frac_vert_wind_alg
    use compute_sl_coefficients_alg_mod, &
                                       only: compute_vert_quintic_coefficients_alg, &
                                             compute_vert_cubic_coefficients_alg
    use ffsl_unity_transport_alg_mod,  only: ffsl_unity_transport_alg
    use split_w2_field_kernel_mod,     only: split_w2_field_kernel_type
    use transport_config_mod,          only: max_vert_cfl_calc,           &
                                             max_vert_cfl_calc_dep_point, &
                                             max_vert_cfl_calc_uniform,   &
                                             vertical_sl_order,           &
                                             vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite
    use map_w2_to_sh_w2_alg_mod,       only: sample_w2_to_sh_w2_alg
    use calc_max_cfl_kernel_mod,       only: calc_max_cfl_kernel_type
    use dg_matrix_vector_kernel_mod,   only: dg_matrix_vector_kernel_type
    use fem_constants_mod,             only: get_inverse_W3_mass_matrix_r_tran
    use r_tran_operator_mod,           only: r_tran_operator_type

    implicit none

    class(transport_runtime_type), intent(inout) :: self

    type(field_type),        target, intent(in) :: primal_wind_n_rdef
    type(field_type),        target, intent(in) :: primal_wind_np1_rdef
    class(model_clock_type), target, intent(in) :: model_clock
    integer(kind=i_def),             intent(in) :: outer
    logical(kind=l_def),             intent(in) :: cheap_update

    type(mesh_type),  pointer, intent(in), optional :: shifted_mesh

    type(r_tran_field_type)          :: cfl, vertical_cfl, horizontal_cfl
    type(r_tran_field_type)          :: cfl_dep, cfl_dep_half
    type(r_tran_field_type)          :: sum_cfl, sum_horizontal_cfl, hori_cfl_dep
    type(r_tran_field_type)          :: dep_pt_wind_n, dep_pt_wind_np1
    integer(kind=i_def)              :: mesh_idx, num_compute_meshes
    integer(kind=i_def)              :: n_steps, n_meshes
    type(mesh_type),         pointer :: mesh => null()
    type(local_mesh_type),   pointer :: local_mesh => null()
    type(r_tran_field_type), pointer :: wind_n   => null()
    type(r_tran_field_type), pointer :: wind_np1 => null()
    type(r_tran_field_type), target  :: shifted_wind_n
    type(r_tran_field_type), target  :: shifted_wind_np1
    type(field_type),        target  :: shifted_wind_n_rdef
    type(field_type),        target  :: shifted_wind_np1_rdef
    type(r_tran_field_type)          :: detj_at_w2_transport
    real(kind=r_tran)                :: cfl_min, cfl_max
    real(kind=r_tran)                :: dep_min, dep_max
    real(kind=r_tran)                :: h_cfl_min, h_cfl_max
    real(kind=r_tran)                :: v_cfl_min, v_cfl_max
    real(r_tran)                     :: cast_dt, half_dt
    logical(kind=l_def)              :: any_scheme_mol, any_scheme_split
    logical(kind=l_def)              :: any_scheme_ffsl, any_shifted
    logical(kind=l_def)              :: any_splitting_vhv, any_scheme_slice
    logical(kind=l_def)              :: any_hori_scheme_sl, any_vert_scheme_sl
    logical(kind=l_def)              :: any_reversible_sl
    logical(kind=l_def)              :: any_consistent_swift
    logical(kind=l_def)              :: any_horz_dep_pts, any_vert_dep_pts
    logical(kind=l_def)              :: hermite_sl, vhv_split_sl
    integer(kind=i_def)              :: full_stencil_extent_x
    integer(kind=i_def)              :: full_stencil_extent_y

    type(mesh_type),           pointer :: tmp_mesh => null()
    type(mesh_type),           pointer :: twod_mesh => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()
    type(function_space_type), pointer :: w3_2d_fs => null()
    type(function_space_type), pointer :: w3_md6_fs => null()
    type(function_space_type), pointer :: w3_md4_fs => null()
    type(function_space_type), pointer :: w3_md2_fs => null()
    type(function_space_type), pointer :: wt_md6_fs => null()
    type(function_space_type), pointer :: wt_md4_fs => null()
    type(function_space_type), pointer :: wt_md2_fs => null()

    ! r_tran type fields
    type(r_tran_field_type), target :: primal_wind_n
    type(r_tran_field_type), target :: primal_wind_np1

    if ( subroutine_timers ) call timer('transport.runtime_init')

    write(log_scratch_space, '(A,I4)') 'Setting up transport_runtime on mesh: ', &
                                       primal_wind_n_rdef%get_mesh_id()
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    ! Proxy for the first time the object is initialised
    if ( .not. allocated(self%mesh_ids) ) self%computed_remapping = .false.
    if ( .not. allocated(self%mesh_ids) ) self%computed_dep_pt_idxs = .false.

    ! TODO: options for remapping density are hard-wired
    ! They could be options in the future
    self%rho_monotone_remap = .true.
    self%rho_enforce_minvalue = .true.
    self%rho_minvalue = 0.0_r_tran

    ! Transfer r_def input to r_tran fields
    call primal_wind_n%initialise(vector_space = primal_wind_n_rdef%get_function_space() )
    call primal_wind_np1%initialise(vector_space = primal_wind_np1_rdef%get_function_space() )
    call invoke_copy_to_rtran(primal_wind_n,primal_wind_n_rdef)
    call invoke_copy_to_rtran(primal_wind_np1,primal_wind_np1_rdef)

    ! ======================================================================== !
    ! Checks for what schemes we have

    any_scheme_mol = check_any_scheme_mol()
    any_scheme_ffsl = check_any_scheme_ffsl()
    any_scheme_split = check_any_scheme_split()
    any_scheme_slice = check_any_scheme_slice()
    any_horz_dep_pts = check_horz_dep_pts()
    any_vert_dep_pts = check_vert_dep_pts()
    any_splitting_vhv = check_any_splitting_vhv()
    any_reversible_sl = check_any_reversible_sl()
    any_hori_scheme_sl = check_any_hori_scheme_sl()
    any_vert_scheme_sl = check_any_vert_scheme_sl()
    any_shifted = check_any_shifted()
    any_consistent_swift = check_any_consistent_swift()

    ! ======================================================================== !
    ! Determine number of meshes

    ! By default only compute auxiliary fields on prime extrusion mesh
    num_compute_meshes = 1

    if ( present(shifted_mesh) ) then
      self%n_meshes = 2
      ! Only compute things on the shifted mesh if we need to
      if (any_shifted) then
        num_compute_meshes = 2
      end if
    else
      self%n_meshes = 1
    end if

    !> @todo This is almost certainly the wrong thing to do but I want to get
    !>       something done.
    !>
    self%model_clock => model_clock
    cast_dt = real( model_clock%get_seconds_per_step(), r_tran )

    mesh => primal_wind_n_rdef%get_mesh()
    local_mesh => mesh%get_local_mesh()
    self%local_mesh_id = local_mesh%get_id()

    if (.not. allocated( self%mesh_ids ) ) then
      if ( subroutine_timers ) call timer('transport.runtime_allocate')

      allocate( self%mesh_ids(self%n_meshes),                   &
                self%advecting_wind(self%n_meshes),             &
                self%horizontal_advecting_wind(self%n_meshes),  &
                self%vertical_advecting_wind(self%n_meshes),    &
                self%departure_points_x_w2(self%n_meshes),      &
                self%departure_points_y_w2(self%n_meshes),      &
                self%departure_points_z_w2(self%n_meshes),      &
                self%departure_points_z_half_w2(self%n_meshes), &
                self%frac_wind_z(self%n_meshes),                &
                self%frac_wind_z_half(self%n_meshes),           &
                self%dep_stencil_extent_x(self%n_meshes),       &
                self%dep_stencil_extent_y(self%n_meshes),       &
                self%adv_unity_x(self%n_meshes),                &
                self%adv_unity_y(self%n_meshes),                &
                self%adv_unity_z(self%n_meshes),                &
                self%adv_unity_half_x(self%n_meshes),           &
                self%adv_unity_half_y(self%n_meshes),           &
                self%adv_unity_half_z(self%n_meshes),           &
                self%vert_cubic_coef_w3(self%n_meshes),         &
                self%vert_cubic_index_w3(self%n_meshes),        &
                self%vert_hermite_coef_w3(self%n_meshes),       &
                self%vert_hermite_index_w3(self%n_meshes),      &
                self%vert_quintic_coef_w3(self%n_meshes),       &
                self%vert_quintic_index_w3(self%n_meshes),      &
                self%vert_linear_coef_w3(self%n_meshes),        &
                self%vert_cubic_coef_wt(self%n_meshes),         &
                self%vert_cubic_index_wt(self%n_meshes),        &
                self%vert_hermite_coef_wt(self%n_meshes),       &
                self%vert_hermite_index_wt(self%n_meshes),      &
                self%vert_quintic_coef_wt(self%n_meshes),       &
                self%vert_quintic_index_wt(self%n_meshes),      &
                self%vert_linear_coef_wt(self%n_meshes),        &
                self%cosmic_istart_x(self%n_meshes),            &
                self%cosmic_iend_x(self%n_meshes),              &
                self%cosmic_istart_y(self%n_meshes),            &
                self%cosmic_iend_y(self%n_meshes),              &
                self%horizontal_cfl_max(self%n_meshes),         &
                self%vertical_cfl_max(self%n_meshes),           &
                self%total_cfl_max(self%n_meshes) )
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
    end if

    ! Get mesh ID and element order
    self%mesh_ids(1) = primal_wind_n_rdef%get_mesh_id()

    ! If asked for compute objects on the shifted mesh
    if ( present(shifted_mesh ) ) then
      self%mesh_ids(2) = shifted_mesh%get_id()
      write(log_scratch_space, '(A,I4)') '... and shifted mesh: ', &
                                         shifted_mesh%get_id()
      call log_event(log_scratch_space, LOG_LEVEL_INFO)
    end if

    ! ======================================================================== !
    ! Create winds on shifted mesh
    if ( present(shifted_mesh) ) then
      if ( subroutine_timers ) call timer('transport.shift_wind')
      ! TODO #3008: only initialise these if they will be used
      ! For now we need to initialise them for copying the transport runtime
      call shifted_wind_n_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_np1_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_n%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_np1%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )

      if (num_compute_meshes == 2) then
        ! Rather than duplicating a lot of mapping code for different field types,
        ! we go by intermediate r_def fields before copying to r_tran fields
        call sample_w2_to_sh_w2_alg(shifted_wind_n_rdef,   primal_wind_n_rdef)
        call sample_w2_to_sh_w2_alg(shifted_wind_np1_rdef, primal_wind_np1_rdef)
        call invoke_copy_to_rtran(shifted_wind_n,shifted_wind_n_rdef)
        call invoke_copy_to_rtran(shifted_wind_np1,shifted_wind_np1_rdef)
      end if
      if ( subroutine_timers ) call timer('transport.shift_wind')
    end if

    ! ======================================================================== !
    ! Initialise fields
    ! TODO #3008: we should only initialise fields that we actually use
    if ( subroutine_timers ) call timer('transport.field_initialise')

    do mesh_idx = 1, self%n_meshes
      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
      twod_mesh => mesh_collection%get_mesh(tmp_mesh, TWOD)
      w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2)
      w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2h)
      w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2v)
      w3_fs => function_space_collection%get_fs(tmp_mesh, element_order, W3)
      w3_2d_fs => function_space_collection%get_fs(twod_mesh, element_order, W3)

      call self%advecting_wind(mesh_idx)%initialise( w2_fs )
      call self%horizontal_advecting_wind(mesh_idx)%initialise( w2h_fs )
      call self%vertical_advecting_wind(mesh_idx)%initialise( w2v_fs )
      call self%departure_points_z_w2(mesh_idx)%initialise( w2v_fs )
      call self%departure_points_z_half_w2(mesh_idx)%initialise( w2v_fs )
      call self%departure_points_x_w2(mesh_idx)%initialise( w2h_fs )
      call self%departure_points_y_w2(mesh_idx)%initialise( w2h_fs )
      call self%frac_wind_z(mesh_idx)%initialise( w2v_fs )
      call self%frac_wind_z_half(mesh_idx)%initialise( w2v_fs )
      call self%adv_unity_x(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_y(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_z(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_half_x(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_half_y(mesh_idx)%initialise( w3_fs )
      call self%adv_unity_half_z(mesh_idx)%initialise( w3_fs )
      call self%cosmic_istart_x(mesh_idx)%initialise( w3_2d_fs )
      call self%cosmic_iend_x(mesh_idx)%initialise( w3_2d_fs )
      call self%cosmic_istart_y(mesh_idx)%initialise( w3_2d_fs )
      call self%cosmic_iend_y(mesh_idx)%initialise( w3_2d_fs )
    end do

    if ( subroutine_timers ) call timer('transport.field_initialise')

    ! ======================================================================== !
    ! Compute auxiliary transport fields

    do mesh_idx = 1, num_compute_meshes

      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))

      !=======================================================================!
      ! Create advecting winds

      if ( mesh_idx == 1 ) then
        ! First pass, make wind_n & wind_np1 point to the primal mesh fields
        wind_n   => primal_wind_n
        wind_np1 => primal_wind_np1
      else
        ! For second pass (if needed) set wind_n & wind_np1 to point to
        ! shifted mesh versions
        wind_n   => shifted_wind_n
        wind_np1 => shifted_wind_np1
      end if

      if ( cheap_update .AND. outer > 1 ) then
        ! Set advecting wind = (wind^{n+1}-wind^{n})/2
        ! For outer>2 this becomes (wind^{n+1}-wind^prev)/2
        call invoke( aX_minus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_np1, &
                                                                0.5_r_tran, wind_n) )
      else
        ! Set advecting wind = (wind^{n}+wind^{n+1})/2
        call invoke( aX_plus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_n, &
                                                               0.5_r_tran, wind_np1) )
      end if

      ! Split into horizontal and vertical advecting winds
      call invoke( setval_c(self%horizontal_advecting_wind(mesh_idx), 0.0_r_tran),      &
                   setval_c(self%vertical_advecting_wind(mesh_idx), 0.0_r_tran),        &
                   split_w2_field_kernel_type(self%horizontal_advecting_wind(mesh_idx), &
                                              self%vertical_advecting_wind(mesh_idx),   &
                                              self%advecting_wind(mesh_idx)) )

      !=======================================================================!
      ! Compute departure points

      ! Get detj_at_w2 using wind_n
      w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2)
      call detj_at_w2_transport%initialise( w2_fs )
      call select_detj_at_w2( wind_n, detj_at_w2_transport )

      ! Set winds for computing departure points based on cheap update flag
      if (any_vert_dep_pts .OR. any_horz_dep_pts) then
        call dep_pt_wind_n%initialise( wind_n%get_function_space() )
        call dep_pt_wind_np1%initialise( wind_np1%get_function_space() )
        if ( cheap_update .AND. outer > 1 ) then
          ! Set up winds for cheap update with FFSL/SL
          call invoke( aX_minus_bY(dep_pt_wind_n, 0.5_r_tran, wind_np1,   &
                                                  0.5_r_tran, wind_n),    &
                       aX_minus_bY(dep_pt_wind_np1, 0.5_r_tran, wind_np1, &
                                                    0.5_r_tran, wind_n) )
        else
          ! Use wind_n and wind_np1
          call invoke( setval_X(dep_pt_wind_n, wind_n), &
                       setval_X(dep_pt_wind_np1, wind_np1) )
        end if
      end if

      ! If any vertical scheme is ffsl/sl compute vertical departure points
      if (any_vert_dep_pts) then

        call cfl_dep%initialise( vector_space = &
                function_space_collection%get_fs(tmp_mesh, element_order, W2) )

        ! TODO #4160: this assumes that if any_splitting_vhv=.true. then all transport uses VHV splitting
        if (any_splitting_vhv) then
          ! If any splitting is VHV then compute departure points with half time step
          half_dt = 0.5_r_tran * cast_dt
          call cfl_dep_half%initialise( vector_space = &
                  function_space_collection%get_fs(tmp_mesh, element_order, W2) )
          call calc_vert_dep_pts( self%departure_points_z_half_w2(mesh_idx), &
                                  cfl_dep_half,                              &
                                  dep_pt_wind_n,                             &
                                  dep_pt_wind_np1,                           &
                                  half_dt )
          ! Multiply CFL by 2 to get full CFL
          call invoke( a_times_X(cfl_dep, 2.0_r_tran, cfl_dep_half) )
          ! Compute fractional wind with half time step
          call calc_frac_vert_wind_alg( self%frac_wind_z_half(mesh_idx),           &
                                        self%departure_points_z_half_w2(mesh_idx), &
                                        half_dt )
        else
          ! If splitting is not VHV then compute full departure points
          call calc_vert_dep_pts( self%departure_points_z_w2(mesh_idx), &
                                  cfl_dep,                              &
                                  dep_pt_wind_n,                        &
                                  dep_pt_wind_np1,                      &
                                  cast_dt )
          ! Compute fractional wind
          call calc_frac_vert_wind_alg( self%frac_wind_z(mesh_idx),           &
                                        self%departure_points_z_w2(mesh_idx), &
                                        cast_dt )
        end if

      end if

      ! If any horizontal scheme is ffsl compute horizontal departure points
      if (any_horz_dep_pts) then
        call calc_hori_dep_pts( self%departure_points_x_w2(mesh_idx),  &
                                self%departure_points_y_w2(mesh_idx),  &
                                dep_pt_wind_n,                         &
                                dep_pt_wind_np1,                       &
                                cast_dt )

        ! Get the required stencil size from the departure points
        call get_field_minmax( self%departure_points_x_w2(mesh_idx), dep_min, dep_max )
        self%dep_stencil_extent_x(mesh_idx) = int( max( abs(dep_max), abs(dep_min) ) )
        call get_field_minmax( self%departure_points_y_w2(mesh_idx), dep_min, dep_max )
        self%dep_stencil_extent_y(mesh_idx) = int( max( abs(dep_max), abs(dep_min) ) )

      end if

      !=======================================================================!
      ! Compute cfls for use in substepping
      if (any_scheme_mol .or. log_level() <= LOG_LEVEL_INFO) then
        if ( subroutine_timers ) call timer('transport.cfl_calculation')

        call cfl%initialise( wind_n%get_function_space() )
        call horizontal_cfl%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
        call vertical_cfl%initialise( self%vertical_advecting_wind(mesh_idx)%get_function_space() )
        call sum_horizontal_cfl%initialise( vector_space = &
                  function_space_collection%get_fs(tmp_mesh, element_order, W3) )
        call sum_cfl%initialise( vector_space = &
                  function_space_collection%get_fs(tmp_mesh, element_order, W3) )

        call invoke( setval_X(cfl, self%advecting_wind(mesh_idx)),             &
                     inc_X_divideby_Y(cfl, detj_at_w2_transport),              &
                     inc_a_times_X(cast_dt, cfl),                              &
                     split_w2_field_kernel_type(horizontal_cfl,                &
                                                vertical_cfl,                  &
                                                cfl) )

        select case(max_vert_cfl_calc)
        ! Calculate the maximum vertical cfl for substepping
        case(max_vert_cfl_calc_uniform)
          call get_field_minmax( vertical_cfl, v_cfl_min, v_cfl_max )
        case(max_vert_cfl_calc_dep_point)
          call hori_cfl_dep%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
          call invoke( split_w2_field_kernel_type(hori_cfl_dep, &
                                                  vertical_cfl, &
                                                  cfl_dep) )
          call get_field_minmax( cfl_dep, v_cfl_min, v_cfl_max )
        case default
          write(log_scratch_space, '(A)') &
            'transport_runtime: maximum vertical CFL method not defined '
          call log_event(log_scratch_space, LOG_LEVEL_ERROR)
        end select

        ! Get the total CFL at each cell - this only works for element_order = 0
        if (element_order == 0_i_def) then
          call invoke( calc_max_cfl_kernel_type(sum_cfl, sum_horizontal_cfl, &
                                                horizontal_cfl, vertical_cfl) )
          call get_field_minmax( sum_horizontal_cfl, h_cfl_min, h_cfl_max )

          call get_field_minmax( sum_cfl, cfl_min, cfl_max )

          self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
          self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
          self%total_cfl_max(mesh_idx) = max(abs(cfl_max), abs(cfl_min))
        else
          call get_field_minmax( horizontal_cfl, h_cfl_min, h_cfl_max )

          self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
          self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
          self%total_cfl_max(mesh_idx) = max( self%horizontal_cfl_max(mesh_idx), &
                                              self%vertical_cfl_max(mesh_idx) )
        end if

        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum horizontal CFL ', self%horizontal_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum vertical CFL ', self%vertical_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum total CFL ', self%total_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )

        if ( subroutine_timers ) call timer('transport.cfl_calculation')
      end if

      !==========================================================================!
      ! For FFSL schemes we require the transport of a unity field to get
      ! the advective FFSL transport
      if (any_scheme_ffsl) then
        call ffsl_unity_transport_alg( self%departure_points_x_w2(mesh_idx),      &
                                       self%departure_points_y_w2(mesh_idx),      &
                                       self%departure_points_z_w2(mesh_idx),      &
                                       self%departure_points_z_half_w2(mesh_idx), &
                                       self%dep_stencil_extent_x(mesh_idx),       &
                                       self%dep_stencil_extent_y(mesh_idx),       &
                                       cast_dt,                                   &
                                       self%adv_unity_x(mesh_idx),                &
                                       self%adv_unity_y(mesh_idx),                &
                                       self%adv_unity_z(mesh_idx),                &
                                       self%adv_unity_half_x(mesh_idx),           &
                                       self%adv_unity_half_y(mesh_idx),           &
                                       self%adv_unity_half_z(mesh_idx) )
      end if

      !==========================================================================!
      ! Compute vertical semi-Lagrangian interpolation coefficients
      if (any_vert_scheme_sl) then
        ! Initialise multi-data field function spaces and coefficient
        ! fields for the primal mesh only unless SLICE is used
        if ( subroutine_timers ) call timer('transport.calc_sl_coeffs')

        if ( mesh_idx == 1 .OR. any_scheme_slice ) then
          w3_md4_fs => function_space_collection%get_fs( tmp_mesh, element_order, &
                                                         W3, 4, ndata_first = .false. )
          w3_md2_fs => function_space_collection%get_fs( tmp_mesh, element_order, &
                                                         W3, 2, ndata_first = .false. )
          wt_md4_fs => function_space_collection%get_fs( tmp_mesh, element_order, &
                                                         Wtheta, 4, ndata_first = .false. )
          wt_md2_fs => function_space_collection%get_fs( tmp_mesh, element_order, &
                                                         Wtheta, 2, ndata_first = .false. )

          if (.not. self%vert_linear_coef_w3(mesh_idx)%is_initialised()) then
            call self%vert_linear_coef_w3(mesh_idx)%initialise( vector_space=w3_md2_fs )
            call self%vert_linear_coef_wt(mesh_idx)%initialise( vector_space=wt_md2_fs )
          end if

          ! TODO: this assumes that if any_splitting_vhv=.true. then all transport uses VHV splitting
          if (any_splitting_vhv) then
            vhv_split_sl = .true.
          else
            vhv_split_sl = .false.
          end if

          if ( any_reversible_sl .OR. vertical_sl_order == vertical_sl_order_cubic_hermite) then
            ! Compute cubic-Hermite coefficients
            hermite_sl = .true.

            if (.not. self%vert_hermite_coef_w3(mesh_idx)%is_initialised()) then
              call self%vert_hermite_coef_w3(mesh_idx)%initialise(  vector_space=w3_md4_fs )
              call self%vert_hermite_index_w3(mesh_idx)%initialise( vector_space=w3_md4_fs )
              call self%vert_hermite_coef_wt(mesh_idx)%initialise(  vector_space=wt_md4_fs )
              call self%vert_hermite_index_wt(mesh_idx)%initialise( vector_space=wt_md4_fs )
            end if

            call compute_vert_cubic_coefficients_alg( self%vert_hermite_coef_w3(mesh_idx),       &
                                                      self%vert_hermite_index_w3(mesh_idx),      &
                                                      self%vert_linear_coef_w3(mesh_idx),        &
                                                      self%vert_hermite_coef_wt(mesh_idx),       &
                                                      self%vert_hermite_index_wt(mesh_idx),      &
                                                      self%vert_linear_coef_wt(mesh_idx),        &
                                                      self%departure_points_z_w2(mesh_idx),      &
                                                      self%departure_points_z_half_w2(mesh_idx), &
                                                      hermite_sl, vhv_split_sl )

          end if

          if ( vertical_sl_order == vertical_sl_order_quintic ) then
            ! Compute quintic coefficients
            if (.not. self%vert_quintic_coef_w3(mesh_idx)%is_initialised()) then
              w3_md6_fs => function_space_collection%get_fs( tmp_mesh, element_order, &
                                                            W3, 6, ndata_first = .false. )
              wt_md6_fs => function_space_collection%get_fs( tmp_mesh, element_order, &
                                                            Wtheta, 6, ndata_first = .false. )

              call self%vert_quintic_coef_w3(mesh_idx)%initialise(  vector_space=w3_md6_fs )
              call self%vert_quintic_index_w3(mesh_idx)%initialise( vector_space=w3_md6_fs )
              call self%vert_quintic_coef_wt(mesh_idx)%initialise(  vector_space=wt_md6_fs )
              call self%vert_quintic_index_wt(mesh_idx)%initialise( vector_space=wt_md6_fs )
            end if

            call compute_vert_quintic_coefficients_alg( self%vert_quintic_coef_w3(mesh_idx),       &
                                                        self%vert_quintic_index_w3(mesh_idx),      &
                                                        self%vert_linear_coef_w3(mesh_idx),        &
                                                        self%vert_quintic_coef_wt(mesh_idx),       &
                                                        self%vert_quintic_index_wt(mesh_idx),      &
                                                        self%vert_linear_coef_wt(mesh_idx),        &
                                                        self%departure_points_z_w2(mesh_idx),      &
                                                        self%departure_points_z_half_w2(mesh_idx), &
                                                        vhv_split_sl )
            nullify( w3_md6_fs, wt_md6_fs )
          else
            ! Compute cubic coefficients
            if (.not. self%vert_cubic_coef_w3(mesh_idx)%is_initialised()) then
              call self%vert_cubic_coef_w3(mesh_idx)%initialise(  vector_space=w3_md4_fs )
              call self%vert_cubic_index_w3(mesh_idx)%initialise( vector_space=w3_md4_fs )
              call self%vert_cubic_coef_wt(mesh_idx)%initialise(  vector_space=wt_md4_fs )
              call self%vert_cubic_index_wt(mesh_idx)%initialise( vector_space=wt_md4_fs )
            end if

            hermite_sl = .false.
            call compute_vert_cubic_coefficients_alg( self%vert_cubic_coef_w3(mesh_idx),         &
                                                      self%vert_cubic_index_w3(mesh_idx),        &
                                                      self%vert_linear_coef_w3(mesh_idx),        &
                                                      self%vert_cubic_coef_wt(mesh_idx),         &
                                                      self%vert_cubic_index_wt(mesh_idx),        &
                                                      self%vert_linear_coef_wt(mesh_idx),        &
                                                      self%departure_points_z_w2(mesh_idx),      &
                                                      self%departure_points_z_half_w2(mesh_idx), &
                                                      hermite_sl, vhv_split_sl )
          end if

          nullify( w3_md4_fs, wt_md4_fs, w3_md2_fs, wt_md2_fs )

        end if

        if ( subroutine_timers ) call timer('transport.calc_sl_coeffs')

      end if ! vertical SL interpolation coefficients

      !==========================================================================!
      ! Compute index for panel ID change for horizontal schemes that use
      ! COSMIC splitting (to get the correct field_x/y at panel edge)
      ! and the required horizontal stencil size based on the maximum CFL
      if (any_horz_dep_pts) then
        if ( special_edges_treatment ) then
          full_stencil_extent_x = self%dep_stencil_extent_x(mesh_idx) + 2 + outer_order
          full_stencil_extent_y = self%dep_stencil_extent_y(mesh_idx) + 2 + outer_order
        else
          full_stencil_extent_x = self%dep_stencil_extent_x(mesh_idx) + 1 + outer_order
          full_stencil_extent_y = self%dep_stencil_extent_y(mesh_idx) + 1 + outer_order
        end if

        call cosmic_index_alg( self%cosmic_istart_x(mesh_idx),      &
                               self%cosmic_iend_x(mesh_idx),        &
                               self%cosmic_istart_y(mesh_idx),      &
                               self%cosmic_iend_y(mesh_idx),        &
                               full_stencil_extent_x,               &
                               full_stencil_extent_y )

        if (any_consistent_swift .and. .not. self%computed_dep_pt_idxs) then

          ! Compute indices for computing outer tracer departure points
          call self%dep_pt_istart_x%initialise( w3_2d_fs )
          call self%dep_pt_iend_x%initialise( w3_2d_fs )
          call self%dep_pt_istart_y%initialise( w3_2d_fs )
          call self%dep_pt_iend_y%initialise( w3_2d_fs )
          ! Use departure point stencil extent as the departure point
          ! calculation only uses this extent
          call cosmic_index_alg( self%dep_pt_istart_x,  &
                                 self%dep_pt_iend_x,    &
                                 self%dep_pt_istart_y,  &
                                 self%dep_pt_iend_y,    &
                                 dep_pt_stencil_extent, &
                                 dep_pt_stencil_extent )

          self%computed_dep_pt_idxs = .true.
        end if

      end if ! COSMIC panel ID index

    end do ! loop over meshes

    !==========================================================================!
    ! Dry fields stored for consistent transport of scalars
    self%num_dry_steps = self%compute_num_dry_steps()

    ! Allocate arrays for dry fields
    if ( .not. allocated( self%rho_d ) ) then
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
      n_meshes = self%n_meshes
      n_steps = self%num_dry_steps
      allocate( self%rho_d(n_meshes, n_steps+1),                               &
                self%rho_d_ffsl_x(n_meshes, n_steps),                          &
                self%rho_d_ffsl_y(n_meshes, n_steps),                          &
                self%flux(n_meshes, n_steps-1),                                &
                self%dry_flux(n_meshes, n_steps),                              &
                self%tracer_dep_pts_ix(n_meshes, n_steps),                     &
                self%tracer_dep_pts_iy(n_meshes, n_steps),                     &
                self%tracer_dep_pts_ox(n_meshes, n_steps),                     &
                self%tracer_dep_pts_oy(n_meshes, n_steps),                     &
                self%tracer_dep_pts_z(n_meshes, n_steps),                      &
                self%dry_frac_flux_ix(n_meshes, n_steps),                      &
                self%dry_frac_flux_iy(n_meshes, n_steps),                      &
                self%dry_frac_flux_ox(n_meshes, n_steps),                      &
                self%dry_frac_flux_oy(n_meshes, n_steps),                      &
                self%dry_frac_flux_z(n_meshes, n_steps),                       &
                self%tracer_stencil_extent_ix(n_meshes, n_steps),              &
                self%tracer_stencil_extent_iy(n_meshes, n_steps),              &
                self%tracer_stencil_extent_ox(n_meshes, n_steps),              &
                self%tracer_stencil_extent_oy(n_meshes, n_steps),              &
                self%tracer_istart_ix(n_meshes, n_steps),                      &
                self%tracer_istart_iy(n_meshes, n_steps),                      &
                self%tracer_istart_ox(n_meshes, n_steps),                      &
                self%tracer_istart_oy(n_meshes, n_steps),                      &
                self%tracer_iend_ix(n_meshes, n_steps),                        &
                self%tracer_iend_iy(n_meshes, n_steps),                        &
                self%tracer_iend_ox(n_meshes, n_steps),                        &
                self%tracer_iend_oy(n_meshes, n_steps)                         &
      )
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
    end if

    ! Set step counter to be 1
    self%tracer_step_ctr = 1

    nullify(mesh, local_mesh, w2_fs, w3_fs, tmp_mesh, w2h_fs, w2v_fs, w3_2d_fs)

    if ( subroutine_timers ) call timer('transport.runtime_init')

  end subroutine transport_runtime_initialiser

  !> Finalizer for the transport runtime
  !> @param [in,out] self The transport runtime object
  subroutine destroy_transport_runtime(self)
    implicit none
    type(transport_runtime_type), intent(inout) :: self

    if ( allocated( self%mesh_ids ) )                  deallocate( self%mesh_ids )
    if ( allocated( self%advecting_wind ) )            deallocate( self%advecting_wind )
    if ( allocated( self%horizontal_advecting_wind ) ) deallocate( self%horizontal_advecting_wind )
    if ( allocated( self%vertical_advecting_wind ) )   deallocate( self%vertical_advecting_wind )
    if ( allocated( self%departure_points_x_w2 ) )     deallocate( self%departure_points_x_w2 )
    if ( allocated( self%departure_points_y_w2 ) )     deallocate( self%departure_points_y_w2 )
    if ( allocated( self%departure_points_z_w2 ) )     deallocate( self%departure_points_z_w2 )
    if ( allocated( self%frac_wind_z ) )               deallocate( self%frac_wind_z )
    if ( allocated( self%frac_wind_z_half ) )          deallocate( self%frac_wind_z_half )
    if ( allocated( self%adv_unity_x ) )               deallocate( self%adv_unity_x )
    if ( allocated( self%adv_unity_y ) )               deallocate( self%adv_unity_y )
    if ( allocated( self%adv_unity_z ) )               deallocate( self%adv_unity_z )
    if ( allocated( self%adv_unity_half_x ) )          deallocate( self%adv_unity_half_x )
    if ( allocated( self%adv_unity_half_y ) )          deallocate( self%adv_unity_half_y )
    if ( allocated( self%adv_unity_half_z ) )          deallocate( self%adv_unity_half_z )
    if ( allocated( self%vert_cubic_coef_w3 ) )        deallocate( self%vert_cubic_coef_w3 )
    if ( allocated( self%vert_cubic_index_w3 ) )       deallocate( self%vert_cubic_index_w3 )
    if ( allocated( self%vert_hermite_coef_w3 ) )      deallocate( self%vert_hermite_coef_w3 )
    if ( allocated( self%vert_hermite_index_w3 ) )     deallocate( self%vert_hermite_index_w3 )
    if ( allocated( self%vert_quintic_coef_w3 ) )      deallocate( self%vert_quintic_coef_w3 )
    if ( allocated( self%vert_quintic_index_w3 ) )     deallocate( self%vert_quintic_index_w3 )
    if ( allocated( self%vert_linear_coef_w3 ) )       deallocate( self%vert_linear_coef_w3 )
    if ( allocated( self%vert_cubic_coef_wt ) )        deallocate( self%vert_cubic_coef_wt )
    if ( allocated( self%vert_cubic_index_wt ) )       deallocate( self%vert_cubic_index_wt )
    if ( allocated( self%vert_hermite_coef_wt ) )      deallocate( self%vert_hermite_coef_wt )
    if ( allocated( self%vert_hermite_index_wt ) )     deallocate( self%vert_hermite_index_wt )
    if ( allocated( self%vert_quintic_coef_wt ) )      deallocate( self%vert_quintic_coef_wt )
    if ( allocated( self%vert_quintic_index_wt ) )     deallocate( self%vert_quintic_index_wt )
    if ( allocated( self%vert_linear_coef_wt ) )       deallocate( self%vert_linear_coef_wt )
    if ( allocated( self%cosmic_istart_x ) )           deallocate( self%cosmic_istart_x )
    if ( allocated( self%cosmic_iend_x ) )             deallocate( self%cosmic_iend_x )
    if ( allocated( self%cosmic_istart_y ) )           deallocate( self%cosmic_istart_y )
    if ( allocated( self%cosmic_iend_y ) )             deallocate( self%cosmic_iend_y )
    if ( allocated( self%rho_d ) )                     deallocate( self%rho_d )
    if ( allocated( self%rho_d_ffsl_x ) )              deallocate( self%rho_d_ffsl_x )
    if ( allocated( self%rho_d_ffsl_y ) )              deallocate( self%rho_d_ffsl_y )
    if ( allocated( self%flux ) )                      deallocate( self%flux )
    if ( allocated( self%dry_flux ) )                  deallocate( self%dry_flux )
    if ( allocated( self%horizontal_cfl_max ) )        deallocate( self%horizontal_cfl_max )
    if ( allocated( self%vertical_cfl_max ) )          deallocate( self%vertical_cfl_max )
    if ( allocated( self%total_cfl_max ) )             deallocate( self%total_cfl_max )
    if ( allocated( self%tracer_dep_pts_ix ) )         deallocate( self%tracer_dep_pts_ix )
    if ( allocated( self%tracer_dep_pts_iy ) )         deallocate( self%tracer_dep_pts_iy )
    if ( allocated( self%tracer_dep_pts_ox ) )         deallocate( self%tracer_dep_pts_ox )
    if ( allocated( self%tracer_dep_pts_oy ) )         deallocate( self%tracer_dep_pts_oy )
    if ( allocated( self%tracer_dep_pts_z ) )          deallocate( self%tracer_dep_pts_z )
    if ( allocated( self%dry_frac_flux_ix ) )          deallocate( self%dry_frac_flux_ix )
    if ( allocated( self%dry_frac_flux_iy ) )          deallocate( self%dry_frac_flux_iy )
    if ( allocated( self%dry_frac_flux_ox ) )          deallocate( self%dry_frac_flux_ox )
    if ( allocated( self%dry_frac_flux_oy ) )          deallocate( self%dry_frac_flux_oy )
    if ( allocated( self%dry_frac_flux_z ) )           deallocate( self%dry_frac_flux_z )
    if ( allocated( self%tracer_istart_ix ) )          deallocate( self%tracer_istart_ix )
    if ( allocated( self%tracer_iend_ix ) )            deallocate( self%tracer_iend_ix )
    if ( allocated( self%tracer_istart_iy ) )          deallocate( self%tracer_istart_iy )
    if ( allocated( self%tracer_iend_iy ) )            deallocate( self%tracer_iend_iy )
    if ( allocated( self%tracer_istart_ox ) )          deallocate( self%tracer_istart_ox )
    if ( allocated( self%tracer_iend_ox ) )            deallocate( self%tracer_iend_ox )
    if ( allocated( self%tracer_istart_oy ) )          deallocate( self%tracer_istart_oy )
    if ( allocated( self%tracer_iend_oy ) )            deallocate( self%tracer_iend_oy )
    if ( allocated( self%tracer_stencil_extent_ix ) )  deallocate( self%tracer_stencil_extent_ix )
    if ( allocated( self%tracer_stencil_extent_iy ) )  deallocate( self%tracer_stencil_extent_iy )
    if ( allocated( self%tracer_stencil_extent_ox ) )  deallocate( self%tracer_stencil_extent_ox )
    if ( allocated( self%tracer_stencil_extent_oy ) )  deallocate( self%tracer_stencil_extent_oy )

  end subroutine destroy_transport_runtime

! ============================================================================ !
! SETTERS
! ============================================================================ !

  !> @brief Sets the dry flux for use in consistent tracer transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     dry_flux  Flux field used to transport dry density
  !> @param[in]     step      The step to store the flux for
  subroutine set_dry_flux(self, dry_flux, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: dry_flux
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),  pointer :: prime_extrusion_mesh => null()

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => dry_flux%get_mesh()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    call dry_flux%copy_field_properties(self%dry_flux(1,step))
    call invoke( setval_X(self%dry_flux(1,step), dry_flux) )

    nullify( prime_extrusion_mesh )

  end subroutine set_dry_flux

  !> @brief Sets dry density field to use in tracer transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self        The transport_runtime object
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for
  subroutine set_rho_d(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    logical(kind=l_def)              :: next_step_hori
    type(mesh_type),         pointer :: prime_extrusion_mesh => null()
    integer(kind=i_def)              :: w2_fs_idx
    integer(kind=i_def)              :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    w2_fs_idx = self%direction_w2_fs(step)
    next_step_hori = (step < self%get_num_dry_steps() + 1 .and. &
                      w2_fs_idx == W2H .or. w2_fs_idx == W2)

    if (extended_mesh .and. next_step_hori) then
      if ( check_any_horizontal_method_mol() ) then
        remap_depth = get_required_stencil_depth()
      else
        ! For consistent transport the cfl may be slightly higher than expected
        ! due to using the dry mass flux to compute departure points, therefore
        ! an extra + 1 is added to remap_depth for safety
        remap_depth = max(self%get_dep_stencil_extent_x(self%mesh_ids(1)), &
                          self%get_dep_stencil_extent_y(self%mesh_ids(1))) &
                    + 2_i_def + max(inner_order, outer_order)
      end if
      call self%remap_on_extended_mesh(self%rho_d(1,step), rho_d, &
                                       self%rho_monotone_remap,   &
                                       self%rho_enforce_minvalue, &
                                       self%rho_minvalue,         &
                                       remap_depth)
    else
      call rho_d%copy_field_properties(self%rho_d(1,step))
      call invoke( setval_X(self%rho_d(1,step), rho_d) )
    end if

    nullify( prime_extrusion_mesh )

  end subroutine set_rho_d

  !> @brief Sets a dry density field to use in FFSL tracer transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self        The transport_runtime object
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for
  subroutine set_rho_d_ffsl_x(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),         pointer :: prime_extrusion_mesh => null()

    integer(kind=i_def) :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    if (extended_mesh) then
      ! For consistent transport the cfl may be slightly higher than expected
      ! due to using the dry mass flux to compute departure points, therefore
      ! an extra + 1 is added to remap_depth for safety
      remap_depth = max(self%get_dep_stencil_extent_x(self%mesh_ids(1)), &
                        self%get_dep_stencil_extent_y(self%mesh_ids(1))) &
                  + 2_i_def + max(inner_order, outer_order)
      call self%remap_on_extended_mesh(self%rho_d_ffsl_x(1,step), rho_d, &
                                       self%rho_monotone_remap,          &
                                       self%rho_enforce_minvalue,        &
                                       self%rho_minvalue,                &
                                       remap_depth)
    else
      call rho_d%copy_field_properties(self%rho_d_ffsl_x(1,step))
      call invoke( setval_X(self%rho_d_ffsl_x(1,step), rho_d) )
    end if

    nullify( prime_extrusion_mesh )

  end subroutine set_rho_d_ffsl_x

  !> @brief Sets a dry density field to use in FFSL tracer transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self        The transport_runtime object
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for
  subroutine set_rho_d_ffsl_y(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type), pointer :: prime_extrusion_mesh => null()
    integer(kind=i_def)      :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    if (extended_mesh) then
      if ( check_any_horizontal_method_mol() ) then
        remap_depth = get_required_stencil_depth()
      else
        ! For consistent transport the cfl may be slightly higher than expected
        ! due to using the dry mass flux to compute departure points, therefore
        ! an extra + 1 is added to remap_depth for safety
        remap_depth = max(self%get_dep_stencil_extent_x(self%mesh_ids(1)), &
                          self%get_dep_stencil_extent_y(self%mesh_ids(1))) &
                    + 2_i_def + max(inner_order, outer_order)
      end if
      call self%remap_on_extended_mesh(self%rho_d_ffsl_y(1,step), rho_d, &
                                       self%rho_monotone_remap,          &
                                       self%rho_enforce_minvalue,        &
                                       self%rho_minvalue,                &
                                       remap_depth)
    else
      call rho_d%copy_field_properties(self%rho_d_ffsl_y(1,step))
      call invoke( setval_X(self%rho_d_ffsl_y(1,step), rho_d) )
    end if

    nullify( prime_extrusion_mesh )

  end subroutine set_rho_d_ffsl_y

  !> @brief Stores a field at the start of the whole transport step
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     field_n   Field at start of whole transport step
  subroutine set_field_n(self, field_n)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: field_n

    call field_n%copy_field_properties(self%field_n)
    call invoke( setval_X(self%field_n, field_n) )

  end subroutine set_field_n

  !> @brief Sets fluxes for use in conservative transport
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     flux      Mass flux for a particular split step
  subroutine set_flux(self, flux)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: flux

    integer(kind=i_def) :: idx

    idx = self%idx_from_mesh_id(flux%get_mesh_id())
    call flux%copy_field_properties(self%flux(idx,self%tracer_step_ctr))
    call invoke( setval_X(self%flux(idx,self%tracer_step_ctr), flux) )

  end subroutine set_flux

! ============================================================================ !
! DRY FIELD ROUTINES
! ============================================================================ !

  !> @brief Restricts the prime mesh dry fields from one transport_runtime
  !!        object to set the dry fields for the prime mesh of another
  !!        transport_runtime object for a coarser mesh.
  !> @param[in,out] self                       Target transport_runtime object
  !> @param[in]     source_transport_runtime   Source transport_runtime object
  subroutine restrict_dry_fields(self, source_transport_runtime)

    use intermesh_constants_mod,   only: get_intermesh_weights_w3_rtran
    use mesh_collection_mod,       only: mesh_collection
    use restrict_scalar_weighted_kernel_mod, &
                                   only: restrict_scalar_weighted_kernel_type
    use restrict_w2_kernel_mod,    only: restrict_w2_kernel_type
    use restrict_w2h_kernel_mod,   only: restrict_w2h_kernel_type
    use restrict_w2v_kernel_mod,   only: restrict_w2v_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    class(transport_runtime_type),         intent(in)    :: source_transport_runtime

    type(function_space_type), pointer       :: w2_fs => null()
    type(function_space_type), pointer       :: w3_fs => null()
    type(mesh_type),           pointer       :: source_mesh => null()
    type(mesh_type),           pointer       :: target_mesh => null()
    type(r_tran_field_type),   pointer       :: source_rho_d => null()
    type(r_tran_field_type),   pointer       :: source_rho_d_ffsl_x => null()
    type(r_tran_field_type),   pointer       :: source_rho_d_ffsl_y => null()
    type(r_tran_field_type),   pointer       :: source_dry_flux => null()
    type(r_tran_field_type),   pointer       :: weights_w3 => null()
    type(r_tran_field_type)                  :: tmp_rho_d
    integer(kind=i_def)                      :: source_ncells
    integer(kind=i_def)                      :: target_ncells
    integer(kind=i_def)                      :: source_mesh_id
    integer(kind=i_def)                      :: target_mesh_id
    integer(kind=i_def)                      :: step, num_steps, fs_idx
    logical(kind=l_def)                      :: any_hori_dep_pts
    integer(kind=i_def)                      :: remap_depth

    if ( subroutine_timers ) call timer('transport.runtime_restrict')

    ! N.B. The meshes should not be the same as one another, otherwise the
    ! transport_runtime objects will be the same

    source_mesh_id = source_transport_runtime%get_prime_extrusion_mesh_id()
    target_mesh_id = self%get_prime_extrusion_mesh_id()
    ! Obtain meshes to check that we can coarsen
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)
    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    if (source_ncells > target_ncells) then
      ! Loop through fields for each step for prime extrusion
      num_steps = source_transport_runtime%get_num_dry_steps()
      do step = 1, num_steps + 1

        ! -------------------------------------------------------------------- !
        ! rho_d
        ! -------------------------------------------------------------------- !
        ! Restrict densities conservatively
        source_rho_d => source_transport_runtime%get_rho_d(source_mesh_id, step)
        weights_w3 => get_intermesh_weights_w3_rtran(source_mesh, target_mesh)
        w3_fs => function_space_collection%get_fs(target_mesh, 0, W3)

        if (extended_mesh) then
          if ( check_any_horizontal_method_mol() ) then
            remap_depth = get_required_stencil_depth()
          else
            ! TODO: we should be able to get away with not doing all of these
            ! remappings, based on the direction and last step
            ! Restrict, then remap
            remap_depth = max(self%get_dep_stencil_extent_x(self%mesh_ids(1)), &
                              self%get_dep_stencil_extent_y(self%mesh_ids(1))) &
                        + 1_i_def + max(inner_order, outer_order)
          end if
          call tmp_rho_d%initialise( vector_space = w3_fs, &
                                     halo_depth=target_mesh%get_halo_depth() )
          call invoke( restrict_scalar_weighted_kernel_type(tmp_rho_d,         &
                                                            source_rho_d,      &
                                                            weights_w3) )
          call self%remap_on_extended_mesh(self%rho_d(1,step), tmp_rho_d,      &
                                           self%rho_monotone_remap,            &
                                           self%rho_enforce_minvalue,          &
                                           self%rho_minvalue,                  &
                                           remap_depth)
        else
          if (.not. self%rho_d(1,step)%is_initialised()) then
            call self%rho_d(1,step)%initialise( vector_space = w3_fs, &
                                                halo_depth = target_mesh%get_halo_depth() )
          end if
          ! Can restrict straight into self%rho_d
          call invoke( restrict_scalar_weighted_kernel_type(                   &
                                                    self%rho_d(1,step),        &
                                                    source_rho_d,              &
                                                    weights_w3) )
        end if

        ! -------------------------------------------------------------------- !
        ! rho_d_ffsl: only used with FFSL and only for number of dry steps
        ! -------------------------------------------------------------------- !
        any_hori_dep_pts = check_horz_dep_pts()
        if ( any_hori_dep_pts .and. step < num_steps + 1 ) then
          if ( source_transport_runtime%rho_d_ffsl_x(1,step)%is_initialised() ) then
            source_rho_d_ffsl_x => source_transport_runtime%get_rho_d_ffsl_x(source_mesh_id, step)
            source_rho_d_ffsl_y => source_transport_runtime%get_rho_d_ffsl_y(source_mesh_id, step)

            if (.not. self%rho_d_ffsl_x(1,step)%is_initialised()) then
              call self%rho_d_ffsl_x(1,step)%initialise( vector_space = w3_fs, &
                                                halo_depth = target_mesh%get_halo_depth() )
              call self%rho_d_ffsl_y(1,step)%initialise( vector_space = w3_fs, &
                                                halo_depth = target_mesh%get_halo_depth() )
            end if

            if (extended_mesh) then
              ! Restrict, then remap
              call invoke( restrict_scalar_weighted_kernel_type(               &
                                                    tmp_rho_d,                 &
                                                    source_rho_d_ffsl_x,       &
                                                    weights_w3) )
              call self%remap_on_extended_mesh(self%rho_d_ffsl_x(1, step),     &
                                               tmp_rho_d,                      &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue,              &
                                               remap_depth)
              call invoke( restrict_scalar_weighted_kernel_type(               &
                                                    tmp_rho_d,                 &
                                                    source_rho_d_ffsl_y,       &
                                                    weights_w3) )
              call self%remap_on_extended_mesh(self%rho_d_ffsl_y(1, step),     &
                                               tmp_rho_d,                      &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue,              &
                                               remap_depth)
            else
              ! Can restrict straight into self%rho_d fields
              call invoke( restrict_scalar_weighted_kernel_type(               &
                                                    self%rho_d_ffsl_x(1,step), &
                                                    source_rho_d_ffsl_x,       &
                                                    weights_w3),               &
                           restrict_scalar_weighted_kernel_type(               &
                                                    self%rho_d_ffsl_y(1,step), &
                                                    source_rho_d_ffsl_y,       &
                                                    weights_w3) )
            end if
          end if
        end if

        ! -------------------------------------------------------------------- !
        ! dry_flux: kernel depends on the direction
        ! -------------------------------------------------------------------- !
        if ( step < num_steps + 1 ) then

          source_dry_flux => source_transport_runtime%get_dry_flux(source_mesh_id, step)

          fs_idx = source_dry_flux%which_function_space()
          if (.not. self%dry_flux(1,step)%is_initialised()) then
            w2_fs => function_space_collection%get_fs(target_mesh, 0, fs_idx)
            call self%dry_flux(1,step)%initialise( vector_space = w2_fs )
          end if

          ! Restrict flux, which depends on split direction
          select case ( source_dry_flux%which_function_space() )
          case ( W2 )
            call invoke(                                                         &
                restrict_w2_kernel_type(self%dry_flux(1,step), source_dry_flux) )
          case ( W2H )
            call invoke(                                                         &
                restrict_w2h_kernel_type(self%dry_flux(1,step), source_dry_flux) )
          case ( W2V )
            call invoke(                                                         &
                restrict_w2v_kernel_type(self%dry_flux(1,step), source_dry_flux) )
          case default
            call log_event('Dry flux space not recognised', LOG_LEVEL_ERROR)
          end select
        end if  ! step is valid for dry flux

      end do  ! loop through steps
    else
      call log_event( 'Can only call restrict_dry_fields when ' // &
                      'target mesh is coarser than source mesh', LOG_LEVEL_ERROR)
    end if

    nullify( source_mesh, target_mesh, source_rho_d, source_rho_d_ffsl_x, &
             source_rho_d_ffsl_y, source_dry_flux, w3_fs, w2_fs, weights_w3 )

    if ( subroutine_timers ) call timer('transport.runtime_restrict')

  end subroutine restrict_dry_fields

  !> @brief Computes stored dry fields on the shifted mesh for consistent
  !!        transport of Wtheta tracers
  !> @param[in,out] self   The transport_runtime object
  subroutine shift_dry_fields(self)

    use apply_w3_to_sh_w3_kernel_mod,     only: apply_w3_to_sh_w3_kernel_type
    use consist_w2_to_sh_w2_kernel_mod,   only: consist_w2_to_sh_w2_kernel_type
    use consist_w2h_to_sh_w2h_kernel_mod, only: consist_w2h_to_sh_w2h_kernel_type
    use consist_w2v_to_sh_w2v_kernel_mod, only: consist_w2v_to_sh_w2v_kernel_type
    use fem_constants_mod,                only: get_rmultiplicity, &
                                                get_detj_at_w3_r_tran

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    integer(kind=i_def)                :: prime_mesh_id, fs_idx, step
    type(mesh_type),           pointer :: prime_extrusion_mesh => null()
    type(mesh_type),           pointer :: shifted_mesh => null()
    type(field_type),          pointer :: rmultiplicity_w2 => null()
    type(r_tran_field_type),   pointer :: detj_shifted => null()
    type(r_tran_field_type),   pointer :: detj_prime => null()
    type(r_tran_field_type)            :: tmp_rho_d_shifted
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    logical(kind=l_def)                :: any_hori_dep_pts
    integer(kind=i_def)                :: remap_depth

    if ( subroutine_timers ) call timer('transport.runtime_shift')

    any_hori_dep_pts = check_horz_dep_pts()

    if (self%n_meshes > 1) then
      prime_extrusion_mesh => mesh_collection%get_mesh(self%mesh_ids(1))
      prime_mesh_id = prime_extrusion_mesh%get_id()
      shifted_mesh => mesh_collection%get_mesh(self%mesh_ids(2))

      detj_shifted => get_detj_at_w3_r_tran(shifted_mesh%get_id())
      detj_prime => get_detj_at_w3_r_tran(prime_mesh_id)
      w3_fs => function_space_collection%get_fs(shifted_mesh, 0, W3)

      if (extended_mesh) then
        if ( check_any_horizontal_method_mol() ) then
          remap_depth = get_required_stencil_depth()
        else
          ! For consistent transport the cfl may be slightly higher than expected
          ! due to using the dry mass flux to compute departure points, therefore
          ! an extra + 1 is added to remap_depth for safety
          remap_depth = max(self%get_dep_stencil_extent_x(self%mesh_ids(1)), &
                            self%get_dep_stencil_extent_y(self%mesh_ids(1))) &
                      + 2_i_def + max(inner_order, outer_order)
        end if

      end if
      if (extended_mesh) call tmp_rho_d_shifted%initialise( w3_fs, &
                                 halo_depth=shifted_mesh%get_halo_depth() )

      do step = 1, self%num_dry_steps + 1

        ! -------------------------------------------------------------------- !
        ! rho_d
        ! -------------------------------------------------------------------- !

        if (extended_mesh) then
          call invoke( apply_w3_to_sh_w3_kernel_type(                          &
                                           tmp_rho_d_shifted,                  &
                                           self%rho_d(1,step),                 &
                                           detj_shifted,                       &
                                           detj_prime) )
         call self%remap_on_extended_mesh(self%rho_d(2,step),                 &
                                           tmp_rho_d_shifted,                  &
                                           self%rho_monotone_remap,            &
                                           self%rho_enforce_minvalue,          &
                                           self%rho_minvalue,                  &
                                           remap_depth)
        else
          if (.not. self%rho_d(2,step)%is_initialised()) then
            call self%rho_d(2,step)%initialise( vector_space = w3_fs, &
                                                halo_depth = shifted_mesh%get_halo_depth() )
          end if
          call invoke( apply_w3_to_sh_w3_kernel_type(                          &
                                           self%rho_d(2,step),                 &
                                           self%rho_d(1,step),                 &
                                           detj_shifted,                       &
                                           detj_prime) )
        end if

        ! -------------------------------------------------------------------- !
        ! rho_d_ffsl: only used with FFSL and only for number of dry steps
        ! -------------------------------------------------------------------- !
        if ( any_hori_dep_pts .and. step < self%num_dry_steps + 1 ) then
          if ( self%rho_d_ffsl_x(1,step)%is_initialised() ) then
            if (.not. self%rho_d_ffsl_x(2,step)%is_initialised()) then
              call self%rho_d_ffsl_x(2,step)%initialise( vector_space = w3_fs, &
                                                halo_depth = shifted_mesh%get_halo_depth() )
              call self%rho_d_ffsl_y(2,step)%initialise( vector_space = w3_fs, &
                                                halo_depth = shifted_mesh%get_halo_depth() )
            end if

            if (extended_mesh) then
              call invoke( apply_w3_to_sh_w3_kernel_type(                      &
                                               tmp_rho_d_shifted,              &
                                               self%rho_d_ffsl_x(1,step),      &
                                               detj_shifted,                   &
                                               detj_prime) )
              call self%remap_on_extended_mesh(self%rho_d_ffsl_x(2,step),      &
                                               tmp_rho_d_shifted,              &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue,              &
                                               remap_depth)
              call invoke( apply_w3_to_sh_w3_kernel_type(                      &
                                               tmp_rho_d_shifted,              &
                                               self%rho_d_ffsl_y(1,step),      &
                                               detj_shifted,                   &
                                               detj_prime) )
              call self%remap_on_extended_mesh(self%rho_d_ffsl_y(2,step),      &
                                               tmp_rho_d_shifted,              &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue,              &
                                               remap_depth)
            else
              call invoke( apply_w3_to_sh_w3_kernel_type(                      &
                                               self%rho_d_ffsl_x(2,step),      &
                                               self%rho_d_ffsl_x(1,step),      &
                                               detj_shifted,                   &
                                               detj_prime),                    &
                           apply_w3_to_sh_w3_kernel_type(                      &
                                               self%rho_d_ffsl_y(2,step),      &
                                               self%rho_d_ffsl_y(1,step),      &
                                               detj_shifted,                   &
                                               detj_prime) )
            end if
          end if
        end if

        ! -------------------------------------------------------------------- !
        ! dry_flux: kernel depends on the direction
        ! -------------------------------------------------------------------- !
        if ( step < self%num_dry_steps + 1 ) then
          ! Transform dry fluxes to the shifted mesh, with case depending on fs_idx
          fs_idx = self%dry_flux(1,step)%which_function_space()

          if (.not. self%dry_flux(2,step)%is_initialised()) then
            w2_fs => function_space_collection%get_fs(shifted_mesh, 0, fs_idx)
            call self%dry_flux(2,step)%initialise( vector_space = w2_fs )
          end if

          select case (fs_idx)
          case (W2)
            rmultiplicity_w2 => get_rmultiplicity(W2, prime_mesh_id)
            call invoke(                                              &
              setval_c(self%dry_flux(2,step), 0.0_r_tran),            &
              consist_w2_to_sh_w2_kernel_type(self%dry_flux(2,step),  &
                                              self%dry_flux(1,step),  &
                                              rmultiplicity_w2) )
          case (W2h)
            rmultiplicity_w2 => get_rmultiplicity(W2h, prime_mesh_id)
            call invoke(                                               &
              setval_c(self%dry_flux(2,step), 0.0_r_tran),             &
              consist_w2h_to_sh_w2h_kernel_type(self%dry_flux(2,step), &
                                                self%dry_flux(1,step), &
                                                rmultiplicity_w2) )
          case (W2v)
            call invoke(                                               &
              consist_w2v_to_sh_w2v_kernel_type(self%dry_flux(2,step), &
                                                self%dry_flux(1,step)) )
          case default
            call log_event( "Can only store dry flux for W2, W2h and W2v spaces", LOG_LEVEL_ERROR )
          end select
        end if  ! step is valid for dry flux

      end do  ! loop through steps
    end if  ! there is a shifted mesh

    nullify( prime_extrusion_mesh, shifted_mesh, detj_shifted, detj_prime, &
             rmultiplicity_w2, w3_fs, w2_fs )

    if ( subroutine_timers ) call timer('transport.runtime_shift')

  end subroutine shift_dry_fields

  !> @brief Computes quantities (such as departure points) necessary for the
  !!        consistent transport of tracers using FFSL
  !> @param[in,out] self   The transport_runtime object
  !> @param[in]     mesh   The mesh to compute consistent quantities on
  subroutine compute_consistent_quantities(self, mesh)

    use consistent_hori_ix_deppt_kernel_mod,  only: consistent_hori_ix_deppt_kernel_type
    use consistent_hori_iy_deppt_kernel_mod,  only: consistent_hori_iy_deppt_kernel_type
    use consistent_hori_ox_deppt_kernel_mod,  only: consistent_hori_ox_deppt_kernel_type
    use consistent_hori_oy_deppt_kernel_mod,  only: consistent_hori_oy_deppt_kernel_type
    use consistent_vertical_deppt_kernel_mod, only: consistent_vertical_deppt_kernel_type
    use fem_constants_mod,                    only: get_detj_at_w3_r_tran
    use departure_points_config_mod,          only: horizontal_limit, &
                                                    horizontal_limit_cap

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(mesh_type),                       intent(in)    :: mesh

    integer(kind=i_def)                :: mesh_id, i, step
    integer(kind=i_def)                :: function_space
    integer(kind=i_def)                :: stencil_extent
    integer(kind=i_def)                :: full_stencil_extent_x
    integer(kind=i_def)                :: full_stencil_extent_y
    real(kind=r_tran)                  :: dep_min, dep_max
    type(mesh_type),           pointer :: twod_mesh => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w3_2d_fs => null()
    type(r_tran_field_type),   pointer :: rho_d => null()
    type(r_tran_field_type),   pointer :: rho_d_x => null()
    type(r_tran_field_type),   pointer :: rho_d_y => null()
    type(r_tran_field_type),   pointer :: dry_flux => null()
    type(r_tran_field_type),   pointer :: detj_at_w3 => null()
    logical(kind=l_def)                :: any_eqn_consistent, cap_dep_points
    logical(kind=l_def)                :: any_vert_dep_pts, any_hori_dep_pts
    logical(kind=l_def)                :: any_consistent_swift
    logical(kind=l_def)                :: any_consistent_cosmic

    if ( subroutine_timers ) call timer('transport.runtime_consistent')

    any_eqn_consistent = check_any_eqn_consistent()
    any_consistent_swift = check_any_consistent_swift()
    any_consistent_cosmic = check_any_consistent_cosmic()
    any_vert_dep_pts = check_vert_dep_pts()
    any_hori_dep_pts = check_horz_dep_pts()

    if (any_consistent_swift .or. any_consistent_cosmic .or. &
        (any_eqn_consistent .and. any_vert_dep_pts)) then

      mesh_id = mesh%get_id()
      i = self%idx_from_mesh_id(mesh_id)
      detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)

      do step = 1, self%num_dry_steps

        rho_d => self%get_rho_d(mesh_id, step)
        dry_flux => self%get_dry_flux(mesh_id, step)

        ! Determine direction of step from function space
        function_space = dry_flux%which_function_space()
        stencil_extent = dep_pt_stencil_extent

        ! -------------------------------------------------------------------- !
        ! Vertical step
        ! -------------------------------------------------------------------- !
        if (function_space == W2V .and. any_vert_dep_pts) then
          if (.not. self%tracer_dep_pts_z(i,step)%is_initialised()) then
            w2_fs => dry_flux%get_function_space()
            call self%tracer_dep_pts_z(i,step)%initialise( w2_fs )
            call self%dry_frac_flux_z(i,step)%initialise( w2_fs )
          end if

          call invoke( consistent_vertical_deppt_kernel_type(                  &
                                          self%tracer_dep_pts_z(i,step),       &
                                          self%dry_frac_flux_z(i,step),        &
                                          dry_flux,                            &
                                          rho_d,                               &
                                          detj_at_w3) )

        ! -------------------------------------------------------------------- !
        ! Horizontal step
        ! -------------------------------------------------------------------- !
        else if (function_space == W2H .and. any_hori_dep_pts) then

          cap_dep_points = (horizontal_limit == horizontal_limit_cap)

          ! Inner step quantities ----------------------------------------------
          if (.not. self%tracer_dep_pts_ix(i,step)%is_initialised()) then
            w2_fs => dry_flux%get_function_space()
            twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
            w3_2d_fs => function_space_collection%get_fs(twod_mesh, 0, W3)
            call self%tracer_dep_pts_ix(i,step)%initialise( w2_fs )
            call self%tracer_dep_pts_iy(i,step)%initialise( w2_fs )
            call self%dry_frac_flux_ix(i,step)%initialise( w2_fs )
            call self%dry_frac_flux_iy(i,step)%initialise( w2_fs )
            call self%tracer_istart_ix(i,step)%initialise( w3_2d_fs )
            call self%tracer_iend_ix(i,step)%initialise( w3_2d_fs )
            call self%tracer_istart_iy(i,step)%initialise( w3_2d_fs )
            call self%tracer_iend_iy(i,step)%initialise( w3_2d_fs )
          end if

          call invoke(                                                         &
                  setval_c(self%tracer_dep_pts_ix(i,step), 0.0_r_tran),        &
                  setval_c(self%tracer_dep_pts_iy(i,step), 0.0_r_tran),        &
                  setval_c(self%dry_frac_flux_ix(i,step), 0.0_r_tran),         &
                  setval_c(self%dry_frac_flux_iy(i,step), 0.0_r_tran),         &
                  consistent_hori_ix_deppt_kernel_type(                        &
                                          self%tracer_dep_pts_ix(i,step),      &
                                          self%dry_frac_flux_ix(i,step),       &
                                          dry_flux,                            &
                                          rho_d, stencil_extent,               &
                                          detj_at_w3, stencil_extent,          &
                                          dep_pt_stencil_extent,               &
                                          cap_dep_points),                     &
                  consistent_hori_iy_deppt_kernel_type(                        &
                                          self%tracer_dep_pts_iy(i,step),      &
                                          self%dry_frac_flux_iy(i,step),       &
                                          dry_flux,                            &
                                          rho_d, stencil_extent,               &
                                          detj_at_w3, stencil_extent,          &
                                          dep_pt_stencil_extent,               &
                                          cap_dep_points) )

          ! Get the required stencil size from the departure points
          call get_field_minmax( self%tracer_dep_pts_ix(i,step), dep_min, dep_max )
          self%tracer_stencil_extent_ix(i,step) = &
            MAX( int(abs(dep_max), i_def), int(abs(dep_min), i_def) )
          call get_field_minmax( self%tracer_dep_pts_iy(i,step), dep_min, dep_max )
          self%tracer_stencil_extent_iy(i,step) = &
            MAX( int(abs(dep_max), i_def), int(abs(dep_min), i_def) )

          ! Compute indices for crossing panels
          ! We don't need these fields when doing SWIFT tracer splitting
          ! As the SWIFT inner step doesn't involve swapping x- and y-sweeps
          if (any_consistent_cosmic) then
            if ( special_edges_treatment ) then
                full_stencil_extent_x = self%tracer_stencil_extent_ix(i,step) + 2 + outer_order
                full_stencil_extent_y = self%tracer_stencil_extent_iy(i,step) + 2 + outer_order
             else
                full_stencil_extent_x = self%tracer_stencil_extent_ix(i,step) + 1 + outer_order
                full_stencil_extent_y = self%tracer_stencil_extent_iy(i,step) + 1 + outer_order
            end if

            call cosmic_index_alg( self%tracer_istart_ix(i,step),              &
                                   self%tracer_iend_ix(i,step),                &
                                   self%tracer_istart_iy(i,step),              &
                                   self%tracer_iend_iy(i,step),                &
                                   full_stencil_extent_x,                      &
                                   full_stencil_extent_y )
          end if

          ! Outer step quantities ----------------------------------------------
          ! Determine if outer fields needed from initialisation of rho_d_ffsl
          if (any_consistent_swift) then
            if (.not. self%tracer_dep_pts_ox(i,step)%is_initialised()) then
              w2_fs => dry_flux%get_function_space()
              twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
              w3_2d_fs => function_space_collection%get_fs(twod_mesh, 0, W3)
              call self%tracer_dep_pts_ox(i,step)%initialise( w2_fs )
              call self%tracer_dep_pts_oy(i,step)%initialise( w2_fs )
              call self%dry_frac_flux_ox(i,step)%initialise( w2_fs )
              call self%dry_frac_flux_oy(i,step)%initialise( w2_fs )
              call self%tracer_istart_ox(i,step)%initialise( w3_2d_fs )
              call self%tracer_iend_ox(i,step)%initialise( w3_2d_fs )
              call self%tracer_istart_oy(i,step)%initialise( w3_2d_fs )
              call self%tracer_iend_oy(i,step)%initialise( w3_2d_fs )
            end if

            rho_d_x => self%get_rho_d_ffsl_x(mesh_id, step)
            rho_d_y => self%get_rho_d_ffsl_y(mesh_id, step)

            call invoke(                                                       &
                    setval_c(self%tracer_dep_pts_ox(i,step), 0.0_r_tran),      &
                    setval_c(self%tracer_dep_pts_oy(i,step), 0.0_r_tran),      &
                    setval_c(self%dry_frac_flux_ox(i,step), 0.0_r_tran),       &
                    setval_c(self%dry_frac_flux_oy(i,step), 0.0_r_tran),       &
                    consistent_hori_ox_deppt_kernel_type(                      &
                                            self%tracer_dep_pts_ox(i,step),    &
                                            self%dry_frac_flux_ox(i,step),     &
                                            dry_flux,                          &
                                            rho_d_y, stencil_extent,           &
                                            rho_d_x, stencil_extent,           &
                                            detj_at_w3, stencil_extent,        &
                                            self%dep_pt_istart_y,              &
                                            self%dep_pt_iend_y,                &
                                            dep_pt_stencil_extent,             &
                                            cap_dep_points),                   &
                    consistent_hori_oy_deppt_kernel_type(                      &
                                            self%tracer_dep_pts_oy(i,step),    &
                                            self%dry_frac_flux_oy(i,step),     &
                                            dry_flux,                          &
                                            rho_d_x, stencil_extent,           &
                                            rho_d_y, stencil_extent,           &
                                            detj_at_w3, stencil_extent,        &
                                            self%dep_pt_istart_x,              &
                                            self%dep_pt_iend_x,                &
                                            dep_pt_stencil_extent,             &
                                            cap_dep_points) )

            ! Get the required stencil size from the departure points
            call get_field_minmax( self%tracer_dep_pts_ox(i,step), dep_min, dep_max )
            self%tracer_stencil_extent_ox(i,step) = &
              MAX( int(abs(dep_max), i_def), int(abs(dep_min), i_def) )
            call get_field_minmax( self%tracer_dep_pts_oy(i,step), dep_min, dep_max )
            self%tracer_stencil_extent_oy(i,step) = &
              MAX( int(abs(dep_max), i_def), int(abs(dep_min), i_def) )

            ! Compute indices for crossing panels

            if ( special_edges_treatment ) then
              full_stencil_extent_x = self%tracer_stencil_extent_ox(i,step) + 2 + outer_order
              full_stencil_extent_y = self%tracer_stencil_extent_oy(i,step) + 2 + outer_order
            else
              full_stencil_extent_x = self%tracer_stencil_extent_ox(i,step) + 1 + outer_order
              full_stencil_extent_y = self%tracer_stencil_extent_oy(i,step) + 1 + outer_order
            end if

            call cosmic_index_alg( self%tracer_istart_ox(i,step),         &
                                   self%tracer_iend_ox(i,step),           &
                                   self%tracer_istart_oy(i,step),         &
                                   self%tracer_iend_oy(i,step),           &
                                   full_stencil_extent_x,                 &
                                   full_stencil_extent_y )

          end if  ! Outer step variables
        end if  ! Horizontal
      end do  ! Loop through steps
    end if  ! Whether consistent quantities need computing

    nullify(w2_fs, w3_2d_fs, rho_d, rho_d_x, rho_d_y, detj_at_w3, dry_flux, &
            twod_mesh)

    if ( subroutine_timers ) call timer('transport.runtime_consistent')

  end subroutine compute_consistent_quantities

! ============================================================================ !
! GETTERS
! ============================================================================ !

  !> @brief Computes number of MoL substeps for a splitting step
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @param[in] cfl_arg    CFL to use. Optional, and if not provided defaults
  !!                       to namelist options.
  !> @return number_substeps  Number of substeps
  function get_number_substeps(self, mesh_id, direction, splitting, cfl_arg) result(number_substeps)
    use transport_config_mod,           only: cfl_mol_3d_stab, &
                                              cfl_mol_2d_stab, &
                                              cfl_mol_1d_stab
    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    real(kind=r_def),   optional,  intent(in) :: cfl_arg
    integer(kind=i_def)                       :: number_substeps
    integer(kind=i_def)                       :: idx
    real(kind=r_def)                          :: cfl_to_use

    idx = self%idx_from_mesh_id(mesh_id)

    if (present(cfl_arg)) then
      cfl_to_use = cfl_arg + tiny_eps
    else
      select case (direction)
      case (direction_v)
        cfl_to_use = cfl_mol_1d_stab + tiny_eps
      case (direction_h)
        cfl_to_use = cfl_mol_2d_stab+tiny_eps
      case (direction_3d)
        cfl_to_use = cfl_mol_3d_stab+tiny_eps
      case default
        call log_event('Direction not recognised', LOG_LEVEL_ERROR)
      end select
    end if

    select case (direction)

      case (direction_v)
        number_substeps = int( self%vertical_cfl_max(idx) / cfl_to_use, i_def) &
                         + 1_i_def
        ! Strang_vhv splitting uses half timestep for the vertical stage
        if ( splitting == splitting_strang_vhv ) then
          number_substeps = int( self%vertical_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if
      case (direction_h)
        number_substeps = int( self%horizontal_cfl_max(idx)      &
                              / cfl_to_use, i_def) &
                        + 1_i_def
        ! Strang_hvh splitting uses half timestep for the horizontal stage
        if ( splitting == splitting_strang_hvh ) then
          number_substeps = int( self%horizontal_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if

      case (direction_3d)
        number_substeps = int( self%total_cfl_max(idx)            &
                              / cfl_to_use, i_def)  &
                         + 1_i_def
      case default
        number_substeps = 1_i_def
    end select

  end function get_number_substeps

  !> @brief Get the MoL dt for substeps for this mesh / direction / splitting
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @return dt_substep  The dt for MoL substeps
  function get_dt_substep(self, mesh_id, direction, splitting) result(dt_substep)

    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    integer(kind=i_def)                       :: number_substeps
    real(kind=r_tran)                         :: dt_substep

    number_substeps = self%get_number_substeps(mesh_id, direction, splitting)
    dt_substep = real(self%model_clock%get_seconds_per_step(), r_tran) &
                 / real(number_substeps, r_tran)
    if ( splitting  == splitting_strang_vhv .and. direction == direction_v ) then
        dt_substep = dt_substep / 2.0_r_tran
    else if ( splitting  == splitting_strang_hvh .and. direction == direction_h ) then
        dt_substep = dt_substep / 2.0_r_tran
    end if

  end function get_dt_substep

  !> @brief Returns the local mesh id for the transport_runtime
  !> @return The identifier for the underlying local mesh
  function get_local_mesh_id(self) result(local_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: local_mesh_id

    local_mesh_id = self%local_mesh_id

  end function get_local_mesh_id

  !> @brief Returns the mesh id for the transport_runtime prime extrusion mesh
  !> @return The identifier for the prime extrusion mesh
  function get_prime_extrusion_mesh_id(self) result(prime_extrusion_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: prime_extrusion_mesh_id

    prime_extrusion_mesh_id = self%mesh_ids(1)

  end function get_prime_extrusion_mesh_id

  !> @brief Returns a pointer to the advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The advecting wind for that mesh
  function get_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'advecting_wind'
    advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_advecting_wind

  !> @brief Returns a pointer to the advecting wind associated with a direction
  !> @param[in] mesh_id    The ID of the mesh to get the object for
  !> @param[in] direction  The enumerator for the direction
  !> @return The advecting wind for that mesh and specified direction
  function get_directional_advecting_wind(self, mesh_id, direction) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: direction
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'directional_advecting_wind'

    select case (direction)
    case (direction_3d)
      advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_h)
      advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_v)
      advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case default
      call log_event('get_directional_advecting_wind: Direction not recognised', LOG_LEVEL_ERROR)
    end select

    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_directional_advecting_wind

   !> @brief Returns a pointer to the horizontal advecting wind
   !> @param[in] mesh_id The ID of the mesh to get the object for
   !> @return The horizontal part of the advecting wind
  function get_horizontal_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'horizontal_advecting_wind'
    advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_horizontal_advecting_wind

  !> @brief Returns a pointer to the vertical advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The vertical part of the advecting wind
  function get_vertical_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'vertical_advecting_wind'
    advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_vertical_advecting_wind

  !> @brief Returns a pointer to the x departure points at W2h DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the x direction at W2h DoFs
  function get_departure_points_x_w2(self, mesh_id) result(departure_points_x_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: departure_points_x_w2
    character(str_def)                                :: field_name

    field_name = 'departure_points_x_w2'
    departure_points_x_w2 => self%departure_points_x_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_x_w2, field_name, mesh_id)

  end function get_departure_points_x_w2

  !> @brief Returns a pointer to the y departure points at W2h DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the y direction at W2h DoFs
  function get_departure_points_y_w2(self, mesh_id) result(departure_points_y_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: departure_points_y_w2
    character(str_def)                                :: field_name

    field_name = 'departure_points_y_w2'
    departure_points_y_w2 => self%departure_points_y_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_y_w2, field_name, mesh_id)

  end function get_departure_points_y_w2

  !> @brief Returns a pointer to the z departure points at W2v DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the z direction at W2v DoFs
  function get_departure_points_z_w2(self, mesh_id, strang) result(departure_points_z_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: departure_points_z_w2
    character(str_def)                                :: field_name

    field_name = 'get_departure_points_z_w2'
    if (strang) then
      departure_points_z_w2 => self%departure_points_z_half_w2(self%idx_from_mesh_id(mesh_id))
    else
      departure_points_z_w2 => self%departure_points_z_w2(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(departure_points_z_w2, field_name, mesh_id)

  end function get_departure_points_z_w2

  !> @brief Returns a pointer to the fractional vertical wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The fractional vertical wind at W2v DOFs
  function get_frac_wind_z(self, mesh_id) result(frac_wind_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: frac_wind_z

    frac_wind_z => self%frac_wind_z(self%idx_from_mesh_id(mesh_id))

  end function get_frac_wind_z

  !> @brief Returns a pointer to the fractional vertical wind computed
  !!        using half departure points and time step for the half steps
  !!        of Strang splitting
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The fractional vertical wind at W2v DOFs
  function get_frac_wind_z_half(self, mesh_id) result(frac_wind_z_half)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: frac_wind_z_half

    frac_wind_z_half => self%frac_wind_z_half(self%idx_from_mesh_id(mesh_id))

  end function get_frac_wind_z_half

  !> @brief Returns a pointer to the consistent tracer inner x departure points
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the departure points for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The tracer departure points for the x direction at W2 DoFs
  function get_tracer_dep_pts_x(self, mesh_id, step, outer_step) result(tracer_dep_points_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: tracer_dep_points_x
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'tracer_dep_points_ox'
      tracer_dep_points_x => self%tracer_dep_pts_ox(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'tracer_dep_points_ix'
      tracer_dep_points_x => self%tracer_dep_pts_ix(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(tracer_dep_points_x, field_name, mesh_id)

  end function get_tracer_dep_pts_x

  !> @brief Returns a pointer to the consistent tracer inner y departure points
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the departure points for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The tracer departure points for the y direction at W2 DoFs
  function get_tracer_dep_pts_y(self, mesh_id, step, outer_step) result(tracer_dep_points_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: tracer_dep_points_y
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'tracer_dep_points_oy'
      tracer_dep_points_y => self%tracer_dep_pts_oy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'tracer_dep_points_iy'
      tracer_dep_points_y => self%tracer_dep_pts_iy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(tracer_dep_points_y, field_name, mesh_id)

  end function get_tracer_dep_pts_y

  !> @brief Returns a pointer to the consistent z departure points
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the departure points for
  !> @return The consistent departure points for the z direction at W2 DoFs
  function get_tracer_dep_pts_z(self, mesh_id, step) result(tracer_dep_points_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: tracer_dep_points_z
    character(str_def)                                :: field_name

    field_name = 'tracer_dep_points_z'
    tracer_dep_points_z => self%tracer_dep_pts_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(tracer_dep_points_z, field_name, mesh_id)

  end function get_tracer_dep_pts_z

  !> @brief Returns a pointer to the dry inner x fractional flux
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the fractional flux for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The dry inner fractional flux for the x direction
  function get_dry_frac_flux_x(self, mesh_id, step, outer_step) result(dry_frac_flux_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: dry_frac_flux_x
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'dry_frac_flux_ox'
      dry_frac_flux_x => self%dry_frac_flux_ox(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'dry_frac_flux_ix'
      dry_frac_flux_x => self%dry_frac_flux_ix(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(dry_frac_flux_x, field_name, mesh_id)

  end function get_dry_frac_flux_x

  !> @brief Returns a pointer to the dry inner y fractional flux
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the fractional flux for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The dry inner fractional flux for the y direction
  function get_dry_frac_flux_y(self, mesh_id, step, outer_step) result(dry_frac_flux_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: dry_frac_flux_y
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'dry_frac_flux_oy'
      dry_frac_flux_y => self%dry_frac_flux_oy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'dry_frac_flux_iy'
      dry_frac_flux_y => self%dry_frac_flux_iy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(dry_frac_flux_y, field_name, mesh_id)

  end function get_dry_frac_flux_y

  !> @brief Returns a pointer to the consistent z fractional flux
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the fractional flux for
  !> @return The consistent fractional flux for the z direction
  function get_dry_frac_flux_z(self, mesh_id, step) result(dry_frac_flux_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_frac_flux_z
    character(str_def)                                :: field_name

    field_name = 'dry_frac_flux_z'
    dry_frac_flux_z => self%dry_frac_flux_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_frac_flux_z, field_name, mesh_id)

  end function get_dry_frac_flux_z

  !> @brief Returns a pointer to the transport of unity in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of transport of unity in x
  function get_adv_unity_x(self, mesh_id) result(adv_unity_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: adv_unity_x
    character(str_def)                                :: field_name

    field_name = 'adv_unity_x'
    adv_unity_x => self%adv_unity_x(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_x, field_name, mesh_id)

  end function get_adv_unity_x

  !> @brief Returns a pointer to the transport of unity in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of transport of unity in y
  function get_adv_unity_y(self, mesh_id) result(adv_unity_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: adv_unity_y
    character(str_def)                                :: field_name

    field_name = 'adv_unity_y'
    adv_unity_y => self%adv_unity_y(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_y, field_name, mesh_id)

  end function get_adv_unity_y

  !> @brief Returns a pointer to the transport of unity in z
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of transport of unity in z
  function get_adv_unity_z(self, mesh_id) result(adv_unity_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: adv_unity_z
    character(str_def)                                :: field_name

    field_name = 'adv_unity_z'
    adv_unity_z => self%adv_unity_z(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_z, field_name, mesh_id)

  end function get_adv_unity_z

  !> @brief Returns a pointer to the half time step transport of unity in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of half time step transport of unity in x
  function get_adv_unity_half_x(self, mesh_id) result(adv_unity_half_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: adv_unity_half_x
    character(str_def)                                :: field_name

    field_name = 'adv_unity_half_x'
    adv_unity_half_x => self%adv_unity_half_x(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_half_x, field_name, mesh_id)

  end function get_adv_unity_half_x

  !> @brief Returns a pointer to the half time step transport of unity in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of half time step transport of unity in y
  function get_adv_unity_half_y(self, mesh_id) result(adv_unity_half_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: adv_unity_half_y
    character(str_def)                                :: field_name

    field_name = 'adv_unity_half_y'
    adv_unity_half_y => self%adv_unity_half_y(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_half_y, field_name, mesh_id)

  end function get_adv_unity_half_y

  !> @brief Returns a pointer to the half time step transport of unity in z
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The update of half time step transport of unity in z
  function get_adv_unity_half_z(self, mesh_id) result(adv_unity_half_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: adv_unity_half_z
    character(str_def)                                :: field_name

    field_name = 'adv_unity_half_z'
    adv_unity_half_z => self%adv_unity_half_z(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(adv_unity_half_z, field_name, mesh_id)

  end function get_adv_unity_half_z

  !> @brief Returns a pointer to the vertical interpolation coefficients
  !!        for semi-Lagrangian transport of a W3 or Wtheta field
  !> @param[in] field   The field to apply the coefficients to
  !> @param[in] order   The order of the coefficients
  !> @return The SL interpolation coefficients
  function get_vert_sl_coef(self, field, order) result(coef)

    use fs_continuity_mod,             only: W3, Wtheta
    use transport_config_mod,          only: vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    integer(kind=i_def),                   intent(in) :: order
    type(r_tran_field_type),               pointer    :: coef

    integer(kind=i_def) :: mesh_id

    ! Get mesh ID
    mesh_id = field%get_mesh_id()

    select case ( field%which_function_space() )
    case ( W3 )
      if (order == vertical_sl_order_cubic) then
        ! Cubic coefficients
        coef => self%vert_cubic_coef_w3(self%idx_from_mesh_id(mesh_id))
      else if (order == vertical_sl_order_cubic_hermite) then
        ! Cubic-Hermite coefficients
        coef => self%vert_hermite_coef_w3(self%idx_from_mesh_id(mesh_id))
      else if (order == vertical_sl_order_quintic) then
        ! Quintic coefficients
        coef => self%vert_quintic_coef_w3(self%idx_from_mesh_id(mesh_id))
      else
        ! Linear coefficients
        coef => self%vert_linear_coef_w3(self%idx_from_mesh_id(mesh_id))
      end if
    case ( Wtheta )
      if (order == vertical_sl_order_cubic) then
        ! Cubic coefficients
        coef => self%vert_cubic_coef_wt(self%idx_from_mesh_id(mesh_id))
      else if (order == vertical_sl_order_cubic_hermite) then
        ! Cubic-Hermite coefficients
        coef => self%vert_hermite_coef_wt(self%idx_from_mesh_id(mesh_id))
      else if (order == vertical_sl_order_quintic) then
        ! Quintic coefficients
        coef => self%vert_quintic_coef_wt(self%idx_from_mesh_id(mesh_id))
      else
        ! Linear coefficients
        coef => self%vert_linear_coef_wt(self%idx_from_mesh_id(mesh_id))
      end if
    case default
      call log_event( "get_vert_sl_coef only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )
    end select

  end function get_vert_sl_coef

  !> @brief Returns a pointer to the vertical interpolation indices
  !!        for semi-Lagrangian transport of a W3/Wtheta field
  !> @param[in] field   The field to apply the coefficients to
  !> @param[in] order   The order of the coefficients for the index
  !> @return The SL indices
  function get_vert_sl_index(self, field, order) result(index)

    use fs_continuity_mod,             only: W3, Wtheta
    use transport_config_mod,          only: vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    integer(kind=i_def),                   intent(in) :: order
    type(integer_field_type),              pointer    :: index

    integer(kind=i_def) :: mesh_id

    ! Get mesh ID
    mesh_id = field%get_mesh_id()

    select case ( field%which_function_space() )
    case ( W3 )
      select case ( order )
      case (vertical_sl_order_cubic)
        ! Cubic coefficients index
        index => self%vert_cubic_index_w3(self%idx_from_mesh_id(mesh_id))
      case (vertical_sl_order_cubic_hermite)
        ! Cubic-Hermite coefficients index
        index => self%vert_hermite_index_w3(self%idx_from_mesh_id(mesh_id))
      case (vertical_sl_order_quintic)
        ! Quintic coefficients index
        index => self%vert_quintic_index_w3(self%idx_from_mesh_id(mesh_id))
      end select
    case ( Wtheta )
      select case ( order )
      case (vertical_sl_order_cubic)
        ! Cubic coefficients index
        index => self%vert_cubic_index_wt(self%idx_from_mesh_id(mesh_id))
      case (vertical_sl_order_cubic_hermite)
        ! Cubic-Hermite coefficients index
        index => self%vert_hermite_index_wt(self%idx_from_mesh_id(mesh_id))
      case (vertical_sl_order_quintic)
        ! Quintic coefficients index
        index => self%vert_quintic_index_wt(self%idx_from_mesh_id(mesh_id))
      end select
    case default
      call log_event( "get_vert_sl_index only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )
    end select

  end function get_vert_sl_index

  !> @brief Returns a pointer to the start index for a change in
  !!        x orientation across a cubed sphere panel edge
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The starting index
  function get_cosmic_istart_x(self, mesh_id) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(integer_field_type),              pointer    :: index

    index => self%cosmic_istart_x(self%idx_from_mesh_id(mesh_id))

  end function get_cosmic_istart_x

  !> @brief Returns a pointer to the end index for a change in
  !!        x orientation across a cubed sphere panel edge
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The starting index
  function get_cosmic_iend_x(self, mesh_id) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(integer_field_type),              pointer    :: index

    index => self%cosmic_iend_x(self%idx_from_mesh_id(mesh_id))

  end function get_cosmic_iend_x

  !> @brief Returns a pointer to the start index for a change in
  !!        y orientation across a cubed sphere panel edge
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The starting index
  function get_cosmic_istart_y(self, mesh_id) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(integer_field_type),              pointer    :: index

    index => self%cosmic_istart_y(self%idx_from_mesh_id(mesh_id))

  end function get_cosmic_istart_y

  !> @brief Returns a pointer to the end index for a change in
  !!        y orientation across a cubed sphere panel edge
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The starting index
  function get_cosmic_iend_y(self, mesh_id) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(integer_field_type),              pointer    :: index

    index => self%cosmic_iend_y(self%idx_from_mesh_id(mesh_id))

  end function get_cosmic_iend_y

  !> @brief Returns a pointer to the start index for a change in
  !!        x orientation across a cubed sphere panel edge for tracer transport
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The starting index
  function get_tracer_istart_x(self, mesh_id, step, outer_step) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(integer_field_type),              pointer    :: index

    if (outer_step) then
      index => self%tracer_istart_ox(self%idx_from_mesh_id(mesh_id), step)
    else
      index => self%tracer_istart_ix(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_istart_x

  !> @brief Returns a pointer to the end index for a change in
  !!        x orientation across a cubed sphere panel edge for tracer transport
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The ending index
  function get_tracer_iend_x(self, mesh_id, step, outer_step) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(integer_field_type),              pointer    :: index

    if (outer_step) then
      index => self%tracer_iend_ox(self%idx_from_mesh_id(mesh_id), step)
    else
      index => self%tracer_iend_ix(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_iend_x

  !> @brief Returns a pointer to the start index for a change in
  !!        y orientation across a cubed sphere panel edge for tracer transport
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The starting index
  function get_tracer_istart_y(self, mesh_id, step, outer_step) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(integer_field_type),              pointer    :: index

    if (outer_step) then
      index => self%tracer_istart_oy(self%idx_from_mesh_id(mesh_id), step)
    else
      index => self%tracer_istart_iy(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_istart_y

  !> @brief Returns a pointer to the end index for a change in
  !!        y orientation across a cubed sphere panel edge for tracer transport
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The ending index
  function get_tracer_iend_y(self, mesh_id, step, outer_step) result(index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(integer_field_type),              pointer    :: index

    if (outer_step) then
      index => self%tracer_iend_oy(self%idx_from_mesh_id(mesh_id), step)
    else
      index => self%tracer_iend_iy(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_iend_y

  !> @brief Returns a pointer to required stencil size for FFSL transport
  !!        based on the maximum horizontal departure point in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The required stencil depth
  function get_dep_stencil_extent_x(self, mesh_id) result(dep_stencil_extent_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_x

    dep_stencil_extent_x => self%dep_stencil_extent_x(self%idx_from_mesh_id(mesh_id))

  end function get_dep_stencil_extent_x

  !> @brief Returns a pointer to required stencil size for FFSL transport
  !!        based on the maximum horizontal departure point in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The required stencil depth
  function get_dep_stencil_extent_y(self, mesh_id) result(dep_stencil_extent_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_y

    dep_stencil_extent_y => self%dep_stencil_extent_y(self%idx_from_mesh_id(mesh_id))

  end function get_dep_stencil_extent_y

  !> @brief Returns a pointer to required stencil size for consistent FFSL
  !!        transport based on the maximum horizontal inner departure point in x
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The required stencil depth
  function get_tracer_stencil_extent_x(self, mesh_id, step, outer_step) result(dep_stencil_extent_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_x

    if (outer_step) then
      dep_stencil_extent_x => self%tracer_stencil_extent_ox(self%idx_from_mesh_id(mesh_id), step)
    else
      dep_stencil_extent_x => self%tracer_stencil_extent_ix(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_stencil_extent_x

  !> @brief Returns a pointer to required stencil size for consistent FFSL
  !!        transport based on the maximum horizontal inner departure point in y
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The required stencil depth
  function get_tracer_stencil_extent_y(self, mesh_id, step, outer_step) result(dep_stencil_extent_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_y

    if (outer_step) then
      dep_stencil_extent_y => self%tracer_stencil_extent_oy(self%idx_from_mesh_id(mesh_id), step)
    else
      dep_stencil_extent_y => self%tracer_stencil_extent_iy(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_stencil_extent_y

  !> @brief Returns number of split transport steps for the dry density
  !> @return The number of split transport steps for the dry density
  function get_num_dry_steps(self) result(num_dry_steps)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: num_dry_steps

    num_dry_steps = self%num_dry_steps

  end function get_num_dry_steps

  !> @brief Returns a pointer stored field at the start of the time step
  !> @return The field at the start of the time step
  function get_field_n(self) result(field_n)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               pointer    :: field_n

    field_n => self%field_n

  end function get_field_n

  !> @brief Returns a pointer to a dry density field from FFSL
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_rho_d(self, mesh_id, step) result(rho_d)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: rho_d
    character(str_def)                                :: field_name

    field_name = 'rho_d'
    rho_d => self%rho_d(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d, field_name, mesh_id)

  end function get_rho_d

  !> @brief Returns a pointer to a dry density field from an FFSL x-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_rho_d_ffsl_x(self, mesh_id, step) result(rho_d_ffsl)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: rho_d_ffsl
    character(str_def)                                :: field_name

    field_name = 'rho_d_ffsl_x'
    rho_d_ffsl => self%rho_d_ffsl_x(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d_ffsl, field_name, mesh_id)

  end function get_rho_d_ffsl_x

  !> @brief Returns a pointer to a dry density field from an FFSL y-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_rho_d_ffsl_y(self, mesh_id, step) result(rho_d_ffsl)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: rho_d_ffsl
    character(str_def)                                :: field_name

    field_name = 'rho_d_ffsl_y'
    rho_d_ffsl => self%rho_d_ffsl_y(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d_ffsl, field_name, mesh_id)

  end function get_rho_d_ffsl_y

  !> @brief Returns a pointer to a mass flux for a particular step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the mass flux
  !> @return The mass flux
  function get_flux(self, mesh_id, step) result(flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: flux

    flux => self%flux(self%idx_from_mesh_id(mesh_id), step)

  end function get_flux

  !> @brief Returns a pointer to the flux from transporting dry density
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the dry flux
  !> @return The dry density flux
  function get_dry_flux(self, mesh_id, step) result(dry_flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_flux
    character(str_def)                                :: field_name

    field_name = 'dry_flux'
    dry_flux => self%dry_flux(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_flux, field_name, mesh_id)

  end function get_dry_flux

  !> @brief Returns the counter of tracer transport steps
  !> @return The tracer step counter
  function get_tracer_step_ctr(self) result(tracer_step_ctr)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def) :: tracer_step_ctr

    tracer_step_ctr = self%tracer_step_ctr

  end function get_tracer_step_ctr

! ============================================================================ !
! UTILITIES
! ============================================================================ !

  !> @brief Increments the counter of tracer transport steps
  subroutine inc_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = self%tracer_step_ctr + 1

  end subroutine inc_tracer_step_ctr

  !> @brief Resets the counter of tracer transport steps
  subroutine reset_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = 1

  end subroutine reset_tracer_step_ctr

  !> @brief Computes the total number of rho transport steps
  !> @result    num_dry_steps    Total number of transport steps for rho
  function compute_num_dry_steps(self) result(num_dry_steps)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    ! Internal variables
    integer(kind=i_def) :: num_dry_steps
    integer(kind=i_def) :: config, dry_config
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up consistent tracer transport ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh, splitting_strang_vhv)
      num_dry_steps = 3
    case(splitting_hv, splitting_vh)
      num_dry_steps = 2
    case(splitting_none)
      num_dry_steps = 1
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented with ' // &
        'consistent tracer transport'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function compute_num_dry_steps

  !> @brief Returns the function space for the direction of the dry step
  !> @param[in] step  Index of the dry density splitting step
  !> @result    fs    Enumerator for the W2 function space
  function direction_w2_fs(self, step) result(fs)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: step
    ! Internal variables
    integer(kind=i_def) :: config, dry_config, fs
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up compute dry steps ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      case default
        fs = 0
      end select
    case(splitting_strang_vhv)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      case default
        fs = 0
      end select
    case(splitting_hv)
      select case(step)
      case(1_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      case default
        fs = 0
      end select
    case(splitting_vh)
      select case(step)
      case(1_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      case default
        fs = 0
      end select
    case(splitting_none)
      fs = W2
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function direction_w2_fs

  !> @brief Private function for getting array index corresponding to mesh_id
  !> @param[in] self      The transport_runtime object
  !> @param[in] mesh_id   Identifier of mesh to find
  function idx_from_mesh_id(self, mesh_id) result(idx)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def)                               :: idx
    integer(kind=i_def)                               :: i

    idx = imdi
    do i = 1, self%n_meshes
      if ( mesh_id == self%mesh_ids(i) ) idx = i
    end do

    if ( idx == imdi ) then
      write(log_scratch_space, '(A,I4)') 'transport_runtime does not contain mesh: ', &
                                          mesh_id
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

  end function idx_from_mesh_id

  subroutine remap_on_extended_mesh(self, remap_field, field,             &
                                    monotone, enforce_minvalue, minvalue, &
                                    depth)

    implicit none
    class(transport_runtime_type), target, intent(inout) :: self

    type(r_tran_field_type), intent(inout) :: remap_field
    type(r_tran_field_type), intent(in)    :: field

    logical(kind=l_def), intent(in) :: monotone
    logical(kind=l_def), intent(in) :: enforce_minvalue
    real(kind=r_tran),   intent(in) :: minvalue
    integer(kind=i_def), intent(in) :: depth

    integer(kind=i_def) :: nremap

    type(mesh_type),           pointer :: mesh => null(), &
                                          twod_mesh => null()
    type(function_space_type), pointer :: w3_fs => null()

    if ( .not. self%computed_remapping ) then
      ! Compute remapping weights for this mesh
      if ( linear_remap ) then
        nremap = 2
      else
        nremap = 4
      end if
      mesh => field%get_mesh()
      twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
      w3_fs => function_space_collection%get_fs(twod_mesh, 0, W3, nremap)
      call self%remap_weights%initialise( w3_fs, halo_depth=twod_mesh%get_halo_depth() )
      call self%remap_indices%initialise( w3_fs, halo_depth=twod_mesh%get_halo_depth() )
      call initialise_remap_on_extended_mesh(self%remap_weights, self%remap_indices)
      self%computed_remapping = .true.
    end if

    call remap_field_on_extended_mesh(remap_field, field, &
                                      self%remap_weights, &
                                      self%remap_indices, &
                                      monotone,           &
                                      enforce_minvalue,   &
                                      minvalue,           &
                                      depth )
    nullify( mesh, twod_mesh, w3_fs )

  end subroutine remap_on_extended_mesh


end module transport_runtime_alg_mod
