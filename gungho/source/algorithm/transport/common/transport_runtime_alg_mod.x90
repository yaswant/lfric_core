!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief A module that controls set-up of various transport objects.
!> @details This module controls the set-up of various objects that are
!!          created at the start of (or during) the transport process, and
!!          are needed throughout the transport routines.

module transport_runtime_alg_mod

  use check_configuration_mod,        only: check_any_scheme_mol,   &
                                            check_any_scheme_ffsl,  &
                                            check_any_scheme_split, &
                                            check_any_shifted,      &
                                            check_horz_dep_pts,     &
                                            check_vert_dep_pts
  use constants_mod,                  only: r_def, r_second, i_def, l_def,  &
                                            str_def, tiny_eps, imdi
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W2, W2h, W2v, W3
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use local_mesh_mod,                 only: local_mesh_type
  use log_mod,                        only: log_event,            &
                                            log_scratch_space,    &
                                            LOG_LEVEL_ERROR,      &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use model_clock_mod,                only: model_clock_type
  use runtime_tools_mod,              only: check_initialised_field
  use transport_enumerated_types_mod, only: scheme_split

  implicit none

  private

  ! Public types
  ! TODO #3008: this should be based on a linked_list_item type
  type, public :: transport_runtime_type

    private

    integer(kind=i_def)                              :: n_meshes
    integer(kind=i_def)                              :: local_mesh_id
    integer(kind=i_def)                              :: num_dry_steps
    integer(kind=i_def)                              :: dry_step_ctr
    integer(kind=i_def)                              :: tracer_step_ctr
    integer(kind=i_def), allocatable, dimension(:)   :: mesh_ids
    type(field_type),    allocatable, dimension(:)   :: advecting_wind
    type(field_type),    allocatable, dimension(:)   :: horizontal_advecting_wind
    type(field_type),    allocatable, dimension(:)   :: vertical_advecting_wind
    type(field_type),    allocatable, dimension(:)   :: detj_at_w2_transport
    type(field_type),    allocatable, dimension(:)   :: departure_points_x_w2
    type(field_type),    allocatable, dimension(:)   :: departure_points_y_w2
    type(field_type),    allocatable, dimension(:)   :: departure_points_z_w2
    type(field_type),    allocatable, dimension(:)   :: div_factor
    type(field_type),    allocatable, dimension(:)   :: field_n
    type(field_type),    allocatable, dimension(:,:) :: rho_d_n
    type(field_type),    allocatable, dimension(:,:) :: rho_d_np1
    type(field_type),    allocatable, dimension(:,:) :: flux_inc
    type(field_type),    allocatable, dimension(:,:) :: dry_flux
    type(field_type),    allocatable, dimension(:,:) :: hori_dry_flux
    type(field_type),    allocatable, dimension(:,:) :: vert_dry_flux
    real(kind=r_def),    allocatable, dimension(:)   :: horizontal_cfl_max
    real(kind=r_def),    allocatable, dimension(:)   :: vertical_cfl_max
    real(kind=r_def),    allocatable, dimension(:)   :: total_cfl_max
    class(model_clock_type), pointer                 :: model_clock

    contains

    procedure, private :: idx_from_mesh_id
    procedure, private :: compute_num_dry_steps
    procedure, private :: direction_w2_fs
    procedure, public  :: get_local_mesh_id
    procedure, public  :: get_prime_extrusion_mesh_id
    procedure, public  :: set_dry_fields
    procedure, public  :: set_field_n
    procedure, public  :: set_flux_inc
    procedure, public  :: copy_all_dry_fields
    procedure, public  :: get_number_substeps
    procedure, public  :: get_dt_substep
    procedure, public  :: get_advecting_wind
    procedure, public  :: get_directional_advecting_wind
    procedure, public  :: get_horizontal_advecting_wind
    procedure, public  :: get_vertical_advecting_wind
    procedure, public  :: get_detj_at_w2_transport
    procedure, public  :: get_departure_points_x_w2
    procedure, public  :: get_departure_points_y_w2
    procedure, public  :: get_departure_points_z_w2
    procedure, public  :: get_div_factor
    procedure, public  :: get_field_n
    procedure, public  :: get_rho_d_n
    procedure, public  :: get_rho_d_np1
    procedure, public  :: get_flux_inc
    procedure, public  :: get_dry_flux
    procedure, public  :: get_hori_dry_flux
    procedure, public  :: get_vert_dry_flux
    procedure, public  :: get_num_dry_steps
    procedure, public  :: get_tracer_step_ctr
    procedure, public  :: inc_tracer_step_ctr
    procedure, public  :: reset_tracer_step_ctr
    procedure, public  :: transport_runtime_assign
    !> Override default assignment for transport_runtime_type pairs.
    generic            :: assignment(=) => transport_runtime_assign
    final              :: destroy_transport_runtime

  end type transport_runtime_type

  !-----------------------------------------------------------------------------
  ! Constructors
  !-----------------------------------------------------------------------------
  !> Function to construct a transport_runtime object
  interface transport_runtime_type
    module procedure transport_runtime_constructor
  end interface

contains

  !> @brief Constructs the transport_runtime object
  !> @param[in] primal_wind_n    Wind field at start of current time step on the
  !!                             prime extrusion
  !> @param[in] primal_wind_np1  Predictor of wind field at next time step on
  !!                             the prime extrusion
  !> @param[in] model_clock      Time within the model
  !> @param[in] shifted_mesh    (Optional) Shifted mesh
  !>
  function transport_runtime_constructor( primal_wind_n,   &
                                          primal_wind_np1, &
                                          model_clock,     &
                                          shifted_mesh) result(self)

    use calc_dep_pts_alg_mod,          only: calc_vert_dep_pts, &
                                             calc_hori_dep_pts, &
                                             select_detj_at_w2
    use split_w2_field_kernel_mod,     only: split_w2_field_kernel_type
    use timestepping_config_mod,       only: beta
    use transport_config_mod,          only: max_vert_cfl_calc,           &
                                             max_vert_cfl_calc_dep_point, &
                                             max_vert_cfl_calc_uniform
    use map_w2_to_sh_w2_alg_mod,       only: sample_w2_to_sh_w2_alg
    use calc_max_cfl_kernel_mod,       only: calc_max_cfl_kernel_type
    use dg_matrix_vector_kernel_mod,   only: dg_matrix_vector_kernel_type
    use fem_constants_mod,             only: get_div, &
                                             get_inverse_W3_mass_matrix
    use operator_mod,                  only: operator_type

    implicit none

    type(field_type),        target, intent(in) :: primal_wind_n
    type(field_type),        target, intent(in) :: primal_wind_np1
    class(model_clock_type), target, intent(in) :: model_clock

    type(mesh_type),  pointer, intent(in), optional :: shifted_mesh

    type(transport_runtime_type)   :: self
    type(field_type)               :: cfl, vertical_cfl, horizontal_cfl, cfl_dep
    type(field_type)               :: sum_cfl, sum_horizontal_cfl, hori_cfl_dep
    integer(kind=i_def)            :: mesh_idx, i, fs_idx, num_compute_meshes
    type(mesh_type),       pointer :: mesh => null()
    type(local_mesh_type), pointer :: local_mesh => null()
    type(field_type),      pointer :: wind_n   => null()
    type(field_type),      pointer :: wind_np1 => null()
    type(field_type),      target  :: shifted_wind_n
    type(field_type),      target  :: shifted_wind_np1
    type(field_type)               :: rhs
    real(kind=r_def)               :: minus_beta_dt
    real(kind=r_def)               :: cfl_min, cfl_max
    real(kind=r_def)               :: h_cfl_min, h_cfl_max
    real(kind=r_def)               :: v_cfl_min, v_cfl_max
    real(r_def)                    :: cast_dt
    logical(kind=l_def)            :: any_scheme_mol, any_scheme_split
    logical(kind=l_def)            :: any_scheme_ffsl, any_shifted
    logical(kind=l_def)            :: any_horz_dep_pts, any_vert_dep_pts
    type(operator_type),   pointer :: mm_w3_inv => null(), &
                                      div       => null()

    type(mesh_type),           pointer :: tmp_mesh => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()

    write(log_scratch_space, '(A,I4)') 'Setting up transport_runtime on mesh: ', &
                                       primal_wind_n%get_mesh_id()
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    ! ======================================================================== !
    ! Checks for what schemes we have

    any_scheme_mol = check_any_scheme_mol()
    any_scheme_ffsl = check_any_scheme_ffsl()
    any_scheme_split = check_any_scheme_split()
    any_horz_dep_pts = check_horz_dep_pts()
    any_vert_dep_pts = check_vert_dep_pts()
    any_shifted = check_any_shifted()

    ! ======================================================================== !
    ! Determine number of meshes

    ! By default only compute auxiliary fields on prime extrusion mesh
    num_compute_meshes = 1

    if ( present(shifted_mesh) ) then
      self%n_meshes = 2
      ! Only compute things on the shifted mesh if we need to
      if (any_shifted) then
        num_compute_meshes = 2
      end if
    else
      self%n_meshes = 1
    end if

    !> @todo This is almost certainly the wrong thing to do but I want to get
    !>       something done.
    !>
    self%model_clock => model_clock
    cast_dt = real( model_clock%get_seconds_per_step(), r_def )

    mesh => primal_wind_n%get_mesh()
    local_mesh => mesh%get_local_mesh()
    self%local_mesh_id = local_mesh%get_id()

    allocate( self%mesh_ids(self%n_meshes),                  &
              self%advecting_wind(self%n_meshes),            &
              self%horizontal_advecting_wind(self%n_meshes), &
              self%vertical_advecting_wind(self%n_meshes),   &
              self%detj_at_w2_transport(self%n_meshes),      &
              self%departure_points_x_w2(self%n_meshes),     &
              self%departure_points_y_w2(self%n_meshes),     &
              self%departure_points_z_w2(self%n_meshes),     &
              self%div_factor(self%n_meshes),                &
              self%horizontal_cfl_max(self%n_meshes),        &
              self%vertical_cfl_max(self%n_meshes),          &
              self%total_cfl_max(self%n_meshes),             &
              self%field_n(self%n_meshes) )

    ! Get mesh ID and element order
    self%mesh_ids(1) = primal_wind_n%get_mesh_id()

    ! If asked for compute objects on the shifted mesh
    if ( present(shifted_mesh ) ) then
      self%mesh_ids(2) = shifted_mesh%get_id()
      write(log_scratch_space, '(A,I4)') '... and shifted mesh: ', &
                                         shifted_mesh%get_id()
      call log_event(log_scratch_space, LOG_LEVEL_INFO)
    end if

    ! ======================================================================== !
    ! Create winds on shifted mesh
    if ( present(shifted_mesh) ) then

      ! TODO #3008: only initialise these if they will be used
      ! For now we need to initialise them for copying the transport runtime
      call shifted_wind_n%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_np1%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )

      if (num_compute_meshes == 2) then
        call sample_w2_to_sh_w2_alg(shifted_wind_n,   primal_wind_n)
        call sample_w2_to_sh_w2_alg(shifted_wind_np1, primal_wind_np1)
      end if
    end if

    ! ======================================================================== !
    ! Initialise fields
    ! TODO #3008: we should only initialise fields that we actually use
    do mesh_idx = 1, self%n_meshes
      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
      w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2)
      w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2h)
      w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2v)
      w3_fs => function_space_collection%get_fs(tmp_mesh, element_order, W3)

      call self%advecting_wind(mesh_idx)%initialise( w2_fs )
      call self%horizontal_advecting_wind(mesh_idx)%initialise( w2h_fs )
      call self%vertical_advecting_wind(mesh_idx)%initialise( w2v_fs )
      call self%detj_at_w2_transport(mesh_idx)%initialise( w2_fs )
      call self%departure_points_z_w2(mesh_idx)%initialise( w2_fs )
      call self%departure_points_x_w2(mesh_idx)%initialise( w2_fs )
      call self%departure_points_y_w2(mesh_idx)%initialise( w2_fs )
      call self%div_factor(mesh_idx)%initialise( w3_fs  )
      call self%field_n(mesh_idx)%initialise( w3_fs  )
    end do

    ! ======================================================================== !
    ! Compute auxiliary transport fields

    do mesh_idx = 1, num_compute_meshes

      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))

      !=======================================================================!
      ! Create advecting winds

      if ( mesh_idx == 1 ) then
        ! First pass, make wind_n & wind_np1 point to the primal mesh fields
        wind_n   => primal_wind_n
        wind_np1 => primal_wind_np1
      else
        ! For second pass (if needed) set wind_n & wind_np1 to point to
        ! shifted mesh versions
        wind_n   => shifted_wind_n
        wind_np1 => shifted_wind_np1
      end if

      call invoke( aX_plus_bY(self%advecting_wind(mesh_idx), 0.5_r_def, wind_n, &
                                                         0.5_r_def, wind_np1),  &
                   ! Presume that we always need horizontal and vertical winds
                   setval_c(self%horizontal_advecting_wind(mesh_idx), 0.0_r_def),       &
                   setval_c(self%vertical_advecting_wind(mesh_idx), 0.0_r_def),         &
                   split_w2_field_kernel_type(self%horizontal_advecting_wind(mesh_idx), &
                                              self%vertical_advecting_wind(mesh_idx),   &
                                              self%advecting_wind(mesh_idx)) )

      !=======================================================================!
      ! Compute departure points

      ! Get detj_at_w2 using wind_n
      call select_detj_at_w2( wind_n, self%detj_at_w2_transport(mesh_idx) )

      ! If any vertical scheme is ffsl/sl compute vertical departure points
      if (any_vert_dep_pts) then
        call cfl_dep%initialise( vector_space = &
                function_space_collection%get_fs(tmp_mesh, element_order, W2) )

        call calc_vert_dep_pts( self%departure_points_z_w2(mesh_idx), &
                                cfl_dep,                              &
                                wind_n,                               &
                                wind_np1,                             &
                                self%detj_at_w2_transport(mesh_idx),  &
                                cast_dt )
      end if

      ! If any horizontal scheme is ffsl compute horizontal departure points
      if (any_horz_dep_pts) then
        call calc_hori_dep_pts( self%departure_points_x_w2(mesh_idx),  &
                                self%departure_points_y_w2(mesh_idx),  &
                                wind_n,                                &
                                wind_np1,                              &
                                self%detj_at_w2_transport(mesh_idx),   &
                                cast_dt )
      end if

      !=======================================================================!
      ! Compute cfls for use in substepping
      call cfl%initialise( wind_n%get_function_space() )
      call horizontal_cfl%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
      call vertical_cfl%initialise( self%vertical_advecting_wind(mesh_idx)%get_function_space() )
      call sum_horizontal_cfl%initialise( vector_space = &
                function_space_collection%get_fs(tmp_mesh, element_order, W3) )
      call sum_cfl%initialise( vector_space = &
                function_space_collection%get_fs(tmp_mesh, element_order, W3) )

      call invoke( setval_X(cfl, self%advecting_wind(mesh_idx)),               &
                   inc_X_divideby_Y(cfl, self%detj_at_w2_transport(mesh_idx)), &
                   inc_a_times_X(cast_dt, cfl),                                &
                   setval_c(horizontal_cfl, 0.0_r_def),                        &
                   setval_c(vertical_cfl, 0.0_r_def),                          &
                   setval_c(sum_horizontal_cfl, 0.0_r_def),                    &
                   setval_c(sum_cfl, 0.0_r_def),                               &
                   split_w2_field_kernel_type(horizontal_cfl,                  &
                                              vertical_cfl,                    &
                                              cfl) )

      select case(max_vert_cfl_calc)
      ! Calculate the maximum vertical cfl for substepping
      case(max_vert_cfl_calc_uniform)
        call vertical_cfl%field_minmax(v_cfl_min, v_cfl_max)
      case(max_vert_cfl_calc_dep_point)
        call hori_cfl_dep%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
        call invoke( split_w2_field_kernel_type(hori_cfl_dep, &
                                                vertical_cfl, &
                                                cfl_dep) )
        call cfl_dep%field_minmax(v_cfl_min, v_cfl_max)
      case default
        write(log_scratch_space, '(A)') &
          'transport_runtime: maximum vertical CFL method not defined '
        call log_event(log_scratch_space, LOG_LEVEL_ERROR)
      end select

      ! Get the total CFL at each cell - this only works for element_order = 0
      if (element_order == 0_i_def) then
        call invoke( calc_max_cfl_kernel_type(sum_cfl, sum_horizontal_cfl, &
                                              horizontal_cfl, vertical_cfl) )
        call sum_horizontal_cfl%field_minmax(h_cfl_min, h_cfl_max)
        call sum_cfl%field_minmax(cfl_min, cfl_max)
        self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
        self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
        self%total_cfl_max(mesh_idx) = max(abs(cfl_max), abs(cfl_min))
      else
        call horizontal_cfl%field_minmax(h_cfl_min, h_cfl_max)
        self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
        self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
        self%total_cfl_max(mesh_idx) = max( self%horizontal_cfl_max(mesh_idx), &
                                            self%vertical_cfl_max(mesh_idx) )
      end if

      write( log_scratch_space, '(A, E16.8)') &
          'Transport: maximum horizontal CFL ', self%horizontal_cfl_max(mesh_idx)
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      write( log_scratch_space, '(A, E16.8)') &
          'Transport: maximum vertical CFL ', self%vertical_cfl_max(mesh_idx)
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      write( log_scratch_space, '(A, E16.8)') &
          'Transport: maximum total CFL ', self%total_cfl_max(mesh_idx)
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      !========================================================================!
      ! Compute the divergence factor for use in density advection
      ! div_factor = 1 - beta*dt*m3_inv*div*wind_n
      minus_beta_dt = -beta*cast_dt
      mm_w3_inv => get_inverse_w3_mass_matrix(self%mesh_ids(mesh_idx))
      div       => get_div(self%mesh_ids(mesh_idx))
      call rhs%initialise( self%div_factor(mesh_idx)%get_function_space() )
      call invoke( name = "compute_density_predictor",                          &
                   dg_matrix_vector_kernel_type(self%div_factor(mesh_idx),      &
                                                wind_n, div),                   &
                   dg_matrix_vector_kernel_type(rhs, self%div_factor(mesh_idx), &
                                                mm_w3_inv),                     &
                   setval_c(self%div_factor(mesh_idx), 1.0_r_def),              &
                   inc_X_plus_bY(self%div_factor(mesh_idx), minus_beta_dt, rhs) )

    end do

    !==========================================================================!
    ! Dry fields stored for consistent transport of scalars
    self%num_dry_steps = self%compute_num_dry_steps()

    ! Allocate arrays for dry fields
    allocate( self%rho_d_n(self%n_meshes, self%num_dry_steps),       &
              self%rho_d_np1(self%n_meshes, self%num_dry_steps),     &
              self%flux_inc(self%n_meshes, self%num_dry_steps),      &
              self%dry_flux(self%n_meshes, self%num_dry_steps),      &
              self%hori_dry_flux(self%n_meshes, self%num_dry_steps), &
              self%vert_dry_flux(self%n_meshes, self%num_dry_steps) )

    ! Initialise these fields
    ! TODO: #3008 can we avoid initialised unused fields?
    ! Dry fluxes only needed if something is transported 'consistently'
    do mesh_idx = 1, self%n_meshes
      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
      w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2h)
      w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2v)
      w3_fs => function_space_collection%get_fs(tmp_mesh, element_order, W3)
      do i = 1, self%num_dry_steps
        call self%rho_d_n(mesh_idx, i)%initialise( vector_space = w3_fs )
        call self%rho_d_np1(mesh_idx, i)%initialise( vector_space = w3_fs )
        call self%flux_inc(mesh_idx, i)%initialise( vector_space = w3_fs )
        call self%hori_dry_flux(mesh_idx, i)%initialise( vector_space = w2h_fs )
        call self%vert_dry_flux(mesh_idx, i)%initialise( vector_space = w2v_fs )
        ! Dry flux could be 3D, horizontal or vertical
        ! Determine what it is for this dry transport step
        fs_idx = self%direction_w2_fs(i)
        w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, fs_idx)
        call self%dry_flux(mesh_idx, i)%initialise( vector_space = w2_fs )
      end do
    end do

    ! Set dry substep counter to be 1
    self%dry_step_ctr = 1
    self%tracer_step_ctr = 1

    nullify(mesh, local_mesh, w2_fs, w3_fs, tmp_mesh, w2h_fs, w2v_fs)

  end function transport_runtime_constructor

  !> Finalizer for the transport runtime
  !> @param [in,out] self The transport runtime object
  subroutine destroy_transport_runtime(self)
    implicit none
    type(transport_runtime_type), intent(inout) :: self

    if ( allocated( self%mesh_ids ) )                  deallocate( self%mesh_ids )
    if ( allocated( self%advecting_wind ) )            deallocate( self%advecting_wind )
    if ( allocated( self%horizontal_advecting_wind ) ) deallocate( self%horizontal_advecting_wind )
    if ( allocated( self%vertical_advecting_wind ) )   deallocate( self%vertical_advecting_wind )
    if ( allocated( self%detj_at_w2_transport ) )      deallocate( self%detj_at_w2_transport )
    if ( allocated( self%departure_points_x_w2 ) )     deallocate( self%departure_points_x_w2 )
    if ( allocated( self%departure_points_y_w2 ) )     deallocate( self%departure_points_y_w2 )
    if ( allocated( self%departure_points_z_w2 ) )     deallocate( self%departure_points_z_w2 )
    if ( allocated( self%div_factor ) )                deallocate( self%div_factor )
    if ( allocated( self%field_n ) )                   deallocate( self%field_n )
    if ( allocated( self%rho_d_n ) )                   deallocate( self%rho_d_n )
    if ( allocated( self%rho_d_np1 ) )                 deallocate( self%rho_d_np1 )
    if ( allocated( self%flux_inc ) )                  deallocate( self%flux_inc )
    if ( allocated( self%dry_flux ) )                  deallocate( self%dry_flux )
    if ( allocated( self%hori_dry_flux ) )             deallocate( self%hori_dry_flux )
    if ( allocated( self%vert_dry_flux ) )             deallocate( self%vert_dry_flux )
    if ( allocated( self%horizontal_cfl_max ) )        deallocate( self%horizontal_cfl_max )
    if ( allocated( self%vertical_cfl_max ) )          deallocate( self%vertical_cfl_max )
    if ( allocated( self%total_cfl_max ) )             deallocate( self%total_cfl_max )

  end subroutine destroy_transport_runtime

  !> @brief Overload the default assign (=) to correctly copy fields
  !> @param[out] dest    The destination transport_runtime object
  !> @param[in]  source  The source transport_runtime object
  subroutine transport_runtime_assign(dest, source)

    implicit none
    class(transport_runtime_type), intent(in)  :: source
    class(transport_runtime_type), intent(out) :: dest
    integer(kind=i_def)                        :: mesh_idx, i

    ! Deep copy of the contents of the transport_runtime_type
    dest%n_meshes = source%n_meshes
    dest%local_mesh_id = source%local_mesh_id
    dest%dry_step_ctr = source%dry_step_ctr
    dest%tracer_step_ctr = source%tracer_step_ctr
    dest%num_dry_steps = source%num_dry_steps

    if (.not. allocated( dest%mesh_ids ) )                  allocate( dest%mesh_ids(dest%n_meshes) )
    if (.not. allocated( dest%advecting_wind ) )            allocate( dest%advecting_wind(dest%n_meshes) )
    if (.not. allocated( dest%horizontal_advecting_wind ) ) allocate( dest%horizontal_advecting_wind(dest%n_meshes) )
    if (.not. allocated( dest%vertical_advecting_wind ) )   allocate( dest%vertical_advecting_wind(dest%n_meshes) )
    if (.not. allocated( dest%detj_at_w2_transport ) )      allocate( dest%detj_at_w2_transport(dest%n_meshes) )
    if (.not. allocated( dest%departure_points_y_w2 ) )     allocate( dest%departure_points_y_w2(dest%n_meshes) )
    if (.not. allocated( dest%departure_points_x_w2 ) )     allocate( dest%departure_points_x_w2(dest%n_meshes) )
    if (.not. allocated( dest%departure_points_z_w2 ) )     allocate( dest%departure_points_z_w2(dest%n_meshes) )
    if (.not. allocated( dest%div_factor ) )                allocate( dest%div_factor(dest%n_meshes) )
    if (.not. allocated( dest%field_n ) )                   allocate( dest%field_n(dest%n_meshes) )
    if (.not. allocated( dest%rho_d_n ) )                   allocate( dest%rho_d_n(dest%n_meshes, dest%num_dry_steps) )
    if (.not. allocated( dest%rho_d_np1 ) )                 allocate( dest%rho_d_np1(dest%n_meshes, dest%num_dry_steps) )
    if (.not. allocated( dest%flux_inc ) )                  allocate( dest%flux_inc(dest%n_meshes, dest%num_dry_steps) )
    if (.not. allocated( dest%dry_flux ) )                  allocate( dest%dry_flux(dest%n_meshes, dest%num_dry_steps) )
    if (.not. allocated( dest%hori_dry_flux ) )             allocate( dest%hori_dry_flux(dest%n_meshes, dest%num_dry_steps) )
    if (.not. allocated( dest%vert_dry_flux ) )             allocate( dest%vert_dry_flux(dest%n_meshes, dest%num_dry_steps) )
    if (.not. allocated( dest%horizontal_cfl_max ) )        allocate( dest%horizontal_cfl_max(dest%n_meshes) )
    if (.not. allocated( dest%vertical_cfl_max ) )          allocate( dest%vertical_cfl_max(dest%n_meshes) )
    if (.not. allocated( dest%total_cfl_max ) )             allocate( dest%total_cfl_max(dest%n_meshes) )

    do mesh_idx = 1, source%n_meshes
      call source%advecting_wind(mesh_idx)%copy_field(dest%advecting_wind(mesh_idx))
      call source%horizontal_advecting_wind(mesh_idx)%copy_field(dest%horizontal_advecting_wind(mesh_idx))
      call source%vertical_advecting_wind(mesh_idx)%copy_field(dest%vertical_advecting_wind(mesh_idx))
      call source%detj_at_w2_transport(mesh_idx)%copy_field(dest%detj_at_w2_transport(mesh_idx))
      call source%departure_points_x_w2(mesh_idx)%copy_field(dest%departure_points_x_w2(mesh_idx))
      call source%departure_points_y_w2(mesh_idx)%copy_field(dest%departure_points_y_w2(mesh_idx))
      call source%departure_points_z_w2(mesh_idx)%copy_field(dest%departure_points_z_w2(mesh_idx))
      call source%div_factor(mesh_idx)%copy_field(dest%div_factor(mesh_idx))
      call source%field_n(mesh_idx)%copy_field(dest%field_n(mesh_idx))
      do i = 1, source%num_dry_steps
        call source%rho_d_n(mesh_idx,i)%copy_field(dest%rho_d_n(mesh_idx,i))
        call source%rho_d_np1(mesh_idx,i)%copy_field(dest%rho_d_np1(mesh_idx,i))
        call source%flux_inc(mesh_idx,i)%copy_field(dest%flux_inc(mesh_idx,i))
        call source%dry_flux(mesh_idx,i)%copy_field(dest%dry_flux(mesh_idx,i))
        call source%hori_dry_flux(mesh_idx,i)%copy_field(dest%hori_dry_flux(mesh_idx,i))
        call source%vert_dry_flux(mesh_idx,i)%copy_field(dest%vert_dry_flux(mesh_idx,i))
      end do
    end do

    dest%mesh_ids(:) = source%mesh_ids(:)
    dest%horizontal_cfl_max(:) = source%horizontal_cfl_max(:)
    dest%vertical_cfl_max(:)   = source%vertical_cfl_max(:)
    dest%total_cfl_max(:)      = source%total_cfl_max(:)
    dest%model_clock => source%model_clock

  end subroutine transport_runtime_assign

  !> @brief Sets dry fields for use in conservative mixing ratio transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     rho_d_n   Dry density field at start of time step
  !> @param[in]     rho_d_np1 Dry density field at end of time step
  !> @param[in]     dry_flux  Flux field used to transport dry density
  subroutine set_dry_fields(self, rho_d_n, rho_d_np1, dry_flux)

    use apply_w3_to_sh_w3_kernel_mod,   only: apply_w3_to_sh_w3_kernel_type
    use consist_w2_to_sh_w2_kernel_mod, only: consist_w2_to_sh_w2_kernel_type
    use consist_w2h_to_sh_w2h_kernel_mod, &
                                        only: consist_w2h_to_sh_w2h_kernel_type
    use consist_w2v_to_sh_w2v_kernel_mod, &
                                        only: consist_w2v_to_sh_w2v_kernel_type
    use fem_constants_mod,              only: get_rmultiplicity
    use intermesh_constants_mod,        only: get_consist_w3_to_sh_w3_op
    use check_configuration_mod,        only: check_any_eqn_consistent
    use split_w2_field_kernel_mod,      only: split_w2_field_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(field_type),                      intent(in)    :: rho_d_n
    type(field_type),                      intent(in)    :: rho_d_np1
    type(field_type),                      intent(in)    :: dry_flux

    integer(kind=i_def)       :: fs_idx
    logical(kind=i_def)       :: any_w3_consistent, any_eqn_consistent
    type(field_type), pointer :: consist_w3_to_sh_w3_op(:) => null()
    type(field_type), pointer :: rmultiplicity_w2 => null()
    type(mesh_type),  pointer :: prime_extrusion_mesh => null()

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => dry_flux%get_mesh()
    fs_idx = dry_flux%which_function_space()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    ! ------------------------------------------------------------------------ !
    ! Copy across fields for prime extrusion mesh
    ! ------------------------------------------------------------------------ !

    call rho_d_n%copy_field(self%rho_d_n(1,self%dry_step_ctr))
    call rho_d_np1%copy_field(self%rho_d_np1(1,self%dry_step_ctr))
    call dry_flux%copy_field(self%dry_flux(1,self%dry_step_ctr))

    ! ------------------------------------------------------------------------ !
    ! Split dry flux on prime extrusion mesh
    ! ------------------------------------------------------------------------ !

    ! TODO #XXXX: the dry flux only needs splitting if we are transporting a W3
    ! tracer consistently (which is not currently done anywhere)
    ! For now force this to be false
    any_w3_consistent = .false.

    if (any_w3_consistent) then
      select case (fs_idx)
      case (W2)
        call invoke(                                                           &
          setval_c(self%hori_dry_flux(1,self%dry_step_ctr), 0.0_r_def),        &
          setval_c(self%vert_dry_flux(1,self%dry_step_ctr), 0.0_r_def),        &
          split_w2_field_kernel_type(self%hori_dry_flux(1,self%dry_step_ctr),  &
                                     self%vert_dry_flux(1,self%dry_step_ctr),  &
                                     dry_flux) )
      end select
    end if

    any_eqn_consistent = check_any_eqn_consistent()

    if (self%n_meshes > 1 .and. any_eqn_consistent) then
      ! Transform these densities and dry fluxes to the shifted mesh
      consist_w3_to_sh_w3_op => get_consist_w3_to_sh_w3_op()

      call invoke( name='shift_dry_densities',                                 &
          apply_w3_to_sh_w3_kernel_type(self%rho_d_n(2,self%dry_step_ctr),     &
                                        self%rho_d_n(1,self%dry_step_ctr),     &
                                        consist_w3_to_sh_w3_op),               &
          apply_w3_to_sh_w3_kernel_type(self%rho_d_np1(2,self%dry_step_ctr),   &
                                        self%rho_d_np1(1,self%dry_step_ctr),   &
                                        consist_w3_to_sh_w3_op) )

      ! Transform dry fluxes to the shifted mesh, with case depending on fs_idx
      select case (fs_idx)
      case (W2)
        ! Shift and then split
        rmultiplicity_w2 => get_rmultiplicity(W2, dry_flux%get_mesh_id())
        call invoke(                                                           &
          setval_c(self%dry_flux(2,self%dry_step_ctr), 0.0_r_def),             &
          setval_c(self%hori_dry_flux(2,self%dry_step_ctr), 0.0_r_def),        &
          setval_c(self%vert_dry_flux(2,self%dry_step_ctr), 0.0_r_def),        &
          consist_w2_to_sh_w2_kernel_type(self%dry_flux(2,self%dry_step_ctr),  &
                                          self%dry_flux(1,self%dry_step_ctr),  &
                                          rmultiplicity_w2) )
        ! The wrong information is extracted if these invokes are combined
        call invoke(                                                           &
          split_w2_field_kernel_type(self%hori_dry_flux(2,self%dry_step_ctr),  &
                                     self%vert_dry_flux(2,self%dry_step_ctr),  &
                                     self%dry_flux(2,self%dry_step_ctr)) )
      case (W2h)
        ! Flux is already horizontal so just shift
        rmultiplicity_w2 => get_rmultiplicity(W2h, dry_flux%get_mesh_id())
        call invoke(                                                            &
          setval_c(self%dry_flux(2,self%dry_step_ctr), 0.0_r_def),              &
          consist_w2h_to_sh_w2h_kernel_type(self%dry_flux(2,self%dry_step_ctr), &
                                            self%dry_flux(1,self%dry_step_ctr), &
                                            rmultiplicity_w2) )
      case (W2v)
        ! Flux is alread vertical so just shift
        call invoke(                                                            &
          consist_w2v_to_sh_w2v_kernel_type(self%dry_flux(2,self%dry_step_ctr), &
                                            self%dry_flux(1,self%dry_step_ctr)) )
      case default
        call log_event( "Can only store dry flux for W2, W2h and W2v spaces", LOG_LEVEL_ERROR )
      end select

      nullify( rmultiplicity_w2, consist_w3_to_sh_w3_op )
    end if

    ! Increment counter for dry substep
    self%dry_step_ctr = self%dry_step_ctr + 1

    nullify( prime_extrusion_mesh )

  end subroutine set_dry_fields

  !> @brief Stores a W3 field at the start of the whole transport step
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     field_n   W3 field at start of whole transport step
  subroutine set_field_n(self, field_n)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(field_type),                      intent(in)    :: field_n

    integer(kind=i_def) :: idx

    idx = self%idx_from_mesh_id(field_n%get_mesh_id())
    call field_n%copy_field(self%field_n(idx))

  end subroutine set_field_n

  !> @brief Sets flux increments for use in conservative transport
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     flux_inc  Flux increment for a particular split step
  subroutine set_flux_inc(self, flux_inc)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(field_type),                      intent(in)    :: flux_inc

    integer(kind=i_def) :: idx

    idx = self%idx_from_mesh_id(flux_inc%get_mesh_id())
    call flux_inc%copy_field(self%flux_inc(idx,self%tracer_step_ctr))

  end subroutine set_flux_inc

  !> @brief Copies across all the dry fields from one transport runtime to
  !!        another, restricting the fields if the target mesh is coarser
  !> @param[in,out] self                       Target transport_runtime object
  !> @param[in]     source_transport_runtime   Source transport_runtime object
  subroutine copy_all_dry_fields(self, source_transport_runtime)

    use fem_constants_mod,         only: get_rmultiplicity
    use mesh_collection_mod,       only: mesh_collection
    use restrict_kernel_mod,       only: restrict_kernel_type
    use restrict_w2_kernel_mod,    only: restrict_w2_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    class(transport_runtime_type),         intent(in)    :: source_transport_runtime
    type(function_space_type),             pointer       :: w2_fs => null()
    type(function_space_type),             pointer       :: w3_fs => null()
    type(mesh_type),                       pointer       :: source_mesh => null()
    type(mesh_type),                       pointer       :: target_mesh => null()
    type(field_type),                      pointer       :: source_rho_d_n => null()
    type(field_type),                      pointer       :: source_rho_d_np1 => null()
    type(field_type),                      pointer       :: source_dry_flux => null()
    type(field_type),                      pointer       :: rmultiplicity_w2 => null()
    type(field_type)                                     :: target_rho_d_n
    type(field_type)                                     :: target_rho_d_np1
    type(field_type)                                     :: target_dry_flux
    integer(kind=i_def)                                  :: source_ncells
    integer(kind=i_def)                                  :: target_ncells
    integer(kind=i_def)                                  :: source_mesh_id
    integer(kind=i_def)                                  :: target_mesh_id
    integer(kind=i_def)                                  :: i

    ! N.B. The meshes should not be the same as one another, otherwise the
    ! transport_runtime objects will be the same

    source_mesh_id = source_transport_runtime%get_prime_extrusion_mesh_id()
    target_mesh_id = self%get_prime_extrusion_mesh_id()
    ! Obtain meshes to check that we can coarsen
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)
    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    ! Get rmultiplicity
    rmultiplicity_w2 => get_rmultiplicity(W2, source_mesh_id)

    w2_fs => function_space_collection%get_fs(target_mesh, element_order, W2)
    w3_fs => function_space_collection%get_fs(target_mesh, element_order, W3)

    ! Initialise target fields
    call target_rho_d_n%initialise( vector_space = w3_fs )
    call target_rho_d_np1%initialise( vector_space = w3_fs )
    call target_dry_flux%initialise( vector_space = w2_fs )

    if (source_ncells > target_ncells) then
      ! Loop through fields for each step for prime extrusion
      do i = 1, source_transport_runtime%get_num_dry_steps()
        source_rho_d_n => source_transport_runtime%get_rho_d_n(source_mesh_id, i)
        source_rho_d_np1 => source_transport_runtime%get_rho_d_np1(source_mesh_id, i)
        source_dry_flux => source_transport_runtime%get_dry_flux(source_mesh_id, i)

        ! TODO #3312: Implement restrict_w2h and restrict_w2v to provide
        ! splitting for consistent transport on a coarser mesh
        ! if (source_dry_flux%which_function_space() /= W2) then
        !   call log_event(                                                   &
        !       'Consistent transport on a coarser mesh not yet implemented', &
        !       LOG_LEVEL_ERROR)
        ! end if

        ! Intergrid kernels have to be called in separate invokes
        call invoke(                                                    &
            setval_c(target_dry_flux, 0.0_r_def),                       &
            restrict_w2_kernel_type(target_dry_flux, source_dry_flux,   &
                                    rmultiplicity_w2) )
        call invoke(                                                    &
            setval_c(target_rho_d_n, 0.0_r_def),                        &
            restrict_kernel_type(target_rho_d_n, source_rho_d_n) )
        call invoke(                                                    &
            setval_c(target_rho_d_np1, 0.0_r_def),                      &
            restrict_kernel_type(target_rho_d_np1, source_rho_d_np1) )

        ! Set dry fields
        call self%set_dry_fields(target_rho_d_n, target_rho_d_np1, target_dry_flux)

      end do

    else
      call log_event( 'Can only call copy_all_dry_fields when ' // &
                      'target mesh is coarser than source mesh', LOG_LEVEL_ERROR)
    end if

    nullify( source_mesh, target_mesh, rmultiplicity_w2, source_rho_d_n, &
             source_rho_d_np1, source_dry_flux, w3_fs, w2_fs )

  end subroutine copy_all_dry_fields

  !> @brief Private function for getting array index corresponding to mesh_id
  !> @param[in] self      The transport_runtime object
  !> @param[in] mesh_id   Identifier of mesh to find
  function idx_from_mesh_id(self, mesh_id) result(idx)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def)                               :: idx
    integer(kind=i_def)                               :: i

    idx = imdi
    do i = 1, self%n_meshes
      if ( mesh_id == self%mesh_ids(i) ) idx = i
    end do

    if ( idx == imdi ) then
      write(log_scratch_space, '(A,I4)') 'transport_runtime does not contain mesh: ', &
                                          mesh_id
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

  end function idx_from_mesh_id

  !> @brief Computes number of MoL substeps for a splitting step
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @return number_substeps  Number of substeps
  function get_number_substeps(self, mesh_id, direction, splitting) result(number_substeps)
    use transport_config_mod,           only: cfl_mol_3d_stab, &
                                              cfl_mol_2d_stab, &
                                              cfl_mol_1d_stab
    use transport_enumerated_types_mod, only: direction_h,          &
                                              direction_v,          &
                                              direction_3d,         &
                                              splitting_strang_vhv, &
                                              splitting_strang_hvh
    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    integer(kind=i_def)                       :: number_substeps
    integer(kind=i_def)                       :: idx

    idx = self%idx_from_mesh_id(mesh_id)
    select case (direction)

      case (direction_v)
        number_substeps = int( self%vertical_cfl_max(idx)        &
                              /(cfl_mol_1d_stab+tiny_eps),i_def) &
                         + 1_i_def
        ! Strang_vhv splitting uses half timestep for the vertical stage
        if ( splitting == splitting_strang_vhv ) then
          number_substeps = int( self%vertical_cfl_max(idx)        &
                              /(2.0_r_def*cfl_mol_1d_stab+tiny_eps),i_def) &
                          + 1_i_def
        end if
      case (direction_h)
        number_substeps = int( self%horizontal_cfl_max(idx)      &
                              /(cfl_mol_2d_stab+tiny_eps),i_def) &
                        + 1_i_def
        ! Strang_hvh splitting uses half timestep for the horizontal stage
        if ( splitting == splitting_strang_hvh ) then
          number_substeps = int( self%horizontal_cfl_max(idx)        &
                              /(2.0_r_def*cfl_mol_2d_stab+tiny_eps),i_def) &
                          + 1_i_def
        end if

      case (direction_3d)
        number_substeps = int( self%total_cfl_max(idx)            &
                              /(cfl_mol_3d_stab+tiny_eps),i_def)  &
                         + 1_i_def
      case default
        number_substeps = 1_i_def
    end select

  end function get_number_substeps

  !> @brief Get the MoL dt for substeps for this mesh / direction / splitting
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @return dt_substep  The dt for MoL substeps
  function get_dt_substep(self, mesh_id, direction, splitting) result(dt_substep)
    use transport_enumerated_types_mod, only: direction_v,          &
                                              direction_h,          &
                                              splitting_strang_vhv, &
                                              splitting_strang_hvh

    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    integer(kind=i_def)                       :: number_substeps
    real(kind=r_def)                          :: dt_substep

    number_substeps = self%get_number_substeps(mesh_id, direction, splitting)
    dt_substep = real(self%model_clock%get_seconds_per_step(), r_def) &
                 / real(number_substeps, r_def)
    if ( splitting  == splitting_strang_vhv .and. direction == direction_v ) then
        dt_substep = dt_substep / 2.0_r_def
    else if ( splitting  == splitting_strang_hvh .and. direction == direction_h ) then
        dt_substep = dt_substep / 2.0_r_def
    end if

  end function get_dt_substep

  !> @brief Returns the local mesh id for the transport_runtime
  !> @return The identifier for the underlying local mesh
  function get_local_mesh_id(self) result(local_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: local_mesh_id

    local_mesh_id = self%local_mesh_id

  end function get_local_mesh_id

  !> @brief Returns the mesh id for the transport_runtime prime extrusion mesh
  !> @return The identifier for the prime extrusion mesh
  function get_prime_extrusion_mesh_id(self) result(prime_extrusion_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: prime_extrusion_mesh_id

    prime_extrusion_mesh_id = self%mesh_ids(1)

  end function get_prime_extrusion_mesh_id

  !> @brief Returns a pointer to the advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The advecting wind for that mesh
  function get_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'advecting_wind'
    advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_advecting_wind

  !> @brief Returns a pointer to the advecting wind associated with a direction
  !> @param[in] mesh_id    The ID of the mesh to get the object for
  !> @param[in] direction  The enumerator for the direction
  !> @return The advecting wind for that mesh and specified direction
  function get_directional_advecting_wind(self, mesh_id, direction) result(advecting_wind)

    use transport_enumerated_types_mod, only: direction_h,          &
                                              direction_v,          &
                                              direction_3d

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: direction
    type(field_type),                      pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'directional_advecting_wind'

    select case (direction)
    case (direction_3d)
      advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_h)
      advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_v)
      advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case default
      call log_event('get_directional_advecting_wind: Direction not recognised', LOG_LEVEL_ERROR)
    end select

    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_directional_advecting_wind

   !> @brief Returns a pointer to the horizontal advecting wind
   !> @param[in] mesh_id The ID of the mesh to get the object for
   !> @return The horizontal part of the advecting wind
  function get_horizontal_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'horizontal_advecting_wind'
    advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_horizontal_advecting_wind

  !> @brief Returns a pointer to the vertical advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The vertical part of the advecting wind
  function get_vertical_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'vertical_advecting_wind'
    advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_vertical_advecting_wind

  !> @brief Returns a pointer to det(J) at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return det(J) evaluated at W2 DoFs
  function get_detj_at_w2_transport(self, mesh_id) result(detj_at_w2_transport)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: detj_at_w2_transport
    character(str_def)                                :: field_name

    field_name = 'detj_at_w2_transport'
    detj_at_w2_transport => self%detj_at_w2_transport(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(detj_at_w2_transport, field_name, mesh_id)

  end function get_detj_at_w2_transport

  !> @brief Returns a pointer to the x departure points at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the x direction at W2 DoFs
  function get_departure_points_x_w2(self, mesh_id) result(departure_points_x_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: departure_points_x_w2
    character(str_def)                                :: field_name

    field_name = 'departure_points_x_w2'
    departure_points_x_w2 => self%departure_points_x_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_x_w2, field_name, mesh_id)

  end function get_departure_points_x_w2

  !> @brief Returns a pointer to the y departure points at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the y direction at W2 DoFs
  function get_departure_points_y_w2(self, mesh_id) result(departure_points_y_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: departure_points_y_w2
    character(str_def)                                :: field_name

    field_name = 'departure_points_y_w2'
    departure_points_y_w2 => self%departure_points_y_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_y_w2, field_name, mesh_id)

  end function get_departure_points_y_w2

  !> @brief Returns a pointer to the z departure points at W2 DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The departure points for the z direction at W2 DoFs
  function get_departure_points_z_w2(self, mesh_id) result(departure_points_z_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: departure_points_z_w2
    character(str_def)                                :: field_name

    field_name = 'get_departure_points_z_w2'
    departure_points_z_w2 => self%departure_points_z_w2(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(departure_points_z_w2, field_name, mesh_id)

  end function get_departure_points_z_w2

  !> @brief Returns a pointer to the divergence factor
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The divergence factor field
  function get_div_factor(self, mesh_id) result(div_factor)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: div_factor
    character(str_def)                                :: field_name

    field_name = 'div_factor'
    div_factor => self%div_factor(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(div_factor, field_name, mesh_id)

  end function get_div_factor

  !> @brief Returns number of split transport steps for the dry density
  !> @return The number of split transport steps for the dry density
  function get_num_dry_steps(self) result(num_dry_steps)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: num_dry_steps

    num_dry_steps = self%num_dry_steps

  end function get_num_dry_steps

  !> @brief Returns a pointer stored field at the start of the time step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The field at the start of the time step
  function get_field_n(self, mesh_id) result(field_n)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(field_type),                      pointer    :: field_n

    field_n => self%field_n(self%idx_from_mesh_id(mesh_id))

  end function get_field_n

  !> @brief Returns a pointer to the dry density field at start of transport step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The step from which to return the density
  !> @return The dry density field before its transport
  function get_rho_d_n(self, mesh_id, step) result(rho_d_n)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(field_type),                      pointer    :: rho_d_n
    character(str_def)                                :: field_name

    field_name = 'rho_d_n'
    rho_d_n => self%rho_d_n(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d_n, field_name, mesh_id)

  end function get_rho_d_n

  !> @brief Returns a pointer to the dry density field after transport
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_rho_d_np1(self, mesh_id, step) result(rho_d_np1)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(field_type),                      pointer    :: rho_d_np1
    character(str_def)                                :: field_name

    field_name = 'rho_d_np1'
    rho_d_np1 => self%rho_d_np1(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d_np1, field_name, mesh_id)

  end function get_rho_d_np1

  !> @brief Returns a pointer to a flux increment for a particular step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the flux increment
  !> @return The flux increment
  function get_flux_inc(self, mesh_id, step) result(flux_inc)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(field_type),                      pointer    :: flux_inc

    flux_inc => self%flux_inc(self%idx_from_mesh_id(mesh_id), step)

  end function get_flux_inc

  !> @brief Returns a pointer to the flux from transporting dry density
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density flux
  function get_dry_flux(self, mesh_id, step) result(dry_flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(field_type),                      pointer    :: dry_flux
    character(str_def)                                :: field_name

    field_name = 'dry_flux'
    dry_flux => self%dry_flux(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_flux, field_name, mesh_id)

  end function get_dry_flux

  !> @brief Returns a pointer to the horizontal flux from transporting dry density
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The horizontal dry density flux
  function get_hori_dry_flux(self, mesh_id, step) result(horizontal_flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(field_type),                      pointer    :: horizontal_flux
    character(str_def)                                :: field_name

    field_name = 'horizontal_dry_flux'
    horizontal_flux => self%hori_dry_flux(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(horizontal_flux, field_name, mesh_id)

  end function get_hori_dry_flux

  !> @brief Returns a pointer to the vertical flux from transporting dry density
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The vertical dry density flux
  function get_vert_dry_flux(self, mesh_id, step) result(vertical_flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(field_type),                      pointer    :: vertical_flux
    character(str_def)                                :: field_name

    field_name = 'vertical_dry_flux'
    vertical_flux => self%vert_dry_flux(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(vertical_flux, field_name, mesh_id)

  end function get_vert_dry_flux

  !> @brief Returns the counter of tracer transport steps
  !> @return The tracer step counter
  function get_tracer_step_ctr(self) result(tracer_step_ctr)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def) :: tracer_step_ctr

    tracer_step_ctr = self%tracer_step_ctr

  end function get_tracer_step_ctr

  !> @brief Increments the counter of tracer transport steps
  subroutine inc_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = self%tracer_step_ctr + 1

  end subroutine inc_tracer_step_ctr

  !> @brief Resets the counter of tracer transport steps
  subroutine reset_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = 1

  end subroutine reset_tracer_step_ctr

  !> @brief Computes the total number of rho transport steps
  !> @result    num_dry_steps    Total number of transport steps for rho
  function compute_num_dry_steps(self) result(num_dry_steps)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name
    use transport_enumerated_types_mod, only: splitting_strang_hvh,   &
                                              splitting_strang_vhv,   &
                                              splitting_hv,           &
                                              splitting_vh,           &
                                              splitting_none

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    ! Internal variables
    integer(kind=i_def) :: num_dry_steps
    integer(kind=i_def) :: config, dry_config
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up consistent tracer transport ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh, splitting_strang_vhv)
      num_dry_steps = 3
    case(splitting_hv, splitting_vh)
      num_dry_steps = 2
    case(splitting_none)
      num_dry_steps = 1
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented with ' // &
        'consistent tracer transport'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function compute_num_dry_steps

  !> @brief Returns the function space for the direction of the dry step
  !> @param[in] step  Index of the dry density splitting step
  !> @result    fs    Enumerator for the W2 function space
  function direction_w2_fs(self, step) result(fs)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name
    use transport_enumerated_types_mod, only: splitting_strang_hvh,   &
                                              splitting_strang_vhv,   &
                                              splitting_hv,           &
                                              splitting_vh,           &
                                              splitting_none

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: step
    ! Internal variables
    integer(kind=i_def) :: config, dry_config, fs
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up compute dry steps ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      end select
    case(splitting_strang_vhv)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      end select
    case(splitting_hv)
      select case(step)
      case(1_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      end select
    case(splitting_vh)
      select case(step)
      case(1_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      end select
    case(splitting_none)
      fs = W2
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function direction_w2_fs

end module transport_runtime_alg_mod
