!-----------------------------------------------------------------------------
! (c) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief   Algorithms for calculating departure points used by FFSL/SL transport.
!> @details Departure points for the cell edges are calculated using departure
!!          winds. These are computed by dividing the computational winds by
!!          Det(J) at cell edges. These algorithms compute the departure points,
!!          (in 3D, in the horizontal, or in the vertical)
!!          and the choice of Det(J) calculation (upwinded or averaged).
!!          This is used by the flux form semi-Lagrangian (FFSL) and the
!!          vertical semi-Lagrangian (SL) transport schemes.

module calc_dep_pts_alg_mod

  use constants_mod,                     only: i_def, r_tran
  use io_config_mod,                     only: subroutine_timers
  use timer_mod,                         only: timer
  use r_tran_field_mod,                  only: r_tran_field_type
  use field_mod,                         only: field_type
  use calc_upwind_detj_at_w2_kernel_mod, only: calc_upwind_detj_at_w2_kernel_type
  use vertical_deppt_kernel_mod,         only: vertical_deppt_kernel_type
  use vertical_uniform_deppt_kernel_mod, only: vertical_uniform_deppt_kernel_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use fs_continuity_mod,                 only: W3, W2
  use finite_element_config_mod,         only: element_order
  use eulerian_deppt_kernel_mod,         only: eulerian_deppt_kernel_type
  use midpoint_deppt_kernel_mod,         only: midpoint_deppt_kernel_type
  use trapezoidal_deppt_kernel_mod,      only: trapezoidal_deppt_kernel_type
  use departure_points_config_mod,       only: method,                  &
                                               method_euler,            &
                                               method_timeaverage,      &
                                               method_trapezoidal,      &
                                               method_midpoint,         &
                                               n_dep_pt_iterations,     &
                                               vertical_method,         &
                                               horizontal_limit,        &
                                               horizontal_limit_cap,    &
                                               departure_grid_physical, &
                                               departure_grid_uniform,  &
                                               departure_grid
  use subgrid_config_mod,                only: dep_pt_stencil_extent,   &
                                               calculate_detj,          &
                                               calculate_detj_averaged, &
                                               calculate_detj_upwind
  use fem_constants_mod,                 only: get_detj_at_w2,          &
                                               get_detj_at_w2_above,    &
                                               get_detj_at_w2_below
  use geometric_constants_mod,           only: get_height
  use log_mod,                           only: log_event,               &
                                               LOG_LEVEL_INFO,          &
                                               LOG_LEVEL_ERROR
  use mesh_mod,                          only: mesh_type
  use psykal_lite_mod,                   only: invoke_copy_to_rtran

  implicit none

  private
  public :: calc_hori_dep_pts
  public :: calc_vert_dep_pts
  public :: select_detj_at_w2

contains


  !===========================================================================!
  !> @brief   An algorithm for calculating horizontal departure points.
  !> @details The algorithm calculates the departure points for the cell edges.
  !!          The departure points are calculated in the x and y direction
  !!          separately as 1D calculations.
  !!          This is used by the dimensionally-split swept-area approach of
  !!          the flux form semi-Lagrangian (FFSL) scheme.
  !!
  !> @param[in,out] dep_pts_x         Departure points in x direction, a W2h field
  !> @param[in,out] dep_pts_y         Departure points in y direction, a W2h field
  !> @param[in]     wind_n            Wind field at timestep n
  !> @param[in]     wind_np1          Wind field at timestep n+1
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     dt                The model timestep length
  subroutine calc_hori_dep_pts( dep_pts_x,        &
                                dep_pts_y,        &
                                wind_n,           &
                                wind_np1,         &
                                detj_at_w2,       &
                                dt )

    implicit none

    type( r_tran_field_type ), intent(inout) :: dep_pts_x
    type( r_tran_field_type ), intent(inout) :: dep_pts_y
    type( r_tran_field_type ), intent(in)    :: wind_n
    type( r_tran_field_type ), intent(in)    :: wind_np1
    type( r_tran_field_type ), intent(in)    :: detj_at_w2
    real( kind=r_tran ),       intent(in)    :: dt

    type( r_tran_field_type ) :: wind_adv
    type( r_tran_field_type ) :: dep_wind
    type( r_tran_field_type ) :: dep_wind_n
    type( r_tran_field_type ) :: dep_wind_np1

    type( function_space_type ), pointer :: w2_fs => null()
    type(mesh_type), pointer ::  mesh => null()
    real( kind=r_tran ) :: max_hori_dep, min_hori_dep

    if ( subroutine_timers ) call timer( 'calc_hori_dep_pts' )

    ! Get function space and mesh
    w2_fs => wind_n%get_function_space()
    mesh  => wind_n%get_mesh()

    call wind_adv%initialise( vector_space = w2_fs )
    call dep_wind%initialise( vector_space = w2_fs )
    call dep_wind_n%initialise( vector_space = w2_fs )
    call dep_wind_np1%initialise( vector_space = w2_fs )

    ! Initialise variables as zero
    call invoke( setval_c( dep_pts_x, 0.0_r_tran ),    &
                 setval_c( dep_pts_y, 0.0_r_tran ),    &
                 setval_c( wind_adv, 0.0_r_tran ),     &
                 setval_c( dep_wind_n, 0.0_r_tran ),   &
                 setval_c( dep_wind_np1, 0.0_r_tran ), &
                 setval_c( dep_wind, 0.0_r_tran )   )

    ! Calculate the departure points based on Eulerian or Lagrangian approach
    select case ( method )

      case ( method_trapezoidal )
        call invoke( X_divideby_Y(dep_wind_n, wind_n, detj_at_w2),                     &
                     X_divideby_Y(dep_wind_np1, wind_np1, detj_at_w2),                 &
                     trapezoidal_deppt_kernel_type( dep_pts_x, dep_pts_y,              &
                                                    dep_wind_n, dep_pt_stencil_extent, &
                                                    dep_wind_np1, n_dep_pt_iterations, dt ) )

      case ( method_midpoint )
        call invoke( X_divideby_Y(dep_wind_n, wind_n, detj_at_w2),                  &
                     midpoint_deppt_kernel_type( dep_pts_x, dep_pts_y,              &
                                                 dep_wind_n, dep_pt_stencil_extent, &
                                                 n_dep_pt_iterations, dt ) )

      case ( method_euler, method_timeaverage)
        ! Set the advecting wind based on the departure point method
        if ( method == method_euler ) then
          call invoke( setval_X(wind_adv, wind_np1) )
        else
          call invoke( aX_plus_bY(wind_adv, 0.5_r_tran, wind_n,0.5_r_tran, wind_np1) )
        end if
        call invoke( X_divideby_Y(dep_wind, wind_adv, detj_at_w2),     &
                     eulerian_deppt_kernel_type( dep_pts_x, dep_pts_y, &
                                                 dep_wind, dt ) )

        if ( horizontal_limit == horizontal_limit_cap) then
          ! Cap the horizontal departure points to lie within the stencil extent
          max_hori_dep = real(dep_pt_stencil_extent, r_tran)
          min_hori_dep = -max_hori_dep
          call invoke( inc_max_aX(min_hori_dep, dep_pts_x), &
                       inc_min_aX(max_hori_dep, dep_pts_x), &
                       inc_max_aX(min_hori_dep, dep_pts_y), &
                       inc_min_aX(max_hori_dep, dep_pts_y) )
        end if

      case default
        call log_event( "Gungho: Invalid departure point method", LOG_LEVEL_ERROR )

    end select

    call dep_pts_x%log_minmax( LOG_LEVEL_INFO, 'dep_pts_x' )
    call dep_pts_y%log_minmax( LOG_LEVEL_INFO, 'dep_pts_y' )

    nullify( w2_fs, mesh )

    if ( subroutine_timers ) call timer( 'calc_hori_dep_pts' )

  end subroutine calc_hori_dep_pts


  !===========================================================================!
  !> @brief   An algorithm for calculating vertical departure points.
  !> @details The algorithm calculates the departure points for the cell edges.
  !!          The departure points are calculated in the z direction.
  !!          This is used by the dimensionally-split swept-area approach of
  !!          the flux form semi-Lagrangian (FFSL) scheme as well as the
  !!          vertical semi-Lagrangian and SLICE schemes.
  !!
  !> @param[in,out] dep_pts_z         Departure points in z direction, a W2v field
  !> @param[in,out] cfl               Vertical CFL from departure points
  !> @param[in]     wind_n            Wind field at timestep n
  !> @param[in]     wind_np1          Wind field at timestep n+1
  !> @param[in]     detj_at_w2        Det(J) at W2 dofs
  !> @param[in]     dt                The model timestep length
  subroutine calc_vert_dep_pts( dep_pts_z,        &
                                cfl,              &
                                wind_n,           &
                                wind_np1,         &
                                detj_at_w2,       &
                                dt )

    implicit none

    type( r_tran_field_type ), intent(inout) :: dep_pts_z
    type( r_tran_field_type ), intent(inout) :: cfl
    type( r_tran_field_type ), intent(in)    :: wind_n
    type( r_tran_field_type ), intent(in)    :: wind_np1
    type( r_tran_field_type ), intent(in)    :: detj_at_w2
    real( kind=r_tran ),       intent(in)    :: dt

    type( r_tran_field_type ) :: departure_wind_n, departure_wind_np1

    type( field_type ), pointer :: height_w2_rdef => null()
    type( r_tran_field_type )   :: height_w2

    type( function_space_type ), pointer :: w2_fs => null()
    type( function_space_type ), pointer :: w3_fs => null()

    type( mesh_type ), pointer ::  mesh => null()

    w2_fs => wind_n%get_function_space()
    mesh  => wind_n%get_mesh()
    w3_fs => function_space_collection%get_fs( mesh, element_order, W3 )

    height_w2_rdef => get_height(W2, mesh%get_id())
    call height_w2%initialise(vector_space = height_w2_rdef%get_function_space() )
    call invoke_copy_to_rtran(height_w2, height_w2_rdef )


    call departure_wind_n%initialise( vector_space = w2_fs )
    call departure_wind_np1%initialise( vector_space = w2_fs )

    if ( subroutine_timers ) call timer( 'calc_vert_dep_pts' )

    ! Calculate vertical departure points and departure winds.
    ! Currently the trapezoidal method has been choosen for calculating departure
    ! points in the vertical.
    ! *_n and *_np1 denotes fields at timestep n and timestep n+1 with density known
    ! at timestep n.
    call invoke( setval_c( dep_pts_z, 0.0_r_tran ),                       &
                 setval_c( cfl, 0.0_r_tran ),                             &
                 setval_c( departure_wind_n, 0.0_r_tran ),                &
                 setval_c( departure_wind_np1, 0.0_r_tran ),              &
                 X_divideby_Y(departure_wind_n, wind_n, detj_at_w2),      &
                 X_divideby_Y(departure_wind_np1, wind_np1, detj_at_w2) )

    select case(departure_grid)

    case(departure_grid_uniform)
      ! Assume uniform grid for departure point calculation
      call invoke( vertical_uniform_deppt_kernel_type( dep_pts_z,                  &
                                                       cfl,                        &
                                                       departure_wind_n,           &
                                                       departure_wind_np1,         &
                                                       n_dep_pt_iterations,        &
                                                       vertical_method, dt )  )

    case default
      ! Use physical grid
      call invoke( vertical_deppt_kernel_type( dep_pts_z,                  &
                                               cfl,                        &
                                               departure_wind_n,           &
                                               departure_wind_np1,         &
                                               height_w2,                  &
                                               n_dep_pt_iterations,        &
                                               vertical_method, dt )  )
    end select

    call dep_pts_z%log_minmax( LOG_LEVEL_INFO, 'dep_pts_z' )

    nullify( w2_fs, mesh )

    if ( subroutine_timers ) call timer( 'calc_vert_dep_pts' )

  end subroutine calc_vert_dep_pts


  !===========================================================================!
  !> @brief   Select either averaged or upwind Det(J) at vertical W2 dofs.
  !> @details Det(J) at vertical W2 dofs can be calculated using either an
  !!          average from the cells either side or from the upwind cell.
  !!
  !> @param[in]     advecting_wind  Advecting wind to determine upwind direction
  !> @param[in,out] detj_at_w2      Det(J) at W2 dofs
  subroutine select_detj_at_w2( advecting_wind, &
                                detj_at_w2 )

    use psykal_lite_mod,               only: invoke_copy_rtran_to_rdef, &
                                             invoke_copy_to_rtran
    implicit none

    type( r_tran_field_type ), intent(in)    :: advecting_wind
    type( r_tran_field_type ), intent(inout) :: detj_at_w2

    ! Det(J) at W2 fields
    type( field_type ), pointer :: detj_at_w2_ave_rdef   => null()
    type( field_type ), pointer :: detj_at_w2_above_rdef  => null()
    type( field_type ), pointer :: detj_at_w2_below_rdef  => null()

    ! r_tran detj fields
    type( r_tran_field_type ) :: detj_at_w2_above
    type( r_tran_field_type ) :: detj_at_w2_below

    ! Mesh ID variable
    integer( kind=i_def ) ::  mesh_id

    ! Get Mesh ID
    mesh_id = advecting_wind%get_mesh_id()

    ! Get Det(J) at W2 using averaged Det(J)
    detj_at_w2_ave_rdef  => get_detj_at_w2(mesh_id)

    select case (calculate_detj)

      case (calculate_detj_averaged)
        ! Set detj_at_w2 to use average Det(J) of neighbouring cells
        call invoke_copy_to_rtran(detj_at_w2, detj_at_w2_ave_rdef )

      case (calculate_detj_upwind)
        ! Get Det(J) at W2 from cells above and below respectively
        detj_at_w2_above_rdef => get_detj_at_w2_above(mesh_id)
        detj_at_w2_below_rdef  => get_detj_at_w2_below(mesh_id)

        call detj_at_w2_above%initialise(vector_space = detj_at_w2_above_rdef%get_function_space() )
        call detj_at_w2_below%initialise(vector_space = detj_at_w2_below_rdef%get_function_space() )
        call invoke_copy_to_rtran(detj_at_w2_above, detj_at_w2_above_rdef )
        call invoke_copy_to_rtran(detj_at_w2_below, detj_at_w2_below_rdef )

        ! Set detj_at_w2 to use average Det(J) for horizontal dofs
        call invoke_copy_to_rtran(detj_at_w2, detj_at_w2_ave_rdef )

        ! Update vertical parts of detj_at_w2 to use upwind Det(J)
        call invoke( calc_upwind_detj_at_w2_kernel_type(detj_at_w2 ,      &
                                                        detj_at_w2_above, &
                                                        detj_at_w2_below, &
                                                        advecting_wind) )

      case default
          call log_event( "Gungho: Invalid Det(J) calculation method", LOG_LEVEL_ERROR )
    end select

    nullify( detj_at_w2_above_rdef, detj_at_w2_below_rdef, detj_at_w2_ave_rdef )

  end subroutine select_detj_at_w2

end module calc_dep_pts_alg_mod
