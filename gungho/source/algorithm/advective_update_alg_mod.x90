!-----------------------------------------------------------------------------
! (c) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Compute the advective update A of a variable f by a wind U: A = U.grad(f)

module advective_update_alg_mod

  use constants_mod,                  only: r_def, i_def
  use runtime_constants_mod,          only: get_coordinates_xyz,                &
                                            get_mass_matrix_diagonal,       &
                                            get_inverse_lumped_mass_matrix, &
                                            wt_id
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order, &
                                            nqp_exact
  use function_space_mod,             only: function_space_type
  use psykal_lite_mol_mod,            only: psykal_lite_mol_adv_init,       &
                                            psykal_lite_mol_adv_final,      &
                                            invoke_poly1d_adv_recon,        &
                                            invoke_poly1d_advective_coeffs, &
                                            invoke_poly2d_adv_recon,        &
                                            invoke_poly2d_advective_coeffs, &
                                            invoke_poly1d_vert_adv_coeffs,  &
                                            invoke_poly1d_vert_adv
  use quadrature_rule_gauss_lobatto_mod, &
                                      only: quadrature_rule_gauss_lobatto_type
  use quadrature_rule_gaussian_mod,   only: quadrature_rule_gaussian_type
  use quadrature_xyoz_mod,            only: quadrature_xyoz_type
  use quadrature_face_mod,            only: quadrature_face_type
  use quadrature_edge_mod,            only: quadrature_edge_type
  use rtheta_kernel_mod,              only: rtheta_kernel_type
  use rtheta_bd_kernel_mod,           only: rtheta_bd_kernel_type
  use transport_config_mod,           only: operators,            &
                                            fv_advective_order,   &
                                            operators_fv,         &
                                            operators_fem,        &
                                            oned_reconstruction,  &
                                            enforce_monotonicity, &
                                            consistent_metric
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_INFO
  use io_config_mod,                  only: subroutine_timers
  use timer_mod,                      only: timer
  use poly_advective_kernel_mod,      only: poly_advective_kernel_type

  implicit none

  private

  ! Interpolation coefficients needed for nonuniform fv operators
  ! These are made puplic to be used by other transport modules
  integer(i_def), public                  :: advective_stencil_extent, &
                                             advective2d_stencil_size
  type( field_type ), public, allocatable :: adv_coeffs(:,:),  &
                                             vert_adv_coeffs(:,:)
  type( field_type ), public              :: advective_av
  type( field_type ), public              :: advective_av_chi3, &
                                             wt_metrics, chi3_at_wt
  integer(i_def), public                  :: nfaces_re_h, nfaces_re_v


  public :: advective_update_alg_init
  public :: advective_update_alg_final
  public :: advective_update_alg

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> @brief Initialises the system for running the advection algorithm.
  !>
  !> @details Initialises system required for FV transport.
  !>          FV aspects currently only support lowest order elements.
  !>
  !> @param[in] mesh_id Identity of the mesh to create all fields on
  !>
  subroutine advective_update_alg_init( mesh_id )

    use fs_continuity_mod,                 only: W1, Wtheta
    use function_space_collection_mod,     only: function_space_collection
    use multiplicity_kernel_mod,           only: multiplicity_kernel_type
    use sample_field_kernel_mod,           only: sample_field_kernel_type
    use reference_element_mod,             only: reference_element_type
    use mesh_mod,                          only: mesh_type

    implicit none

    integer(i_def),  intent(in) :: mesh_id

    integer(i_def)              :: advective_stencil_size, &
                                   direction, polynomial
    type( field_type ), pointer :: chi_xyz(:) => null()
    type( field_type ), pointer :: md_wt => null()

    type( quadrature_rule_gaussian_type )      :: gaussian_quadrature
    type( quadrature_rule_gauss_lobatto_type ) :: gauss_lobatto_quadrature

    type( quadrature_xyoz_type )           :: qr
    type( quadrature_edge_type )           :: qre
    type( function_space_type ),   pointer :: wt_fs => null()
    type(function_space_type),     pointer :: w1_fs => null()
    type( field_type )                     :: wt_field
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type),               pointer :: mesh => null()
    integer(i_def)                         :: edge_quad_order
    integer(i_def)                         :: nqp_xy, nqp_z, nqp_xyz

    if ( operators == operators_fv ) then
      ! This setup is only needed for FV methods
      if ( element_order == 0 ) then

        ! Compute stencil extents
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
        !======================================================================!
        ! Compute stencil for nonuniform polynomial fit
        ! Initialise PSy layer arrays (this will not be needed when
        ! multi-dimensional field arrays are supported)
        ! This needs some temporary fields for computing undf in the PSy layer
        wt_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )
        call wt_field%initialise( vector_space = wt_fs )

        ! Get topology information from the reference element
        mesh              => wt_field%get_mesh()
        reference_element => mesh%get_reference_element()
        ! Number of horizontal neighbours from the reference element
        nfaces_re_h = reference_element%get_number_horizontal_faces()
        ! Number of vertical neighbours from the reference element
        nfaces_re_v = reference_element%get_number_vertical_faces()
        if ( oned_reconstruction ) then
          advective_stencil_size = fv_advective_order + 1
        else
          advective2d_stencil_size = 1
          do polynomial = 1, fv_advective_order
            if ( mod(polynomial, 2) == 0 ) then
              advective2d_stencil_size = advective2d_stencil_size + nfaces_re_h
            else
              advective2d_stencil_size = advective2d_stencil_size + nfaces_re_h*polynomial
            end if
          end do
          advective_stencil_size = advective2d_stencil_size
        end if
        allocate( adv_coeffs(advective_stencil_size, nfaces_re_h) )
        do direction = 1, nfaces_re_h
          do polynomial = 1,advective_stencil_size
              call adv_coeffs(polynomial, direction)%initialise( vector_space = wt_fs )
          end do
        end do
        call psykal_lite_mol_adv_init(wt_field, fv_advective_order,        &
                                      advective_stencil_size, nfaces_re_h, &
                                      nfaces_re_v)

        chi_xyz => get_coordinates_xyz()
        nqp_xyz = fv_advective_order+1
        if ( oned_reconstruction ) then
          edge_quad_order = 1
        else
          edge_quad_order = fv_advective_order+1
        end if

        ! Compute advective coefficients
        call log_event( "Gungho: computing horizontal advective coeffs", LOG_LEVEL_INFO )
        ! Quadrature rule which has enough points to exactly integrate
        ! fv_advective_order polynomials and is odd order horizontaly and has
        ! 2 vertical points such that it gives points on the vertical faces
        nqp_xy = fv_advective_order+3
        nqp_z  = 2
        qr = quadrature_xyoz_type(nqp_xy, nqp_xy, nqp_z, &
                                  gauss_lobatto_quadrature)
        ! Edge based quadrature rule on horizontal edges
        nqp_xyz = edge_quad_order
        qre = quadrature_edge_type(nqp_xyz, .true., .false.,           &
                                   reference_element, gaussian_quadrature)

        md_wt => get_mass_matrix_diagonal(wt_id)
        w1_fs => function_space_collection%get_fs( mesh_id, element_order, W1 )
        call advective_av%initialise( vector_space =  w1_fs )
        if ( oned_reconstruction ) then
          call invoke_poly1d_advective_coeffs( adv_coeffs, md_wt, chi_xyz, qr, qre,  &
                                               fv_advective_order,                   &
                                               advective_stencil_extent, nfaces_re_h )
        else
          call invoke_poly2d_advective_coeffs( adv_coeffs, md_wt, chi_xyz, qr, qre, &
                                               fv_advective_order,                  &
                                               advective2d_stencil_size,            &
                                               nfaces_re_h )
        end if
        ! Vertical advective coeffs
        call log_event( "Gungho: computing vertical advective coeffs", LOG_LEVEL_INFO )
        allocate( vert_adv_coeffs(fv_advective_order+1, nfaces_re_v) )
        do direction = 1, nfaces_re_v
          do polynomial = 1, fv_advective_order+1
            call vert_adv_coeffs(polynomial, direction)%initialise( vector_space = wt_fs )
          end do
        end do
        call invoke_poly1d_vert_adv_coeffs( vert_adv_coeffs, chi_xyz, &
                                            fv_advective_order, nfaces_re_v )
        if ( consistent_metric ) then
          call advective_av_chi3%initialise(vector_space = w1_fs )
          call wt_metrics%initialise(vector_space = wt_fs )
          call chi3_at_wt%initialise(vector_space = wt_fs )
          call invoke( setval_c(wt_field,   0.0_r_def),       &
                       setval_c(chi3_at_wt, 0.0_r_def),       &
                       multiplicity_kernel_type(wt_field),    &
                       sample_field_kernel_type(chi3_at_wt, wt_field, chi_xyz(3)) )
        end if
        !======================================================================!
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high &
                         order elements", LOG_LEVEL_ERROR )
      end if
    end if

    nullify( chi_xyz, md_wt, wt_fs, w1_fs, reference_element, mesh )

  end subroutine advective_update_alg_init

  !=============================================================================
  !> @details Finalises allocatable arrays and calls finalising routines for
  !>          kernels that this algorithm initialised.
  subroutine advective_update_alg_final()

    implicit none

    if ( operators == operators_fv .and. &
         element_order == 0 ) then
      deallocate( adv_coeffs,  vert_adv_coeffs )
      ! Deallocate PSy layer arrays (this will not be needed when
      ! multi-dimensional field arrays are supported)
      call psykal_lite_mol_adv_final()
    end if

  end subroutine advective_update_alg_final

  !=============================================================================
  !> @brief Compute advective update wind.grad(adv_field) using desired spatial
  !>        reconstruction. Options for this are either FE or FV reconstructions.
  !>        A monotonicity filter is also applied if enforce_monotonicity=.true.
  !> @param[in,out] rhs Advective increment
  !> @param[in]    adv_field Field to advect
  !> @param[in]    wind Advecting wind field
  !> @param[in]    dt timestep
  subroutine advective_update_alg(rhs, adv_field, wind, dt)

    use consistent_wind_kernel_mod,  only: consistent_wind_kernel_type
    use reference_element_mod,       only: reference_element_type
    use mesh_mod,                    only: mesh_type
    use monotonic_update_kernel_mod, only: monotonic_update_kernel_type

    implicit none

    type(field_type), intent(in)           :: adv_field, wind
    type(field_type), intent(inout)        :: rhs
    real(kind=r_def), intent(in)           :: dt
    type(quadrature_xyoz_type)             :: qr
    type(quadrature_face_type)             :: qrf
    type(quadrature_rule_gaussian_type)    :: quadrature_rule
    type(field_type), pointer              :: chi_xyz(:) => null()
    type(field_type), pointer              :: mt_lumped_inv => null()
    class(reference_element_type), pointer :: reference_element =>null()
    type(mesh_type),               pointer :: mesh => null()
    integer(kind=i_def)                    :: mono_stencil
    type(field_type)                       :: consistent_wind, u_grad_f

    mt_lumped_inv => get_inverse_lumped_mass_matrix(wt_id)
    call u_grad_f%initialise( adv_field%get_function_space() )

    select case(operators)

    case default
      call log_event( "Gungho: Unrecognized option for operator.", LOG_LEVEL_ERROR )

    case(operators_fv)
      call invoke( setval_c(advective_av, 0.0_r_def) )
      if ( consistent_metric )  call invoke( setval_c(advective_av_chi3, 0.0_r_def) )
      if ( oned_reconstruction ) then
       ! Use 1d reconstruction
        call invoke_poly1d_adv_recon( advective_av, wind, adv_field, adv_coeffs, &
                                      fv_advective_order, advective_stencil_extent, nfaces_re_h )
        ! Horizontal advection of metric terms
        if ( consistent_metric ) &
          call invoke_poly1d_adv_recon( advective_av_chi3, wind, chi3_at_wt, adv_coeffs, &
                                        fv_advective_order, advective_stencil_extent, nfaces_re_h )
      else
       ! Use 2d reconstruction
        call invoke_poly2d_adv_recon( advective_av, wind, adv_field, adv_coeffs,       &
                                      fv_advective_order, advective2d_stencil_size,    &
                                      nfaces_re_h )
        ! Horizontal advection of metric terms
        if ( consistent_metric ) &
          call invoke_poly2d_adv_recon( advective_av_chi3, wind, chi3_at_wt, adv_coeffs, &
                                        fv_advective_order, advective2d_stencil_size,    &
                                        nfaces_re_h )

      end if
      ! Compute horizontal advective update
      call invoke( poly_advective_kernel_type(u_grad_f, wind, advective_av) )
      call wind%copy_field(consistent_wind)
      if ( consistent_metric ) then
        chi_xyz => get_coordinates_xyz()
        call invoke( poly_advective_kernel_type(wt_metrics, wind, advective_av_chi3), &
        ! Modify advecting wind
                     consistent_wind_kernel_type(consistent_wind, wind, wt_metrics, chi_xyz) )
      end if
      ! Compute vertical component of advective update
      call invoke_poly1d_vert_adv( u_grad_f, consistent_wind, adv_field, &
                                   vert_adv_coeffs, fv_advective_order, nfaces_re_v )

    case(operators_fem)
      ! Use project u.grad(adv_field) into the adv_field function space
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)
      mesh              => rhs%get_mesh()
      reference_element => mesh%get_reference_element()
      ! Quadrature rule on lateral faces only
      qrf = quadrature_face_type(nqp_exact, .true., .false., &
                                 reference_element, quadrature_rule)
      call invoke( setval_c(u_grad_f, 0.0_r_def),                     &
                   rtheta_kernel_type(u_grad_f, adv_field, wind, qr), &
                   rtheta_bd_kernel_type(u_grad_f, adv_field,         &
                                         1, wind, 1, qrf) )
    end select

    ! Apply monotonicity (as if this is a full timestep)
    if ( enforce_monotonicity ) then
      if ( operators == operators_fem ) then
        mono_stencil = 1
      else
        mono_stencil = fv_advective_order/2
      end if
      call invoke( monotonic_update_kernel_type(u_grad_f, adv_field,         &
                                                mono_stencil, mt_lumped_inv, &
                                                dt, fv_advective_order) )
    end if

    call invoke( X_times_Y(rhs, u_grad_f, mt_lumped_inv) )

    nullify( chi_xyz, mt_lumped_inv, reference_element, mesh )

  end subroutine advective_update_alg

end module advective_update_alg_mod
