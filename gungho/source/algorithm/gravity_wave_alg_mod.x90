!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief A two time-level iterative time-discretisation of the linear 
!>       gravity wave equations
module gravity_wave_alg_mod

  use constants_mod,                  only: i_def,r_def
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO,    &
                                            LOG_LEVEL_TRACE

  ! Configuration options
  use finite_element_config_mod,      only: element_order
  use timestepping_config_mod,        only: dt, alpha 
  use derived_config_mod,             only: bundle_size
  use runtime_constants_mod,          only: get_div, &
                                            get_mass_matrix, &
                                            w3inv_id
  use initial_temperature_config_mod, only: bvf_square  
  use gw_miniapp_constants_config_mod,only: cs_square

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                only: invoke_scale_field_data
  use field_bundle_mod,               only: clone_bundle, & 
                                            copy_bundle  

  ! Derived Types
  use field_mod,                      only: field_type
  use function_space_mod,             only: function_space_type
  use operator_mod,                   only: operator_type

  ! Algorithms
  use gw_si_solver_alg_mod,           only: gw_si_solver_alg, &
                                            gw_si_solver_init

  use field_indices_mod,              only: igw_u, igw_p, igw_b

  use output_config_mod,              only: subroutine_timers 
  use timer_mod,                      only: timer

  implicit none

  private

  ! 'State' items private to the algorithm that need to be 
  !  created once but used every step
  type( field_type ), allocatable :: state(:), state_n(:)
  type( field_type ), allocatable :: rhs_n(:) 
  type( field_type )              :: rhs_p
  type(operator_type)             :: Q

  public :: gravity_wave_alg_init
  public :: gravity_wave_alg_step

contains
!=============================================================================!
  !> @details Initialisation procedure for the timestepping algorithm
  !>          Initialises various internal fields
  !> @param[in]    mesh Mesh object on which the model runs
  !> @param[inout] wind  The 3D wind field
  !> @param[inout] pressure The pressure field
  !> @param[inout] buoyancy The buoyancy field
  subroutine gravity_wave_alg_init( mesh_id, wind, pressure, buoyancy)
    use quadrature_mod,                only: quadrature_type, GAUSSIAN
    use compute_q_operator_kernel_mod, only: compute_q_operator_type, &
                                             compute_q_operator_init
    use mesh_mod,                      only: mesh_type
    use mesh_collection_mod,           only: mesh_collection

    implicit none

    ! Mesh
    integer(i_def), intent(in) :: mesh_id 

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: wind, pressure, buoyancy

    type(function_space_type), pointer :: u_fs => null()
    type(function_space_type), pointer :: p_fs => null()
    type(function_space_type), pointer :: b_fs => null()
    type(quadrature_type)              :: qr
    real(kind=r_def), allocatable      :: dz(:)
    type(mesh_type),           pointer :: mesh => null()
    integer(kind=i_def)                :: nlayers

    !=== Allocate internal state field arrays ================================!
    allocate(state(bundle_size))
    allocate(state_n(bundle_size))
    allocate(rhs_n(bundle_size))

    !=== Initialise internal state field objects =============================!
    u_fs => wind%get_function_space() 
    p_fs => pressure%get_function_space()
    b_fs => buoyancy%get_function_space()

    state(igw_u) = field_type( vector_space = u_fs )
    state(igw_p) = field_type( vector_space = p_fs )
    state(igw_b) = field_type( vector_space = b_fs )

    call clone_bundle(state, state_n,   bundle_size)
    call clone_bundle(state, rhs_n,     bundle_size)

    rhs_p =  field_type( vector_space = p_fs )

    !=== Copy prognostic field data to state arrays ===========================!
    call invoke( copy_field(wind,     state(igw_u)), &
                 copy_field(pressure, state(igw_p)), & 
                 copy_field(buoyancy, state(igw_b)) )

    ! Create Q operator
    Q = operator_type( u_fs, b_fs)
    qr = quadrature_type(element_order+2, GAUSSIAN)
    mesh => mesh_collection%get_mesh( mesh_id )
    nlayers = mesh%get_nlayers()
    allocate ( dz(nlayers) )
    call mesh%get_dz(dz)
    call compute_q_operator_init(dz, nlayers)
    call invoke( compute_q_operator_type(Q, qr) )

    call gw_si_solver_init(state)

    call log_event( "Gravity Wave: initialised timestepping algorithm", LOG_LEVEL_INFO )
  end subroutine gravity_wave_alg_init
!=============================================================================!

  !> @details An algorithm for timestepping the 3D linear  gravity wave equations
  !>         using a cnetred implicit method
  !> @param[inout] wind  The 3D wind field
  !> @param[inout] pressure The pressure field
  !> @param[inout] buoyancy The buoyancy field
  subroutine gravity_wave_alg_step(wind, pressure, buoyancy)

  use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type
  use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
  use enforce_bc_kernel_mod,              only: enforce_bc_kernel_type

    implicit none

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: wind, pressure, buoyancy

    type(operator_type), pointer :: div    => null() 
    type(operator_type), pointer :: m3_inv => null() 
  
    if ( subroutine_timers ) call timer('gravity_wave_alg')
    !=== Do a single timestep ==============================================!
    div => get_div()
    m3_inv => get_mass_matrix(w3inv_id)
    call invoke( copy_field(wind,     state(igw_u)), &
                 copy_field(pressure, state(igw_p)), &
                 copy_field(buoyancy, state(igw_b)) )
    call copy_bundle(state, state_n, bundle_size)

    ! Compute rhs
    call invoke( set_field_scalar(0.0_r_def, rhs_n(igw_u)), &
                 set_field_scalar(0.0_r_def, rhs_n(igw_b)) )
    call invoke( transpose_matrix_vector_kernel_type(rhs_n(igw_u), state_n(igw_p), div), &
                 matrix_vector_kernel_type          (rhs_n(igw_u), state_n(igw_b), Q), &
                 dg_matrix_vector_kernel_type       (rhs_p,        state_n(igw_u), div), &
                 dg_matrix_vector_kernel_type       (rhs_n(igw_p), rhs_p,          m3_inv), &
                 transpose_matrix_vector_kernel_type(rhs_n(igw_b), state_n(igw_u), Q) )

    ! Apply timestep scalings
    call invoke_scale_field_data( dt,            rhs_n(igw_u))
    call invoke_scale_field_data(-dt*cs_square,  rhs_n(igw_p))
    call invoke_scale_field_data(-dt*bvf_square, rhs_n(igw_b))

    call invoke( enforce_bc_kernel_type(rhs_n(igw_u)) )

    ! Solve
    call gw_si_solver_alg(state, rhs_n)
       
    ! Return fields
    call invoke( copy_field(state(igw_u), wind),     &
                 copy_field(state(igw_p), pressure), &
                 copy_field(state(igw_b), buoyancy) )
    if ( subroutine_timers ) call timer('gravity_wave_alg')

  end subroutine gravity_wave_alg_step


end module gravity_wave_alg_mod
