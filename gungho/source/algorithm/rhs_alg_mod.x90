!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the rhs of the prognostic
!>       equations
module rhs_alg_mod

  use constants_mod,                       only: r_def, i_def
  use enforce_bc_kernel_mod,               only: enforce_bc_kernel_type
  use runtime_constants_mod,               only: get_geopotential, &
                                                 get_coordinates,  &
                                                 get_mass_matrix,  &
                                                 w2_id, w3inv_id, theta_space_id
  use field_bundle_mod,                    only: clone_bundle
  use field_mod,                           only: field_type
  use finite_element_config_mod,           only: element_order, wtheta_on
  use formulation_config_mod,              only: rotating
  use geopotential_gradient_kernel_mod,    only: geopotential_gradient_kernel_type
  use kinetic_energy_gradient_kernel_mod,  only: kinetic_energy_gradient_kernel_type
  use matrix_vector_kernel_mod,            only: matrix_vector_kernel_type
  use operator_mod,                        only: operator_type
  use pressure_gradient_kernel_mod,        only: pressure_gradient_kernel_type
  use psykal_lite_mod,                     only: invoke_inc_xpby, &
                                                 invoke_ru_bd_kernel
  use quadrature_mod,                      only: quadrature_type, GAUSSIAN
  use rotation_kernel_mod,                 only: rotation_kernel_type
  use solver_config_mod,                   only: method
  use solver_mod,                          only: solver_algorithm
  use derived_config_mod,                  only: bundle_size
  use field_indices_mod,                   only: igh_u, igh_t, igh_d
  use output_config_mod,                   only: subroutine_timers 
  use timer_mod,                           only: timer

  implicit none

  private
  public :: rhs_alg

contains
!>@details A wrapper algorithm for computing the rhs of the prognostic
!>         equations. If computing the lhs of the semi-implicit equations
!>         a correction to the theta and rho advection terms is also computed 
!>         (d_adv terms) namely:
!>         \f[
!>            \mathbf{R_u} = \mathbf{u} 
!>                         + \alpha\Delta t\left[ 2\Omega \times \mathbf{u}
!>                         + \nabla\left(\Phi + 1/2\mathbf{u}.\mathbf{u}\right)
!>                         + Cp\theta\nabla\Pi \right]
!>         \f]
!>         \f[ R_\rho = \rho + d_{adv}\alpha\Delta t \nabla.\left(\rho\mathbf{u}\right) \f]
!>         \f[ R_\theta = \theta + d_{adv}\alpha\Delta t\mathbf{u}.\nabla\theta \f]
!>         This can be given either timelevel n or n+1 fields to compute
!>         the appropriate part of the full right hand side
!> @param[inout] rhs The state vector to compute
!> @param[in]    alpha_dt The offcentering parameter times the timestep
!> @param[in]    state The current model prognostic state
  subroutine rhs_alg(rhs, alpha_dt, state)
  
  implicit none

  real(r_def),                  intent(in)    :: alpha_dt
  
  ! Form of state and rhs is [u,theta,rho,exner] 
  type(field_type), target,     intent(in)    :: state(bundle_size)
  type(field_type),             intent(inout) :: rhs(bundle_size)

  type(field_type), pointer :: chi(:), geopotential => null()
  type(operator_type), pointer :: mm_w2 => null(), mm_w3_inv => null(), mm_wtheta => null()

  type( quadrature_type )   :: qr 
  type(field_type), pointer :: u     => null(), &
                               theta => null(), &
                               rho   => null()
  type(field_type)          :: rhs_tmp(bundle_size)

  if ( subroutine_timers ) call timer('rhs_alg')

  geopotential => get_geopotential()
  mm_w2        => get_mass_matrix(w2_id)
  mm_w3_inv    => get_mass_matrix(w3inv_id)
  mm_wtheta    => get_mass_matrix(theta_space_id)
  chi          => get_coordinates()

  u     => state(igh_u)
  theta => state(igh_t)
  rho   => state(igh_d)
 
  call clone_bundle(rhs, rhs_tmp, bundle_size)

  qr = quadrature_type(element_order+2, GAUSSIAN)

  ! Initialise RHS u and theta fields
  call invoke( set_field_scalar(0.0_r_def, rhs_tmp(igh_u)), & 
               set_field_scalar(0.0_r_def, rhs(igh_u)),     &
               set_field_scalar(0.0_r_def, rhs_tmp(igh_t)), &
               set_field_scalar(0.0_r_def, rhs(igh_t)) )

  ! Compute rhs_u
  if(wtheta_on) call invoke_ru_bd_kernel (rhs_tmp(igh_u), rho, theta, qr)
  call invoke( pressure_gradient_kernel_type( rhs_tmp(igh_u), rho, theta, qr ) )
  call invoke( kinetic_energy_gradient_kernel_type( rhs_tmp(igh_u), u, chi, qr ) )
  call invoke( geopotential_gradient_kernel_type( rhs_tmp(igh_u), &
                                                  geopotential, qr ) )
  if ( rotating ) &
    call invoke( rotation_kernel_type( rhs_tmp(igh_u), u, chi, qr ) )
  call invoke( matrix_vector_kernel_type( rhs(igh_u), u, mm_w2) )
  call invoke_inc_xpby( rhs(igh_u) , alpha_dt, rhs_tmp(igh_u) )
  call invoke( enforce_bc_kernel_type(rhs(igh_u)) )
 
  ! Compute rhs_theta
  call invoke( matrix_vector_kernel_type( rhs(igh_t), theta, mm_wtheta) )
  call invoke_inc_xpby( rhs(igh_t), alpha_dt, rhs_tmp(igh_t) )

  ! Compute rhs_rho
  call invoke( copy_field(rho, rhs(igh_d)) )
  if ( subroutine_timers ) call timer('rhs_alg')

  end subroutine rhs_alg

end module rhs_alg_mod


