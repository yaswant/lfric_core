!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Wrapper algorithm to compute the rhs of the prognostic
!>       equations
module rhs_alg_mod

  use constants_mod,                       only: r_def
  use enforce_bc_kernel_mod,               only: enforce_bc_kernel_type
  use runtime_constants_mod,               only: get_geopotential, &
                                                 get_coordinates,  &
                                                 get_mass_matrix,  &
                                                 w2_id,            &
                                                 theta_space_id,   &
                                                 w3inv_id, dl_id
  use field_mod,                           only: field_type
  use finite_element_config_mod,           only: element_order, wtheta_on
  use formulation_config_mod,              only: rotating
  use kinetic_energy_gradient_kernel_mod,  only: kinetic_energy_gradient_kernel_type
  use matrix_vector_kernel_mod,            only: matrix_vector_kernel_type
  use operator_mod,                        only: operator_type
  use hydrostatic_kernel_mod,              only: hydrostatic_kernel_type
  use psykal_lite_mod,                     only: invoke_ru_bd_kernel
  use quadrature_xyoz_mod,                 only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,        only: quadrature_rule_gaussian_type
  use rotation_kernel_mod,                 only: rotation_kernel_type
  use derived_config_mod,                  only: bundle_size
  use field_indices_mod,                   only: igh_u, igh_t, igh_d, igh_p
  use output_config_mod,                   only: subroutine_timers 
  use timer_mod,                           only: timer
  use rhs_eos_kernel_mod,                  only: rhs_eos_kernel_type
  use dg_matrix_vector_kernel_mod,         only: dg_matrix_vector_kernel_type

  implicit none

  private
  public :: rhs_alg

contains

  !>@details A wrapper algorithm for computing the rhs of the prognostic
  !>         equations. If computing the lhs of the semi-implicit equations
  !>         a correction to the theta and rho advection terms is also computed 
  !>         (d_adv terms) namely:
  !>         \f[
  !>            \mathbf{R_u} = \mathbf{u} 
  !>                         + \alpha\Delta t\left[ 2\Omega \times \mathbf{u}
  !>                         + \nabla\left(\Phi + 1/2\mathbf{u}.\mathbf{u}\right)
  !>                         + Cp\theta\nabla\Pi \right]
  !>         \f]
  !>         \f[ R_\rho = \rho + d_{adv}\alpha\Delta t \nabla.\left(\rho\mathbf{u}\right) \f]
  !>         \f[ R_\theta = \theta + d_{adv}\alpha\Delta t\mathbf{u}.\nabla\theta \f]
  !>         This can be given either timelevel n or n+1 fields to compute
  !>         the appropriate part of the full right hand side
  !> @param[inout] rhs The state vector to compute
  !> @param[in]    alpha_dt The offcentering parameter times the timestep
  !> @param[in]    state The current model prognostic state
  !> @param[in]    compute_eos Flag to control computation of the equation of
  !!               state
  !> @param[in]    dlayer_rhs Use damping layer in rhs yes/no
  subroutine rhs_alg(rhs, alpha_dt, state, compute_eos, dlayer_rhs)
  
    implicit none

    real(r_def),                  intent(in)    :: alpha_dt
    logical,                      intent(in)    :: dlayer_rhs
  
    ! Form of state and rhs is [u,theta,rho,exner] 
    type(field_type), target,     intent(in)    :: state(bundle_size)
    type(field_type),             intent(inout) :: rhs(bundle_size)
    logical,                      intent(in)    :: compute_eos

    type(operator_type), pointer :: mm_vel    => null(), &
                                    mm_wtheta => null(), &
                                    mm_w3_inv => null()
    type(field_type), pointer :: chi(:)       => null(), &
                                 geopotential => null(), &
                                 u            => null(), &
                                 theta        => null(), &
                                 rho          => null(), &
                                 exner        => null()
    type(field_type)          :: rhs_tmp, rhs_eos
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule

    if ( subroutine_timers ) call timer('rhs_alg')

    geopotential => get_geopotential()
    mm_wtheta    => get_mass_matrix(theta_space_id)
    chi          => get_coordinates()
    mm_w3_inv    => get_mass_matrix(w3inv_id)
   
    ! Using modified velocity mass matrix if using damping layer
    if(dlayer_rhs) then
      mm_vel => get_mass_matrix(dl_id)
    else
      mm_vel => get_mass_matrix(w2_id)
    end if 


    u     => state(igh_u)
    theta => state(igh_t)
    rho   => state(igh_d)
    exner => state(igh_p)
 
    rhs_tmp = field_type( vector_space=rhs(igh_u)%get_function_space() )
    rhs_eos = field_type( vector_space=rhs(igh_p)%get_function_space() )
    qr = quadrature_xyoz_type(element_order+2, quadrature_rule)

    ! Initialise RHS u and theta fields
    call invoke( name = "Initialise RHS u and theta fields", &
                 setval_c( rhs_tmp,    0.0_r_def ),          & 
                 setval_c( rhs(igh_u), 0.0_r_def ),          &
                 setval_c( rhs(igh_t), 0.0_r_def ) )

    ! Compute rhs_u
    if (wtheta_on) call invoke_ru_bd_kernel (rhs_tmp, exner, theta, qr)
    call invoke( name = "Compute rhs_u setup",                               &
                 hydrostatic_kernel_type( rhs_tmp, exner, theta, geopotential,qr ),   &
                 kinetic_energy_gradient_kernel_type( rhs_tmp, u, chi, qr ), &
                 matrix_vector_kernel_type( rhs(igh_u), u, mm_vel ) )
    if ( rotating ) &
      call invoke( rotation_kernel_type( rhs_tmp, u, chi, qr ) )

    call invoke( name = "Compute rhs_u evaluation",                 &
                 inc_X_plus_bY( rhs(igh_u), alpha_dt, rhs_tmp ),    &
                 enforce_bc_kernel_type(rhs(igh_u)) )
 
    call invoke( name = "Compute rhs_theta and rhs_rho",                    &
    ! Compute rhs_theta
                 matrix_vector_kernel_type( rhs(igh_t), theta, mm_wtheta ), &
    ! Compute rhs_rho
                 setval_X( rhs(igh_d), rho ) )
    if ( compute_eos ) then
      qr = quadrature_xyoz_type(1, quadrature_rule)
      call invoke( name = "Compute rhs_eos",               &
                   rhs_eos_kernel_type(rhs_eos, exner, rho, theta, chi, qr), & 
                   dg_matrix_vector_kernel_type( rhs(igh_p), rhs_eos, mm_w3_inv ))
    else
      call invoke( setval_c(rhs(igh_p), 0.0_r_def) )
    end if

    if ( subroutine_timers ) call timer('rhs_alg')

  end subroutine rhs_alg

end module rhs_alg_mod


