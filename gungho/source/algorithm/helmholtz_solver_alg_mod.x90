!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!>@brief Routines for solving the semi-implicit equation set by
!!       eliminating all variables in favour of the exner pressure increment

module helmholtz_solver_alg_mod
  use field_mod,                 only: field_type
  use constants_mod,             only: i_def, r_def
  use si_operators_alg_mod,      only: get_m3_rho_star, &
                                       get_m3_exner_star, &
                                       get_compound_div, &
                                       get_div_star, &
                                       get_ptheta2, &
                                       get_p2theta, &
                                       get_p3theta, &
                                       get_rho_at_u, &
                                       get_tri_precon, &
                                       get_helm_diag
  use runtime_constants_mod,     only: get_coordinates, &
                                       get_mass_matrix, &
                                       get_mass_matrix_diagonal, &
                                       get_div, &
                                       get_inverse_lumped_mass_matrix, &
                                       w2_id, w3inv_id, theta_space_id
  use solver_config_mod,         only: normalise
  use derived_config_mod,        only: si_bundle_size, bundle_size
  use field_indices_mod,         only: igh_u, igh_t, igh_d, igh_p
  use output_config_mod,         only: subroutine_timers 
  use timer_mod,                 only: timer
  use timestepping_config_mod,   only: tau_u, tau_t, tau_r
  implicit none

  private 
  real(kind=r_def),    private, parameter :: sc_err_min = 1.0e-5_r_def
  type(field_type),    private            :: helmholtz_rhs
  type(field_type),    private            :: exner_increment

  ! Temporary fields needed for: 
  ! Fields for bicgstab (all W3)
  type(field_type), private :: res, p, v, s, t, z, y
  ! For building rhs
  type(field_type), private :: r_u, r_p, u_term, rho_at_u, &
                               flux, theta_adv_term, m2_u, mt_r_t
  ! For applying lhs
  type(field_type), private :: grad_p
  ! For Back substitute
  type(field_type), private, allocatable :: rhs_inc(:)
  type(field_type), private :: rho_inc, u_inc, theta_inc

  type(field_type) :: hb_inv


  ! Sub algorithms used for solving the helmholtz equation
  public  :: helmholtz_solver_init
  public  :: helmholtz_solver_alg
  private :: build_helmholtz_rhs
  public  :: compute_inv_hb
  private :: apply_helmholtz_lhs
  private :: bicgstab
  private :: back_substitute 
  private :: helmholtz_precondition
contains
!=============================================================================!
!>@brief Create all the required fields for the Helmholtz solver
  subroutine helmholtz_solver_init(state)
    use function_space_mod,        only: function_space_type
    use field_bundle_mod,          only: clone_bundle
    implicit none
    type(field_type), intent(in)       :: state(bundle_size)
    type(function_space_type), pointer :: w3 => null(), &
                                          w2 => null(), &
                                          wtheta => null()

    ! Get needed function spaces
    w3     => state(igh_d)%get_function_space()
    w2     => state(igh_u)%get_function_space()
    wtheta => state(igh_t)%get_function_space()

    helmholtz_rhs   = field_type(vector_space = w3)
    exner_increment = field_type(vector_space = w3)

    ! For building the rhs
    r_u            = field_type(vector_space = w2)
    r_p            = field_type(vector_space = w3)
    u_term         = field_type(vector_space = w2)
    flux           = field_type(vector_space = w2)
    theta_adv_term = field_type(vector_space = wtheta)
    m2_u           = field_type(vector_space = w2)
    mt_r_t         = field_type(vector_space = wtheta)

    ! Create invert_h_b fields
    hb_inv = field_type(vector_space = w2)

    ! Create bicgstab fields
    v   = field_type( vector_space = w3)
    z   = field_type( vector_space = w3)
    p   = field_type( vector_space = w3)
    t   = field_type( vector_space = w3)
    s   = field_type( vector_space = w3)
    y   = field_type( vector_space = w3)
    res = field_type( vector_space = w3)
    
    ! Apply lhs
    grad_p  = field_type(vector_space = w2)

    ! Back substitute
    allocate( rhs_inc(bundle_size) )
    call clone_bundle( state, rhs_inc, bundle_size)
    rho_inc   = field_type(vector_space = w3)
    u_inc     = field_type(vector_space = w2)
    theta_inc = field_type(vector_space = wtheta)

  end subroutine helmholtz_solver_init

!=============================================================================!
!>@brief Control routine for the helmholtz solver
!>@details Control routine for the helmholtz solver:
!>         1) Builds the helmholtz rhs 
!>         2) Solves for the presssure increment using a Krylov method
!>         3) Back substitutes to find remaining field increments

  subroutine helmholtz_solver_alg(x0, rhs0)
    implicit none

    type(field_type), intent(inout) :: x0(si_bundle_size)
    type(field_type), intent(in)    :: rhs0(si_bundle_size)

    if ( subroutine_timers ) call timer('helmholtz_solver_alg')
    ! Build Helmholtz RHS
    call build_helmholtz_rhs(helmholtz_rhs, rhs0)

    ! Krylov solver to obtain pressure increment
    call bicgstab(exner_increment, helmholtz_rhs)

    ! Back substitution to obtain other fields
    call back_substitute(x0, exner_increment, rhs0)
    if ( subroutine_timers ) call timer('helmholtz_solver_alg')

  end subroutine helmholtz_solver_alg

!=============================================================================!
!>@brief Compute the rhs to the helmholtz equation for the pressure increment
  subroutine build_helmholtz_rhs(helmholtz_rhs, rhs0)
    use psykal_lite_mod,              only: invoke_inc_X_times_Y, &
                                            invoke_inc_axpy,      &
                                            invoke_multiply_field_data
    use matrix_vector_kernel_mod,     only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod,  only: dg_matrix_vector_kernel_type
    use apply_variable_hx_kernel_mod, only: apply_variable_hx_kernel_type
    use timestepping_config_mod,      only: dt
    use planet_config_mod,            only: cp
    use operator_mod,                 only: operator_type
    use enforce_bc_kernel_mod,        only: enforce_bc_kernel_type
    use log_mod,                      only: LOG_LEVEL_DEBUG

    implicit none
    type(field_type),                intent(inout) :: helmholtz_rhs
    type(field_type),                intent(in)    :: rhs0(si_bundle_size)

    type(operator_type), pointer :: m3_rho_star => null(), &
                                    m3_inv => null(), &
                                    p2theta => null(), &
                                    ptheta2 => null(), &
                                    p3theta => null(), &
                                    compound_div => null()
    type(field_type),    pointer :: mt_lumped_inv => null()
    type(field_type),    pointer :: H_diag => null()
    real(kind=r_def)             :: mdt

    p2theta       => get_p2theta()
    ptheta2       => get_ptheta2()
    p3theta       => get_p3theta()
    m3_rho_star   => get_m3_rho_star()
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)
    m3_inv        => get_mass_matrix(w3inv_id)
    compound_div  => get_compound_div()
   
    ! r_u = rhs_u + tau*dt*cp*P02*M0^-1*rhs_t       
    call invoke_multiply_field_data(rhs0(igh_t), mt_lumped_inv, mt_r_t)
    call invoke( set_field_scalar(0.0_r_def, r_u) )
    call invoke( matrix_vector_kernel_type(r_u, mt_r_t, p2theta) )
    call invoke_inc_axpy(tau_u*dt*cp, r_u, rhs0(igh_u)) 
    ! Compute H_B * u_term = r_u
    call invoke( enforce_bc_kernel_type( r_u ) )
    call invoke_multiply_field_data(r_u, hb_inv, u_term)

    ! Compute H(u_term)
    ! r_pi = rhs_pi + P03*M0^-1*rhs_t + M3rho*M3^-1*rhs_r
    ! rhs_pi \equiv 0
    ! r_rho already contains M3^-1 factor
    mdt = -dt   
    call invoke( apply_variable_hx_kernel_type( helmholtz_rhs, u_term, mt_lumped_inv, rhs0(igh_d), &
                                                compound_div, p3theta, ptheta2, m3_rho_star, &
                                                tau_t, mdt), &
                 matrix_vector_kernel_type(helmholtz_rhs, mt_r_t, p3theta) )

    if ( normalise ) then 
      H_diag => get_helm_diag()
      call invoke_inc_X_times_Y(helmholtz_rhs, H_diag)
    end if

    call helmholtz_rhs%log_minmax(LOG_LEVEL_DEBUG, 'helmholtz_rhs')

  end subroutine build_helmholtz_rhs

!=============================================================================!
!>@brief Compute the lumped inverse H_B operator
  subroutine compute_inv_hb
    use timestepping_config_mod,  only: dt
    use planet_config_mod,        only: cp
    use psykal_lite_mod,          only: invoke_inc_X_times_Y, &
                                        invoke_inc_axpy,      &
                                        invoke_raise_field
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type
    use operator_mod,             only: operator_type
    use enforce_bc_kernel_mod,    only: enforce_bc_kernel_type

    implicit none
    type(operator_type), pointer                   :: m2, p2theta,         &
                                                      ptheta2 => null()
    type(field_type),    pointer                   :: mt_lumped_inv => null()
    real(kind=r_def)                               :: timestep_term
    type(field_type)                               :: ones

   timestep_term = cp*tau_u*tau_t*dt**2

    m2            => get_mass_matrix(w2_id)
    p2theta       => get_p2theta()
    ptheta2       => get_ptheta2()
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)

    ones = field_type( vector_space = hb_inv%get_function_space() )

    call invoke(set_field_scalar(1.0_r_def, ones), &
                set_field_scalar(0.0_r_def, hb_inv), &
                set_field_scalar(0.0_r_def, m2_u), &
                set_field_scalar(0.0_r_def, theta_adv_term) )
    call invoke( matrix_vector_kernel_type(m2_u, ones, m2), &
                 matrix_vector_kernel_type(theta_adv_term, ones, ptheta2) )
    call invoke_inc_X_times_Y(theta_adv_term, mt_lumped_inv)

    call invoke( matrix_vector_kernel_type(hb_inv, theta_adv_term, p2theta) )  
    call invoke_inc_axpy( timestep_term, hb_inv, m2_u )
    call invoke_raise_field(hb_inv, -1_i_def)

  end subroutine compute_inv_hb

!=============================================================================!
!>@brief Apply the full Helmholtz lhs to a pressure field p, this is the Ax
!>       routine called from the Krylov solver 
  subroutine apply_helmholtz_lhs(Hp, p)
    use timestepping_config_mod,         only: dt
    use planet_config_mod,               only: cp
    use scaled_matrix_vector_kernel_mod, only: scaled_matrix_vector_kernel_type, &
                                               opt_scaled_matrix_vector_kernel_type
    use psykal_lite_mod,                 only: invoke_inc_X_times_Y
    use operator_mod,                    only: operator_type
    use enforce_bc_kernel_mod,           only: enforce_bc_kernel_type
    use apply_variable_hx_kernel_mod,    only: apply_variable_hx_kernel_type, &
                                               opt_apply_variable_hx_kernel_type
    use finite_element_config_mod,       only: element_order, wtheta_on

    implicit none
    type(field_type),                intent(inout) :: Hp
    type(field_type),                intent(in)    :: p

    type(operator_type), pointer :: m3_exner_star => null(), &
                                    div_star => null(), &
                                    compound_div => null(), &
                                    ptheta2 => null(), &
                                    p3theta => null()
    real(kind=r_def)             :: timestep_term
    type(field_type),    pointer :: H_diag => null(), &
                                    mt_lumped_inv => null()

    m3_exner_star => get_m3_exner_star()
    div_star      => get_div_star()
    compound_div  => get_compound_div()
    ptheta2       => get_ptheta2()
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)
    p3theta       => get_p3theta()

    ! Compute M3*p + cp*tau_u*dt*H[ D{\theta*}*p ]
    timestep_term = cp*tau_u*dt**2
    if ( wtheta_on .and. element_order == 0 ) then
      ! Hard wired optimisation for desired configuration
      call invoke( set_field_scalar(0.0_r_def, grad_p),                        &
                   opt_scaled_matrix_vector_kernel_type(grad_p, p, div_star,   &
                                                        hb_inv),               &
                   enforce_bc_kernel_type( grad_p ),                           &
                   opt_apply_variable_hx_kernel_type(                          &
                       Hp, grad_p, mt_lumped_inv, p,                           &
                       compound_div, p3theta, ptheta2, m3_exner_star,          &
                       tau_t, timestep_term) )
    else
      call invoke( set_field_scalar(0.0_r_def, grad_p),                        &
                   scaled_matrix_vector_kernel_type(grad_p, p, div_star,       &
                                                    hb_inv),                   &
                   enforce_bc_kernel_type( grad_p ),                           &
                   apply_variable_hx_kernel_type(                              &
                         Hp, grad_p, mt_lumped_inv, p,                         &
                         compound_div, p3theta, ptheta2, m3_exner_star,        &
                         tau_t, timestep_term) )

    end if
    if ( normalise ) then 
      H_diag => get_helm_diag()
      call invoke_inc_X_times_Y(Hp, H_diag)
    end if

  end subroutine apply_helmholtz_lhs

!=============================================================================!
!>@brief Krylov solver specifically for solving the Helmholtz equation 
  subroutine bicgstab(lhs, rhs)
    use solver_config_mod,     only: maximum_iterations, &
                                     si_pressure_tolerance
    use psykal_lite_mod,       only: invoke_inner_prod,       &
                                     invoke_X_innerproduct_X, &
                                     invoke_axpy,             &
                                     invoke_inc_axpy,         &
                                     invoke_inc_xpby
    use log_mod,               only: log_event,         &
                                     log_scratch_space, &
                                     LOG_LEVEL_ERROR,   &
                                     LOG_LEVEL_INFO,    &
                                     LOG_LEVEL_DEBUG,   &
                                     LOG_LEVEL_TRACE
    implicit none
    type(field_type),             intent(inout) :: lhs
    type(field_type),             intent(in)    :: rhs

    ! the scalars
    real(kind=r_def)                   :: rho, alpha, omega, beta, norm
    real(kind=r_def)                   :: ts, tt
    ! others
    real(kind=r_def)                   :: err, sc_err, init_err
    integer(kind=i_def)                :: iter
    
    ! compute the residual this is a global sum to the PSy ---
    call invoke_X_innerproduct_X(sc_err, rhs)
    sc_err = max(sqrt(sc_err), sc_err_min)
    write( log_scratch_space, '(A,E15.8)' ) &
         "solver_algorithm: bicgstab starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    alpha  = 1.0_r_def
    omega  = 1.0_r_def
    norm   = 1.0_r_def

    call invoke( set_field_scalar(0.0_r_def, lhs), &
                 copy_field(rhs,res) )

    call invoke_X_innerproduct_X(err, res)
    err = sqrt(err)/sc_err
    init_err=err
    if (err < si_pressure_tolerance) then
      write( log_scratch_space, '(A,I3,A,E12.4,A,E15.8)') &
           "helmholtz solver_algorithm:converged in ", 0,  &
           " iters, init=", init_err," final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if

    call invoke( set_field_scalar(0.0_r_def, v), &
                 set_field_scalar(0.0_r_def, p) )

    do iter = 1, maximum_iterations

      call invoke_inner_prod(res,rhs,rho)
      beta = (rho/norm) * (alpha/omega)
      ! p = r + beta*(p - omega*v)
      call invoke_inc_axpy(beta, p, res)
      call invoke_inc_xpby(p, -beta*omega, v)
      call helmholtz_precondition( y, p)
      call apply_helmholtz_lhs( v, y)
      
      call invoke_inner_prod(rhs,v,norm)
      alpha = rho/norm
      call invoke_axpy(-alpha,v,res,s)
      call helmholtz_precondition( z, s )
      call apply_helmholtz_lhs( t, z )

      call invoke_X_innerproduct_X(tt, t)
      call invoke_inner_prod(t,s,ts)

      omega = ts/tt

      ! lhs = lhs + omega * z + alpha * y
      call invoke_inc_xpby(lhs, omega, z)
      call invoke_inc_xpby(lhs, alpha, y)
      call invoke_axpy(-omega,t,s,res)

      norm = rho

      ! check for convergence
      call invoke_X_innerproduct_X(err, res)
      err = sqrt(err)/sc_err

      write( log_scratch_space, '(A,I3,A,E15.8)' ) &
             "solver_algorithm[", iter, "]: res = ", err
      call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

      if (err < si_pressure_tolerance) then
        write( log_scratch_space, '(A,I3,A,E12.4,A,E15.8)' )      &
             "Helmholtz solver_algorithm:converged in ", iter,    &
             " iters, init=", init_err, " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if(iter >= maximum_iterations) then
      write(log_scratch_space, '(A, I3, A, E15.8)') &
           "Helmholtz solver_algorithm: NOT converged in", iter, " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if
  end subroutine bicgstab

!=============================================================================!
!>@brief Obtain the increments to each field from the pressure field given by
!>       the helmholtz equation
  subroutine back_substitute( state, exner_inc, rhs)
    use log_mod,                     only: LOG_LEVEL_DEBUG, &
                                           LOG_LEVEL_INFO
    use timestepping_config_mod,     only: dt
    use planet_config_mod,           only: cp
    use psykal_lite_mod,             only: invoke_inc_axpy,            &
                                           invoke_multiply_field_data, &
                                           invoke_increment_field
    use matrix_vector_kernel_mod,    only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use operator_mod,                only: operator_type  
    use enforce_bc_kernel_mod,       only: enforce_bc_kernel_type
    use formulation_config_mod,      only: eliminate_p

    implicit none
    type(field_type),                intent(inout) :: state(si_bundle_size)
    type(field_type),                intent(in)    :: exner_inc
    type(field_type),                intent(in)    :: rhs(si_bundle_size)

    type(field_type),    pointer :: mt_lumped_inv => null(), &
                                    rho_at_u => null()
    type(operator_type), pointer :: div_star => null(), &
                                    ptheta2 => null(),  &
                                    div => null(),      &
                                    m3_inv => null()

    ! Need to pass in mathfrak{R}_u
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)
    div_star      => get_div_star()
    ptheta2       => get_ptheta2()
    rho_at_u      => get_rho_at_u()
    div           => get_div()
    m3_inv        => get_mass_matrix(w3inv_id)
    ! Initialise increment fields
    call invoke( set_field_scalar(0.0_r_def, rhs_inc(igh_u)), &
                 set_field_scalar(0.0_r_def, rhs_inc(igh_t)) )

    ! u increment
    call invoke( matrix_vector_kernel_type(rhs_inc(igh_u), exner_inc, div_star) )
    call invoke_inc_axpy((tau_u*dt*cp), rhs_inc(igh_u), r_u)
    call invoke( enforce_bc_kernel_type( rhs_inc(igh_u) ) )
    call invoke_multiply_field_data(rhs_inc(igh_u), hb_inv, u_inc)

    ! theta increment
    call invoke( matrix_vector_kernel_type(rhs_inc(igh_t), u_inc, ptheta2) )
    call invoke_inc_axpy(-(tau_t*dt), rhs_inc(igh_t), rhs(igh_t) )  
    call invoke_multiply_field_data(rhs_inc(igh_t), mt_lumped_inv, theta_inc)

    ! rho increment
    call invoke_multiply_field_data(rho_at_u, u_inc, flux)
    call invoke( dg_matrix_vector_kernel_type( rhs_inc(igh_d), flux, div ) )
    call invoke( dg_matrix_vector_kernel_type( rho_inc, rhs_inc(igh_d), m3_inv) )
    call invoke_inc_axpy( -(tau_r*dt), rho_inc, rhs(igh_d))

    call exner_inc%log_minmax(LOG_LEVEL_DEBUG, 'exner increment ') 
    call u_inc    %log_minmax(LOG_LEVEL_DEBUG, 'u increment     ') 
    call theta_inc%log_minmax(LOG_LEVEL_DEBUG, 'theta increment ') 
    call rho_inc  %log_minmax(LOG_LEVEL_DEBUG, 'rho increment   ')
 
    call invoke_increment_field(u_inc,     state(igh_u))
    call invoke_increment_field(theta_inc, state(igh_t))
    call invoke_increment_field(rho_inc,   state(igh_d))
    if ( .not. eliminate_p ) call invoke_increment_field(exner_inc, state(igh_p))

  end subroutine back_substitute
!=============================================================================!
!>@brief Preconditioner for the helmholtz equation 
!>@details Options to precondition the helmholtz equation, currently allows only
!>         preconditioning with the inverse mass matrix or no preconditioner
  subroutine helmholtz_precondition( y, x, prec)
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use operator_mod,                only: operator_type 
    use tri_solve_kernel_mod,        only: tri_solve_kernel_type
    use solver_config_mod,           only: si_pressure_preconditioner, &
                                           solver_si_pressure_preconditioner_tridiagonal, & 
                                           solver_si_pressure_preconditioner_diagonal 

    implicit none
    type(field_type),  intent(inout) :: y
    type(field_type),  intent(in)    :: x
    integer, optional, intent(in)    :: prec

    integer                      :: precon
    type(operator_type), pointer :: m3_inv => null()
    type(field_type),    pointer :: tri(:) => null()

    if ( .not. present(prec) ) then
      precon = si_pressure_preconditioner
    else
      precon = prec
    end if
    select case ( precon )
      case ( solver_si_pressure_preconditioner_diagonal )       
        m3_inv   => get_mass_matrix(w3inv_id)
        call invoke( dg_matrix_vector_kernel_type(y, x, m3_inv) )     
      case ( solver_si_pressure_preconditioner_tridiagonal )
        tri => get_tri_precon()
        call invoke( tri_solve_kernel_type(y, x, tri) )
      case default
        call invoke( copy_field(x, y) )
    end select
  end subroutine helmholtz_precondition
!=============================================================================!
end module helmholtz_solver_alg_mod

