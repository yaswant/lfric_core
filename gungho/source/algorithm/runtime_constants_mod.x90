!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!
!> @brief A module providing various run time constants
!>
!> @details A module holding various objects that are created at
!>         setup and are not changed thereafter but are needed
!>         throughout the algorithm layers
module runtime_constants_mod

  use constants_mod,                     only: i_def, r_def  
  use log_mod,                           only: log_event, &
                                               LOG_LEVEL_INFO, &
                                               LOG_LEVEL_ERROR
  ! Configuration
  use finite_element_config_mod,         only: element_order
  use formulation_config_mod,            only: transport_only, dlayer_on, &
                                               rotating
  use transport_config_mod,              only: scheme,                     &
                                               transport_scheme_horz_cosmic
  use mixing_config_mod,                 only: smagorinsky

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use fs_continuity_mod,                 only: W0, W1, W2, W2H, W3, Wtheta, Wchi
  use mesh_mod,                          only: mesh_type
  use operator_mod,                      only: operator_type
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_mpi_calc_cell_orientation, &
                                               invoke_raise_field,               &
                                               invoke_mpi_detj_at_w2

  use multiplicity_kernel_mod,           only: multiplicity_kernel_type

  ! PsyKAl PSYClone kernels
  use compute_derahm_matrices_kernel_mod,    only: compute_derahm_matrices_kernel_type
  use compute_dl_matrix_kernel_mod,          only: compute_dl_matrix_kernel_type
  use compute_geopotential_kernel_mod,       only: compute_geopotential_kernel_type
  use mm_diagonal_kernel_mod,                only: mm_diagonal_kernel_type
  use invert_local_operator_kernel_mod,      only: invert_local_operator_kernel_type
  use matrix_vector_kernel_mod,              only: matrix_vector_kernel_type
  use get_height_kernel_mod,                 only: get_height_kernel_type
  use compute_geopotential_kernel_mod,       only: compute_geopotential_kernel_type
  use calc_detj_at_w2_kernel_mod,            only: calc_detj_at_w2_kernel_type
  use calc_dA_at_w2_kernel_mod,              only: calc_dA_at_w2_kernel_type
  use calc_delta_at_wtheta_kernel_mod,       only: calc_delta_at_wtheta_kernel_type
  use w2_normalisation_kernel_mod,           only: w2_normalisation_kernel_type
  use compute_coriolis_matrix_kernel_mod,    only: compute_coriolis_matrix_kernel_type
  use output_config_mod,                     only: subroutine_timers 
  use timer_mod,                             only: timer
  implicit none

  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them 

  type(field_type), target              :: mm0_diag 
  type(field_type), target              :: mm1_diag
  type(field_type), target              :: mm2_diag
  type(field_type), target              :: mm3_diag
  type(field_type), target              :: eye
  type(field_type), target              :: mmtheta_diag
  type(operator_type), target           :: mm_w0
  type(operator_type), target           :: mm_w1
  type(operator_type), target           :: mm_w2
  type(operator_type), target           :: mm_w3
  type(operator_type), target           :: mm_w3_inv
  type(operator_type), target           :: mm_wtheta
  type(operator_type), target           :: mm_dl
  type(field_type), target              :: geopotential
  type(field_type), pointer             :: coords(:)
  type(field_type), target              :: temp_w2_field
  type(field_type), target              :: cell_orientation
  type(field_type), target              :: detj_at_w2
  type(field_type), target              :: dA_at_w2
  type(field_type), target              :: delta_at_wtheta
  type(operator_type), target           :: grad, curl, div
  type( quadrature_xyoz_type ),target   :: qr
  type( quadrature_rule_gaussian_type ) :: quadrature_rule
  type(field_type), target              :: m0_lumped_inv
  type(field_type), target              :: m1_lumped_inv
  type(field_type), target              :: mt_lumped_inv
  type(field_type), target              :: height_wth, height_w3
  type(field_type), target              :: nodal_rmultiplicity_w1
  type(field_type), target              :: nodal_rmultiplicity_w2
  type(field_type), target              :: nodal_rmultiplicity_w2h
  type(field_type), target              :: nodal_rmultiplicity_w0
  type(field_type), target              :: w2_normalisation
  type(operator_type), target           :: coriolis

  ! Enumerated types
  integer(i_def), parameter, public :: w0_id    = 0_i_def
  integer(i_def), parameter, public :: w1_id    = 1_i_def
  integer(i_def), parameter, public :: w2_id    = 2_i_def
  integer(i_def), parameter, public :: w3_id    = 3_i_def
  integer(i_def), parameter, public :: wt_id    = 4_i_def
  integer(i_def), parameter, public :: w3inv_id = 5_i_def
  integer(i_def), parameter, public :: eye_id   = 6_i_def
  integer(i_def), parameter, public :: theta_space_id = 7_i_def
  integer(i_def), parameter, public :: dl_id = 8_i_def


  ! Public functions to create and access the module contents

  public :: create_runtime_constants
  public :: final_runtime_constants
  public :: get_coordinates
  public :: get_geopotential
  public :: get_cell_orientation
  public :: get_detj_at_w2
  public :: get_dA_at_w2
  public :: get_mass_matrix
  public :: get_mass_matrix_diagonal
  public :: get_grad
  public :: get_curl
  public :: get_div
  public :: get_qr
  public :: get_rmultiplicity
  public :: get_inverse_lumped_mass_matrix
  public :: get_height
  public :: get_normalisation
  public :: get_coriolis

contains
  !>@brief Subroutine to create the runtime constants
  !> @param[in] mesh_id Mesh_id
  !> @param[in] chi chi field
  subroutine create_runtime_constants(mesh_id, chi)

    implicit none

    integer(i_def),           intent(in) :: mesh_id
    type(field_type), target, intent(in) :: chi(:)

    type(function_space_type), pointer :: w0_fs     => null()
    type(function_space_type), pointer :: w1_fs     => null()
    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w2h_fs    => null()
    type(function_space_type), pointer :: w3_fs     => null()
    type(function_space_type), pointer :: wtheta_fs => null()
    type(function_space_type), pointer :: wth_k0_fs => null() ! lowest order wth fs 
    type(function_space_type), pointer :: w3_k0_fs  => null() ! lowest order w3 fs 
    type(field_type)                   :: ones
    type(field_type)                   :: dx_at_w2


    ! Temporary fields
    type(field_type) :: nodal_multiplicity_w1
    type(field_type) :: nodal_multiplicity_w2
    type(field_type) :: nodal_multiplicity_w2h
    type(field_type) :: nodal_multiplicity_w0


    if ( subroutine_timers ) call timer('runtime_constants_alg')
    call log_event( "Gungho: creating runtime_constants", LOG_LEVEL_INFO )


    !=========== Create function spaces required for setup ===================!

    w0_fs     => function_space_collection%get_fs( mesh_id, element_order, W0 )
    w1_fs     => function_space_collection%get_fs( mesh_id, element_order, W1 )
    w2_fs     => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w2h_fs    => function_space_collection%get_fs( mesh_id, element_order, W2H )
    w3_fs     => function_space_collection%get_fs( mesh_id, element_order, W3 )
    wtheta_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )
    w3_k0_fs  => function_space_collection%get_fs( mesh_id,             0, W3 )
    wth_k0_fs => function_space_collection%get_fs( mesh_id,             0, Wtheta )

    !================= Create quadrature object =====================!
    qr = quadrature_xyoz_type(element_order+3, quadrature_rule)

    !=================== Create geopotential field ============================!

    geopotential = field_type( vector_space = w0_fs )
    call invoke( compute_geopotential_kernel_type( geopotential, chi ) )

    !=================== Create cell orientation field ========================!

    if ( transport_only ) then
      temp_w2_field = field_type( vector_space = w2_fs )
      cell_orientation = field_type( vector_space = w3_fs )
      call invoke( setval_c(temp_w2_field,    9999.0_r_def), &
                   setval_c(cell_orientation, 9999.0_r_def) )
      call invoke_mpi_calc_cell_orientation( temp_w2_field, cell_orientation )
    end if

    !================ Create detj values at W2 dof locations ==================!

    detj_at_w2 = field_type( vector_space = w2_fs )
    call invoke( setval_c(detj_at_w2, 9999.0_r_def) )
    call invoke_mpi_detj_at_w2(detj_at_w2, chi)

    !================ Create dA values at W2 dof locations ==================!

    dA_at_w2 = field_type( vector_space = w2_fs )
    call invoke( setval_c(dA_at_w2, 9999.0_r_def),&
                 calc_dA_at_w2_kernel_type(dA_at_w2, chi) )

    !================ Create edge lengths and delta values ==================!

    if (smagorinsky) then
      dx_at_w2 = field_type( vector_space = w2_fs )
      delta_at_wtheta = field_type( vector_space = wtheta_fs )
      call invoke( X_divideby_Y(dx_at_w2, detJ_at_w2, dA_at_w2),&
                   calc_delta_at_wtheta_kernel_type(delta_at_wtheta, dx_at_w2)  )
    end if

    !=================== Create DeRahm cochain operators =========================!

    mm_w0 = operator_type( w0_fs, w0_fs )
    mm_w1 = operator_type( w1_fs, w1_fs )
    mm_w2 = operator_type( w2_fs, w2_fs )
    mm_dl = operator_type( w2_fs, w2_fs )
    mm_w3 = operator_type( w3_fs, w3_fs )
    mm_w3_inv = operator_type( w3_fs, w3_fs )
    mm_wtheta = operator_type( wtheta_fs, wtheta_fs )
    grad = operator_type( w1_fs, w0_fs )
    curl = operator_type( w2_fs, w1_fs )
    div  = operator_type( w3_fs, w2_fs )

    call invoke( name = "Create mass matrix operators",                   &
                 compute_derahm_matrices_kernel_type(mm_w0, mm_w1, mm_w2, &
                                                     mm_w3, mm_wtheta,    &
                                                     grad, curl, div,     &
                                                     chi, qr),            &
                 invert_local_operator_kernel_type(mm_w3_inv, mm_w3) )

    ! Compute W2 mass matrix with damping layer
    ! Eventually this may be absorbed into the DeRham complex computations
    ! but until the final form is settled upon it is left separate
    if (dlayer_on) call invoke( compute_dl_matrix_kernel_type(mm_dl, chi, qr) )

    !================= Create mass matrix diagonal fields =====================!

    mm0_diag       = field_type( vector_space = w0_fs )
    mm1_diag       = field_type( vector_space = w1_fs )
    mm2_diag       = field_type( vector_space = w2_fs )
    mm3_diag       = field_type( vector_space = w3_fs )
    mmtheta_diag   = field_type( vector_space = wtheta_fs )
    eye            = field_type( vector_space = w3_fs )

    ! Initialise fields
    call invoke( name = "Create mass matrix diagonal fields",      &
                 setval_c(mm0_diag,     0.0_r_def),                &
                 setval_c(mm1_diag,     0.0_r_def),                &
                 setval_c(mm2_diag,     0.0_r_def),                &
                 setval_c(mm3_diag,     0.0_r_def),                &
                 setval_c(mmtheta_diag, 0.0_r_def),                &
    ! Compute mass matrices
                 mm_diagonal_kernel_type(mm0_diag, mm_w0),         &
                 mm_diagonal_kernel_type(mm1_diag, mm_w1),         &
                 mm_diagonal_kernel_type(mm2_diag, mm_w2),         &
                 mm_diagonal_kernel_type(mm3_diag, mm_w3),         &
                 mm_diagonal_kernel_type(mmtheta_diag, mm_wtheta), &
    ! W3 equations are solved pointwise and so the mass matrix is inverted
    ! exactly, therefore the diagonal, where used should be 1
                 setval_c(eye, 1.0_r_def) )


    !================= Create inverse lumped mass matrices =====================!

    ones           = field_type( vector_space = w1_fs )
    m1_lumped_inv  = field_type( vector_space = w1_fs )
    call invoke( name = "Create m1_lumped_inv",      &
                 setval_c(ones,          1.0_r_def), &
                 setval_c(m1_lumped_inv, 0.0_r_def), &
                 matrix_vector_kernel_type(m1_lumped_inv, ones, mm_w1) )
    ! PSyclone does not currently support raising field to an integer power
    call invoke_raise_field(m1_lumped_inv, -1_i_def)

    ones           = field_type( vector_space = w0_fs )
    m0_lumped_inv  = field_type( vector_space = w0_fs )
    call invoke( name = "Create m0_lumped_inv",      &
                 setval_c(ones,          1.0_r_def), &
                 setval_c(m0_lumped_inv, 0.0_r_def), &
                 matrix_vector_kernel_type(m0_lumped_inv, ones, mm_w0) )
    ! PSyclone does not currently support raising field to an integer power
    call invoke_raise_field( m0_lumped_inv, -1_i_def)

    ones           = field_type( vector_space = wtheta_fs )
    mt_lumped_inv  = field_type( vector_space = wtheta_fs )
    call invoke( name = "Create mt_lumped_inv",      &
                 setval_c(ones,          1.0_r_def), &
                 setval_c(mt_lumped_inv, 0.0_r_def), &
                 matrix_vector_kernel_type(mt_lumped_inv, ones, mm_wtheta) )
    ! PSyclone does not currently support raising field to an integer power
    call invoke_raise_field( mt_lumped_inv, -1_i_def )

    !================= Create a height field =====================!
    ! Note that these fields represent the height relative to 
    ! the surface as represented by a sphere.  With the current
    ! representation of chi, this will result in the lowest
    ! levels being -ve. This should be reviewed with ticket #562
    height_w3  = field_type( vector_space = w3_k0_fs )
    height_wth = field_type( vector_space = wth_k0_fs )
    call invoke( get_height_kernel_type(height_w3, chi) )
    call invoke( get_height_kernel_type(height_wth, chi) )

    !=== Create multiplicity for horizontally continuous fields ===!
    ! NB most of the time we want 1/multiplicity
    
    nodal_multiplicity_w1  = field_type( vector_space = w1_fs )
    nodal_multiplicity_w2  = field_type( vector_space = w2_fs )
    nodal_multiplicity_w2h = field_type( vector_space = w2h_fs )
    nodal_multiplicity_w0  = field_type( vector_space = w0_fs )
    call invoke( name = "Create multiplicity",                     &
                 setval_c(nodal_multiplicity_w1, 0.0_r_def),       &
                 multiplicity_kernel_type(nodal_multiplicity_w1),  &
                 setval_c(nodal_multiplicity_w2, 0.0_r_def),       &
                 multiplicity_kernel_type(nodal_multiplicity_w2),  &
                 setval_c(nodal_multiplicity_w2h, 0.0_r_def),      &
                 multiplicity_kernel_type(nodal_multiplicity_w2h), &
                 setval_c(nodal_multiplicity_w0, 0.0_r_def),       &
                 multiplicity_kernel_type(nodal_multiplicity_w0) )

    ! Calculate the reciprocals
    nodal_rmultiplicity_w1  = field_type( vector_space = w1_fs )
    nodal_rmultiplicity_w2  = field_type( vector_space = w2_fs )
    nodal_rmultiplicity_w2h = field_type( vector_space = w2h_fs )
    nodal_rmultiplicity_w0  = field_type( vector_space = w0_fs )

    ones = field_type( vector_space = w1_fs )
    call invoke( setval_c(ones, 1.0_r_def), &
                 X_divideby_Y(nodal_rmultiplicity_w1, ones, nodal_multiplicity_w1) )

    ones = field_type( vector_space = w2_fs )
    call invoke( setval_c(ones, 1.0_r_def), &
                 X_divideby_Y(nodal_rmultiplicity_w2, ones, nodal_multiplicity_w2) )

    ones = field_type( vector_space = w2h_fs )
    call invoke( setval_c( ones, 1.0_r_def ), &
                 X_divideby_Y(nodal_rmultiplicity_w2h, ones, nodal_multiplicity_w2h) )

    ones = field_type( vector_space = w0_fs )
    call invoke( setval_c(ones, 1.0_r_def), &
                 X_divideby_Y(nodal_rmultiplicity_w0, ones, nodal_multiplicity_w0) )

    w2_normalisation = field_type( vector_space = w2_fs )
    call invoke( setval_c(w2_normalisation, 0.0_r_def),                    &
                 w2_normalisation_kernel_type(w2_normalisation, chi),      &
                 inc_X_divideby_Y(w2_normalisation, nodal_multiplicity_w2) )
    call invoke_raise_field(w2_normalisation, -1_i_def)

    ! Compute Coriolis operator
    if ( rotating ) then
      coriolis = operator_type( w2_fs, w2_fs )
      call invoke( compute_coriolis_matrix_kernel_type(coriolis, chi, qr) )
    end if

    ! Store pointer to chi field so things downstream can access it via
    ! runtime_constants
    coords => chi

    nullify( w0_fs  )
    nullify( w1_fs  )
    nullify( w2_fs  )
    nullify( w2h_fs )
    nullify( w3_fs  )
    nullify( wtheta_fs )
    nullify( wth_k0_fs )
    nullify( w3_k0_fs  )

    call log_event( "Gungho: created runtime_constants", LOG_LEVEL_INFO )
    if ( subroutine_timers ) call timer('runtime_constants_alg')

  end subroutine create_runtime_constants


  !> @brief Function to return a pointer to the coordinate array
  !> @return The coordinate field array
  function get_coordinates() result(coords_ptr)
    implicit none
    type(field_type), pointer :: coords_ptr(:)
    coords_ptr => coords

  end function get_coordinates

  !> @brief Function to return a pointer to a height field
  !> @param[in] i the space of the desired height field
  !> @return A height field
  function get_height(space) result(height)
    implicit none
    integer(i_def), intent(in) :: space
    type(field_type), pointer :: height

    select case (space)
    case (W3)
      height => height_w3
    case (Wtheta)
      height => height_wth
    case default
      height => null()
      call log_event( "Height not available on requested space", LOG_LEVEL_ERROR)
    end select

  end function get_height

  !> @brief Function to return a pointer to the geopotential field
  !> @return The geopotential field
  function get_geopotential() result(phi)
    implicit none
    type(field_type), pointer :: phi
    phi => geopotential

  end function get_geopotential

  !> @brief Function to return a pointer to the cell_orientation field
  !> @return The cell_orientation field
  function get_cell_orientation() result(orientation)
    implicit none
    type(field_type), pointer :: orientation
    if ( transport_only ) then
      orientation => cell_orientation
    else
      call log_event( "Cell orientation variable has not been created", LOG_LEVEL_ERROR )
    end if

  end function get_cell_orientation


  !> @brief Function to return the detj values at W2 dof locations
  !> @return The detj field
  function get_detj_at_w2() result(detj)
    implicit none
    type(field_type), pointer :: detj
    detj => detj_at_w2

  end function get_detj_at_w2

  !> @brief Function to return the dA values at W2 dof locations
  !> @return The dA field
  function get_dA_at_w2() result(dA)
    implicit none
    type(field_type), pointer :: dA
    dA => dA_at_w2

  end function get_dA_at_w2

  !> @brief Function to return a pointer to a mass matrix
  !> @param[in] i the index of the desired mass matrix field
  !> @return The mass matrix operator
  function get_mass_matrix(i) result(mm)
    implicit none
    integer(i_def), intent(in) :: i
    type(operator_type), pointer :: mm 

    select case (i)
      case (w0_id)
        mm => mm_w0
      case (w1_id)
        mm => mm_w1
      case (w2_id)
        mm => mm_w2
      case (w3_id)
        mm => mm_w3
      case (w3inv_id)
        mm => mm_w3_inv
      case (wt_id)
        mm => mm_wtheta
      case (theta_space_id)
        mm => mm_wtheta
      case (dl_id)
        mm => mm_dl
      case default
        mm => null()
        call log_event( "Mass matrix operator does not exist", LOG_LEVEL_ERROR)
        stop
    end select

  end function get_mass_matrix

  !> @brief Function to return a pointer to a mass matrix diagonal
  !> @param[in] i Index of the desired mass matrix diagonal field
  !> @return The mass matrix diagonal field
  function get_mass_matrix_diagonal(i) result(mmd)
    implicit none
    integer(i_def), intent(in) :: i
    type(field_type), pointer :: mmd  

    select case (i)
      case (w0_id)
        mmd => mm0_diag
      case (w1_id)
        mmd => mm1_diag
      case (w2_id)
        mmd => mm2_diag
      case (eye_id)
        mmd => eye
      case (wt_id)
        mmd => mmtheta_diag
      case (w3_id)
        mmd => mm3_diag
      case (theta_space_id)
        mmd => mmtheta_diag
      case default
        mmd => null()
        call log_event( "Mass matrix diagonal does not exist", LOG_LEVEL_ERROR)
        stop
    end select

  end function get_mass_matrix_diagonal

  !> @brief Function to return a pointer to the grad operator
  !> @return The grad operator
  function get_grad() result(grad_op)
    implicit none
    type(operator_type), pointer :: grad_op
    grad_op => grad

  end function get_grad

  !> @brief Function to return a pointer to the curl operator
  !> @return The curl operator
  function get_curl() result(curl_op)
    implicit none
    type(operator_type), pointer :: curl_op
    curl_op => curl

  end function get_curl

  !> @brief Function to return a pointer to the div operator
  !> @return The grad operator
  function get_div() result(div_op)
    implicit none
    type(operator_type), pointer :: div_op
    div_op => div

  end function get_div

  !> @brief Function to return a pointer to the quadrature object
  !> @return The quadrature object
  function get_qr() result(qr_obj)
    implicit none
    type(quadrature_xyoz_type), pointer :: qr_obj
    qr_obj => qr

  end function get_qr

  !> @brief Function to return a pointer to a inverse lumped mass matrix
  !> @param[in] i Index of the desired lumped mass matrix inverse field
  !> @return The lumped inverse mass matrix 
  function get_inverse_lumped_mass_matrix(i) result(mm)
    implicit none
    integer(i_def), intent(in) :: i
    type(field_type), pointer :: mm

    select case (i)
      case (w0_id)
        mm => m0_lumped_inv
      case (w1_id)
        mm => m1_lumped_inv
      case (wt_id)
        mm => mt_lumped_inv
      case (theta_space_id)
        mm => mt_lumped_inv
      case default
        mm => null()
        call log_event( "Lumped inverse mass matrix does not exist", LOG_LEVEL_ERROR)
        stop
    end select

  end function get_inverse_lumped_mass_matrix

  !> @brief Function to return a pointer to the reciprocal of the multiplicity field
  !> @return The nodal multiplicity field
  !> @param[in] space enumeration of the function space
  function get_rmultiplicity(space) result(rmultiplicity)
    implicit none
    integer(i_def), intent(in) :: space
    type(field_type), pointer :: rmultiplicity

    select case (space)
      case (W0)
        rmultiplicity => nodal_rmultiplicity_w0
      case (W1)
        rmultiplicity => nodal_rmultiplicity_w1
      case (W2)
        rmultiplicity => nodal_rmultiplicity_w2
      case (W2H)
        rmultiplicity => nodal_rmultiplicity_w2h
      case default
        rmultiplicity => null()
        call log_event( "RMultiplicity does not exist for given space", &
           LOG_LEVEL_ERROR)
    end select

  end function get_rmultiplicity

  !> @brief Function to return a pointer to the normalisation of prognostic fields
  !> @return The normalisation field
  !> @param[in] space enumeration of the function space
  function get_normalisation(space) result(normalisation)
    implicit none
    integer(i_def), intent(in) :: space
    type(field_type), pointer :: normalisation

    select case (space)
      case (w2_id)
        normalisation => w2_normalisation
      case (wt_id)
        normalisation => mt_lumped_inv
      case (theta_space_id)
        normalisation => mt_lumped_inv
      case default
        normalisation => null()
        call log_event( " Normalisation does not exist for given space", &
           LOG_LEVEL_ERROR)
    end select

  end function get_normalisation

  !> @brief Function to return the Coriolis operator
  !> @return The Coriolis operator
  function get_coriolis() result(coriolis_op)
    implicit none
    type(operator_type), pointer :: coriolis_op
    if ( rotating ) then
      coriolis_op => coriolis
    else
      call log_event( "Coriolis operator not computed for nonrotating flow", &
                      LOG_LEVEL_ERROR)
    end if
  end function get_coriolis

  !> @brief Explicitly reclaim memory from module scope variables
  !
  subroutine final_runtime_constants()

    implicit none

    call mm0_diag%field_final() 
    call mm1_diag%field_final() 
    call mm2_diag%field_final() 
    call mm3_diag%field_final() 
    call eye%field_final() 
    call mmtheta_diag%field_final() 
    call mm_w0%operator_final()
    call mm_w1%operator_final()
    call mm_w2%operator_final()
    call mm_w3%operator_final()
    call mm_w3_inv%operator_final()
    call mm_wtheta%operator_final()
    call mm_dl%operator_final()
    call geopotential%field_final() 
    call temp_w2_field%field_final() 
    call cell_orientation%field_final() 
    call detj_at_w2%field_final() 
    call dA_at_w2%field_final() 
    call grad%operator_final()
    call curl%operator_final()
    call div%operator_final()
    call qr%quadrature_final()
    call m0_lumped_inv%field_final() 
    call m1_lumped_inv%field_final() 
    call mt_lumped_inv%field_final() 
    call height_wth%field_final()
    call height_w3%field_final() 
    call nodal_rmultiplicity_w1%field_final() 
    call nodal_rmultiplicity_w2%field_final() 
    call nodal_rmultiplicity_w2h%field_final() 
    call nodal_rmultiplicity_w0%field_final() 
    call w2_normalisation%field_final()

    nullify(coords)

  end subroutine final_runtime_constants

end module runtime_constants_mod
