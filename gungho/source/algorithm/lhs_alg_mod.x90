!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the lhs of the prognostic
!>       equations
module lhs_alg_mod

  use constants_mod,                     only: r_def, i_def
  use runtime_constants_mod,             only: get_coordinates, &
                                               get_div, &
                                               get_mass_matrix, &
                                               get_rmultiplicity, &
                                               w2_id, w3inv_id, theta_space_id
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use finite_element_config_mod,         only: element_order, wtheta_on
  use fs_continuity_mod,                 only: W2
  use transport_config_mod,              only: operators, &
                                               transport_operators_fv
  use field_indices_mod,                 only: igh_u, igh_t, igh_d, igh_p
  use output_config_mod,                 only: subroutine_timers 
  use timer_mod,                         only: timer

  implicit none

  type(field_type), private              :: f_star, r_rho
  type(field_type), allocatable, private :: lhs_tmp(:)
  type(field_type)                       :: mt_lumped
  type( field_type ), target             :: exner_inc
  type(function_space_type), pointer     :: u_fs => null()

  private
  public  :: lhs_alg
  public  :: lhs_init
  private :: on_the_fly_lhs_alg
  private :: operator_lhs_alg
contains

!>@brief Initialise fields to be used for computing the lhs
  subroutine lhs_init(state)
    use field_bundle_mod,          only: clone_bundle
    use derived_config_mod,        only: si_bundle_size
    use matrix_vector_kernel_mod,  only: matrix_vector_kernel_type
    use operator_mod,              only: operator_type

    implicit none

    type(field_type), intent(in) :: state(si_bundle_size)

    type(function_space_type), pointer :: rho_fs => null()
    type(field_type)                   :: ones

    allocate( lhs_tmp(si_bundle_size) )
    call clone_bundle(state, lhs_tmp, si_bundle_size)

    ! For computing lhs_theta
    rho_fs => state(igh_d)%get_function_space()
    ones = field_type( vector_space = rho_fs )
    call invoke( set_field_scalar(1.0_r_def, ones) )
    r_rho = field_type( vector_space = rho_fs )

    ! for computing lhs rho
    u_fs => state(igh_u)%get_function_space()
    f_star = field_type( vector_space = u_fs )

    ! For computing lhs u with operators and diagnostic exner
    exner_inc = field_type( vector_space = rho_fs )

  end subroutine lhs_init
  !============================================================================!
!>@details A wrapper for computing the lhs of the prognostic
!>         equations by choosing certain terms to approximate the 
!>         Jacobian, namely:
!>         \f[
!>         \mathbf{L_u} = \mathbf{u}' 
!>                      + \tau_u\Delta t Cp\left( \theta^*\nabla\Pi'
!>                                                +\theta'\nabla\Pi^*\right)
!>         \f]
!>         \f[ L_\rho = \rho' 
!>                    + tau_r\Delta t\nabla.\left(\rho^*\mathbf{u}'\right) \f]
!>         \f[ L_\theta = \theta' + tau_t\Delta t\mathbf{u}'.\nabla\theta^*\f]
!>
!>         Where primed terms are increments to the n+1 timelevel field and
!>         star terms are a reference profile
!> @param[inout] lhs State vector to compute
!> @param[in]    tau_{u,t,r}_dt Relaxation parameter times the timestep
!> @param[inout] state Current model prognostic state
!> @param[in] ref_state Reference state of the model fields
  subroutine lhs_alg(lhs, state, ref_state, tau_u_dt, tau_t_dt, tau_r_dt)
  use derived_config_mod, only: si_bundle_size, bundle_size
  use solver_config_mod,  only: use_operators

  implicit none
  ! Form of state and lhs is [u,theta,rho,exner]
  type(field_type),                  intent(inout) :: lhs(si_bundle_size)
  type(field_type),                  intent(inout) :: state(si_bundle_size)

  type(field_type),        optional, intent(in)    :: ref_state(bundle_size)
  real(kind=r_def),                  intent(in)    :: tau_u_dt, tau_t_dt, tau_r_dt

  if ( subroutine_timers ) call timer('lhs_alg')
  if ( use_operators ) then
    call operator_lhs_alg(lhs, state, tau_u_dt, tau_t_dt, tau_r_dt)
  else
    call on_the_fly_lhs_alg(lhs, state, ref_state, tau_u_dt, tau_t_dt, tau_r_dt)
  end if
  if ( subroutine_timers ) call timer('lhs_alg')

  end subroutine lhs_alg
  !============================================================================!
  !>@brief Apply LHS terms with operators computed on the fly
  subroutine on_the_fly_lhs_alg(lhs, state, ref_state, tau_u_dt, tau_t_dt, tau_r_dt)
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use formulation_config_mod,            only: eliminate_p
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use rtheta_wtheta_kernel_mod,          only: rtheta_wtheta_kernel_type
  use pert_pressure_gradient_kernel_mod, only: pert_pressure_gradient_kernel_type
  use exner_gradient_kernel_mod,         only: exner_gradient_kernel_type
  use psykal_lite_mod,                   only: invoke_axpy,                             &
                                               invoke_inc_xpby,                         &
                                               invoke_scale_field_data,                 &
                                               invoke_sample_flux_kernel,               &
                                               invoke_rtheta_bd_kernel,                 &
                                               invoke_exner_gradient_bd_kernel,         &
                                               invoke_pert_pressure_gradient_bd_kernel, &
                                               invoke_multiply_field_data
  use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
  use operator_mod,                      only: operator_type
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use w3_solver_kernel_mod,              only: w3_solver_kernel_type
  use derived_config_mod,                only: si_bundle_size, bundle_size
  use lhs_exner_kernel_mod,              only: lhs_exner_kernel_type

  implicit none

  real(kind=r_def),             intent(in)    :: tau_u_dt, tau_t_dt, tau_r_dt
  ! Form of state and lhs is [u,theta,rho,exner]
  type(field_type), target,     intent(inout) :: state(si_bundle_size)
  type(field_type), target,     intent(in)    :: ref_state(bundle_size)
  type(field_type),             intent(inout) :: lhs(si_bundle_size)

  type(quadrature_type)        :: qr
  type(field_type),    pointer :: chi(:)=> null()
  type(operator_type), pointer :: mm_w2 => null(),     &
                                  mm_w3_inv => null(), &
                                  mm_wtheta => null()
  type(operator_type), pointer :: div => null()
  type(field_type),    pointer :: u => null()
  type(field_type),    pointer :: theta => null()
  type(field_type),    pointer :: rho => null()
  type(field_type),    pointer :: exner => null()
  type(field_type),    pointer :: theta_ref => null()
  type(field_type),    pointer :: rho_ref => null()
  type(field_type),    pointer :: w2_rmultiplicity => null()

  ! Get operators from runtime constants
  mm_w2     => get_mass_matrix(w2_id)
  mm_w3_inv => get_mass_matrix(w3inv_id)
  mm_wtheta => get_mass_matrix(theta_space_id)
  chi       => get_coordinates()
  div       => get_div()
  w2_rmultiplicity => get_rmultiplicity( W2 )

  ! dereference state
  u     => state(igh_u)
  theta => state(igh_t)
  rho   => state(igh_d)

  theta_ref => ref_state(igh_t)
  rho_ref   => ref_state(igh_d)

  qr = quadrature_type(element_order+2, GAUSSIAN)

  ! Compute lhs_u
  call invoke( set_field_scalar(0.0_r_def, lhs_tmp(igh_u)), &
               set_field_scalar(0.0_r_def, lhs(igh_u)) )
  if ( eliminate_p ) then
    if(wtheta_on) then
      call invoke_pert_pressure_gradient_bd_kernel( lhs_tmp(igh_u), rho, rho_ref, &
                                                    theta, theta_ref, qr )
    end if
    call invoke( pert_pressure_gradient_kernel_type(  &
                   lhs_tmp(igh_u), rho, rho_ref, theta, theta_ref, qr ), &
                 matrix_vector_kernel_type( lhs(igh_u), u, mm_w2) )
  else 
    ! Use r_rho as a zero field so that exner' = 0 in pert_pressure_gradient_kernel
    call invoke( set_field_scalar(0.0_r_def, r_rho) )
    exner => state(igh_p)

    if(wtheta_on) then
      call invoke_exner_gradient_bd_kernel( lhs_tmp(igh_u), exner, theta_ref, qr )
      call invoke_pert_pressure_gradient_bd_kernel( lhs_tmp(igh_u), r_rho, rho_ref, &
                                                     theta, theta_ref, qr )
    end if
    call invoke( exner_gradient_kernel_type( lhs_tmp(igh_u), exner, theta_ref, qr ), &
                 pert_pressure_gradient_kernel_type( lhs_tmp(igh_u), r_rho, rho_ref, &
                                                     theta, theta_ref, qr ), &
                 matrix_vector_kernel_type( lhs(igh_u), u, mm_w2) )

  end if
  call invoke_inc_xpby( lhs(igh_u), -tau_u_dt, lhs_tmp(igh_u) )
  call invoke( enforce_bc_kernel_type( lhs(igh_u) ) )
 
  qr = quadrature_type(element_order+1, GAUSSIAN)

  ! Compute lhs_theta
  call invoke( set_field_scalar(0.0_r_def, lhs_tmp(igh_t)), &
               set_field_scalar(0.0_r_def, lhs(igh_t)) )
  if(wtheta_on) then
    call invoke_rtheta_bd_kernel ( lhs_tmp(igh_t), theta_ref, u, qr )
    call invoke( rtheta_wtheta_kernel_type( lhs_tmp(igh_t), theta_ref, u, qr), &
                 matrix_vector_kernel_type( lhs(igh_t), theta, mm_wtheta ) )
  else
    call invoke( rtheta_kernel_type( lhs_tmp(igh_t), theta_ref, u, qr), &
                 matrix_vector_kernel_type( lhs(igh_t), theta, mm_wtheta ) )
  end if
  call invoke_inc_xpby( lhs(igh_t), tau_t_dt, lhs_tmp(igh_t) )

  ! Compute lhs_rho
  ! Need to create u*rho^ref \in W2 for lhs_tmp(igh_d) kernel -> sampled mass flux
  call invoke( set_field_scalar(0.0_r_def, f_star), &
               set_field_scalar(0.0_r_def, r_rho),  &
               set_field_scalar(0.0_r_def, lhs_tmp(igh_d)) )
  call invoke_sample_flux_kernel( f_star, u, w2_rmultiplicity, rho_ref )
  call invoke( matrix_vector_kernel_type(r_rho, f_star, div) )
  call invoke_scale_field_data(-1.0_r_def, r_rho) 
  call invoke( matrix_vector_kernel_type( lhs_tmp(igh_d), r_rho, mm_w3_inv) )
  call invoke_axpy( -tau_r_dt, lhs_tmp(igh_d), rho, lhs(igh_d) )

  ! Compute lhs exner
  if ( .not. eliminate_p ) then
    exner => state(igh_p)
    call invoke( set_field_scalar(0.0_r_def, lhs(igh_p)), &
                 set_field_scalar(0.0_r_def, lhs_tmp(igh_p)) )
    call invoke( lhs_exner_kernel_type(lhs_tmp(igh_p), theta, rho, exner, &
                                       theta_ref, rho_ref, chi, qr ) )
    call invoke( matrix_vector_kernel_type( lhs(igh_p), lhs_tmp(igh_p), mm_w3_inv) )

  end if

  end subroutine on_the_fly_lhs_alg

  !============================================================================!
  !>@brief Apply LHS terms with precomputed operators
  subroutine operator_lhs_alg(lhs, state, tau_u_dt, tau_t_dt, tau_r_dt)

  use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
  use operator_mod,                       only: operator_type
  use derived_config_mod,                 only: si_bundle_size
  use si_operators_alg_mod,               only: get_p2theta,       &
                                                get_div_star,      &
                                                get_ptheta2,       &
                                                get_m3_rho_star,   &
                                                get_m3_exner_star, &
                                                get_m3_exner_star_inv, &
                                                get_p3theta, &
                                                get_rho_at_u
  use planet_config_mod,                  only: cp
  use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
  use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type
  use formulation_config_mod,             only: eliminate_p
  implicit none

  ! Form of state and lhs is [u,theta,rho]       if eliminate_p
  ! Form of state and lhs is [u,theta,rho,exner] if not eliminate_p
  type(field_type), target,        intent(inout) :: state(si_bundle_size)
  type(field_type),                intent(inout) :: lhs(si_bundle_size)
  real(kind=r_def),                intent(in)    :: tau_u_dt, tau_t_dt, tau_r_dt

  type(operator_type), pointer :: mm_w2 => null(), mm_w3_inv => null(), mm_wtheta => null()
  type(operator_type), pointer :: div => null()
  type(field_type),    pointer :: u ,theta, rho, exner => null()
  type(operator_type), pointer :: p2theta => null(), &
                                  div_star => null(), &
                                  ptheta2 => null(), &
                                  m3_rho_star => null(), &
                                  m3_exner_star => null(), &
                                  p3theta => null(), &
                                  m3_exner_star_inv => null()
  type(field_type),    pointer :: rho_at_u => null()
  real(kind=r_def)             :: s1
  real(kind=r_def), parameter  :: minus_one = -1.0_r_def

  ! Function spaces for input variables, these are not needed but used for psyclone reasoning
  ! W2 => state(igh_u)%get_function_space()
  ! Wt => state(igh_t)%get_function_space()
  ! W3 => state(igh_d)%get_function_space()
  ! W2 => lhs(igh_u)%get_function_space()
  ! Wt => lhs(igh_t)%get_function_space()
  ! W3 => lhs(igh_d)%get_function_space()
  ! if ( .not. eliminate_p ) then
  !   W3 => state(igh_p)%get_function_space()
  !   W3 => lhs(igh_p)%get_function_space()
  ! end if 

  ! Dereference the state variable
  u     => state(igh_u)
  theta => state(igh_t)
  rho   => state(igh_d)

  ! Obtain operators from runtime constants
  mm_w2      => get_mass_matrix(w2_id)
  mm_w3_inv  => get_mass_matrix(w3inv_id)
  mm_wtheta  => get_mass_matrix(theta_space_id)
  div        => get_div()

  ! Obtain operators from si operators
  p2theta       => get_p2theta()
  div_star      => get_div_star()
  ptheta2       => get_ptheta2()
  m3_rho_star   => get_m3_rho_star()
  m3_exner_star => get_m3_exner_star()
  p3theta       => get_p3theta()
  rho_at_u      => get_rho_at_u()

  ! Combine constants
  s1 = -tau_u_dt*cp

  if ( eliminate_p ) then
    ! Recompute exner' from linear eos
    m3_exner_star_inv => get_m3_exner_star_inv()
    exner => exner_inc
    call invoke( name="Compute diagnostic exner increment",                  &
                 dg_matrix_vector_kernel_type(lhs(igh_d), rho, m3_rho_star), &
                 matrix_vector_kernel_type(lhs(igh_d), theta, p3theta),      &
                 dg_matrix_vector_kernel_type( exner_inc, lhs(igh_d),        &
                                               m3_exner_star_inv ),          &
                 set_field_scalar( 0.0_r_def, lhs(igh_d) )                   &
               )
  else
    exner => state(igh_p)
  end if

  ! Use operators
  ! Initialise lhs_u and lhs_theta to 0
  call invoke( name="Compute mixed lhs",                                            &
  ! Initialise field that are incremented 
               set_field_scalar(0.0_r_def, lhs_tmp(igh_u)),                         &
               set_field_scalar(0.0_r_def, lhs(igh_u)),                             &
               set_field_scalar(0.0_r_def, lhs_tmp(igh_t)),                         &
               set_field_scalar(0.0_r_def, lhs(igh_t)),                             &
  ! L_u
               matrix_vector_kernel_type(lhs(igh_u), theta, p2theta),               &
               matrix_vector_kernel_type(lhs(igh_u), exner, div_star),              &
               matrix_vector_kernel_type(lhs_tmp(igh_u), u, mm_w2),                 &
               inc_axpy(s1,lhs(igh_u), lhs_tmp(igh_u)),                             &
               enforce_bc_kernel_type( lhs(igh_u) ),                                &
  ! L_theta
               matrix_vector_kernel_type(lhs(igh_t), u, ptheta2),                   &
               matrix_vector_kernel_type(lhs_tmp(igh_t), theta, mm_wtheta),         &
               inc_axpy(tau_t_dt,lhs(igh_t), lhs_tmp(igh_t)),                         &
  ! L_rho
               multiply_fields(rho_at_u, u, f_star),                                &
               dg_matrix_vector_kernel_type(lhs_tmp(igh_d), f_star, div),           &
               dg_matrix_vector_kernel_type(lhs(igh_d), lhs_tmp(igh_d), mm_w3_inv), &
               inc_axpy(tau_r_dt, lhs(igh_d), rho)                                    &
              )

  if ( .not. eliminate_p ) then
    ! L_pi 
    call invoke( name="Compute pressure lhs",                                         & 
                 dg_matrix_vector_kernel_type(lhs(igh_p), rho, m3_rho_star),          &
                 matrix_vector_kernel_type(lhs(igh_p), theta, p3theta),               &
                 dg_matrix_vector_kernel_type(lhs_tmp(igh_p), exner, m3_exner_star),  &
                 inc_axpby(1.0_r_def, lhs_tmp(igh_p), minus_one, lhs(igh_p)),        &
                 dg_matrix_vector_kernel_type( lhs(igh_p), lhs_tmp(igh_p), mm_w3_inv) &
               )
  end if
  end subroutine operator_lhs_alg
  !============================================================================!

end module lhs_alg_mod


