!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief A two time-level iterative time-discretisation of the nonlinear 
!>       3D equations
module iter_timestep_alg_mod

  use constants_mod,             only: i_def,r_def
  use log_mod,                   only: log_event,         &
                                       log_scratch_space, &
                                       LOG_LEVEL_INFO,    &
                                       LOG_LEVEL_TRACE

  ! Configuration options
  use restart_control_mod,       only: restart_type
  use formulation_config_mod,    only: use_moisture, use_physics, dlayer_on, &
                                       use_wavedynamics,          &
                                       dry_static_adjust
  use output_config_mod,         only: diagnostic_frequency, subroutine_timers
  use solver_config_mod,         only: method, helmholtz_solve, use_operators, &
                                       guess_np1, &
                                       reference_reset_freq
  use timestepping_config_mod,   only: dt, alpha, &
                                       outer_iterations, inner_iterations, &
                                       spinup_period, spinup_alpha, spinup_winds
  use derived_config_mod,        only: bundle_size
  use runtime_constants_mod,     only: get_qr, get_coordinates, get_height, &
                                       get_mass_matrix, get_da_at_w2,       &
                                       w3inv_id,                            &
                                       theta_space_id, w2_id,               &
                                       get_normalisation

  use fs_continuity_mod,         only: W3, Wtheta

  ! PsyKAl-lite kernels
  use psykal_lite_mod,           only: invoke_tracer_viscosity, &
                                       invoke_momentum_viscosity

  use field_bundle_mod,          only: clone_bundle,      & 
                                       bundle_axpy,       & 
                                       bundle_axpby,      &
                                       add_bundle,        &
                                       copy_bundle,       &
                                       set_bundle_scalar, &
                                       bundle_ax 
  ! PsyKAl PSYClone kernels
  use project_pressure_kernel_mod, only: project_pressure_kernel_type
  use sort_ref_kernel_mod,         only: sort_ref_kernel_type
  use extract_w_kernel_mod,        only: extract_w_kernel_type

  ! Derived Types
  use field_mod,                 only: field_type
  use quadrature_xyoz_mod,       only: quadrature_xyoz_type
  use operator_mod,              only: operator_type

  ! xios output
  use output_config_mod,         only : write_xios_output
  use io_mod,                    only : output_xios_nodal

  ! Algorithms
  use solver_mod,                  only: solver_algorithm
  use rhs_alg_mod,                 only: rhs_alg
  use advection_alg_mod,           only: advection_alg, advection_alg_init, advection_mr_alg
  use si_solver_alg_mod,           only: si_solver_alg, si_solver_init
  use si_operators_alg_mod,        only: create_si_operators, compute_si_operators
  use helmholtz_solver_alg_mod,    only: helmholtz_solver_init, &
                                         compute_inv_hb
  use fast_physics_alg_mod,        only: fast_physics
  use slow_physics_alg_mod,        only: slow_physics
  use checks_and_balances_alg_mod, only: check_fields
 
  ! Field mappings
  use map_physics_fields_alg_mod,only: map_physics_fields_alg

  ! Moisture species
  use mr_indices_mod,            only: nummr

  ! Field indices
  use field_indices_mod,         only: igh_u, igh_t, igh_d, igh_p

  ! Mixing settings
  use mixing_config_mod,         only: viscosity
#ifdef UM_PHYSICS
  ! UM BL scheme
  use bl_init_mod, only: bl_init
  use bl_alg_mod,  only: bl_alg_step
#endif

  use timer_mod,                 only: timer

  implicit none

  private

  ! 'State' items private to the algorithm that need to be 
  !  created once but used every step
  type( field_type ), allocatable :: state(:), state_n(:), reference_state(:)
  type( field_type ), allocatable :: rhs_n(:), rhs_np1(:), rhs_adv(:)
  type( field_type ), allocatable :: rhs_phys(:), inc(:)
  type( field_type ) :: u_adv   ! Advective wind (centered in time)
  type( field_type ) :: u_physics ! winds for physics
  type( field_type ) :: w_physics ! copy of vertical winds for physics
  type( field_type ) :: dtheta ! increment to theta
  type( field_type ) :: du ! increment to u


  public :: iter_alg_init
  public :: iter_alg_step

contains

  !> @details Initialisation procedure for the timestepping algorithm
  !>          Initialises various internal fields
  !> @param[in]    mesh_id Mesh id of the mesh object on which the model runs
  !> @param[inout] u  3D wind field
  !> @param[inout] rho Density
  !> @param[inout] theta Potential temperature
  !> @param[inout] exner Exner pressure
  !> @param[inout] tstar_2d   Surface tempature
  !> @param[inout] zh_2d      Boundary layer depth
  !> @param[inout] z0msea_2d  Roughness length
  subroutine iter_alg_init( mesh_id, u, rho, theta, exner, &
                            tstar_2d, zh_2d, z0msea_2d )

    implicit none

    ! Mesh
    integer(i_def), intent(in) :: mesh_id 

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta, exner, &
                                           tstar_2d, zh_2d, z0msea_2d

    !--------------------------------------------------------------------
    ! Allocate internal state field arrays
    !--------------------------------------------------------------------

    allocate(state(bundle_size))
    allocate(state_n(bundle_size))
    allocate(reference_state(bundle_size))
    allocate(rhs_n(bundle_size))
    allocate(rhs_np1(bundle_size))
    allocate(rhs_adv(bundle_size))
    allocate(rhs_phys(bundle_size))
    allocate(inc(bundle_size))

    !--------------------------------------------------------------------
    ! Initialise internal state field objects
    !--------------------------------------------------------------------

    call u%copy_field_properties( state(igh_u) )
    call theta%copy_field_properties( state(igh_t) )
    call rho%copy_field_properties( state(igh_d) )
    call exner%copy_field_properties( state(igh_p) )

    call clone_bundle(state, state_n,   bundle_size)
    call clone_bundle(state, rhs_n,     bundle_size)
    call clone_bundle(state, rhs_np1,   bundle_size)
    call clone_bundle(state, rhs_adv,   bundle_size)
    call clone_bundle(state, rhs_phys,  bundle_size)
    call clone_bundle(state, inc,       bundle_size)
    call clone_bundle(state, reference_state, bundle_size)

    call theta%copy_field_properties(dtheta)
    call u%copy_field_properties(du)
    call u%copy_field_properties(u_physics)
    call theta%copy_field_properties(w_physics)

    !--------------------------------------------------------------------
    ! If held-suarez forcing is not used, then we want the following to be 
    ! initialized to zero
    !--------------------------------------------------------------------
    call set_bundle_scalar(0.0_r_def, rhs_phys, bundle_size)

    !--------------------------------------------------------------------
    ! Operators for si solves
    !--------------------------------------------------------------------
    if ( helmholtz_solve ) call helmholtz_solver_init(state)
    if ( helmholtz_solve .or. use_operators ) call create_si_operators(mesh_id)

    !--------------------------------------------------------------------
    ! Copy prognostic field data to state arrays
    !--------------------------------------------------------------------
    call invoke( name = "Copy init fields to state", &
                 setval_X(state(igh_u), u    ),      &
                 setval_X(state(igh_t), theta),      &
                 setval_X(state(igh_d), rho  ),      &
                 setval_X(state(igh_p), exner) )
    call si_solver_init(state)
    call advection_alg_init(mesh_id)

    call u%copy_field_properties( u_adv )

    ! Set initial reference state 
    call copy_bundle(state, reference_state, bundle_size)
    if (dry_static_adjust)call invoke( sort_ref_kernel_type(reference_state(igh_t) ) )  

#ifdef UM_PHYSICS
    if ( use_physics ) then
      ! Initialization for the UM boundary layer
      call bl_init(theta, tstar_2d, zh_2d, z0msea_2d)
    end if
#endif

    call log_event( "iter_timestep: initialised timestepping algorithm", LOG_LEVEL_INFO )

  end subroutine iter_alg_init

  !> @details An algorithm for timestepping the 3D nonlinear equations
  !>          using an iterative process of the same form as endgame.
  !>          The algorithm splits all processes into one of three parts.
  !>          Old time level forcings computed once per timestep.
  !>          Advection terms computed in an outer loop using time-averaged
  !>          fields.
  !>          New time level forcings computed in an inner loop.
  !>          If matching ENDGame, 2 outer and 2 inner loops are used per timestep
  !>          by default. This means that there is one evaluation of old time
  !>          level terms, 2 evaluation of advective terms and 4 evaluations 
  !>          of new time level terms and increment updates per timestep
  !> @param[inout] u  3D wind field
  !> @param[inout] rho Density
  !> @param[inout] theta Potential temperature
  !> @param[inout] exner Exner pressure
  !> @param[inout] mr Mixing ratios
  !> @param[inout] xi Vorticity field
  !> @param[inout] u1_in_w3 Component of wind on w3 space
  !> @param[inout] u2_in_w3 Component of wind on w3 space
  !> @param[inout] u3_in_w3 Component of wind on w3 space
  !> @param[inout] rho_in_wth Rho on wth space
  !> @param[inout] theta_in_w3 Theta on w3 space
  !> @param[inout] exner_in_wth Pressure on wth space
  !> @param[inout] tstar_2d   Surface tempature
  !> @param[inout] zh_2d      Boundary layer depth
  !> @param[inout] z0msea_2d  Roughness length
  !> @param[in]    timestep model timestep number
  subroutine iter_alg_step(u, rho, theta, exner, mr, xi, &
                           u1_in_w3, u2_in_w3, u3_in_w3, &
                           rho_in_wth, theta_in_w3,      &
                           exner_in_wth, tstar_2d,       &
                           zh_2d, z0msea_2d, timestep)

    implicit none

    ! Prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta, exner, xi
    type( field_type ), intent( inout ) :: u1_in_w3, u2_in_w3, u3_in_w3
    type( field_type ), intent( inout ) :: rho_in_wth, theta_in_w3
    type( field_type ), intent( inout ) :: exner_in_wth
    type( field_type ), intent( inout ) :: mr(nummr)
    ! UM 2d fields
    type( field_type ), intent( inout ) :: tstar_2d, zh_2d, z0msea_2d
    ! Timestep value
    integer, intent(in) :: timestep  

    ! Quadrature object
    type( quadrature_xyoz_type ) :: qr
    ! Coordinate fields
    type( field_type ), pointer  :: chi(:) => null()

    type( field_type ), pointer :: height_w3  => null()
    type( field_type ), pointer :: height_wth => null()
    type( field_type ), pointer :: t_normalisation => null()
    type( field_type ), pointer :: u_normalisation => null()
    type(operator_type), pointer :: m3_inv => null()
    type( field_type ), pointer  :: dA => null() ! Areas of faces

    integer(kind=i_def):: outer, inner, iter
    real(kind=r_def)   :: varalpha, varbeta ! alpha, beta weight to use
                                            ! these may differ from input values
                                            ! during the spinup period

    real(kind=r_def), dimension(bundle_size) :: si_err

    if ( subroutine_timers ) call timer('iter_timestep_alg')

    qr = get_qr()
    chi => get_coordinates()
    height_w3  => get_height(W3)
    height_wth => get_height(Wtheta)
    dA => get_da_at_w2()
    !--------------------------------------------------------------------
    ! Pass updated fields into state
    !--------------------------------------------------------------------
    if (spinup_winds .and. timestep*dt <= spinup_period) then
      call invoke( name = "Copy step fields to state", &
                   setval_X(state(igh_u), u    ),      &
                   setval_X(state(igh_t), theta),      &
                   setval_X(state(igh_d), rho  ),      &
                   setval_X(state(igh_p), exner) )
    end if

    if (spinup_alpha .and. timestep*dt <= spinup_period) then
      varalpha = alpha + (spinup_period - timestep*dt + 1) * &
         (1.0 - alpha)/spinup_period
    else
      varalpha = alpha
    end if
    varbeta = 1.0 - varalpha

    ! Perform some checking on the fields.
    call check_fields(state)

    !============================================================================
    ! Fields for physics
    !============================================================================
    if (use_physics)then
      call map_physics_fields_alg(state(igh_u), state(igh_p),                  & 
                                  state(igh_d), state(igh_t),                  &
                                  u1_in_w3, u2_in_w3, u3_in_w3, theta_in_w3,   &
                                  exner_in_wth, rho_in_wth, timestep)
      !--------------------------------------------------------------------
      ! Call the slow physics terms
      !--------------------------------------------------------------------
      call invoke( setval_c(dtheta, 0.0_r_def) )
      call invoke( setval_c(du, 0.0_r_def) )
      call invoke( X_divideby_Y(u_physics, u, dA) )
      call invoke( extract_w_kernel_type(w_physics, u_physics) )
      call u_physics%log_minmax(LOG_LEVEL_INFO, 'u_physics')
      call w_physics%log_minmax(LOG_LEVEL_INFO, 'w_physics')
      if (write_xios_output) then
        call output_xios_nodal("w_physics", w_physics, w_physics%get_mesh_id())
      end if
      call slow_physics(chi, du, u_physics, dtheta, theta, exner_in_wth)
      call invoke(inc_X_times_Y(du,dA)) ! This is the map back
      call invoke(name="update from slow physics", &
                  inc_X_plus_Y(state(igh_t), dtheta), &
                  inc_X_plus_Y(state(igh_u), du), &
                  )
      call log_event( "slow physics: completed slow physics.", LOG_LEVEL_INFO )
    end if

    if (use_wavedynamics) then

      call copy_bundle(state, state_n, bundle_size)
      call rhs_alg(rhs_n, varbeta*dt, state_n, .false., .false.)

      !============================================================================
      ! Start the Outer (advection) loop
      !============================================================================
      outer_dynamics_loop: do outer = 1,outer_iterations

        if (use_physics) then
          ! If outer == 1 then the n+1 fields are the same as the n fields and
          ! so the remapping does not need to be done again 
          if ( outer > 1 ) &
            call map_physics_fields_alg(state(igh_u), state(igh_p),              & 
                                        state(igh_d), state(igh_t),              &
                                        u1_in_w3, u2_in_w3, u3_in_w3,            &
                                        theta_in_w3, exner_in_wth, rho_in_wth,   &
                                        timestep)
          !--------------------------------------------------------------------
          ! Call the fast physics terms
          !--------------------------------------------------------------------
          call fast_physics(chi, state, rhs_phys)
          call log_event( "iter_timestep: completed fast physics.", LOG_LEVEL_INFO )
        end if

        ! Set advecting velocity & terms
        call invoke( aX_plus_bY(u_adv, varbeta, state_n(igh_u), varalpha, state(igh_u)) )
        call advection_alg(rhs_adv, state_n, xi, u_adv)
        if ( use_moisture ) call advection_mr_alg(mr, u_adv)
        call bundle_ax(dt, rhs_adv, rhs_adv, bundle_size) 

        !============================================================================
        ! Start the Inner (nonlinear, coriolis) loop
        !============================================================================
        inner_dynamics_loop: do inner = 1,inner_iterations
          if ( guess_np1 ) then
            ! rho^np1 and theta^np1 can be directly guessed from advection terms
            call invoke( X_plus_Y(state(igh_d), rhs_adv(igh_d), rhs_n(igh_d)), &
                         X_plus_Y(inc(igh_t), rhs_adv(igh_t), rhs_n(igh_t)) )
            call solver_algorithm(state(igh_t), inc(igh_t))
            ! exner^np1 can be directly guessed from eos
            m3_inv => get_mass_matrix(w3inv_id)
          
            call invoke( project_pressure_kernel_type( state(igh_p), state(igh_d), state(igh_t), &
                                                       chi, m3_inv, qr ) )
          end if
          ! Reset reference state using latest guess
          iter = inner + (outer-1)*inner_iterations
          if ( mod(iter-1_i_def,reference_reset_freq) == 0_i_def ) then
            call copy_bundle(state, reference_state, bundle_size) 
            if (dry_static_adjust)call invoke( sort_ref_kernel_type(reference_state(igh_t) ) )  
            if ( helmholtz_solve .or. use_operators ) call compute_si_operators(reference_state)
            if ( helmholtz_solve ) call compute_inv_hb()
          end if

          call rhs_alg(rhs_np1, -varalpha*dt, state, .true., dlayer_on)

          !--------------------------------------------------------------------
          ! Solve for the increments
          !
          ! Add on advective terms: rhs = rhs_n - rhs_np1 + rhs_adv
          ! (reuse rhs_np1 for rhs)
          !--------------------------------------------------------------------
          call bundle_axpy(-1.0_r_def, rhs_np1, rhs_n, rhs_np1, bundle_size)
          call add_bundle(rhs_np1, rhs_adv, rhs_np1, bundle_size)
          call add_bundle(rhs_np1, rhs_phys, rhs_np1, bundle_size)

          ! Normalise theta & u residual
          t_normalisation => get_normalisation(theta_space_id)
          u_normalisation => get_normalisation(w2_id)
          call invoke( inc_X_times_Y(rhs_np1(igh_t), t_normalisation), &
                       inc_X_times_Y(rhs_np1(igh_u), u_normalisation) )
          write( log_scratch_space, '(A,2I3)' ) 'loop indices (o, i): ', &
                                                    , outer, inner
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          ! Write out si residuals
          call invoke( name = "Compute SI residuals",           &
                       X_innerproduct_X(si_err(igh_u), rhs_np1(igh_u)), &
                       X_innerproduct_X(si_err(igh_t), rhs_np1(igh_t)), &
                       X_innerproduct_X(si_err(igh_d), rhs_np1(igh_d)), &
                       X_innerproduct_X(si_err(igh_p), rhs_np1(igh_p))  &
                     )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in momentum equation:  ',sqrt(si_err(igh_u))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in energy equation:    ',sqrt(si_err(igh_t))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in continuity equation:',sqrt(si_err(igh_d))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in equation of state:  ',sqrt(si_err(igh_p))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          call si_solver_alg(state, rhs_np1, reference_state)
          ! Recompute exner from eos
          m3_inv => get_mass_matrix(w3inv_id)
          call invoke( project_pressure_kernel_type( state(igh_p), state(igh_d), state(igh_t), &
                                                     chi, m3_inv, qr ) )
        end do inner_dynamics_loop
        !--------------------------------------------------------------------
        ! End of Inner (nonlinear, coriolis) loop
        !--------------------------------------------------------------------

      end do outer_dynamics_loop
      !--------------------------------------------------------------------
      ! End of Outer (advection) loop
      !--------------------------------------------------------------------

    end if ! use_wavedynamics

    !--------------------------------------------------------------------
    ! Apply viscosity
    !--------------------------------------------------------------------
    if ( viscosity ) then
      call log_event( 'Applying Viscosity', LOG_LEVEL_INFO ) 
      call invoke_tracer_viscosity(   inc(igh_t), state(igh_t), 1, chi)
      call invoke_momentum_viscosity( inc(igh_u), state(igh_u), 1, chi)
      call invoke( setval_c(inc(igh_d), 0.0_r_def) ) 
      call bundle_axpy(dt, inc, state, state, bundle_size)
    end if    

#ifdef UM_PHYSICS
    if ( use_physics ) then
      ! Algorithm that calls the UM Boundary Layer scheme
      ! NB. this needs moving into fast and slow physics ultimately, but
      ! that will be done in a later ticket as changes need to happen
      ! to the model state first...
      call bl_alg_step(state(igh_t), rho, rho_in_wth, state(igh_p), &
                       exner_in_wth,                                &
                       u1_in_w3, u2_in_w3, height_w3, height_wth,   &
                       tstar_2d, zh_2d, z0msea_2d)
    end if
#endif
    
    if (use_wavedynamics) then
      if (.not. (spinup_winds .and. timestep*dt <= spinup_period)) then
        !--------------------------------------------------------------------
        ! Return field in u array
        !--------------------------------------------------------------------
        call invoke( setval_X(u, state(igh_u)) )
      end if
      !--------------------------------------------------------------------
      ! Return fields in theta, rho, exner arrays
      !--------------------------------------------------------------------
      call invoke( setval_X(theta, state(igh_t)), &
                   setval_X(rho,   state(igh_d)), &
                   setval_X(exner, state(igh_p)) )
    else
      !--------------------------------------------------------------------
      ! Return field in theta array only
      !--------------------------------------------------------------------
      call invoke( setval_X(theta, state(igh_t)) )
    end if

    if ( subroutine_timers ) call timer('iter_timestep_alg')

  end subroutine iter_alg_step

end module iter_timestep_alg_mod
