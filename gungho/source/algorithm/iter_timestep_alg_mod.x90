!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief A two time-level iterative time-discretisation of the nonlinear 
!>       3D equations
module iter_timestep_alg_mod

  use constants_mod,             only: i_def,r_def
  use log_mod,                   only: log_event,         &
                                       log_scratch_space, &
                                       LOG_LEVEL_INFO,    &
                                       LOG_LEVEL_TRACE,   &
                                       LOG_LEVEL_ERROR

  ! Configuration options
  use section_choice_config_mod, only: boundary_layer,     &
                                       boundary_layer_um,  &
                                       radiation,          &
                                       radiation_socrates, &
                                       cloud,              &
                                       cloud_um

  use formulation_config_mod,    only: use_moisture, use_physics, dlayer_on, &
                                       use_wavedynamics,          &
                                       dry_static_adjust,         &
                                       exner_from_eos
  use io_config_mod,             only: subroutine_timers
  use mixed_solver_config_mod,   only: guess_np1,                                &
                                       reference_reset_freq
  use timestepping_config_mod,   only: dt, alpha, &
                                       outer_iterations, inner_iterations, &
                                       spinup_period, spinup_alpha, spinup_winds
  use derived_config_mod,        only: bundle_size
  use runtime_constants_mod,     only: get_qr, get_coordinates, get_height, &
                                       get_mass_matrix, get_da_at_w2,       &
                                       get_delta_at_wtheta, w3inv_id,       &
                                       get_max_diff,                        &
                                       theta_space_id, w2_id,               &
                                       get_normalisation
  use fs_continuity_mod,         only: W3, Wtheta

  ! PsyKAl-lite kernels
  use psykal_lite_mod,           only: invoke_tracer_viscosity, &
                                       invoke_momentum_viscosity

  use field_bundle_mod,          only: clone_bundle,      & 
                                       bundle_axpy,       & 
                                       bundle_axpby,      &
                                       add_bundle,        &
                                       copy_bundle,       &
                                       set_bundle_scalar, &
                                       bundle_ax 
  ! PsyKAl PSYClone kernels
  use project_pressure_kernel_mod,        only: project_pressure_kernel_type
  use sort_ref_kernel_mod,                only: sort_ref_kernel_type
  use extract_w_kernel_mod,               only: extract_w_kernel_type
  use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
  use smagorinsky_shear_kernel_mod,       only: smagorinsky_shear_kernel_type
  use tracer_smagorinsky_diff_kernel_mod, only: tracer_smagorinsky_diff_kernel_type
  use moist_dyn_factors_kernel_mod,       only: moist_dyn_factors_kernel_type

  ! Derived Types
  use field_mod,                 only: field_type
  use field_collection_mod,      only: field_collection_type
  use quadrature_xyoz_mod,       only: quadrature_xyoz_type
  use operator_mod,              only: operator_type

  ! Algorithms
  use mass_matrix_solver_alg_mod,  only: mass_matrix_solver_alg
  use rhs_alg_mod,                 only: rhs_alg
  use advection_alg_mod,           only: advection_alg,       &
                                         advection_alg_init,  &
                                         advection_alg_final, &
                                         advection_mr_alg
  use si_operators_alg_mod,        only: create_si_operators,  &
                                         compute_si_operators, &
                                         final_si_operators
  use fast_physics_alg_mod,        only: fast_physics
  use slow_physics_alg_mod,        only: slow_physics
  use checks_and_balances_alg_mod, only: check_fields

  use semi_implicit_solver_alg_mod, only: semi_implicit_solver_alg_init, &
                                          semi_implicit_solver_alg_step, &
                                          semi_implicit_solver_alg_final
  use field_vector_mod,             only: field_vector_type 

  ! Field mappings
  use map_physics_fields_alg_mod, only: map_physics_fields_alg
  use physics_mappings_alg_mod,   only: map_physics_winds, &
                                        map_physics_scalars

  ! Moisture species
  use mr_indices_mod,             only: nummr, imr_v, imr_cl
  use moist_dyn_mod,              only: num_moist_factors, gas_law

  ! Field indices
  use field_indices_mod,          only: igh_u, igh_t, igh_d, igh_p

  ! Mixing settings
  use mixing_config_mod,          only: viscosity, smagorinsky, mix_factor

  ! Physics settings

#ifdef UM_PHYSICS
  use um_init_mod,                only: um_init
  use socrates_init_mod,          only: socrates_init
  use cld_alg_mod,                only: cld_alg_step
  use cloud_config_mod,           only: scheme, &
                                        scheme_smith
#endif

  use timer_mod,                  only: timer

  implicit none

  private

  ! 'State' items private to the algorithm that need to be 
  !  created once but used every step

  ! latest estimate of the prognostic fields throughout the timestep
  type( field_type ), allocatable :: state(:)
  ! prognostic fields at time level n, i.e. start of timestep
  type( field_type ), allocatable :: state_n(:)
  ! prognostic fields after slow physics, i.e. state_n + slow incs
  type( field_type ), allocatable :: state_after_slow(:) 
  type( field_type ), allocatable :: reference_state(:)
  type( field_type ), allocatable :: mr_n(:), mr_inc(:), mr_after_slow(:)
  type( field_type ), allocatable :: rhs_n(:), rhs_np1(:), rhs_adv(:)
  type( field_type ), allocatable :: rhs_phys(:), inc(:)
  type( field_type ) :: u_adv   ! Advective wind (centered in time)
  type( field_type ) :: dtheta ! increment to theta
  type( field_type ) :: dtheta_cld ! increment to theta from cloud
  type( field_type ) :: du ! increment to u
       
  type( field_vector_type ) :: vector_state, vector_rhs
 
  type( field_type ) :: shear ! shear term
  type( field_type ) :: visc_m ! Smagorinsky diffusion coefficient for momentum
  type( field_type ) :: visc_h ! Smagorinsky diffusion coefficient for scalars
  logical            :: helmholtz_solve

  public :: iter_alg_init
  public :: iter_alg_step
  public :: iter_alg_final

contains

  !> @details Initialisation procedure for the timestepping algorithm
  !>          Initialises various internal fields
  !> @param[in]    mesh_id Mesh id of the mesh object on which the model runs
  !> @param[in,out] u  3D wind field
  !> @param[in,out] rho Density
  !> @param[in,out] theta Potential temperature
  !> @param[in,out] exner Exner pressure
  !> @param[in,out] mr Mixing ratios
  !> @param[in,out] twodfields 2D field collection for UM physics
  subroutine iter_alg_init( mesh_id, u, rho, theta, exner, mr, &
                            twod_fields )

    implicit none

    ! Mesh
    integer(i_def), intent(in) :: mesh_id

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta, exner
    type( field_collection_type ), intent(inout)  :: twod_fields
    type( field_type ), intent( inout ) :: mr(nummr)

    !--------------------------------------------------------------------
    ! Allocate internal state field arrays
    !--------------------------------------------------------------------

    allocate(state(bundle_size))
    allocate(state_n(bundle_size))
    allocate(state_after_slow(bundle_size))
    allocate(reference_state(bundle_size))
    allocate(rhs_n(bundle_size))
    allocate(rhs_np1(bundle_size))
    allocate(rhs_adv(bundle_size))
    allocate(rhs_phys(bundle_size))
    allocate(inc(bundle_size))
    allocate(mr_n(nummr)) ! always needed otherwise subroutine calls fail
    if (use_moisture)then
      allocate(mr_after_slow(nummr))
      allocate(mr_inc(nummr))
    end if

    !--------------------------------------------------------------------
    ! Initialise internal state field objects
    !--------------------------------------------------------------------

    call u%copy_field_properties( state(igh_u) )
    call theta%copy_field_properties( state(igh_t) )
    call rho%copy_field_properties( state(igh_d) )
    call exner%copy_field_properties( state(igh_p) )

    call clone_bundle(state, state_n,   bundle_size)
    call clone_bundle(state, state_after_slow,   bundle_size)
    call clone_bundle(state, rhs_n,     bundle_size)
    call clone_bundle(state, rhs_np1,   bundle_size)
    call clone_bundle(state, rhs_adv,   bundle_size)
    call clone_bundle(state, rhs_phys,  bundle_size)
    call clone_bundle(state, inc,       bundle_size)
    call clone_bundle(state, reference_state, bundle_size)

    call theta%copy_field_properties(dtheta)
    call u%copy_field_properties(du)

    call clone_bundle(mr, mr_n, nummr)
    if (use_moisture)then
      call clone_bundle(mr, mr_after_slow, nummr)
      call clone_bundle(mr, mr_inc, nummr)
    end if

    if ( use_physics )then
      ! Set up the shear field to be in the same space as theta
      call theta%copy_field_properties( shear )
      ! Set up the diffusion coefficient fields to be in the same space as theta
      call theta%copy_field_properties( visc_m )
      call theta%copy_field_properties( visc_h )
      if ( smagorinsky)then
        ! Initialise to zero
        call invoke( setval_c(shear, 0.0_r_def),          &
                     setval_c(visc_m , 0.0_r_def),  &
                     setval_c(visc_h , 0.0_r_def) )
      end if
    end if

    !--------------------------------------------------------------------
    ! Initialise the physics increments to 0
    !--------------------------------------------------------------------
    call set_bundle_scalar(0.0_r_def, rhs_phys, bundle_size)

    !--------------------------------------------------------------------
    ! Operators for si solves
    !--------------------------------------------------------------------
    call create_si_operators(mesh_id)

    !--------------------------------------------------------------------
    ! Copy prognostic field data to state arrays
    !--------------------------------------------------------------------
    call invoke( name = "Copy init fields to state", &
                 setval_X(state(igh_u), u    ),      &
                 setval_X(state(igh_t), theta),      &
                 setval_X(state(igh_d), rho  ),      &
                 setval_X(state(igh_p), exner) )
    call advection_alg_init(mesh_id)

    call u%copy_field_properties( u_adv )

    ! Set initial reference state 
    call copy_bundle(state, reference_state, bundle_size)
    if (dry_static_adjust)call invoke( sort_ref_kernel_type(reference_state(igh_t) ) )  

#ifdef UM_PHYSICS
    if ( use_physics ) then
      if (radiation == radiation_socrates) then
        ! Initialisation for the Socrates radiation scheme
        call socrates_init()
      end if
      ! Initialization for the UM physics schemes (BL, cloud, mphys, conv)
      call um_init(theta)
    end if
#endif

    ! Construct semi-implicit solver
    vector_state = field_vector_type(bundle_size)
    vector_rhs   = field_vector_type(bundle_size)
    call vector_state%import_field(u,     igh_u)
    call vector_state%import_field(theta, igh_t)
    call vector_state%import_field(rho,   igh_d)
    call vector_state%import_field(exner, igh_p)
    call semi_implicit_solver_alg_init(vector_state)

    call log_event( "iter_timestep: initialised timestepping algorithm", LOG_LEVEL_INFO )

  end subroutine iter_alg_init



  !> @details An algorithm for timestepping the 3D nonlinear equations
  !>          using an iterative process of the same form as endgame.
  !>          The algorithm splits all processes into one of three parts.
  !>          Old time level forcings computed once per timestep.
  !>          Advection terms computed in an outer loop using time-averaged
  !>          fields.
  !>          New time level forcings computed in an inner loop.
  !>          If matching ENDGame, 2 outer and 2 inner loops are used per timestep
  !>          by default. This means that there is one evaluation of old time
  !>          level terms, 2 evaluation of advective terms and 4 evaluations 
  !>          of new time level terms and increment updates per timestep
  !> @param[in,out] u                 3D wind field
  !> @param[in,out] rho               Density
  !> @param[in,out] theta             Potential temperature
  !> @param[in,out] exner             Exner pressure
  !> @param[in,out] mr                Mixing ratios
  !> @param[in,out] moist_dyn         Factors for moist dynamics
  !> @param[in,out] xi                Vorticity field
  !> @param[in,out] derived_fields    Group of derived fields
  !> @param[in,out] cloud_fields      Group of cloud fields
  !> @param[in,out] twod_fields       2D fields for UM physics
  !> @param[in,out] physics_incs      Group of physics increments
  !> @param[in,out] jules_ancils      Ancillary fields for Jules
  !> @param[in,out] jules_prognostics Prognostic fields for Jules
  !> @param[in]     timestep          Model timestep number
  !> @param[in]     twod_mesh_id      Identifier given to the current 2d mesh
  subroutine iter_alg_step(u, rho, theta, exner, mr, moist_dyn, xi,       &
                           derived_fields, cloud_fields, twod_fields,     &
                           physics_incs, jules_ancils, jules_prognostics, &
                           timestep, twod_mesh_id)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta, exner, xi
    type( field_type ), intent( inout ) :: mr(nummr)
    type( field_type ), intent( inout ) :: moist_dyn(num_moist_factors)
    ! Surface fields
    type( field_collection_type ), intent(inout) :: jules_ancils
    type( field_collection_type ), intent(inout) :: jules_prognostics
    ! field groups
    type( field_collection_type ), intent( inout ) :: derived_fields
    type( field_collection_type ), intent( inout ) :: cloud_fields
    type( field_collection_type ), intent( inout ) :: twod_fields
    type( field_collection_type ), intent( inout ) :: physics_incs
    ! Timestep value
    integer, intent(in) :: timestep  
    integer, intent(in) :: twod_mesh_id

    ! Quadrature object
    type( quadrature_xyoz_type ) :: qr
    ! Coordinate fields
    type( field_type ), pointer  :: chi(:) => null()

    type( field_type ), pointer :: height_w3  => null()
    type( field_type ), pointer :: height_wth => null()
    type( field_type ), pointer :: t_normalisation => null()
    type( field_type ), pointer :: u_normalisation => null()
    type(operator_type), pointer :: m3_inv => null()
    type(operator_type), pointer :: mm_wt => null()
    type( field_type ), pointer  :: dA => null() ! Areas of faces
    type( field_type ), pointer  :: delta => null() ! Horizontal edge length
    type( field_type ), pointer  :: max_diff_smag => null() ! Max Smagorinsky diffusion allowed in this run

    ! Temporary field to unpack from field collection
    type( field_type ), pointer :: u_physics => null()
    type( field_type ), pointer :: w_physics  => null()
    type( field_type ), pointer :: theta_star => null()
    type( field_type ), pointer :: u_star => null()
    type( field_type ), pointer :: u_physics_star => null()
    type( field_type ), pointer :: w_physics_star  => null()
    type( field_type ), pointer :: u1_in_w3_star  => null()
    type( field_type ), pointer :: u2_in_w3_star  => null()
    type( field_type ), pointer :: u3_in_w3_star  => null()
    type( field_type ), pointer :: exner_theta  => null()

    type( field_type ), pointer :: tstar_ptr  => null()

    integer(kind=i_def):: outer, inner, iter
    real(kind=r_def)   :: varalpha, varbeta ! alpha, beta weight to use
                                            ! these may differ from input values
                                            ! during the spinup period

    real(kind=r_def), dimension(bundle_size) :: si_err

    ! Stencil depth for the Smagorinsky diffusion kernel
    integer(kind=i_def):: smag_stencil_depth

    if ( subroutine_timers ) call timer('iter_timestep_alg')

    qr = get_qr()
    chi => get_coordinates()
    height_w3  => get_height(W3)
    height_wth => get_height(Wtheta)
    dA => get_da_at_w2()
    delta => get_delta_at_wtheta()
    max_diff_smag => get_max_diff()
    mm_wt => get_mass_matrix(theta_space_id) 
    !--------------------------------------------------------------------
    ! Pass updated fields into state
    !--------------------------------------------------------------------
    if (spinup_winds .and. timestep*dt <= spinup_period) then
      call invoke( name = "Copy step fields to state", &
                   setval_X(state(igh_u), u    ),      &
                   setval_X(state(igh_t), theta),      &
                   setval_X(state(igh_d), rho  ),      &
                   setval_X(state(igh_p), exner) )
    end if

    if (spinup_alpha .and. timestep*dt <= spinup_period) then
      varalpha = alpha + (spinup_period - timestep*dt + 1) * &
         (1.0 - alpha)/spinup_period
    else
      varalpha = alpha
    end if
    varbeta = 1.0 - varalpha

    ! Perform some checking on the fields.
    call check_fields(state)

    ! Update state_n and mr_n with start of timestep values
    call copy_bundle(state, state_n, bundle_size)
    call copy_bundle(mr, mr_n, nummr)

    !==========================================================================
    ! Fields for physics
    !==========================================================================
    if (use_physics)then
      call map_physics_fields_alg(state_n(igh_u), state_n(igh_p),       &
                                  state_n(igh_d), state_n(igh_t),       &
                                  mr_n, derived_fields)
      u_physics => derived_fields%get_field('u_physics')
      w_physics => derived_fields%get_field('w_physics')
      ! map dynamics winds into physics space
      call invoke(         X_divideby_Y(u_physics, state_n(igh_u), dA), &
                  extract_w_kernel_type(w_physics, u_physics) )
      call u_physics%log_minmax(LOG_LEVEL_INFO, 'u_physics')
      call w_physics%log_minmax(LOG_LEVEL_INFO, 'w_physics')

      if ( smagorinsky ) then
        call log_event( 'Calculate 3D shear', LOG_LEVEL_INFO )
        ! Calculate 3D shear
        call invoke(smagorinsky_shear_kernel_type( shear,         &
                                                   u_physics,  1, &
                                                   height_wth, 1, &
                                                   height_w3,  1, &
                                                   chi ) )      
      end if

      !--------------------------------------------------------------------
      ! Call the slow physics terms
      !--------------------------------------------------------------------
      call invoke( setval_c(dtheta, 0.0_r_def), &
                   setval_c(du, 0.0_r_def) )
      call slow_physics(du, dtheta, state_n(igh_t), state_n(igh_d),     &
                        state_n(igh_p), mr_n, mr,                       &
                        derived_fields, cloud_fields, twod_fields,      &
                        physics_incs, jules_ancils, jules_prognostics,  &
                        height_w3, height_wth, chi, twod_mesh_id)
      ! update state prognostics including map back of winds
      call invoke(name="update_from_slow_physics",                      &
                  inc_X_plus_Y(state(igh_t), dtheta),                   &
                  inc_X_times_Y(du,dA),                                 &
                  inc_X_plus_Y(state(igh_u), du)                        &
                  )
      call log_event( "slow physics: completed slow physics.", LOG_LEVEL_INFO )
    end if !use_physics

    ! Update state_after_slow and mr_after_slow with 
    ! start of timestep + slow physics values
    call copy_bundle(state, state_after_slow, bundle_size)
    if (use_moisture) then
      call copy_bundle(mr, mr_after_slow, nummr)
      call invoke(moist_dyn_factors_kernel_type(moist_dyn, mr))
    end if

    call rhs_alg(rhs_n, varbeta*dt, state_after_slow, moist_dyn, .false., .false.)

    !==========================================================================
    ! Start the Outer (advection) loop
    !==========================================================================
    outer_dynamics_loop: do outer = 1,outer_iterations

      if (use_wavedynamics) then

        ! Set advecting velocity & terms
        call invoke( aX_plus_bY(u_adv, varbeta, state_after_slow(igh_u), varalpha, state(igh_u)) )
        call advection_alg(rhs_adv, state_after_slow, xi, u_adv, state_n(igh_u), state(igh_u) )
        if ( use_moisture )then
          ! Advect mr_after_slow values with latest advecting velocity 
          call advection_mr_alg(mr_inc, mr_after_slow, u_adv)
          ! Update latest value for mr
          call add_bundle(mr_inc, mr_after_slow, mr, nummr)
        end if
        call bundle_ax(dt, rhs_adv, rhs_adv, bundle_size) 

      end if !use_wavedynamics

      if (use_physics) then
        ! setting predictors for fast physics
        theta_star  => derived_fields%get_field('theta_star')
        u_star  => derived_fields%get_field('u_star')
        
        if (use_wavedynamics) then
          ! theta_star can be directly guessed from advection terms
          call invoke( X_plus_Y(inc(igh_t), rhs_adv(igh_t), rhs_n(igh_t)) )
          call mass_matrix_solver_alg(theta_star, inc(igh_t))

          ! Compute u_star = u_np1 + M^-1(-rhs_np1 + rhs_n + rhs_a)
          call rhs_alg(rhs_np1, -varalpha*dt, state, moist_dyn, .false., dlayer_on)      
          call invoke( inc_aX_plus_Y(-1.0_r_def, rhs_np1(igh_u), rhs_n(igh_u)),&
                       inc_X_plus_Y(rhs_np1(igh_u), rhs_adv(igh_u)) )
          call mass_matrix_solver_alg(inc(igh_u), rhs_np1(igh_u) )
          call invoke( X_plus_Y(u_star, inc(igh_u), state(igh_u)) )
        else
          ! predictors are just the current state
          call invoke( setval_X(theta_star, state(igh_t)), &
                       setval_X(u_star, state(igh_u)) )
        end if !use_wavedynamics

        ! map physics predictors into required spaces
        u_physics_star  => derived_fields%get_field('u_physics_star')
        w_physics_star  => derived_fields%get_field('w_physics_star')
        call invoke(         X_divideby_Y(u_physics_star, u_star, dA),     &
                    extract_w_kernel_type(w_physics_star, u_physics_star) )
        u1_in_w3_star => derived_fields%get_field('u1_in_w3_star')
        u2_in_w3_star => derived_fields%get_field('u2_in_w3_star')
        u3_in_w3_star => derived_fields%get_field('u3_in_w3_star')
        call map_physics_winds(u1_in_w3_star, u2_in_w3_star, u3_in_w3_star, &
                               u_star)

        !--------------------------------------------------------------------
        ! Call the fast physics terms
        !--------------------------------------------------------------------
        call invoke( setval_c(dtheta, 0.0_r_def), &
                     setval_c(du, 0.0_r_def) )
        call fast_physics(du, dtheta, mr, outer, state_n(igh_t),        &
                          state_n(igh_d), state_n(igh_p), mr_n,         &
                          shear, delta, max_diff_smag,                  &
                          derived_fields, cloud_fields, twod_fields,    &
                          visc_m, visc_h,                               &
                          physics_incs, height_w3, height_wth)

        tstar_ptr => twod_fields%get_field('tstar')
        call tstar_ptr%log_minmax(LOG_LEVEL_INFO, 'tstar after read')
        if (use_wavedynamics) then
          ! copy increments into rhs_phys, including convert to weak form theta
          ! NB there is no update to pressure or density, currently awaiting
          ! winds to be added here
          ! need to reset rhs_phys to 0 because matrix_vector_kernel_type
          ! increments the field rather than over-writing it
          call set_bundle_scalar(0.0_r_def, rhs_phys, bundle_size)
          call invoke(name="update_rhs_phys_from_fast_physics",               &
                    matrix_vector_kernel_type(rhs_phys(igh_t), dtheta, mm_wt) &
                    )
        end if

        call log_event( "iter_timestep: completed fast physics.", LOG_LEVEL_INFO )
      end if !use_physics

      if (use_wavedynamics) then

        ! Update factors for moist dynamics
        if (use_moisture) call invoke(moist_dyn_factors_kernel_type(moist_dyn, mr))

        !============================================================================
        ! Start the Inner (nonlinear, coriolis) loop
        !============================================================================
        inner_dynamics_loop: do inner = 1,inner_iterations
          if ( guess_np1 ) then
            ! rho^np1 and theta^np1 can be directly guessed from advection terms
            call invoke( X_plus_Y(state(igh_d), rhs_adv(igh_d), rhs_n(igh_d)), &
                         X_plus_Y(inc(igh_t), rhs_adv(igh_t), rhs_n(igh_t)) )
            call mass_matrix_solver_alg(state(igh_t), inc(igh_t))
            ! exner^np1 can be directly guessed from eos
            m3_inv => get_mass_matrix(w3inv_id)

            call invoke( project_pressure_kernel_type( state(igh_p), state(igh_d), state(igh_t), &
                                                       moist_dyn(gas_law), chi, m3_inv, qr ) )
          end if
          ! Reset reference state using latest guess
          iter = inner + (outer-1)*inner_iterations
          if ( mod(iter-1_i_def,reference_reset_freq) == 0_i_def ) then
            call copy_bundle(state, reference_state, bundle_size) 
            if (dry_static_adjust)call invoke( sort_ref_kernel_type(reference_state(igh_t) ) )  
            call compute_si_operators(reference_state)
          end if

          call rhs_alg(rhs_np1, -varalpha*dt, state, moist_dyn, .true., dlayer_on)

          !--------------------------------------------------------------------
          ! Solve for the increments
          !
          ! Add on advective terms: rhs = rhs_n - rhs_np1 + rhs_adv
          ! (reuse rhs_np1 for rhs)
          !--------------------------------------------------------------------
          call bundle_axpy(-1.0_r_def, rhs_np1, rhs_n, rhs_np1, bundle_size)
          call add_bundle(rhs_np1, rhs_adv, rhs_np1, bundle_size)
          call add_bundle(rhs_np1, rhs_phys, rhs_np1, bundle_size)

          ! Normalise theta & u residual
          t_normalisation => get_normalisation(theta_space_id)
          u_normalisation => get_normalisation(w2_id)
          call invoke( inc_X_times_Y(rhs_np1(igh_t), t_normalisation), &
                       inc_X_times_Y(rhs_np1(igh_u), u_normalisation) )
          write( log_scratch_space, '(A,2I3)' ) 'loop indices (o, i): ', &
                                                outer, inner
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          ! Write out si residuals
          call invoke( name = "Compute SI residuals",           &
                       X_innerproduct_X(si_err(igh_u), rhs_np1(igh_u)), &
                       X_innerproduct_X(si_err(igh_t), rhs_np1(igh_t)), &
                       X_innerproduct_X(si_err(igh_d), rhs_np1(igh_d)), &
                       X_innerproduct_X(si_err(igh_p), rhs_np1(igh_p))  &
                     )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in momentum equation:  ',sqrt(si_err(igh_u))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in energy equation:    ',sqrt(si_err(igh_t))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in continuity equation:',sqrt(si_err(igh_d))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )
          write( log_scratch_space, '(A,E16.8)' ) &
            'Residual in equation of state:  ',sqrt(si_err(igh_p))
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          call vector_rhs%import_field(rhs_np1(igh_u), igh_u)
          call vector_rhs%import_field(rhs_np1(igh_t), igh_t)
          call vector_rhs%import_field(rhs_np1(igh_d), igh_d)
          call vector_rhs%import_field(rhs_np1(igh_p), igh_p)
          call vector_state%import_field(state(igh_u), igh_u)
          call vector_state%import_field(state(igh_t), igh_t)
          call vector_state%import_field(state(igh_d), igh_d)
          call vector_state%import_field(state(igh_p), igh_p)
          call semi_implicit_solver_alg_step(vector_state, vector_rhs)
          call vector_state%export_field(state(igh_u), igh_u)
          call vector_state%export_field(state(igh_t), igh_t)
          call vector_state%export_field(state(igh_d), igh_d)
          call vector_state%export_field(state(igh_p), igh_p)

          ! Recompute exner from eos
          if (exner_from_eos) then
            m3_inv => get_mass_matrix(w3inv_id)
            call invoke( project_pressure_kernel_type( state(igh_p), state(igh_d), &
                                                       state(igh_t),               &
                                                       moist_dyn(gas_law), chi,    &
                                                       m3_inv, qr ) )
          end if

        end do inner_dynamics_loop
        !--------------------------------------------------------------------
        ! End of Inner (nonlinear, coriolis) loop
        !--------------------------------------------------------------------

      else ! when use_wavedynamics=false, just add increments here

        !NB This is currently only updating theta
        call invoke(inc_X_plus_Y(state(igh_t), dtheta) )

      end if ! use_wavedynamics

    end do outer_dynamics_loop
    !--------------------------------------------------------------------
    ! End of Outer (advection) loop
    !--------------------------------------------------------------------

    !--------------------------------------------------------------------
    ! Apply Smagorinsky subgrid mixing
    !--------------------------------------------------------------------
    if ( smagorinsky ) then
      call log_event( 'Applying Smagorinsky mixing', LOG_LEVEL_INFO )

      ! Stencil depth for the Smagorinsky diffusion kernel
      smag_stencil_depth=1

      if ( boundary_layer == boundary_layer_um ) then

        ! Use stability-dependent diffusion coefficient from UM BL scheme
        ! This will be the blended BL-Smag coefficient if mixing_option='blending'
        call log_event( 'Using stability-dependent Smagorinsky coefficient', LOG_LEVEL_INFO )
        ! Potential temperature:
        call invoke( tracer_smagorinsky_diff_kernel_type( inc(igh_t),           &
                                                          state(igh_t),         &
                                                          smag_stencil_depth,   &
                                                          visc_h,               &
                                                          chi  ) )
        if ( use_moisture ) then
          ! Water vapour and cloud liquid:
          call invoke( tracer_smagorinsky_diff_kernel_type( mr_inc(imr_v),      &
                                                            mr(imr_v),          &
                                                            smag_stencil_depth, &
                                                            visc_h,             &
                                                            chi  ),             &
                       tracer_smagorinsky_diff_kernel_type( mr_inc(imr_cl),     &
                                                            mr(imr_cl),         &
                                                            smag_stencil_depth, &
                                                            visc_h,             &
                                                            chi  ) )
        end if

      else

        call log_event( 'Using pure Smagorinsky coefficient', LOG_LEVEL_INFO )
        ! Calculate visc_h as (mix_factor * delta)**2 * shear
        ! Potential temperature:
        call invoke( a_times_X( visc_h, mix_factor, delta ),                    &
                     inc_X_powint_n( visc_h, 2 ),                               &
                     inc_X_times_Y( visc_h, shear ),                            &
                     tracer_smagorinsky_diff_kernel_type( inc(igh_t),           &
                                                          state(igh_t),         &
                                                          smag_stencil_depth,   &
                                                          visc_h,               &
                                                          chi  ) )
        if (use_moisture) then
          ! Water vapour and cloud liquid:
          call invoke( tracer_smagorinsky_diff_kernel_type( mr_inc(imr_v),      &
                                                            mr(imr_v),          &
                                                            smag_stencil_depth, &
                                                            visc_h,             &
                                                            chi  ),             &
                       tracer_smagorinsky_diff_kernel_type( mr_inc(imr_cl),     & 
                                                            mr(imr_cl),         &
                                                            smag_stencil_depth, &
                                                            visc_h,             &
                                                            chi  ) )
        end if    

      end if

      !  Momentum mixing is to be implemented in a future ticket

      ! Apply increments from Smagorinsky mixing
      ! Set u increment to zero until momentum mixing is implemented:
      call invoke( inc_X_plus_bY( state(igh_t), dt, inc(igh_t) ),   &
                   inc_X_plus_bY( mr(imr_v), dt, mr_inc(imr_v) ),   &
                   inc_X_plus_bY( mr(imr_cl), dt, mr_inc(imr_cl) ), &
                   setval_c(inc(igh_u), 0.0_r_def),                 &
                   inc_X_plus_bY( state(igh_u), dt, inc(igh_u) ) )
    end if    
    
    ! ----------------------------------------------------------------------
    ! Call cloud scheme to generate cloud and latent heating after pressure 
    ! changes are applied from the solver. First obtain current exner mapped 
    ! on theta levels
    ! ----------------------------------------------------------------------


#ifdef UM_PHYSICS
    if (use_physics) then
     if ( cloud == cloud_um .and. &
          scheme == scheme_smith ) then
      if (use_moisture) then

        call log_event( 'iter timestep: Running Cloud Scheme', LOG_LEVEL_INFO )
  
        dtheta_cld = field_type( vector_space = theta%get_function_space() )
        call invoke( setval_c(dtheta_cld, 0.0_r_def) )
        exner_theta => derived_fields%get_field('exner_in_wth')
        call map_physics_scalars(exner_theta, state(igh_p))
  
        call cld_alg_step(  state(igh_p), exner_theta, state(igh_t),   &
                   mr, cloud_fields, twod_fields, dtheta_cld)    

        call invoke(inc_X_plus_Y(state(igh_t), dtheta_cld))

      else ! not use moisture

        ! throw an error: user has made a mistake --> no clouds without moisture.
        call log_event( &
        'iter_timestep_: Cloud scheme cannot be run without moisture. Please correct', &
         LOG_LEVEL_ERROR )

      end if ! use moisture
     end if
    endif
#endif

    !--------------------------------------------------------------------
    ! Apply viscosity
    !--------------------------------------------------------------------
    if ( viscosity ) then
      call log_event( 'Applying Viscosity', LOG_LEVEL_INFO ) 
      call invoke_tracer_viscosity(   inc(igh_t), state(igh_t), 1, chi)
      call invoke_momentum_viscosity( inc(igh_u), state(igh_u), 1, chi)
      call invoke( inc_X_plus_bY( state(igh_t), dt, inc(igh_t) ), &
                   inc_X_plus_bY( state(igh_u), dt, inc(igh_u) ) )
    end if    
    
    if (.not. (spinup_winds .and. timestep*dt <= spinup_period)) then

      !--------------------------------------------------------------------
      ! Return field in u array
      !--------------------------------------------------------------------
      call invoke( setval_X(u, state(igh_u)) )
    end if
    !--------------------------------------------------------------------
    ! Return fields in theta, rho, exner arrays
    !--------------------------------------------------------------------
    call invoke( setval_X(theta, state(igh_t)), &
                 setval_X(rho,   state(igh_d)), &
                 setval_X(exner, state(igh_p)) )

    nullify( m3_inv, chi, height_w3, height_wth, &
             t_normalisation, u_normalisation, dA, delta )

    if ( subroutine_timers ) call timer('iter_timestep_alg')

  end subroutine iter_alg_step


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> Release all claimed resources once completed.
  !>
  subroutine iter_alg_final()

    implicit none

    call semi_implicit_solver_alg_final()
    call advection_alg_final()
 
    call final_si_operators()

    if (allocated(state))           deallocate(state)
    if (allocated(state_n))         deallocate(state_n)
    if (allocated(state_after_slow))         deallocate(state_after_slow)
    if (allocated(reference_state)) deallocate(reference_state)
    if (allocated(rhs_n))           deallocate(rhs_n)
    if (allocated(rhs_np1))         deallocate(rhs_np1)
    if (allocated(rhs_adv))         deallocate(rhs_adv)
    if (allocated(rhs_phys))        deallocate(rhs_phys)
    if (allocated(inc))             deallocate(inc)

    call u_adv%field_final()
    call dtheta%field_final()
    call du%field_final()

    if ( use_physics )then
      call shear%field_final()
      call visc_m%field_final()
      call visc_h%field_final()
    end if

    return
  end subroutine iter_alg_final

end module iter_timestep_alg_mod
