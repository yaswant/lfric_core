!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief An algorithm for COSMIC transport scheme on the cubed-sphere.
!> @details The algorithm iterates forwards in time and transports the density
!>          field using the COSMIC advection scheme. This routine updates density
!>          for horizontal transport only.
module cusph_cosmic_transport_alg_mod

  use constants_mod,                     only: r_def, i_def, LARGE_REAL_NEGATIVE
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use finite_element_config_mod,         only: element_order
  use fs_continuity_mod,                 only: W2, W3
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE
  use runtime_constants_mod,             only: get_coordinates, &
                                               get_cell_orientation, &
                                               get_detj_at_w2
  use cusph_split_transport_alg_mod,     only: cusph_split_transport_alg
  use cusph_fv_density_update_alg_mod,   only: cusph_fv_density_update_alg
  use flux_direction_mod,                only: x_direction, y_direction
  use initial_u_kernel_mod,              only: initial_u_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type
  use timestepping_config_mod,           only: dt
  use mass_matrix_solver_alg_mod,        only: mass_matrix_solver_alg
  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type ) :: u_n, u_np1
  type( field_type ) :: r_u

  public :: set_winds
  public :: cusph_cosmic_transport_step

contains

  !> @brief Routine which analytically defines the winds each timestep.
  !> @details Wind field is defined each timestep for the transport only test
  !>          cases which are run within the transport mini-app.
  !> @param[in,out]   u         3D wind field
  !> @param[in]       mesh_id   Mesh id of mesh on which the model runs
  !> @param[in]       timestep  Timestep
  subroutine set_winds(u, mesh_id, timestep)

    implicit none

    integer(i_def),   intent(in)    :: mesh_id
    type(field_type), intent(inout) :: u
    integer(i_def),   intent(in)    :: timestep

    type(function_space_type), pointer    :: w2_fs   => null()
    type(function_space_type), pointer    :: w3_fs   => null()
    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule

    type(field_type),          pointer :: chi(:) => null()
    real(r_def)                        :: time

    w2_fs   => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w3_fs   => function_space_collection%get_fs( mesh_id, element_order, W3 )

    u_n         = field_type( vector_space = w2_fs )
    u_np1       = field_type( vector_space = w2_fs )
    r_u         = field_type( vector_space = w2_fs )

    qr = quadrature_xyoz_type(element_order+2, quadrature_rule)
    chi => get_coordinates()


    time = dt*real(timestep,r_def)

    call invoke( name = "Initialise U",    &
                 setval_c(u,   0.0_r_def), &
                 setval_c(r_u, 0.0_r_def), &
                 initial_u_kernel_type(r_u, chi, time, qr), &
                 enforce_bc_kernel_type( r_u ) )
    call mass_matrix_solver_alg(u, r_u)
    
    call invoke( setval_X(u_n, u), &
                 setval_X(u_np1, u) )

    nullify(w2_fs, w3_fs, chi)

  end subroutine set_winds

  !> @brief An algorithm for testing the COSMIC transport scheme.
  !> @details The algorithm iterates forwards in time and transports the density
  !>          field using the COSMIC advection scheme. This routine advects in
  !>          horizontal direction only. The wind profile is defined analytically.
  !> @param[in,out] increment        Density increment
  !> @param[in]     rho              Density field
  !> @param[in]     dep_pts_x        Departure points in the x direction
  !> @param[in]     dep_pts_y        Departure points in the y direction
  subroutine cusph_cosmic_transport_step( increment,          &
                                          rho,                &
                                          dep_pts_x,          &
                                          dep_pts_y )

    implicit none

    type(field_type),    intent(inout) :: increment
    type(field_type),    intent(in)    :: rho
    type(field_type),    intent(in)    :: dep_pts_x
    type(field_type),    intent(in)    :: dep_pts_y

    ! Array to hold cell orientation values in W3 field
    type(field_type), pointer :: cell_orientation => null()
    ! Array to hold detj values at W2 dof locations
    type(field_type), pointer :: detj_at_w2 => null()

    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()

    type( field_type ) :: increment_x, increment_y
    type( field_type ) :: mass_flux_x, mass_flux_y

    cell_orientation => get_cell_orientation()
    detj_at_w2       => get_detj_at_w2()

    w2_fs => dep_pts_x%get_function_space()
    w3_fs => rho%get_function_space()

    mass_flux_x = field_type( vector_space = w2_fs )
    mass_flux_y = field_type( vector_space = w2_fs )
    increment_x = field_type( vector_space = w3_fs )
    increment_y = field_type( vector_space = w3_fs )

    ! Call algorithm to calculate mass fluxes in x and y direction using COSMIC scheme
    call cusph_split_transport_alg( rho, cell_orientation,             &
                                    mass_flux_x, mass_flux_y, dep_pts_x, &
                                    dep_pts_y, detj_at_w2 )

    ! Calculate divergence (increment) in the x direction
    call cusph_fv_density_update_alg( increment_x, mass_flux_x, mass_flux_y,     &
                                      cell_orientation, x_direction, detj_at_w2)

    ! Calculate divergence (increment) in the y direction
    call cusph_fv_density_update_alg( increment_y, mass_flux_x, mass_flux_y,     &
                                      cell_orientation, y_direction, detj_at_w2)

    call invoke( X_plus_Y( increment, increment_x, increment_y ) )

    nullify(cell_orientation, detj_at_w2, w2_fs, w3_fs)

  end subroutine cusph_cosmic_transport_step

end module cusph_cosmic_transport_alg_mod
