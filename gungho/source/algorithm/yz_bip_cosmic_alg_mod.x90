!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
!> @brief An algorithm for testing the COSMIC transport scheme in Y-Z plane.
!> @details The algorithm iterates forwards in time and transports the density
!>          field using the COSMIC scheme. This implementation has currently
!>          been tested in the biperiodic planar domain and in the Y-Z plane
!>          only.
module yz_bip_cosmic_alg_mod

  use constants_mod,                     only: r_def, i_def, LARGE_REAL_NEGATIVE
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use finite_element_config_mod,         only: element_order
  use fs_continuity_mod,                 only: W2, W3
  use runtime_constants_mod,             only: get_coordinates
  use io_mod,                            only: output_nodal
  use runtime_constants_mod,             only: get_detJ_at_w2
  use vert_advective_cosmic_alg_mod,     only: vert_advective_cosmic_alg
  use vert_conservative_cosmic_alg_mod,  only: vert_conservative_cosmic_alg
  use oned_conservative_flux_alg_mod,    only: oned_conservative_flux_alg
  use oned_density_update_alg_mod,       only: oned_density_update_alg
  use cosmic_divergence_alg_mod,         only: cosmic_divergence_alg
  use timestepping_config_mod,           only: dt
  use flux_direction_mod,                only: x_direction, y_direction, z_direction

  implicit none

  private

  public :: yz_bip_cosmic_step

contains

  !> @brief An algorithm for testing the COSMIC transport scheme
  !> @details The algorithm iterates forwards in time and transports the density
  !>          field using the COSMIC advection scheme. This implementation
  !>          has currently been tested in the biperiodic planar domain and in
  !>          the horizontal direction only. The wind profile is defined
  !>          analytically.
  !> @param[in,out] increment  Density increment
  !> @param[in]     rho        Density field
  !> @param[in]     dep_pts_y  Departure points in the y-direction
  !> @param[in]     dep_pts_z  Departure points in the z-direction
  subroutine yz_bip_cosmic_step( increment, rho, dep_pts_y, dep_pts_z )

    implicit none

    type(field_type), intent(inout) :: increment
    type(field_type), intent(in)    :: rho
    type(field_type), intent(in)    :: dep_pts_y
    type(field_type), intent(in)    :: dep_pts_z

    type(field_type) :: cell_orientation
    type(field_type) :: mass_flux_y, mass_flux_z
    type(field_type) :: rho_adv_z, rho_hat_adv_z
    type(field_type) :: rho_adv_y, rho_hat_adv_y
    type(field_type) :: increment_y
    type(field_type) :: increment_z

    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()

    type(field_type), pointer :: detj_at_w2 => null()

    detj_at_w2 => get_detj_at_w2()

    w2_fs      => dep_pts_y%get_function_space()
    w3_fs      => rho%get_function_space()

    mass_flux_y        = field_type( vector_space = w2_fs )
    mass_flux_z        = field_type( vector_space = w2_fs )

    cell_orientation   = field_type( vector_space = w3_fs )
    rho_hat_adv_y      = field_type( vector_space = w3_fs )
    rho_adv_y          = field_type( vector_space = w3_fs )
    rho_hat_adv_z      = field_type( vector_space = w3_fs )
    rho_adv_z          = field_type( vector_space = w3_fs )
    increment_y        = field_type( vector_space = w3_fs )
    increment_z        = field_type( vector_space = w3_fs )

    ! Calculate the departure points for W2 nodal points at lowest order
    call invoke( setval_c(cell_orientation, 1.0_r_def) )

    ! Perform advective update in the Y direction.
    call oned_density_update_alg(y_direction,dep_pts_y,cell_orientation,detj_at_w2,rho,rho_adv_y)

    ! Perform advective update in the Z direction.
    call vert_advective_cosmic_alg(rho_adv_z,rho,dep_pts_z,cell_orientation,dt)

    ! This step is equation (37) of Leonard, Lock and MacVean (1996) or equivalenlty
    ! equations (17) and (18) of Putman and Lin, 2007.
    call invoke( name = "average_advective_density", &
                 aX_plus_bY(rho_hat_adv_y, 0.5_r_def, rho, 0.5_r_def, rho_adv_y), &
                 aX_plus_bY(rho_hat_adv_z, 0.5_r_def, rho, 0.5_r_def, rho_adv_z) )

    ! Calculate the mass flux in the Y direction.
    call oned_conservative_flux_alg(y_direction, dep_pts_y, cell_orientation,  &
                                                    rho_hat_adv_z, rho_hat_adv_z, mass_flux_y)

    ! Calculate the divergence in the Y direction and update density.
    call cosmic_divergence_alg(increment_y, mass_flux_y, detj_at_w2,          &
                               cell_orientation, y_direction)

    ! Calculate the mass flux in the Z direction.
    call vert_conservative_cosmic_alg( mass_flux_z, rho_hat_adv_y, dep_pts_z, dt )

    ! Calculate the divergence in the Z direction and update density.
    call cosmic_divergence_alg(increment_z, mass_flux_z, detj_at_w2,          &
                               cell_orientation, z_direction)

    call invoke( X_plus_Y( increment, increment_y, increment_z ) )

    nullify( w2_fs, w3_fs, detj_at_w2 )

  end subroutine yz_bip_cosmic_step

end module yz_bip_cosmic_alg_mod
