!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the transport equation
!>@details An algorithm for timstepping the 3D transport equation using a
!>         multistage explicit Runge-Kutta algorithm.
module rk_transport_mod

  use constants_mod,                     only: r_def, i_def, pi
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE
  use fs_continuity_mod,                 only: W1
  ! Configuration options
  use finite_element_config_mod,         only: element_order, supg
  use timestepping_config_mod,           only: dt
  use runge_kutta_init_mod,              only: num_rk_stage, ak
  use runtime_constants_mod,             only: get_mass_matrix,                &
                                               get_mass_matrix_diagonal,       &
                                               get_inverse_lumped_mass_matrix, &
                                               get_qr,                         &
                                               w2_id, w3_id, w3inv_id,         &
                                               wt_id, theta_space_id,          &
                                               get_coordinates

  use transport_config_mod,              only: operators,          &
                                               fv_flux_order,      &
                                               fv_advective_order, &
                                               operators_fv,       &
                                               operators_fem,        &
                                               oned_reconstruction,            &
                                               consistent_metric

  ! PsyKAl-lite kernels
  use psykal_lite_mol_mod,               only: psykal_lite_mol_init,           &
                                               psykal_lite_mol_final,          &
                                               invoke_poly1d_flux,             &
                                               invoke_poly1d_flux_coeffs,      &
                                               invoke_poly1d_vert_flux,        &
                                               invoke_poly1d_vert_flux_coeffs, &
                                               invoke_poly2d_flux,             &
                                               invoke_poly2d_flux_coeffs,      &
                                               invoke_poly1d_adv_recon,        &
                                               invoke_poly1d_advective_coeffs, &
                                               invoke_poly2d_adv_recon,        &
                                               invoke_poly2d_advective_coeffs, &
                                               invoke_poly1d_vert_adv_coeffs,  &
                                               invoke_poly1d_vert_adv

  ! PsyKAl PSYClone kernels
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use flux_rhs_kernel_mod,               only: flux_rhs_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use rtheta_supg_kernel_mod,            only: rtheta_supg_kernel_type
  use poly_advective_kernel_mod,         only: poly_advective_kernel_type
  use consistent_wind_kernel_mod,        only: consistent_wind_kernel_type

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use operator_mod,                      only: operator_type

  ! Algorithms
  use mass_matrix_solver_alg_mod,        only: mass_matrix_solver_alg
  ! Log
  use log_mod,                           only: log_event,         &
                                               LOG_LEVEL_ERROR
  use io_config_mod,                     only: subroutine_timers 
  use timer_mod,                         only: timer
  implicit none

  private

  ! 'State' items that need to be created once but used every step
  type( field_type )              :: rho_n, r_u, r_rho, rho_inc, mass_flux, &
                                     theta_n, r_theta, theta_inc
  type( field_type ), allocatable :: rr_prediction(:), rt_prediction(:)
  type( field_type )              :: mt_lumped
  type( field_type )              :: rho0, theta0
  type( field_type )              :: ones
  type( field_type )              :: theta_av
  type( field_type )              :: advective_av_chi3, theta_metrics, chi3_at_wt

  ! Needed for nonuniform fv operators
  type( field_type ), allocatable :: flux_coeffs(:,:), vert_flux_coeffs(:,:), &
                                     adv_coeffs(:,:),  vert_adv_coeffs(:,:)

  integer(i_def) :: flux_stencil_extent,      &
                    advective_stencil_extent, &
                    flux2d_stencil_size,      &
                    advective2d_stencil_size
  integer(i_def) :: nfaces_h, nfaces_v

  public :: rk_transport_init
  public :: rk_transport_step
  public :: rk_transport_final

contains

  !> @brief Init routine for rk transport timestepping algorithm
  !> @details Rho and u fields are initialised before
  !>          this algorithm is called. State items are created,
  !> @param[in]    mesh_id Mesh id of mesh on which the model runs
  !> @param[in]    u 3D wind field
  !> @param[inout] rho Density like field
  !> @param[inout] theta Temperature like field
  subroutine rk_transport_init( mesh_id, u, rho, theta)
    use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
    use sample_field_kernel_mod,           only: sample_field_kernel_type
    use quadrature_xyoz_mod,               only: quadrature_xyoz_type
    use quadrature_face_mod,               only: quadrature_face_type
    use quadrature_edge_mod,               only: quadrature_edge_type
    use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type
    use quadrature_rule_gauss_lobatto_mod, &
                                           only: quadrature_rule_gauss_lobatto_type
    use multiplicity_kernel_mod,           only: multiplicity_kernel_type
    use sample_field_kernel_mod,           only: sample_field_kernel_type
    use reference_element_mod,             only: reference_element_type
    use mesh_mod,                          only: mesh_type
    implicit none

    ! Mesh id
    integer(i_def),  intent(in) :: mesh_id
    ! Prognostic fields
    type( field_type ), intent( in ) :: u, rho, theta

    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: theta_fs => null()

    ! Timestepping variables
    integer(i_def)               :: stage
    type(operator_type), pointer :: mm_wt => null()

    type( field_type ), pointer :: chi(:) => null()
    type( field_type ), pointer :: md_w3 => null(), md_wt => null()
    type( field_type )          :: wt_multiplicity
    integer(i_def)              :: direction, polynomial

    type( quadrature_xyoz_type )           :: qr
    type( quadrature_face_type )           :: qrf
    type( quadrature_edge_type )           :: qre
    type( quadrature_rule_gaussian_type )  :: gaussian_quadrature
    type( quadrature_rule_gauss_lobatto_type )  :: gauss_lobatto_quadrature
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type),               pointer :: mesh => null()
    integer(i_def)                         :: face_quad_order
    integer(i_def)                         :: nqp_xy, nqp_z, nqp_xyz
    if ( subroutine_timers ) call timer('rk_transport_alg')

    allocate ( rr_prediction(num_rk_stage) )
    allocate ( rt_prediction(num_rk_stage) )

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    u_fs     => u%get_function_space()
    rho_fs   => rho%get_function_space()
    theta_fs => theta%get_function_space()

    rho_n        = field_type( vector_space = rho_fs )
    r_rho        = field_type( vector_space = rho_fs )
    rho_inc      = field_type( vector_space = rho_fs )
    r_u          = field_type( vector_space = u_fs )
    mass_flux    = field_type( vector_space = u_fs )
    theta_n      = field_type( vector_space = theta_fs )
    r_theta      = field_type( vector_space = theta_fs )
    theta_inc    = field_type( vector_space = theta_fs )


    do stage = 1,num_rk_stage
      rr_prediction(stage) = field_type( vector_space = rho_fs )
      rt_prediction(stage) = field_type( vector_space = theta_fs )
    end do

    call invoke( setval_c(mass_flux, 0.0_r_def) )

    if ( operators == operators_fv ) then
      if ( element_order == 0 ) then
        ! Get topology information from the reference element
        mesh              => theta%get_mesh()
        reference_element => mesh%get_reference_element()
        ! Number of horizontal neighbours
        nfaces_h = reference_element%get_number_horizontal_faces()
        ! Number of vertical neighbours is (and always will be) 2
        nfaces_v = reference_element%get_number_vertical_faces() 

        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high order elements", LOG_LEVEL_ERROR )
      end if
      mm_wt => get_mass_matrix(wt_id)
      ones  = field_type( vector_space = theta_fs )
      mt_lumped  = field_type( vector_space = theta_fs )
      call invoke( name = "Compute mt_lumped",     &
                   setval_c(ones,      1.0_r_def), &
                   setval_c(mt_lumped, 0.0_r_def), &
                   matrix_vector_kernel_type(mt_lumped, ones, mm_wt) )

      ! Compute stencil for nonuniform polynomial fit   
      ! Initialise PSy layer arrays (this will not be needed when
      ! multi-dimensional field arrays are supported)
      if ( oned_reconstruction ) then
        call psykal_lite_mol_init(theta, rho,                         &
                                  fv_flux_order, fv_flux_order+1,     &
                                  fv_advective_order,                 &
                                  fv_advective_order+1,               &
                                  nfaces_h, nfaces_v)
      else 
        flux2d_stencil_size = 1    
        do polynomial = 1, fv_flux_order
          if ( mod(polynomial,2) == 0 ) then
            flux2d_stencil_size = flux2d_stencil_size + nfaces_h
          else
            flux2d_stencil_size = flux2d_stencil_size + nfaces_h*polynomial
          end if
        end do
        advective2d_stencil_size = 1    
        do polynomial = 1, fv_advective_order
          if ( mod(polynomial,2) == 0 ) then
            advective2d_stencil_size = advective2d_stencil_size + nfaces_h
          else
            advective2d_stencil_size = advective2d_stencil_size + nfaces_h*polynomial
          end if
        end do
        call psykal_lite_mol_init(theta, rho, &
                                  fv_flux_order, flux2d_stencil_size, &
                                  fv_advective_order, advective2d_stencil_size, &
                                  nfaces_h, nfaces_v)
      end if
   
      chi => get_coordinates()
      nqp_xyz = fv_flux_order+1
      qr = quadrature_xyoz_type(nqp_xyz, gaussian_quadrature)
      mesh              => rho%get_mesh()
      reference_element => mesh%get_reference_element()
      if ( oned_reconstruction ) then
        face_quad_order = 1
      else
        face_quad_order = fv_flux_order+1
      end if
      qrf = quadrature_face_type(face_quad_order, .true., .false., &
                                 reference_element, gaussian_quadrature)
      call log_event( "Gungho: computing horizontal flux coeffs", LOG_LEVEL_INFO )
      md_w3 => get_mass_matrix_diagonal(w3_id)
      if ( oned_reconstruction ) then
        allocate( flux_coeffs(fv_flux_order+1, nfaces_h) )
        do direction = 1,nfaces_h
          do polynomial = 1,fv_flux_order+1
            flux_coeffs(polynomial,direction) = field_type( vector_space = rho_fs )
          end do
        end do
        call invoke_poly1d_flux_coeffs( flux_coeffs, md_w3, chi, qr, qrf, &
                                        fv_flux_order,                    &
                                        flux_stencil_extent, nfaces_h )
      else
        allocate( flux_coeffs(flux2d_stencil_size, nfaces_h) )
        do direction = 1,nfaces_h
          do polynomial = 1,flux2d_stencil_size
            flux_coeffs(polynomial,direction) = field_type( vector_space = rho_fs )
          end do
        end do
        call invoke_poly2d_flux_coeffs( flux_coeffs, md_w3, chi, qr, qrf, &
                                        fv_flux_order,                    &
                                        flux2d_stencil_size, nfaces_h )
      end if
      call log_event( "Gungho: computing vertical flux coeffs", LOG_LEVEL_INFO )
      ! Vertical flux coeffs
      allocate( vert_flux_coeffs(fv_flux_order+1, nfaces_v) )
      do direction = 1,nfaces_v
        do polynomial = 1,fv_flux_order+1
          vert_flux_coeffs(polynomial,direction) = field_type( vector_space = rho_fs )
        end do
      end do
      nqp_xyz = 1
      qrf = quadrature_face_type(nqp_xyz, .false., .true., &
                                 reference_element, gaussian_quadrature)

      call invoke_poly1d_vert_flux_coeffs( vert_flux_coeffs, md_w3, chi, &
                                           qr, qrf, fv_flux_order, nfaces_v )
      if ( subroutine_timers ) call timer('rk_transport_alg: V flux coeffs')

      ! Compute advective coeffcients
      ! This needs a quadrature rule with GLL points in the vertical
      call log_event( "Gungho: computing horizontal advective coeffs", LOG_LEVEL_INFO )
      nqp_xy = fv_advective_order+3
      nqp_z = 2
      qr = quadrature_xyoz_type(nqp_xy, nqp_xy, nqp_z, &
                                gauss_lobatto_quadrature)
      qre = quadrature_edge_type(face_quad_order, .true., .false., &
                                 reference_element, gaussian_quadrature)
      md_wt => get_mass_matrix_diagonal(wt_id)
      theta_av = field_type( vector_space =                                    &
          function_space_collection%get_fs(mesh_id, element_order, W1) )
      if ( oned_reconstruction ) then
        allocate( adv_coeffs(fv_advective_order+1, nfaces_h) )
        do direction = 1,nfaces_h
          do polynomial = 1,fv_advective_order+1
            adv_coeffs(polynomial,direction) = field_type( vector_space = theta_fs )
          end do
        end do
        call invoke_poly1d_advective_coeffs( adv_coeffs, md_wt, chi, qr, qre,  &
                                             fv_advective_order,               &
                                             advective_stencil_extent, nfaces_h )
      else
        allocate( adv_coeffs(advective2d_stencil_size, nfaces_h) )
        do direction = 1,nfaces_h
          do polynomial = 1,advective2d_stencil_size
            adv_coeffs(polynomial,direction) = field_type( vector_space = theta_fs )
          end do
        end do
        call invoke_poly2d_advective_coeffs( adv_coeffs, md_wt, chi, qr, &
                                             qre, fv_advective_order,    &
                                             advective2d_stencil_size,   &
                                             nfaces_h )
      end if
      call log_event( "Gungho: computing vertical advective coeffs", LOG_LEVEL_INFO )
      ! Vertical advective coeffs
      allocate( vert_adv_coeffs(fv_advective_order+2, nfaces_v) )
      do direction = 1,nfaces_v
        do polynomial = 1,fv_advective_order+2
          vert_adv_coeffs(polynomial,direction) = field_type( vector_space = theta_fs )
        end do
      end do
      call invoke_poly1d_vert_adv_coeffs( vert_adv_coeffs, md_wt, chi, & 
                                          fv_advective_order, nfaces_v )

      if ( consistent_metric ) then
        advective_av_chi3 = field_type(vector_space = theta_av%get_function_space() )
        theta_metrics     = field_type(vector_space = theta_fs )
        chi3_at_wt        = field_type(vector_space = theta_fs )
        wt_multiplicity   = field_type(vector_space = theta_fs )
        call invoke( setval_c(wt_multiplicity, 0.0_r_def),       &
                     multiplicity_kernel_type(wt_multiplicity),  &
                     sample_field_kernel_type( chi3_at_wt, wt_multiplicity, chi(3)) )
      end if
      if ( subroutine_timers ) call timer('rk_transport_alg: V adv coeffs')
    else
      ones  = field_type( vector_space = rho_fs)
      call invoke( setval_c(ones, 1.0_r_def) )
    end if

    ! Store initial values for computing errors
    rho0   = rho
    theta0 = theta

    nullify( mm_wt, u_fs, rho_fs, theta_fs, mesh, reference_element )

    if ( subroutine_timers ) call timer('rk_transport_alg')

  end subroutine rk_transport_init

  !> @brief A Runge-Kutta time-discretisation of the transport equation
  !> @details An algorithm for timstepping the transport equation using the
  !>          Runge-Kutta algorithm. theta, rho and u fields are initialised before
  !>          this algorithm is called.
  !>          If fem advection is used theta must be in W0,
  !>          If fv advection is used theta must be in Wtheta
  !> @param[in]    u 3D wind field
  !> @param[inout] rho Density like tracer
  !> @param[inout] theta Temperature like tracer

  subroutine rk_transport_step( u, rho, theta)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta

    ! The quadrature object
    type( quadrature_xyoz_type )          :: qr
    ! Coordinate fields
    type( field_type ), pointer :: chi(:) => null()

    integer(i_def) :: stage, st


    ! Temps for retrieving objects back from runtime constants
    type(operator_type), pointer :: mm_w3_inv => null()
    type(field_type), pointer    :: mt_lumped_inv => null()
    type(field_type)             :: consistent_wind
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)

    if ( subroutine_timers ) call timer('rk_transport_alg')

    qr = get_qr()
    chi => get_coordinates()

    ! Create operators needed for timestepping
    mm_w3_inv => get_mass_matrix(w3inv_id)
    call invoke( setval_X(rho_n,   rho), &
                 setval_X(theta_n, theta) )


    ! Runge-Kutta algorithm
    do stage = 1,num_rk_stage
      ! Compute advection terms
      ! mass flux ( F = rho * u )
      select case(operators)
        case(operators_fv)
          ! Use polynomial reconstruction
          call invoke( setval_c(theta_av, 0.0_r_def) )
          if ( oned_reconstruction ) then
            call invoke_poly1d_flux( mass_flux, u, rho, flux_coeffs, &
                                     fv_flux_order, flux_stencil_extent, nfaces_h )
            call invoke_poly1d_adv_recon( theta_av, u, theta, adv_coeffs, &
                                          fv_advective_order, advective_stencil_extent, &
                                          nfaces_h )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) then 
              call invoke( setval_c(advective_av_chi3, 0.0_r_def) )
              call invoke_poly1d_adv_recon( advective_av_chi3, u, &
                                            chi3_at_wt, adv_coeffs, &
                                            fv_advective_order, advective_stencil_extent, &
                                            nfaces_h )
            end if
          else
            ! Use 2d flux code
            call invoke_poly2d_flux( mass_flux, u, rho, flux_coeffs, &
                                     fv_flux_order, flux2d_stencil_size, nfaces_h )
            call invoke_poly2d_adv_recon( theta_av, u, theta, adv_coeffs, &
                                          fv_advective_order, advective2d_stencil_size, &
                                          nfaces_h )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) & 
              call invoke_poly2d_adv_recon( advective_av_chi3, u, &
                                            chi3_at_wt, adv_coeffs, &
                                            fv_advective_order, advective2d_stencil_size, &
                                            nfaces_h )
          end if
          call invoke( poly_advective_kernel_type( rt_prediction(stage), &
                                                   u, theta_av) )

          ! Compute vertical components of mass flux
          call invoke_poly1d_vert_flux( mass_flux, u, rho, &
                                        vert_flux_coeffs, &
                                        fv_flux_order, nfaces_v)

          ! Compute vertical components of advective update
          consistent_wind = u
          if ( consistent_metric ) then
            call invoke( poly_advective_kernel_type(theta_metrics, u, advective_av_chi3), &
            ! Modify advecting wind
                         consistent_wind_kernel_type(consistent_wind, u, theta_metrics, chi) )
          end if
          call invoke_poly1d_vert_adv( rt_prediction(stage), consistent_wind, theta, &
                                       vert_adv_coeffs, &
                                       fv_advective_order, nfaces_v)
        case(operators_fem)      
          ! Use FEM projection
          ! Initialise fields
          call invoke( name = "Initialise fields",                &
                       setval_c(r_u,                  0.0_r_def), &
                       setval_c(mass_flux,            0.0_r_def), &
                       setval_c(rt_prediction(stage), 0.0_r_def) )

          ! Rho advection, compute mass flux 
          call invoke( name = "Compute mass flux",                 & 
                       flux_rhs_kernel_type(r_u, u, rho, chi, qr), &
                       enforce_bc_kernel_type(r_u) )
          call mass_matrix_solver_alg( mass_flux, r_u) 

          ! Theta advection
          call invoke( rtheta_kernel_type( rt_prediction(stage), theta, u, qr) )
          if ( supg ) &
            call invoke( rtheta_supg_kernel_type(rt_prediction(stage),     &
                                theta, theta_n, u, ones, chi, qr) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select
      ! Compute rrho = div(F)
      call invoke( rrho_kernel_type(rr_prediction(stage), mass_flux, qr), &
                   setval_c(r_rho,   0.0_r_def),                          &
                   setval_c(r_theta, 0.0_r_def) )

      do st = 1, stage
        call invoke( inc_X_plus_bY(r_rho, ak(stage,st), rr_prediction(st)), &
                     inc_X_plus_bY(r_theta, ak(stage,st), rt_prediction(st)) )
      end do

      ! Invert mass matrices and add increments
      ! Rho
      call invoke( name = "Invert mass matrices and add increments",     &
                   setval_c(rho_inc, 0.0_r_def),                         &
                   matrix_vector_kernel_type(rho_inc, r_rho, mm_w3_inv), &
                   aX_plus_Y(rho, dt, rho_inc, rho_n) )

      ! Theta
      select case(operators)
        case(operators_fv) ! theta in Wtheta
          call invoke( inc_X_divideby_Y(r_theta, mt_lumped), &
                       X_minus_bY(theta, theta_n, dt, r_theta) )
        case(operators_fem)
          call mass_matrix_solver_alg( theta_inc, r_theta)
          call invoke( X_minus_bY(theta, theta_n, dt, theta_inc) )
      end select
    end do

    nullify( mm_w3_inv, mt_lumped_inv, chi )
    if ( subroutine_timers ) call timer('rk_transport_alg')

  end subroutine rk_transport_step

  !> @brief Final routine for rk transport timestepping algorithm

  !> @param[in] rho Density
  !> @param[in] theta Potential temperature field
  subroutine rk_transport_final( rho, theta)

    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type

    implicit none

    type( field_type ), intent(in) :: rho, theta
 
    type( field_type )                 :: drho, dtheta, l2_rho, l2_theta
    type(function_space_type), pointer :: rho_fs   => null(), &
                                          theta_fs => null()
    type(operator_type),       pointer :: mm_wt => null(), &
                                          mm_w3 => null()
    real(kind=r_def)                   :: l2_rho_diff, l2_theta_diff, &
                                          l2_rho_analytic, l2_theta_analytic

    if ( subroutine_timers ) call timer('rk_transport_alg')

    ! Compute L errors
    theta_fs => theta%get_function_space()
    rho_fs   => rho%get_function_space()

    dtheta   = field_type( vector_space = theta_fs )
    l2_theta = field_type( vector_space = theta_fs )
    drho     = field_type( vector_space = rho_fs )
    l2_rho   = field_type( vector_space = rho_fs )

    mm_w3 => get_mass_matrix(w3_id)
    mm_wt => get_mass_matrix(theta_space_id)

    call invoke( name = "Compute L2 error for theta and rho",           &
                 X_minus_Y(drho,   rho,   rho0  ),                      &
                 X_minus_Y(dtheta, theta, theta0),                      &
                 setval_c(l2_theta, 0.0_r_def),                         &
                 setval_c(l2_rho,   0.0_r_def),                         &
    ! Compute L2 error for theta and rho
                 matrix_vector_kernel_type(l2_theta, dtheta, mm_wt),    &
                 matrix_vector_kernel_type(l2_rho,   drho,   mm_w3),    &
                 X_innerproduct_Y(l2_theta_diff, dtheta, l2_theta),     &
                 X_innerproduct_Y(l2_rho_diff,   drho,   l2_rho),       &
                 setval_c(l2_theta, 0.0_r_def),                         &
                 setval_c(l2_rho,   0.0_r_def),                         &
    ! Compute L2 norm of analytic results
                 matrix_vector_kernel_type(l2_theta, theta0, mm_wt),    &
                 matrix_vector_kernel_type(l2_rho,   rho0,   mm_w3),    &
                 X_innerproduct_Y(l2_theta_analytic, theta0, l2_theta), &
                 X_innerproduct_Y(l2_rho_analytic,   rho0,   l2_rho)    &
               )

    ! Write out normalised L2 errors
    write( log_scratch_space, '(A, E15.8)' ) &
      "L2 theta = ", sqrt(l2_theta_diff)/sqrt(l2_theta_analytic)
    call log_event( log_scratch_space, LOG_LEVEL_INFO ) 
    write( log_scratch_space, '(A, E15.8)' ) &
      "L2 rho   = ", sqrt(l2_rho_diff)/sqrt(l2_rho_analytic)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

    ! Write out Linf errors
    call dtheta%log_absmax(LOG_LEVEL_INFO, 'L inf theta')
    call drho%log_absmax(LOG_LEVEL_INFO,   'L inf rho')

    if ( operators == operators_fv .and. element_order == 0 ) then
      deallocate( flux_coeffs, vert_flux_coeffs, &
                  adv_coeffs, vert_adv_coeffs )
    end if

    ! Deallocate PSy layer arrays (this will not be needed when
    ! multi-dimensional field arrays are supported)
    call psykal_lite_mol_final()

    if ( subroutine_timers ) call timer('rk_transport_alg')

  end subroutine rk_transport_final

end module rk_transport_mod
