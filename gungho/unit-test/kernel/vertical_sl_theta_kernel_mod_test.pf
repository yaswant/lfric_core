!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!

!> Test the vertical_sl_theta_kernel.
!>
module vertical_sl_theta_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use yaxt,          only : xt_initialize, xt_finalize
  use mpi_mod,       only : store_comm, clear_comm

  implicit none

  private

  public :: test_all

  @TestCase
  type, public, extends(MPITestCase) :: vertical_sl_theta_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type vertical_sl_theta_test_type

contains
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

  use feign_config_mod,      only : feign_transport_config
  use transport_config_mod,  only : scheme_method_of_lines,      &
                                    operators_fv,                &
                                    rho_splitting_none,          &
                                    theta_splitting_none,        &
                                    rho_vertical_scheme_slice,   &
                                    theta_vertical_scheme_sl,    &
                                    slice_order_cubic,           &
                                    vertical_sl_order_cubic,     &
                                    cosmic_flux_splitting_full,  &
                                    cosmic_advective_splitting_full

    implicit none

    class(vertical_sl_theta_test_type), intent(inout) :: this

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())
    call feign_transport_config( scheme = scheme_method_of_lines,             &
                                 operators = operators_fv,                    &
                                 fv_flux_order = 2,                           &
                                 fv_advective_order = 2,                      &
                                 consistent_metric  = .false.,                &
                                 enforce_monotonicity = .false.,              &
                                 oned_reconstruction = .false.,               &
                                 rho_splitting = rho_splitting_none,          &
                                 theta_splitting = theta_splitting_none,      &
                                 cfl_control_stab = 1.5_r_def,                &
                                 cfl_mol_1d_stab = 1.0_r_def,                 &
                                 cfl_mol_2d_stab = 1.0_r_def,                 &
                                 cfl_mol_3d_stab = 1.0_r_def,                 &
                                 rho_vertical_scheme = rho_vertical_scheme_slice,  &
                                 theta_vertical_scheme = theta_vertical_scheme_sl, &
                                 slice_order = slice_order_cubic,                  &
                                 vertical_sl_order = vertical_sl_order_cubic,      &
                                 use_density_predictor = .false.,                  &
                                 log_rho=.false.,                             &
                                 log_theta=.false.,                           &
                                 cosmic_flux_splitting = cosmic_flux_splitting_full,           &
                                 cosmic_advective_splitting = cosmic_advective_splitting_full  &
                                 )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,  only: final_configuration

    implicit none

    class(vertical_sl_theta_test_type), intent(inout) :: this

    call final_configuration()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_all( this )

    use vertical_sl_theta_kernel_mod, only: vertical_sl_theta_code

    implicit none

    class(vertical_sl_theta_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def) :: answer

    integer(i_def), parameter :: nlayers = 10
    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: nfaces_h  = 4
    integer(i_def), parameter :: undf_w2 = nfaces_h*nlayers & ! Horizontal dofs
                                         + nlayers + 1        ! + vertical dofs
    integer(i_def), parameter :: ndf_wtheta = 2
    integer(i_def), parameter :: undf_wtheta = nlayers + 1

    integer(i_def), dimension(ndf_w2)     :: map_w2
    integer(i_def), dimension(ndf_wtheta) :: map_wtheta
    real(r_def), dimension(undf_w2)       :: wind
    real(r_def), dimension(undf_wtheta)   :: theta_in, theta_out
    real(r_def), dimension(4) :: cubic_param, cubic_coeff
    real(r_def)     :: dt_here, x
    integer(i_def)  :: i, im1, ip1, ip2, df

    ! Create the dof map for any number of layers
    ! Dofs are contiguous in the vertical and so each entry is
    ! offset by nlayers

    do df = 1, nfaces_h
      map_w2(df) = 1 + (df-1)*nlayers
    end do

    ! Vertical dofs are contiguous and so
    ! map(6) needs to be 1 more than map(5)

    map_w2(nfaces_h+1) = 1 + nfaces_h*nlayers
    map_w2(ndf_w2)     = map_w2(nfaces_h+1) + 1

    ! Theta has two dofs, and follows the same pattern as the vertical dofs
    ! in the wind field
    map_wtheta(:) = (/ 1, 2 /)

    ! Get canned information for the reference cube

    theta_in(:) = 0.0_r_def
    cubic_param(:) = (/ -1.0_r_def, 2.0_r_def, 1.0_r_def,  2.0_r_def /)
    cubic_coeff(:) = (/ -1.0_r_def, 9.0_r_def, 9.0_r_def, -1.0_r_def /)
    cubic_coeff(:) = cubic_coeff(:)/16_r_def

    wind =  -1.0_r_def
    dt_here = 0.5_r_def

    ! Set top and bottom w=0
    wind(map_w2(5))= 0.0_r_def
    wind(map_w2(5)+nlayers) = 0.0_r_def

    do i = 1, nlayers + 1
      x  = real(i-1,r_def)
      theta_in(i) = cubic_param(1)*x**3 + cubic_param(2)*x**2 + &
                    cubic_param(3)*x    + cubic_param(4)
    end do

    do i = 1, nlayers + 1
       im1 = max(i-1,1)
       ip1 = min(i+1,nlayers+1)
       ip2 = min(i+2,nlayers+1)

       theta_out(i) = cubic_coeff(1)*theta_in(im1) + cubic_coeff(2)*theta_in(i) &
                    + cubic_coeff(3)*theta_in(ip1) + cubic_coeff(4)*theta_in(ip2)
    end do
    theta_out(1)         = theta_in(1)
    theta_out(nlayers+1) = theta_in(nlayers+1)
    theta_out(nlayers)   = 0.5_r_def*theta_in(nlayers) +  &
                           0.5_r_def*theta_in(nlayers+1)

    ! Theta_in gets overwitten by the new values on exit

    call vertical_sl_theta_code( nlayers,                             &
                                 wind,                                &
                                 theta_in,                            &
                                 dt_here,                             &
                                 ndf_w2, undf_w2, map_w2,             &
                                 ndf_wtheta, undf_wtheta, map_wtheta  )
    do i = 1,nlayers + 1
      @assertEqual(theta_out(i), theta_in(i) , tol)
    end do

  end subroutine test_all

end module vertical_sl_theta_kernel_mod_test
