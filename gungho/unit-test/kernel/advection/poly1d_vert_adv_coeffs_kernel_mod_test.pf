!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the computation of the vertical adv coefficients 
module poly1d_vert_adv_coeffs_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use yaxt,          only : xt_initialize, xt_finalize
  use mpi_mod,       only : store_comm, clear_comm
  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(MPITestCase), public :: poly1d_vert_adv_coeffs_test_type
    private
  contains
    procedure setUp
    procedure test_all
    procedure tearDown
  end type poly1d_vert_adv_coeffs_test_type

contains

  subroutine setUp( this ) 
    use feign_config_mod,     only : feign_base_mesh_config, &
                                     feign_planet_config
    use base_mesh_config_mod, only : geometry_planar, &
                                     partitioner_planar
    implicit none 

    class(poly1d_vert_adv_coeffs_test_type), intent(inout) :: this

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    call feign_base_mesh_config( filename='foo', prime_mesh_name='unit_test', &
                                 geometry=geometry_planar,                    &
                                 partitioner=partitioner_planar,              &
                                 fplane=.false., f_lat_deg=0.0_r_def )
 
  end subroutine setUp

  @Test( npes=[1] )
  subroutine test_all( this )

    use poly1d_vert_adv_coeffs_kernel_mod, only: poly1d_vert_adv_coeffs_code
    implicit none 

    class(poly1d_vert_adv_coeffs_test_type), intent(inout) :: this

    real(r_def), parameter    :: tol = 1.0e-12_r_def
    real(r_def), dimension(4) :: answer

    integer(i_def), parameter :: nfaces_v = 2

    integer(i_def), parameter :: nlayers = 5
    integer(i_def), parameter :: ndf_wt = 2
    integer(i_def), parameter :: ndf_wx = 8
    integer(i_def), parameter :: undf_wt = nlayers+1
    integer(i_def), parameter :: undf_wx = ndf_wx*nlayers
    integer(i_def), parameter :: global_order = 2
    integer(i_def), dimension(ndf_wt) :: map_wt
    integer(i_def), dimension(ndf_wx) :: map_wx

    real(r_def), dimension(global_order+2,2,undf_wt) :: coeff
    real(r_def), dimension(undf_wt) :: mdwt
    real(r_def), dimension(undf_wx) :: x, y, z

    real(r_def), dimension(1,ndf_wx,ndf_wt)     :: basis_wx

    real(r_def), parameter :: dx = 2.0_r_def
    real(r_def), parameter :: dy = 1.0_r_def
    real(r_def), parameter :: dz = 3.0_r_def

    integer(i_def) :: k, df

    map_wt(:) = (/ 1, 2 /)

    do df = 1,ndf_wx
      map_wx(df) = 1 + (df-1)*nlayers
    end do

    mdwt(:) = dx*dy*dz

    x(:) = 0.0_r_def
    y(:) = 0.0_r_def
    z(:) = 0.0_r_def
    do k = 0,nlayers-1      
      x(map_wx(2)+k) = dx
      x(map_wx(4)+k) = dx
      y(map_wx(3)+k) = dy
      y(map_wx(4)+k) = dy

      do df = 1,4
        x(map_wx(4+df)+k) = x(map_wx(df)+k)
        y(map_wx(4+df)+k) = y(map_wx(df)+k)
        z(map_wx(df)+k)   = k*dz
        z(map_wx(4+df)+k) = z(map_wx(df)+k) + dz
      end do
    end do

    basis_wx(:,:,:) = 0.0_r_def
    do df = 1,4
      basis_wx(1,df,1) = 0.25_r_def
      basis_wx(1,4+df,2) = 0.25_r_def
    end do

 
    call poly1d_vert_adv_coeffs_code(nlayers,                   &
                                     coeff,                     &
                                     mdwt,                      &
                                     x, y, z,                   &
                                     ndf_wt,                    &
                                     undf_wt,                   &
                                     map_wt,                    &
                                     ndf_wx,                    &
                                     undf_wx,                   &
                                     map_wx,                    &
                                     basis_wx,                  &
                                     global_order,              &
                                     nfaces_v)

    answer = (/ 1.0_r_def, -6.0_r_def, 3.0_r_def, 2.0_r_def /)/6.0_r_def
    @assertEqual(answer, coeff(:,1,3), tol)
    answer = (/-2.0_r_def, -3.0_r_def, 6.0_r_def, -1.0_r_def /)/6.0_r_def
    @assertEqual(answer, coeff(:,2,3), tol)

    answer(1:2) = (/ -1.0_r_def, 1.0_r_def /)
    @assertEqual(answer(1:2), coeff(1:2,1,2), tol)
    @assertEqual(answer(1:2), coeff(1:2,2,nlayers), tol)
  end subroutine test_all

  subroutine tearDown( this )
    implicit none 

    class(poly1d_vert_adv_coeffs_test_type), intent(inout) :: this
    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()
  end  subroutine tearDown

end module poly1d_vert_adv_coeffs_kernel_mod_test
