!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the computation of the vertical adv coefficients
module poly1d_vert_adv_coeffs_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use yaxt,          only : xt_initialize, xt_finalize
  use mpi_mod,       only : store_comm, clear_comm
  implicit none

  private
  public :: test_uniform_mesh
  public :: test_stretched_mesh

  @TestCase
  type, extends(MPITestCase), public :: poly1d_vert_adv_coeffs_test_type
    private
  contains
    procedure setUp
    procedure test_uniform_mesh
    procedure test_stretched_mesh
    procedure tearDown
  end type poly1d_vert_adv_coeffs_test_type

contains

  subroutine setUp( this )
    use feign_config_mod,     only : feign_base_mesh_config, &
                                     feign_planet_config,    &
                                     feign_transport_config
    use base_mesh_config_mod, only : geometry_planar,    &
                                     partitioner_planar, &
                                     topology_fully_periodic
    use transport_config_mod, only : scheme_method_of_lines,     &
                                     operators_fv,               &
                                     rho_splitting_none,         &
                                     theta_splitting_none,       &
                                     rho_vertical_scheme_slice,  &
                                     theta_vertical_scheme_sl,   &
                                     slice_order_cubic,          &
                                     vertical_sl_order_cubic,    &
                                     cosmic_flux_splitting_full, &
                                     cosmic_advective_splitting_full
    implicit none

    class(poly1d_vert_adv_coeffs_test_type), intent(inout) :: this

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    call feign_base_mesh_config( filename='foo',                      &
                                 prime_mesh_name='unit_test',         &
                                 geometry=geometry_planar,            &
                                 partitioner=partitioner_planar,      &
                                 topology=topology_fully_periodic,    &
                                 fplane=.false., f_lat_deg=0.0_r_def )
    call feign_transport_config( scheme = scheme_method_of_lines, &
                                 operators = operators_fv, &
                                 fv_flux_order = 2, &
                                 fv_advective_order = 2, &
                                 consistent_metric  = .false., &
                                 enforce_monotonicity = .false., &
                                 oned_reconstruction = .false., &
                                 rho_splitting = rho_splitting_none, &
                                 theta_splitting = theta_splitting_none, &
                                 cfl_control_stab = 1.5_r_def, &
                                 cfl_mol_1d_stab = 1.0_r_def,  &
                                 cfl_mol_2d_stab = 1.0_r_def,  &
                                 cfl_mol_3d_stab = 1.0_r_def,  &
                                 rho_vertical_scheme = rho_vertical_scheme_slice,  &
                                 theta_vertical_scheme = theta_vertical_scheme_sl, &
                                 slice_order = slice_order_cubic,                  &
                                 vertical_sl_order = vertical_sl_order_cubic,      &
                                 use_density_predictor = .false.,                  &
                                 log_rho=.true.,    &
                                 log_theta=.false., &
                                 cosmic_flux_splitting = cosmic_flux_splitting_full,           &
                                 cosmic_advective_splitting = cosmic_advective_splitting_full  &
                                 )
  end subroutine setUp

  @Test( npes=[1] )
  subroutine test_uniform_mesh( this )

    use poly1d_vert_adv_coeffs_kernel_mod, only: poly1d_vert_adv_coeffs_code
    use poly1d_vert_adv_kernel_mod,        only: poly1d_vert_adv_code
    implicit none

    class(poly1d_vert_adv_coeffs_test_type), intent(inout) :: this

    real(r_def), parameter    :: tol = 1.0e-12_r_def   ! r_def 64bit tolerance
    real(r_def), dimension(3) :: answer

    integer(i_def), parameter :: nfaces_v = 2

    integer(i_def), parameter :: nlayers = 9
    integer(i_def), parameter :: mol_order = 2
    integer(i_def), parameter :: ndf_c  = 2
    integer(i_def), parameter :: ndf_wx = 8
    integer(i_def), parameter :: ndata = (mol_order+1)*nfaces_v
    integer(i_def), parameter :: undf_c  = ndata*(nlayers+1)
    integer(i_def), parameter :: undf_wx = ndf_wx*nlayers
    integer(i_def), dimension(ndf_c)  :: map_c
    integer(i_def), dimension(ndf_wx) :: map_wx

    real(r_def), dimension(undf_c)  :: coeff
    real(r_def), dimension(undf_wx) :: x, y, z

    real(r_def), dimension(1,ndf_wx,ndf_c) :: basis_wx

    real(r_def), parameter :: dx = 2.0_r_def
    real(r_def), parameter :: dy = 1.7_r_def
    real(r_def)            :: dz = 3.0_r_def

    integer(i_def) :: i, k, df

    map_c(:) = (/ 1, 1 + ndata /)

    do df = 1,ndf_wx
      map_wx(df) = 1 + (df-1)*nlayers
    end do

    x(:) = 0.0_r_def
    y(:) = 0.0_r_def
    z(:) = 0.0_r_def
    do k = 0,nlayers-1
      x(map_wx(2)+k) = dx
      x(map_wx(4)+k) = dx
      y(map_wx(3)+k) = dy
      y(map_wx(4)+k) = dy

      do df = 1,4
        x(map_wx(4+df)+k) = x(map_wx(df)+k)
        y(map_wx(4+df)+k) = y(map_wx(df)+k)
        z(map_wx(df)+k)   = k*dz
        z(map_wx(4+df)+k) = z(map_wx(df)+k) + dz
      end do
    end do

    basis_wx(:,:,:) = 0.0_r_def
    do df = 1,4
      basis_wx(1,df,1) = 0.25_r_def
      basis_wx(1,4+df,2) = 0.25_r_def
    end do


    call poly1d_vert_adv_coeffs_code(nlayers,                   &
                                     coeff,                     &
                                     x, y, z,                   &
                                     ndata,                     &
                                     mol_order,                 &
                                     ndf_c,                     &
                                     undf_c,                    &
                                     map_c,                     &
                                     ndf_wx,                    &
                                     undf_wx,                   &
                                     map_wx,                    &
                                     basis_wx)

    answer = (/ -1.0_r_def, 6.0_r_def, 3.0_r_def /)/8.0_r_def
    do df = 0,2
      @assertEqual(answer(df+1), coeff(df + map_c(1) + 2*ndata), tol)
    end do
    answer = (/ 3.0_r_def, 6.0_r_def, -1.0_r_def /)/8.0_r_def
    do df = 0,2
      @assertEqual(answer(df+1), coeff(df + (mol_order+1) + map_c(1) + 2*ndata), tol)
    end do

  end subroutine test_uniform_mesh

  @Test( npes=[1] )
  subroutine test_stretched_mesh( this )

    use, intrinsic :: iso_fortran_env,     only : real64
    use poly1d_vert_adv_coeffs_kernel_mod, only : poly1d_vert_adv_coeffs_code
    use poly1d_vert_adv_kernel_mod,        only : poly1d_vert_adv_code
    implicit none

    class(poly1d_vert_adv_coeffs_test_type), intent(inout) :: this

    real(r_def), parameter    :: tol = 1.0e-12_r_def  ! r_def 64bit tolerance
    real(r_def), dimension(3) :: answer
    real(r_def)               :: use_tol

    integer(i_def), parameter :: nfaces_v = 2

    integer(i_def), parameter :: nlayers = 9
    integer(i_def), parameter :: mol_order = 2
    integer(i_def), parameter :: logspace = 0
    integer(i_def), parameter :: ndf_wt = 2
    integer(i_def), parameter :: ndf_c  = 2
    integer(i_def), parameter :: ndf_wx = 8
    integer(i_def), parameter :: ndata = (mol_order+1)*nfaces_v
    integer(i_def), parameter :: undf_wt = (nlayers+1)
    integer(i_def), parameter :: undf_c  = ndata*(nlayers+1)
    integer(i_def), parameter :: undf_wx = ndf_wx*nlayers
    integer(i_def), dimension(ndf_c)  :: map_c
    integer(i_def), dimension(ndf_wt) :: map_wt
    integer(i_def), dimension(ndf_wx) :: map_wx

    real(r_def), dimension(undf_c)  :: coeff
    real(r_def), dimension(undf_wx) :: x, y, z
    real(r_def), dimension(undf_wt) :: mdwt

    real(r_def), dimension(1,ndf_wx,ndf_c) :: basis_wx

    real(r_def), parameter :: dx = 2.0_r_def
    real(r_def), parameter :: dy = 1.7_r_def
    real(r_def)            :: dz = 3.0_r_def

    integer(i_def) :: i, k, df

    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: undf_w2 = 4*nlayers + 2*(nlayers+1)
    integer(i_def), dimension(ndf_w2)  :: map_w2
    real(r_def),    dimension(undf_wt) :: flux
    real(r_def),    dimension(undf_w2) :: wind
    real(r_def),    dimension(undf_wt) :: density
    real(r_def),    dimension(undf_wt) :: ddensitydz
    real(r_def)                        :: ddz
    integer(i_def)                     :: power = 1
    real(r_def)                        :: stretch = 1.5_r_def

    map_c(:)  = (/ 1, 1 + ndata /)
    map_wt(:) = (/ 1, 2 /)

    do df = 1,ndf_wx
      map_wx(df) = 1 + (df-1)*nlayers
    end do

    basis_wx(:,:,:) = 0.0_r_def
    do df = 1,4
      basis_wx(1,df,1) = 0.25_r_def
      basis_wx(1,4+df,2) = 0.25_r_def
    end do

    ! Test reconstruciton on a stretched grid
    coeff = 0.0_r_def
    mdwt = 0.0_r_def
    x(:) = 0.0_r_def
    y(:) = 0.0_r_def
    z(:) = 0.0_r_def
    dz = 2.3_r_def
    do k = 0,nlayers-1
      x(map_wx(2)+k) = dx
      x(map_wx(4)+k) = dx
      y(map_wx(3)+k) = dy
      y(map_wx(4)+k) = dy
      dz = dz * stretch
      do df = 1,4
        x(map_wx(4+df)+k) = x(map_wx(df)+k)
        y(map_wx(4+df)+k) = y(map_wx(df)+k)
        if ( k == 0 ) then
          z(map_wx(df)+k) = 0.0_r_def
        else
          z(map_wx(df)+k) = z(map_wx(4+df)+k-1)
        end if
        z(map_wx(4+df)+k) = z(map_wx(df)+k) + dz
      end do
      mdwt(map_wt(1)+k) = mdwt(map_wt(1)+k) + 0.5_r_def*dx*dy*dz
      mdwt(map_wt(2)+k) = mdwt(map_wt(2)+k) + 0.5_r_def*dx*dy*dz
      density(1+k)    = z(map_wx(1)+k)**power
      ddensitydz(1+k) = real(power,r_def)*z(map_wx(1)+k)**(power-1)

   end do
   density(nlayers+1)    = z(map_wx(5)+nlayers-1)**power
   ddensitydz(nlayers+1) = real(power,r_def)*z(map_wx(5)+nlayers-1)**(power-1)

    ! Compute the coeffs for the stretched mesh
    call poly1d_vert_adv_coeffs_code(nlayers,                   &
                                     coeff,                     &
                                     x, y, z,                   &
                                     ndata,                     &
                                     mol_order,                 &
                                     ndf_c,                     &
                                     undf_c,                    &
                                     map_c,                     &
                                     ndf_wx,                    &
                                     undf_wx,                   &
                                     map_wx,                    &
                                     basis_wx)

    ! compute the reconstruction
    do df = 1,4
      map_w2(df) = 1 + (df-1)*nlayers
    end do
    map_w2(5) = 1 + 4*nlayers
    map_w2(6) = map_w2(5) + 1

    do i = 0,1
      wind = (-1.0_r_def + 2.0_r_def*real(i,r_def))*dx*dy
      flux = 0.0_r_def

      call poly1d_vert_adv_code( nlayers,              &
                                 flux,                 &
                                 wind,                 &
                                 density,              &
                                 coeff,                &
                                 ndata,                &
                                 mol_order,            &
                                 logspace,             &
                                 ndf_wt,               &
                                 undf_wt,              &
                                 map_wt,               &
                                 ndf_w2,               &
                                 undf_w2,              &
                                 map_w2,               &
                                 ndf_c,                &
                                 undf_c,               &
                                 map_c)
       if ( r_def == real64 ) then
         use_tol = tol
         do k = 1,nlayers-1
           ddz = flux(map_wt(1)+k)/mdwt(map_wt(1)+k) * dx*dy/wind(map_w2(5))
           @assertEqual(ddensitydz(map_wt(1)+k), ddz, use_tol)
         end do
       else
         do k = 1,nlayers-1
           ddz = flux(map_wt(1)+k)/mdwt(map_wt(1)+k) * dx*dy/wind(map_w2(5))
           use_tol = 10.0_r_def*spacing( ddz )
           @assertEqual(ddensitydz(map_wt(1)+k), ddz, use_tol)
         end do
       endif
    end do

  end subroutine test_stretched_mesh

  subroutine tearDown( this )
    implicit none

    class(poly1d_vert_adv_coeffs_test_type), intent(inout) :: this
    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()
  end  subroutine tearDown

end module poly1d_vert_adv_coeffs_kernel_mod_test
