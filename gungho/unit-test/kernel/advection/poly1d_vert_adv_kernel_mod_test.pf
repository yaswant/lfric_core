!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the flux computation using 1d polynomials
module poly1d_vert_adv_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use yaxt,          only : xt_initialize, xt_finalize
  use mpi_mod,       only : store_comm, clear_comm

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(MPITestCase), public :: poly1d_vert_adv_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type poly1d_vert_adv_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use feign_config_mod,     only: feign_transport_config
    use transport_config_mod, only: scheme_method_of_lines,      &
                                     operators_fv,               &
                                     rho_splitting_none,         &
                                     theta_splitting_none,       &
                                     rho_vertical_scheme_slice,  &
                                     theta_vertical_scheme_sl,   &
                                     slice_order_cubic,          &
                                     vertical_sl_order_cubic
    implicit none

    class(poly1d_vert_adv_test_type), intent(inout) :: this

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    !Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    call feign_transport_config( scheme = scheme_method_of_lines, &
                                 operators = operators_fv, &
                                 fv_flux_order = 2, &
                                 fv_advective_order = 2, &
                                 consistent_metric  = .false., &
                                 enforce_monotonicity = .false., &
                                 oned_reconstruction = .false., &
                                 rho_splitting = rho_splitting_none, &
                                 theta_splitting = theta_splitting_none, &
                                 cfl_mol_1d_stab = 1.0_r_def, &
                                 cfl_mol_2d_stab = 1.0_r_def, &
                                 cfl_mol_3d_stab = 1.0_r_def, &
                                 rho_vertical_scheme = rho_vertical_scheme_slice,  &
                                 theta_vertical_scheme = theta_vertical_scheme_sl, &
                                 slice_order = slice_order_cubic,                  &
                                 vertical_sl_order = vertical_sl_order_cubic,      &
                                 upwind_direction_from_w_at_wtheta = .true.        &
                                 )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod, only: final_configuration

    implicit none

    class(poly1d_vert_adv_test_type), intent(inout) :: this

    call final_configuration()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_all( this )
    use poly1d_vert_adv_kernel_mod, only: poly1d_vert_adv_code
    implicit none

    class(poly1d_vert_adv_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def)            :: answer

    integer(i_def), parameter :: nfaces_v = 2
    integer(i_def), parameter :: nlayers = 6
    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: ndf_wt = 2
    integer(i_def), parameter :: undf_w2 = 4*nlayers + 2*(nlayers+1)
    integer(i_def), parameter :: undf_wt = nlayers+1
    integer(i_def), parameter :: order = 2

    integer(i_def), dimension(ndf_w2) :: map_w2
    integer(i_def), dimension(ndf_wt) :: map_wt

    real(r_def), dimension(undf_wt)           :: flux
    real(r_def), dimension(undf_w2)           :: wind
    real(r_def), dimension(undf_wt)           :: density
    real(r_def), dimension(order+1,2,undf_wt) :: coeff

    integer(i_def) :: df, k


    map_wt(:) = (/ 1, 2 /)
    do df = 1,4
      map_w2(df) = 1 + (df-1)*nlayers
    end do
    map_w2(5) = 1 + 4*nlayers
    map_w2(6) = map_w2(5) + 1

    wind(:) = 1.0_r_def

    do k = 1,nlayers+1
      density(k) = real(k,r_def)
    end do

    coeff(1,:,:) =  3.0_r_def/8.0_r_def
    coeff(2,:,:) =  6.0_r_def/8.0_r_def
    coeff(3,:,:) = -1.0_r_def/8.0_r_def

    flux = 0.0_r_def

    call poly1d_vert_adv_code( nlayers,              &
                               flux,                 &
                               wind,                 &
                               density,              &
                               coeff,                &
                               ndf_wt,               &
                               undf_wt,              &
                               map_wt,               &
                               ndf_w2,               &
                               undf_w2,              &
                               map_w2,               &
                               order,                &
                               nfaces_v )
    answer = 1.0_r_def
    @assertEqual(answer, flux(map_wt(1)+3) , tol)
    @assertEqual(answer, flux(map_wt(1)+4) , tol)

  end subroutine test_all

end module poly1d_vert_adv_kernel_mod_test
