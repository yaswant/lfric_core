!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the computation of 1d advective coeffs
module poly1d_advective_coeffs_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use yaxt,          only : xt_initialize, xt_finalize
  use mpi_mod,       only : store_comm, clear_comm
  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(MPITestCase), public :: poly1d_advective_coeffs_test_type
    private
  contains
    procedure setUp
    procedure test_all
    procedure tearDown
  end type poly1d_advective_coeffs_test_type

contains

  subroutine setUp( this )
    use feign_config_mod,     only: feign_base_mesh_config, &
                                    feign_domain_size_config
    use base_mesh_config_mod, only: geometry_planar, &
                                    partitioner_planar
    implicit none
    class(poly1d_advective_coeffs_test_type), intent(inout) :: this

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    call feign_base_mesh_config( filename='foo',                      &
                                 prime_mesh_name='unit_test',         &
                                 geometry=geometry_planar,            &
                                 partitioner=partitioner_planar,      &
                                 fplane=.false., f_lat_deg=0.0_r_def )

    call  feign_domain_size_config(planar_domain_min_x = -10.0_r_def, &
                                   planar_domain_max_x = 10.0_r_def,  &
                                   planar_domain_min_y = -10.0_r_def, &
                                   planar_domain_max_y = 10.0_r_def )

  end subroutine setUp


  @Test( npes=[1] )
  subroutine test_all( this )

    use poly1d_advective_coeffs_kernel_mod, only: poly1d_advective_coeffs_code

    implicit none

    class(poly1d_advective_coeffs_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def), dimension(3) :: answer

    integer(i_def), parameter :: nlayers = 3
    integer(i_def), parameter :: ndf_wt = 2
    integer(i_def), parameter :: ndf_wx = 8
    integer(i_def), parameter :: stencil_size = 5
    integer(i_def), parameter :: order = 2
    integer(i_def), parameter :: nqp = 3
    integer(i_def), parameter :: nqp_h = nqp**2
    integer(i_def), parameter :: nqp_v = 2
    integer(i_def), parameter :: nqp_e = 1
    integer(i_def), parameter :: undf_wt = (nlayers+1)*stencil_size
    integer(i_def), parameter :: undf_wx = ndf_wx*nlayers*stencil_size
    integer(i_def), dimension(ndf_wt,stencil_size) :: smap_wt
    integer(i_def), dimension(ndf_wx,stencil_size) :: smap_wx

    real(r_def), dimension(ndf_wx,nqp_h,nqp_v) :: basis_wx
    real(r_def), dimension(ndf_wx,nqp_e,4,2) :: edge_basis_wx
    real(r_def), dimension(nqp_h)            :: wqp_h
    real(r_def), dimension(nqp_v), parameter :: wqp_v = (/ 0.5_r_def, 0.5_r_def /)
    real(r_def), dimension(nqp_e), parameter :: wqp_e = (/ 1.0_r_def /)

    real(r_def), dimension(order+1,4,undf_wt) :: coeff
    real(r_def), dimension(undf_wt)           :: mdwt
    real(r_def), dimension(undf_wx)           :: x, y, z
    real(r_def), dimension(stencil_size) :: stencil_dx, stencil_dy
    real(r_def), dimension(3) :: xq, wqp

    real(r_def), parameter :: dx = 2.0_r_def
    real(r_def), parameter :: dy = 3.0_r_def
    real(r_def), parameter :: dz = 4.0_r_def
    real(r_def), parameter :: dv = dx*dy*dz

    integer(i_def) :: k, df, s, ij, i, j

    xq(:) = 0.5_r_def + 0.5_r_def*(/ -sqrt(3.0_r_def/5.0_r_def), 0.0_r_def, sqrt(3.0_r_def/5.0_r_def) /)
    wqp(:) = (/5.0_r_def, 8.0_r_def, 5.0_r_def/)/18.0_r_def
    do j = 1,nqp
      do i = 1,nqp
        ij = i+(j-1)*nqp
        wqp_h(ij) = wqp(i)*wqp(j)
      end do
    end do

    do s = 1,stencil_size
      smap_wt(1,s) = 1 + (s-1)*(nlayers+1)
      smap_wt(2,s) = 2 + (s-1)*(nlayers+1)

      do df = 1, ndf_wx
        smap_wx(df,s) = 1 + (df-1)*nlayers + (s-1)*nlayers*ndf_wx
      end do
    end do

    stencil_dx = (/ 0.0_r_def, -dx, 0.0_r_def, dx, 0.0_r_def /)
    stencil_dy = (/ 0.0_r_def, 0.0_r_def, -dy, 0.0_r_def, dy /)

    do k = 0,nlayers-1
      x(smap_wx(1,1)+k) = 0.0_r_def
      x(smap_wx(2,1)+k) = dx
      x(smap_wx(3,1)+k) = 0.0_r_def
      x(smap_wx(4,1)+k) = dx
      y(smap_wx(1,1)+k) = 0.0_r_def
      y(smap_wx(2,1)+k) = 0.0_r_def
      y(smap_wx(3,1)+k) = dy
      y(smap_wx(4,1)+k) = dy
      z(smap_wx(1,1)+k) = k*dz
      z(smap_wx(2,1)+k) = k*dz
      z(smap_wx(3,1)+k) = k*dz
      z(smap_wx(4,1)+k) = k*dz
      do df = 1,4
        x(smap_wx(4+df,1)+k) = x(smap_wx(df,1)+k)
        y(smap_wx(4+df,1)+k) = y(smap_wx(df,1)+k)
        z(smap_wx(4+df,1)+k) = z(smap_wx(df,1)+k) + dz
      end do
      do i = 2, stencil_size
        do df = 1,8
          x(smap_wx(df,i)+k) = x(smap_wx(df,1)+k) + stencil_dx(i)
          y(smap_wx(df,i)+k) = y(smap_wx(df,1)+k) + stencil_dy(i)
          z(smap_wx(df,i)+k) = z(smap_wx(df,1)+k)
         end do
      end do

    end do

    mdwt(:) = dv

    basis_wx = 0.0_r_def
    do j = 1,nqp
      do i = 1,nqp
        ij = i+(j-1)*nqp
        basis_wx(1,ij,1) = (1.0_r_def - xq(i))*(1.0_r_def - xq(j))
        basis_wx(2,ij,1) =              xq(i) *(1.0_r_def - xq(j))
        basis_wx(3,ij,1) = (1.0_r_def - xq(i))*             xq(j)
        basis_wx(4,ij,1) =              xq(i) *             xq(j)
        basis_wx(5,ij,2) = (1.0_r_def - xq(i))*(1.0_r_def - xq(j))
        basis_wx(6,ij,2) =              xq(i) *(1.0_r_def - xq(j))
        basis_wx(7,ij,2) = (1.0_r_def - xq(i))*             xq(j)
        basis_wx(8,ij,2) =              xq(i) *             xq(j)
      end do
    end do

    edge_basis_wx(:,:,:,:) = 0.0_r_def
    edge_basis_wx(1,1,1,1) = 0.5_r_def
    edge_basis_wx(1,1,2,1) = 0.5_r_def
    edge_basis_wx(2,1,2,1) = 0.5_r_def
    edge_basis_wx(2,1,3,1) = 0.5_r_def
    edge_basis_wx(3,1,1,1) = 0.5_r_def
    edge_basis_wx(3,1,4,1) = 0.5_r_def
    edge_basis_wx(4,1,3,1) = 0.5_r_def
    edge_basis_wx(4,1,4,1) = 0.5_r_def
    edge_basis_wx(5,1,1,2) = 0.5_r_def
    edge_basis_wx(5,1,2,2) = 0.5_r_def
    edge_basis_wx(6,1,2,2) = 0.5_r_def
    edge_basis_wx(6,1,3,2) = 0.5_r_def
    edge_basis_wx(7,1,1,2) = 0.5_r_def
    edge_basis_wx(7,1,4,2) = 0.5_r_def
    edge_basis_wx(8,1,3,2) = 0.5_r_def
    edge_basis_wx(8,1,4,2) = 0.5_r_def

    call poly1d_advective_coeffs_code(nlayers,                   &
                                      coeff,                     &
                                      mdwt,                      &
                                      x, y, z,                   &
                                      ndf_wt,                    &
                                      undf_wt,                   &
                                      stencil_size,              &
                                      smap_wt,                   &
                                      ndf_wx,                    &
                                      undf_wx,                   &
                                      stencil_size,              &
                                      smap_wx,                   &
                                      basis_wx,                  &
                                      edge_basis_wx,             &
                                      order,                     &
                                      4_i_def,                   &
                                      nqp_h, nqp_v, wqp_h, wqp_v,&
                                      4_i_def, nqp_e, wqp_e )
    answer = (/  5.0_r_def/6.0_r_def,  2.0_r_def/6.0_r_def, -1.0_r_def/6.0_r_def /)
    @assertEqual(answer, coeff(:,1,1), tol)
  end subroutine test_all

  subroutine tearDown( this )
    implicit none

    class(poly1d_advective_coeffs_test_type), intent(inout) :: this
   ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()
  end subroutine tearDown

end module poly1d_advective_coeffs_kernel_mod_test
