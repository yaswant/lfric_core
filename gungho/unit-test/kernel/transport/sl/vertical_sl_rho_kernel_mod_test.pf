!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!

!> Test the vertical_sl_rho_kernel.
!>
module vertical_sl_rho_kernel_mod_test

  use constants_mod, only : i_def, r_def, l_def
  use pFUnit_Mod
  use transport_enumerated_types_mod, only : vertical_monotone_none,        &
                                             vertical_monotone_strict,      &
                                             vertical_monotone_order_high

  implicit none

  private

  public :: test_all

  @TestCase
  type, public, extends(TestCase) :: vertical_sl_rho_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type vertical_sl_rho_test_type

contains
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

  use feign_config_mod,      only : feign_transport_config
  use transport_config_mod,  only : operators_fv,                  &
                                    runge_kutta_method_ssp2,       &
                                    slice_order_cubic,             &
                                    vertical_sl_order_quintic,     &
                                    ffsl_flux_splitting_full,      &
                                    ffsl_advective_splitting_full, &
                                    max_vert_cfl_calc_uniform,     &
                                    moisture_eqn_advective,        &
                                    horizontal_monotone,           &
                                    vertical_monotone,             &
                                    vertical_monotone_order

    implicit none

    class(vertical_sl_rho_test_type), intent(inout) :: this

    call feign_transport_config( operators = operators_fv,                                 &
                                 transport_ageofair=.false.,                               &
                                 ageofair_reset_level = 10,                                &
                                 runge_kutta_method = runge_kutta_method_ssp2,             &
                                 fv_vertical_order = 2,                                    &
                                 fv_horizontal_order = 2,                                  &
                                 advective_then_flux = .false.,                            &
                                 broken_w2_projection = .false.,                           &
                                 consistent_metric  = .false.,                             &
                                 oned_reconstruction = .false.,                            &
                                 cfl_mol_1d_stab = 1.0_r_def,                              &
                                 cfl_mol_2d_stab = 1.0_r_def,                              &
                                 cfl_mol_3d_stab = 1.0_r_def,                              &
                                 slice_order = slice_order_cubic,                          &
                                 vertical_sl_order = vertical_sl_order_quintic,            &
                                 use_density_predictor = .false.,                          &
                                 ffsl_flux_splitting = ffsl_flux_splitting_full,           &
                                 ffsl_advective_splitting = ffsl_advective_splitting_full, &
                                 moisture_eqn=moisture_eqn_advective,                      &
                                 dry_field_name='tracer',                                  &
                                 profile_size = 1,                                         &
                                 field_names = (/'tracer'/),                               &
                                 scheme = (/1/),                                           &
                                 splitting = (/1/),                                        &
                                 horizontal_method = (/1/),                                &
                                 vertical_method = (/1/),                                  &
                                 horizontal_monotone = (/1/),                              &
                                 vertical_monotone = (/1/),                                &
                                 vertical_monotone_order = (/1/),                          &
                                 log_space = (/.false./),                                  &
                                 enforce_min_value = (/.false./),                          &
                                 min_value = (/0.0_r_def/),                                &
                                 max_vert_cfl_calc = max_vert_cfl_calc_uniform,            &
                                 reversible = (/.false./)                                  &
                                 )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,  only: final_configuration

    implicit none

    class(vertical_sl_rho_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env,      only : real64
    use vertical_sl_rho_kernel_mod, only: vertical_sl_rho_code
    use transport_config_mod,       only: vertical_sl_order_cubic, &
                                          vertical_sl_order_quintic

    implicit none

    class(vertical_sl_rho_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def)            :: use_tol
    integer(i_def), parameter :: nlayers = 5
    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: nfaces_h  = 4
    integer(i_def), parameter :: undf_w2 = nfaces_h*nlayers & ! Horizontal dofs
                                         + nlayers + 1        ! + vertical dofs
    integer(i_def), parameter :: ndf_w3  = 1
    integer(i_def), parameter :: undf_w3 = nlayers
    integer(i_def), parameter :: ndf_wtheta = 2
    integer(i_def), parameter :: undf_wtheta = nlayers + 1
    integer(i_def), dimension(ndf_w2)     :: map_w2
    integer(i_def), dimension(ndf_w3)     :: map_w3
    integer(i_def), dimension(ndf_wtheta) :: map_wtheta
    real(r_def), dimension(undf_w2)       :: dep_pts_z
    real(r_def), dimension(undf_w3)       :: rho_in, rho_in2, rho_out
    real(r_def), dimension(undf_wtheta)   :: z_edges
    real(r_def), dimension(6)             :: quintic_param, quintic_coeff
    real(r_def), dimension(6)             :: cubic_coeff, linear_coeff
    real(r_def)     :: dt_here, wind_const, x, xd
    integer(i_def)  :: i, im3, im2, im1, ip1, ip2, df, sl_order
    logical(l_def)  :: enforce_min_value
    integer(i_def)  :: monotone, monotone_order
    real(r_def)     :: min_value
    ! Create the dof map for any number of layers
    ! Dofs are contiguous in the vertical and so each entry is
    ! offset by nlayers
    sl_order = vertical_sl_order_quintic
    do df = 1, nfaces_h
      map_w2(df) = 1 + (df-1)*nlayers
    end do
    ! Vertical dofs are contiguous and so
    ! map(6) needs to be 1 more than map(5)
    map_w2(nfaces_h+1) = 1 + nfaces_h*nlayers
    map_w2(ndf_w2)     = map_w2(nfaces_h+1) + 1
    map_w3(:) = 1
    map_wtheta(:) = (/ 1, 2 /)

    ! Set 6 parameters to define a unique global quintic function f(x)
    quintic_param(:) = (/1.0_r_def, -2.0_r_def,  1.0_r_def,  2.0_r_def,  0.5_r_def, 1.5_r_def/)
    ! Set the interpolation weights (quinctic, cubic, linear) for a displacement of 0.5
    quintic_coeff(:) = (/3.0_r_def,-25.0_r_def,150.0_r_def,150.0_r_def,-25.0_r_def, 3.0_r_def/)
      cubic_coeff(:) = (/0.0_r_def, -1.0_r_def,  9.0_r_def,  9.0_r_def, -1.0_r_def, 0.0_r_def/)
     linear_coeff(:) = (/0.0_r_def,  0.0_r_def,  0.5_r_def,  0.5_r_def,  0.0_r_def, 0.0_r_def/)
      cubic_coeff(:) =   cubic_coeff(:)/16.0_r_def
    quintic_coeff(:) = quintic_coeff(:)/256.0_r_def

    wind_const = 1.0_r_def
    dt_here = 0.5_r_def
    dep_pts_z = wind_const*dt_here
    do i = 1, nlayers + 1
      z_edges(i) = real(i-1,r_def)/real(nlayers,r_def)
    end do

    do i = 1, nlayers
      x  = 0.5_r_def*( z_edges(i) + z_edges(i+1) )
      rho_in(i) = quintic_param(1)*(x**5) + quintic_param(2)*(x**4) + &
                  quintic_param(3)*(x**3) + quintic_param(4)*(x**2) + &
                  quintic_param(5)*x      + quintic_param(6)
    end do
    ! The default interpolation is quintic, but reduces to cubic or linear
    ! as the setencil of data reduces near the boundaries. This is also the rule
    ! inside the kernel "vertical_sl_rho_code"
    do i = 1, nlayers
      im1 = max(i-1_i_def,1_i_def)
      im2 = max(i-2_i_def,1_i_def)
      im3 = max(i-3_i_def,1_i_def)
      ip1 = min(i+1_i_def,nlayers)
      ip2 = min(i+2_i_def,nlayers)
      if ( im3 == im2 .or. ip1 == ip2 ) then
          if ( im2 == im1 .or. i == ip1 ) then
             rho_out(i) = linear_coeff(1)*rho_in(im3) + linear_coeff(2)*rho_in(im2) + &
                          linear_coeff(3)*rho_in(im1) + linear_coeff(4)*rho_in(i  ) + &
                          linear_coeff(5)*rho_in(ip1) + linear_coeff(6)*rho_in(ip2)
          else
             rho_out(i) = cubic_coeff(1)*rho_in(im3) + cubic_coeff(2)*rho_in(im2) + &
                          cubic_coeff(3)*rho_in(im1) + cubic_coeff(4)*rho_in(i  ) + &
                          cubic_coeff(5)*rho_in(ip1) + cubic_coeff(6)*rho_in(ip2)
          end if
      else
        rho_out(i) = quintic_coeff(1)*rho_in(im3) + quintic_coeff(2)*rho_in(im2) + &
                     quintic_coeff(3)*rho_in(im1) + quintic_coeff(4)*rho_in(i  ) + &
                     quintic_coeff(5)*rho_in(ip1) + quintic_coeff(6)*rho_in(ip2)
      end if
    end do
    ! For i=1 the depature is clipped (zd=z(1)) because it oustide the data range
    ! and the dispalcement is 0
    rho_out(1) = rho_in(1)
    ! rho_in gets overwitten by the new values on exit
    monotone = vertical_monotone_none
    monotone_order = vertical_monotone_order_high
    enforce_min_value = .false.
    min_value = 0.0_r_def
    rho_in2(:)=rho_in(:)

    call vertical_sl_rho_code( nlayers,                            &
                               dep_pts_z,                          &
                               rho_in,                             &
                               z_edges,                            &
                               sl_order,                           &
                               monotone,                           &
                               monotone_order,                     &
                               enforce_min_value,                  &
                               min_value,                          &
                               ndf_w2, undf_w2, map_w2,            &
                               ndf_w3, undf_w3, map_w3,            &
                               ndf_wtheta, undf_wtheta, map_wtheta )
    if ( r_def == real64 ) then
       use_tol = tol
    else
       use_tol = 10.0_r_def*spacing(maxval(rho_in(:)))
    end if

    do i = 1,nlayers
      @assertEqual(rho_out(i), rho_in(i) , use_tol)
    end do

    ! redo the test with mono on

    monotone = vertical_monotone_strict
    monotone_order = vertical_monotone_order_high
    enforce_min_value = .false.
    min_value = 0.0_r_def

    call vertical_sl_rho_code( nlayers,                            &
                               dep_pts_z,                          &
                               rho_in2,                            &
                               z_edges,                            &
                               sl_order,                           &
                               monotone,                           &
                               monotone_order,                     &
                               enforce_min_value,                  &
                               min_value,                          &
                               ndf_w2, undf_w2, map_w2,            &
                               ndf_w3, undf_w3, map_w3,            &
                               ndf_wtheta, undf_wtheta, map_wtheta )
    if ( r_def == real64 ) then
       use_tol = tol
    else
       use_tol = 10.0_r_def*spacing(maxval(rho_in2(:)))
    end if

    do i = 1,nlayers
      @assertEqual(rho_out(i), rho_in2(i) , use_tol)
    end do
  end subroutine test_all
end module vertical_sl_rho_kernel_mod_test
