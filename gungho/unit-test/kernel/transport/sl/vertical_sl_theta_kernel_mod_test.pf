!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!

!> Test the vertical_sl_theta_kernel.
!>
module vertical_sl_theta_kernel_mod_test

  use constants_mod, only : i_def, r_def, l_def
  use pFUnit_Mod
  use transport_enumerated_types_mod, only : vertical_monotone_none,        &
                                             vertical_monotone_strict,      &
                                             vertical_monotone_order_high

  implicit none

  private

  public :: test_all

  @TestCase
  type, public, extends(TestCase) :: vertical_sl_theta_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type vertical_sl_theta_test_type

contains
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

  use feign_config_mod,      only : feign_transport_config
  use transport_config_mod,  only : operators_fv,                  &
                                    runge_kutta_method_ssp2,       &
                                    slice_order_cubic,             &
                                    vertical_sl_order_cubic,       &
                                    ffsl_flux_splitting_full,      &
                                    ffsl_advective_splitting_full, &
                                    max_vert_cfl_calc_uniform,     &
                                    moisture_eqn_advective,        &
                                    horizontal_monotone,           &
                                    vertical_monotone,             &
                                    vertical_monotone_order

    implicit none

    class(vertical_sl_theta_test_type), intent(inout) :: this

    call feign_transport_config( operators = operators_fv,                                 &
                                 runge_kutta_method = runge_kutta_method_ssp2,             &
                                 fv_vertical_order = 2,                                    &
                                 fv_horizontal_order = 2,                                  &
                                 advective_then_flux = .false.,                            &
                                 broken_w2_projection = .false.,                           &
                                 consistent_metric  = .false.,                             &
                                 oned_reconstruction = .false.,                            &
                                 cfl_mol_1d_stab = 1.0_r_def,                              &
                                 cfl_mol_2d_stab = 1.0_r_def,                              &
                                 cfl_mol_3d_stab = 1.0_r_def,                              &
                                 slice_order = slice_order_cubic,                          &
                                 vertical_sl_order = vertical_sl_order_cubic,              &
                                 use_density_predictor = .false.,                          &
                                 ffsl_flux_splitting = ffsl_flux_splitting_full,           &
                                 ffsl_advective_splitting = ffsl_advective_splitting_full, &
                                 moisture_eqn=moisture_eqn_advective,                      &
                                 dry_field_name='tracer',                                  &
                                 profile_size = 1,                                         &
                                 field_names = (/'tracer'/),                               &
                                 scheme = (/1/),                                           &
                                 splitting = (/1/),                                        &
                                 horizontal_method = (/1/),                                &
                                 vertical_method = (/1/),                                  &
                                 horizontal_monotone = (/1/),                              &
                                 vertical_monotone = (/1/),                                &
                                 vertical_monotone_order = (/1/),                          &
                                 log_space = (/.false./),                                  &
                                 enforce_min_value = (/.false./),                          &
                                 min_value = (/0.0_r_def/),                                &
                                 max_vert_cfl_calc = max_vert_cfl_calc_uniform,            &
                                 reversible = (/.false./),                                 &
                                 transport_ageofair=.false.,                               &
                                 ageofair_reset_level = 10                                 &
                                 )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,  only: final_configuration

    implicit none

    class(vertical_sl_theta_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env,      only : real64
    use vertical_sl_theta_kernel_mod, only: vertical_sl_theta_code
    use transport_config_mod,         only: vertical_sl_order_cubic

    implicit none

    class(vertical_sl_theta_test_type), intent(inout) :: this
    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def)            :: use_tol
    integer(i_def), parameter :: nlayers = 5
    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: nfaces_h  = 4
    integer(i_def), parameter :: undf_w2 = nfaces_h*nlayers & ! Horizontal dofs
                                         + nlayers + 1        ! + vertical dofs
    integer(i_def), parameter :: ndf_wtheta = 2
    integer(i_def), parameter :: undf_wtheta = nlayers + 1
    integer(i_def), dimension(ndf_w2)     :: map_w2
    integer(i_def), dimension(ndf_wtheta) :: map_wtheta
    real(r_def), dimension(undf_w2)       :: dep_pts_z
    real(r_def), dimension(undf_wtheta)   :: theta_in, theta_in2, theta_out, z_edges
    real(r_def), dimension(4) :: cubic_param, cubic_coeff
    real(r_def)     :: x
    integer(i_def)  :: i, im1, ip1, ip2, df, sl_order
    logical(l_def)  :: enforce_min_value
    integer(i_def)  :: monotone, monotone_order
    real(r_def)     :: min_value
    ! Create the dof map for any number of layers
    ! Dofs are contiguous in the vertical and so each entry is
    ! offset by nlayers
    sl_order = vertical_sl_order_cubic
    do df = 1, nfaces_h
      map_w2(df) = 1 + (df-1)*nlayers
    end do
    ! Vertical dofs are contiguous and so
    ! map(6) needs to be 1 more than map(5)
    map_w2(nfaces_h+1) = 1 + nfaces_h*nlayers
    map_w2(ndf_w2)     = map_w2(nfaces_h+1) + 1
    ! Theta has two dofs, and follows the same pattern as the vertical dofs
    ! in the wind field
    map_wtheta(:) = (/ 1, 2 /)
    ! Get canned information for the reference cube
    theta_in(:) = 0.0_r_def
    cubic_param(:) = (/ -1.0_r_def, 2.0_r_def, 1.0_r_def,  2.0_r_def /)
    cubic_coeff(:) = (/ -1.0_r_def, 9.0_r_def, 9.0_r_def, -1.0_r_def /)
    cubic_coeff(:) = cubic_coeff(:)/16_r_def
    dep_pts_z = -0.5_r_def
    ! Set top and bottom departure distance (w=0)
    dep_pts_z(map_w2(5))= 0.0_r_def
    dep_pts_z(map_w2(5)+nlayers) = 0.0_r_def

    do i = 1, nlayers + 1
      z_edges(i) = real(i-1,r_def)/real(nlayers,r_def)
    end do

    do i = 1, nlayers + 1
      x  = z_edges(i)
      theta_in(i) = cubic_param(1)*x**3 + cubic_param(2)*x**2 + &
                    cubic_param(3)*x    + cubic_param(4)
    end do
    do i = 1, nlayers + 1
       im1 = max(i-1,1)
       ip1 = min(i+1,nlayers+1)
       ip2 = min(i+2,nlayers+1)
       theta_out(i) = cubic_coeff(1)*theta_in(im1) + cubic_coeff(2)*theta_in(i) &
                    + cubic_coeff(3)*theta_in(ip1) + cubic_coeff(4)*theta_in(ip2)
    end do
    theta_out(1)         = theta_in(1)
    theta_out(nlayers+1) = theta_in(nlayers+1)
    theta_out(nlayers)   = 0.5_r_def*theta_in(nlayers) +  &
                           0.5_r_def*theta_in(nlayers+1)
    ! Theta_in gets overwitten by the new values on exit
    monotone = vertical_monotone_none
    monotone_order = vertical_monotone_order_high
    enforce_min_value = .false.
    min_value = 0.0_r_def
    theta_in2(:)=theta_in(:)

    call vertical_sl_theta_code( nlayers,                             &
                                 dep_pts_z,                           &
                                 theta_in,                            &
                                 z_edges,                             &
                                 sl_order,                            &
                                 monotone,                            &
                                 monotone_order,                      &
                                 enforce_min_value,                   &
                                 min_value,                           &
                                 ndf_w2, undf_w2, map_w2,             &
                                 ndf_wtheta, undf_wtheta, map_wtheta  )

    if ( r_def == real64 ) then
       use_tol = tol
    else
       use_tol = 10.0_r_def*spacing(maxval(theta_in(:)))
    end if
    do i = 1,nlayers + 1
      @assertEqual(theta_out(i), theta_in(i) ,use_tol)
    end do

    ! redo the test with mono on

    monotone = vertical_monotone_strict
    monotone_order = vertical_monotone_order_high
    enforce_min_value = .false.
    min_value = 0.0_r_def

    call vertical_sl_theta_code( nlayers,                             &
                                 dep_pts_z,                           &
                                 theta_in2,                           &
                                 z_edges,                             &
                                 sl_order,                            &
                                 monotone,                            &
                                 monotone_order,                      &
                                 enforce_min_value,                   &
                                 min_value,                           &
                                 ndf_w2, undf_w2, map_w2,             &
                                 ndf_wtheta, undf_wtheta, map_wtheta  )

    if ( r_def == real64 ) then
       use_tol = tol
    else
       use_tol = 10.0_r_def*spacing(maxval(theta_in2(:)))
    end if
    do i = 1,nlayers + 1
      @assertEqual(theta_out(i), theta_in2(i) ,use_tol)
    end do

  end subroutine test_all
end module vertical_sl_theta_kernel_mod_test
