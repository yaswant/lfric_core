#!jinja2
{%- set science_configurations = 'runge-kutta', 'semi-implicit',
                                 'transport-rk', 'transport-biperiodic',
                                 'biperiodic_p0_gw', 'biperiodic_p1_gw', 'biperiodic_p0_gw_short',
                                 'biperiodic_p0_gw_fem',
                                 'dcmip301', 'robert', 'robert-moist', 'robert_short',
                                 'sbr', 'sbr_spinupwinds', 'sbr_spinupalpha',
                                 'straka_x', 'straka_y', 'straka_200m',
                                 'biperiodic-cosmic',
                                 'baroclinic'%}
{%- set miniapp_configurations = ['gravity_wave', 'umphysics_testbuild'] %}
{%- set groups = {'developer': ['science(semi-implicit, env={"nrun":3})',
                                'science(runge-kutta, env={"nrun":30})',
                                'science(transport-rk)',
                                'science(transport-biperiodic)',
                                'science(biperiodic_p0_gw_short)',
                                'science(biperiodic_p1_gw)',
                                'science(straka_y, plotstr="straka_plot_y.py $NODAL_DATA_DIR theta T000090 $PLOT_DIR")',
                                'science(robert_short, env={"crun":3, "nrun":5})',	
                                'science(baroclinic, plotstr="slices.py diagDynamo $NODAL_DATA_DIR theta:rho:1u:2u:3u T000010 180 50 0 $PLOT_DIR")',
                                'check_compilers(fast-debug)',
                                'canned_test',
                                'godlines',
                                'cleanlines'],	
                  'nightly': ['science(biperiodic_p0_gw, checkkgo=False, plotstr="gw_cart_plot.py $NODAL_DATA_DIR theta T000000:T000100:T000200:T000300 $PLOT_DIR")',
                              'science(biperiodic_p0_gw_fem, plotstr="gw_cart_plot.py $NODAL_DATA_DIR theta T000000:T000100:T000200:T000300 $PLOT_DIR")',
                              'science(robert,      env={"crun":3, "nrun":50}, checkkgo=True)',
                              'science(robert-moist,env={"crun":3, "nrun":50}, checkkgo=True)',
                              'science(straka_200m, plotstr="straka_plot_x.py $NODAL_DATA_DIR theta T000360 $PLOT_DIR")',
                              'science(straka_x, plotstr="straka_plot_x.py $NODAL_DATA_DIR theta T000090 $PLOT_DIR" )',
                              'science(straka_y, plotstr="straka_plot_y.py $NODAL_DATA_DIR theta T000090 $PLOT_DIR" )',
                              'science(dcmip301, plotstr="dcmip301.py $NODAL_DATA_DIR theta T000180:T000252:T000324:T000360 $PLOT_DIR")',
                              'science(biperiodic-cosmic,plotstr="biperiodic-cosmic_plot.py $NODAL_DATA_DIR rho T000000:T000500 $PLOT_DIR")',
                              'science(sbr, env={"nrun":60})',
                              'miniapp(gravity_wave, plotstr="slices.py gravity_wave $NODAL_DATA_DIR buoyancy T000036 150 0 6 $PLOT_DIR")',
                              'check_compilers(full-debug, True)',
                              'godlines(True)',
                              'publish_commit']} %}


{# The csar groups are now included in the following #}
%include inc/csar.rc
{%- do groups.update(csar_groups) %}

{%- set mesh_types = ['cubedsphere', 'biperiodic'] %}
{%- set plot_config = {} %}
{%- set compiler_setup = {} -%}
{%- for compiler, setup in TARGET_COMPILER_SETUP|batch(2) -%}
{%-     do compiler_setup.update({compiler : [setup]}) -%}
{%- endfor -%}

{%- if RUN_NAMES is defined %}
{%-   if RUN_NAMES is string %}
{%-     set groupsToRun = [RUN_NAMES] %}
{%-   else %}
{%-     set groupsToRun = RUN_NAMES %}
{%-   endif %}
{%- else %}
{%-   set groupsToRun = ['developer'] %}
{%- endif %}

{%- if MIRROR_UPLOAD_URL and MIRROR_UPLOAD_URL|list|last != '/' %}
{%-   set MIRROR_UPLOAD_URL = MIRROR_UPLOAD_URL + '/' %}
{%- endif %}

{#- #########################################################################}
{%-   set SCIENCE_LABEL =  TARGET_SCIENCE_COMPILER + '_fast-debug' %}
{%- macro science( configuration, resolutions="None", checkkgo=True, plotstr="None", env=None) %}
{%-   set label = SCIENCE_LABEL %}

{% set crun = 1 %}
{% if env is not none %}
{%   if 'crun' in env.keys() %}
{%     set crun = env['crun'] %}
{%   endif %}
{% endif %}

{%-  if resolutions == "None" %}
{%-     set resolutions=[('')] %}
{%-  endif %}
{%-  for resolution in resolutions %}
{%-   set resname = resolution if resolution is string else (resolution[0] if resolution|length>1 else '') %}
{%-   set dt_vals = [''] if (resolution is string or (resolution|length<2)) else resolution[1:] %}
{%-  for dt in dt_vals %}

{%-    set label_res = label + ('' if resname=='' else '_') + resname + ('' if dt=='' else '_dt-') ~ dt %}
{%-    set label_res = label_res|replace('.','p') %} {# we can't have '.' in a task name, to replace with a 'p' #}
{%- if crun > 1  %}
         [[[R{{crun}}/P1/{{crun}}]]]
            graph = """
            run_{{configuration}}_{{label_res}}[-P1] => run_{{configuration}}_{{label_res}}
                 """
         [[[R1/P{{crun}}/{{crun}}]]]
            graph = """
{%-     if checkkgo %}
{%-        if TARGET_SCIENCE_COMPILER in TARGET_PERFORM_KGO_TESTS  %}
            run_{{configuration}}_{{label_res}} => check_{{configuration}}_{{label_res}}
{%-        endif %}
{%-     endif %}
{%-   if plotstr != "None" %}
{%-     do plot_config.update( {configuration : plotstr} ) %}
            run_{{configuration}}_{{label_res}}:finish => plot_{{configuration}}_{{label_res}}
            plot_{{configuration}}_{{label_res}}:finish  => publish_{{configuration}}_{{label_res}}_plots
{%-   endif %}
                 """
{%- endif %}
        [[[R1]]]
            graph = """
            purge_local => purge_target
            purge_target => export_for_{{label}}
            export_for_{{label}} => compile_with_{{label}}
{%- if do_meshes %}
	    compile_with_{{label}} => GENERATE_MESHES_{{label|upper}}
{%-   if TARGET_SCIENCE_COMPILER in TARGET_PERFORM_RUN %}
            GENERATE_MESHES_{{label|upper}}:finish-all=> run_{{configuration}}_{{label_res}}
{%-   endif %}
{%- else %}
	    compile_with_{{label}} => run_{{configuration}}_{{label_res}}
{%-   endif %}
{%-   if checkkgo  %}
{%-   if TARGET_SCIENCE_COMPILER in TARGET_PERFORM_RUN %}
{%-     if TARGET_SCIENCE_COMPILER in TARGET_PERFORM_KGO_TESTS and crun < 2  %}
            run_{{configuration}}_{{label_res}} => check_{{configuration}}_{{label_res}}
{%-     endif %}
{%-     endif %}
{%-   endif %}
{%-   if plotstr != "None" and crun < 2 %}
            run_{{configuration}}_{{label_res}} => publish_{{configuration}}_{{label_res}}
{%-     do plot_config.update( {configuration : plotstr} ) %}
            run_{{configuration}}_{{label_res}} => plot_{{configuration}}_{{label_res}}
            plot_{{configuration}}_{{label_res}} => publish_{{configuration}}_{{label_res}}_plots
{%-   endif %}
                 """
{%-  endfor  %}
{%-  endfor  %}
{%- endmacro %}
{#- #########################################################################}
{%- macro canned_test() %}
      [[[R1]]] 
{%-   set label = TARGET_SCIENCE_COMPILER | lower + '_' + 'fast-debug' %}
{%-   if TARGET_SCIENCE_COMPILER in TARGET_PERFORM_RUN %}
            purge_local => purge_target
            purge_target => export_for_{{label}}
            export_for_{{label}} => compile_with_{{label}}
            compile_with_{{label}} => run_canned_test_{{label}}
{%-   endif %}
{%- endmacro %}
{#- #########################################################################}
{%- macro miniapp( appname, plotstr="None", env=None, checkkgo=True ) %}
      [[[R1]]] 
{%-   set label = TARGET_SCIENCE_COMPILER|lower + '_fast-debug' %}
            purge_local => purge_target
            purge_target => export_for_{{label}}
            export_for_{{label}} => compile_with_{{label}}
{%-   if TARGET_SCIENCE_COMPILER in TARGET_PERFORM_RUN %}
            compile_with_{{label}} => run_{{label}}_{{appname}}
{%-    if checkkgo  %}
{%-     if TARGET_SCIENCE_COMPILER in TARGET_PERFORM_KGO_TESTS %}
            run_{{label}}_{{appname}} => check_{{label}}_{{appname}}
{%-     endif %}
{%-    endif %}
{%-   endif %}
{%-   if plotstr != "None" %}
{%-     do plot_config.update( {appname : plotstr} ) %}
            run_{{label}}_{{appname}}:finish => plot_{{appname}}_{{label}}
            plot_{{appname}}_{{label}}:finish  => publish_{{appname}}_{{label}}_plots
{%-   endif %}
{%- endmacro %}
{#- #########################################################################}
{%- macro cleanlines() %}
      [[[R1]]] 
{%-   set label =  TARGET_TECHNICAL_COMPILER | lower + '_fast-debug' %}
{%-   if 'cleanliness' in TECHNICAL_DEVELOPER_TESTS %}
            purge_local => purge_target
            purge_target => export_for_{{label}}
            export_for_{{label}} => compile_with_{{label}}
{#- The following line removed due to a bug brought to light by #730. #}
{#- Ticket #762 has been created to fix this.                         #}
{#-            compile_with_{{label}} => check_for_unused_source #}
{%-   endif %}
{%- endmacro %}
{#- Documentation, it's next to cleanlines ##################################}
{%- macro godlines(publish=False) %}
      [[[R1]]] 
{%-   set label =  TARGET_TECHNICAL_COMPILER | lower + '_fast-debug' %}
{%-   if 'documentation' in TECHNICAL_DEVELOPER_TESTS %}
            purge_local => purge_target
            purge_target => export_for_{{label}}
            export_for_{{label}} => api_documentation
            export_for_{{label}} => uml_documentation
            export_for_{{label}} => design_documentation
{%-     if publish %}
            api_documentation    => publish_api_documentation
            api_documentation    => publish_api_log
            uml_documentation    => publish_uml_documentation
            design_documentation => publish_design_documentation
{%-     endif %}
{%-   endif %}
{%- endmacro %}
{#- #########################################################################}
{%- macro publish_commit() %}
      [[[R1]]] 
            PUBLISH:finish-all => publish_index
            publish_index      => mirror_results_local
{%- if MIRROR_UPLOAD_URL %}
            publish_index      => mirror_results_remote
{%- endif %}
{%- endmacro %}
{#- #########################################################################}
{%- macro check_compilers( build, publish=False ) %}
      [[[R1]]] 
{%-   for compiler in compiler_setup.keys() %}
{%-     set label = compiler | lower + '_' + build | lower%}
{%-     set perform_run = TARGET_PERFORM_RUN %}
{%-     if build == 'full-debug' and TARGET_PERFORM_DEBUG_RUN is defined %}
{%-       set perform_run = TARGET_PERFORM_DEBUG_RUN %}
{%-     endif %}
            purge_local => purge_target
            purge_target => export_for_{{label}}
            export_for_{{label}} => compile_with_{{label}}
{%-     if publish %}
            compile_with_{{label}}:finish => publish_{{label}}_compile
{%-     endif %}
{%-     if compiler in perform_run %}
{%-       if compiler in TARGET_PERFORM_UNIT_TESTS %}
            compile_with_{{label}} => unit_test_with_{{label}}
{%-       endif %}
            compile_with_{{label}} => run_semi-implicit_{{label}}
{%-       if publish %}
            run_semi-implicit_{{label}}:finish => publish_semi-implicit_{{label}}
{%-       endif %}
{%-       if compiler in TARGET_PERFORM_KGO_TESTS %}
            run_semi-implicit_{{label}} => check_semi-implicit_{{label}}
{%-       endif %}
{%-     endif %}
{%-   endfor %}
{%- endmacro %}
{#- #########################################################################}
{%- macro schedule() %}
{%-   for group in groupsToRun %}
{%-       for mission in groups[group] %}
{{          mission | executeMacro() }}
{%-       endfor %}
{%-   endfor %}
{%- endmacro %}
{#- #########################################################################}
{%- macro setTaskEnv(scheduledTasksDict) %}
{%-   for group in groupsToRun %}
{%-      for mission in groups[group] %}
{%-           set k,envDict = mission | getEnvMacro() %}
{%-        if k is not none %}
{%            set key = k + '_' + SCIENCE_LABEL %} 
{%-           do scheduledTasksDict.update({key: envDict}) %}
{%-        endif %}
{%-      endfor %}
{%-   endfor %}
{%- endmacro %}
{#- #########################################################################}
{%- macro setCrunInfo(crunInfo,scheduledTasksDict) %}
{%-   for key, envDict in scheduledTasksDict.items() %}
{%-      if 'crun' in envDict.keys() %}
{%          if envDict['crun'] > crunInfo['maxcrun']  %}
{%-           do crunInfo.update({'maxcrun':envDict['crun']})  -%}
{%-         endif  -%}
{%-      endif %}
{%-   endfor %}
{%- endmacro %}
{#- #########################################################################}
{%- macro setResolutions(resolution_choices) %}
{%-   for group in groupsToRun %}
{%-      for mission in groups[group] %}
{%-         set configuration,resList,resDict = mission | getResolutionMacro() %}
{%          if resList != [] %}
{%-          if configuration not in resolution_choices.keys() %}
{%-            do resolution_choices.update({configuration:[]})  -%}
{%-          endif %}
{%-          for res in resList %}
{%-            if res not in resolution_choices[configuration] %}
{%-               do resolution_choices[configuration].append(res) -%}
{%-            endif %}
{%-          endfor %}
{%-         endif %}
{%-      endfor %}
{%-   endfor %}
{%- endmacro %}

{#
# crunInfo is dictionary containing variables needed to dynamically 
# construct the graph for cruns:
#     maxcrun specifies the maximum number of cycles
# scheduledTasksEnv is a dictionary of environment variables to be 
# passed from the mission to the task - these are evalulated as a string
# of variable = value pairs
# scheduledTasksDict is as scheduledTasksEnv, but the python dictionary
# rather than a string - this is then used in setting the directives
# These are updated from the mission calls
#}

{%- set crunInfo = {'maxcrun':1} %}  {# 'maxcrun' is used as the number of cycles based on the requested jobs #}
{%- set MAXRUNAHEAD = 50 %} {# The maximum allowable runahead limit - if we need more thant this then maybe split up the suite, or just be patient! #}
{%- set scheduledTasksEnv = {} %}
{%- set scheduledTasksDict = {} %}
{%- set dummy = setTaskEnv(scheduledTasksDict) -%} {# sets the environment configurations for each job #}
{%- set dummy = setCrunInfo(crunInfo, scheduledTasksDict) -%} {# sets the crunInfo #}

{%- set resolution_choices = {} %}
{%- set dummy = setResolutions(resolution_choices) %} {# sets the requested resolutions #}
{# Based on the resolutions and configurations, work out which meshes we need to generate #}
{%- set mesh_names = [] %}
{%- for config, resolutions in resolution_choices.items() %}
{%-   for resolution in resolutions %}
{%-     set mesh_name = resolution if resolution is string else (resolution[0] if resolution|length>1 else '') %}
{%-     do mesh_names.append(mesh_name) if mesh_name not in mesh_names%}
{%-   endfor %}
{%- endfor %}
{%- set do_meshes = mesh_names|length > 0 %}{# Only make meshes if we need to #}

{%- macro deleteDirectory( directory ) %}
test -w "{{directory}}" -o ! -e "{{directory}}" && rm -rf {{directory}} || ( echo ** Unable to delete "{{directory}}", not writable >&2; false )
{%- endmacro %}

[cylc]
    UTC mode = True
    [[events]]
        mail events = timeout
        abort on timeout = True
{%- if 'nightly' in groupsToRun %}
        abort on stalled = True
{%- endif %}
        timeout = PT3H

[scheduling]
    cycling mode        = integer
    initial cycle point = 1
    final cycle point   = {{ crunInfo['maxcrun'] }}
    max active cycle points = {{ crunInfo['maxcrun'] if crunInfo['maxcrun'] < MAXRUNAHEAD else MAXRUNAHEAD  }}
    
    [[queues]]
        [[[host_throttle]]]
            limit = {{ TARGET_THROTTLE }}
            members = root
    [[dependencies]]
{%- set scheduledTasks = schedule() | deduplicateSchedule()%}
{{scheduledTasks}}

{%- set allTasks = scheduledTasks  %}

[runtime]
    [[root]]
        initial scripting = """
                            export CYLC_VERSION={{CYLC_VERSION}}
                            export ROSE_VERSION={{ROSE_VERSION}}
                            """
        script = "rose task-run"
        [[[events]]]
{%- if TROUBLE_MAIL_ADDRESS is defined %}
            mail to = {{TROUBLE_MAIL_ADDRESS}}
            mail events = submission timeout, submission failed, timeout, failed, execution timeout
{%- endif %}
            submission timeout = PT12H
            execution timeout  =  PT3H
        [[[environment]]]
            SOURCE_ROOT = $CYLC_SUITE_SHARE_DIR/source
            OUTPUT_ROOT = $CYLC_SUITE_SHARE_DIR/output

    [[ LOCAL ]]
        [[[remote]]]
            host = {{ ROSE_ORIG_HOST }}
        [[[job]]]
            batch system = background

    [[TARGET]]
        [[[remote]]]
            host = {{TARGET_HOST}}
        [[[job]]]
            batch system = {{TARGET_BATCHER}}

{%- macro ensureDestination() %}
                     mkdir -p $DESTINATION
{%- endmacro %}
{%- set publish_destination = '$CYLC_SUITE_SHARE_DIR/publish-' + TARGET_OPT %}
    [[PUBLISH]]
        [[[environment]]]
            DESTINATION = {{publish_destination}}

##############################################################################
    [[purge_local]]
        inherit = None, LOCAL
        script = '''
                 {{deleteDirectory( "$OUTPUT_ROOT" )}}
                 {{deleteDirectory( "$SOURCE_ROOT" )}}
                 '''

    # The build directives are used to ensure that any temporary space which
    # might be used for building is available to be cleaned.
    [[purge_target]]
        inherit = None, TARGET
        script = '''
                 {{deleteDirectory( TARGET_BUILD_ROOT )}}
                 {{deleteDirectory( "$OUTPUT_ROOT" )}}
                 {{deleteDirectory( "$SOURCE_ROOT" )}}
                 '''
        [[[directives]]]
{%- for DIRECTIVE in TARGET_BUILD_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%- endfor %}

{%- if 'publish_index' in allTasks %}
    # This task can not be part of the PUBLISH family as a prerequisite of
    # running it is that the PUBLISH family have completed. i.e. A circular
    # dependency. This means it can not take advantage of the environment set
    # up by the family. That is why some items are duplicated.
    [[publish_index]]
        inherit = None, LOCAL
        script = rose task-run --app-key=publish --command-key=index
        [[[environment]]]
            DESTINATION = $CYLC_SUITE_SHARE_DIR/publish-{{TARGET_OPT}}
{%-   if ROSE_BUSH_URL %}
            ROSE_BUSH_ARG = -bush {{ROSE_BUSH_URL}}
{%-   endif %}
{%- endif %}

{%- if 'mirror_results_local' in allTasks %}
    # Again, something which happens after publishing and so cannot be in the
    # PUBLISH family.
    [[mirror_results_local]]
        inherit = None, LOCAL
        script = rose task-run --app-key=publish --command-key=mirror
        [[[environment]]]
            REWRITE = ''
            SOURCE  = $CYLC_SUITE_SHARE_DIR/publish-{{TARGET_OPT}}
            TARGET  = file:///$HOME/public_html/lfric-gungho-{{TARGET_OPT}}
{%- endif %}

{%- if 'mirror_results_remote' in allTasks %}
    # Again, something which happens after publishing and so cannot be in the
    # PUBLISH family.
    [[mirror_results_remote]]
        inherit = None, LOCAL
        script = rose task-run --app-key=publish --command-key=mirror
        [[[environment]]]
            REWRITE = {{MIRROR_REWRITE}}
            SOURCE  = $CYLC_SUITE_SHARE_DIR/publish-{{TARGET_OPT}}
            TARGET  = {{MIRROR_UPLOAD_URL}}lfric-gungho-{{TARGET_OPT}}
{%- endif %}

##############################################################################
    [[TECHNICAL]]
        [[[environment]]]
            SOURCE_DIRECTORY      = $SOURCE_ROOT/{{TARGET_TECHNICAL_COMPILER}}_fast-debug
            DESTINATION_DIRECTORY = $OUTPUT_ROOT/{{TARGET_TECHNICAL_COMPILER}}_fast-debug
            WORKING_DIR           = {{TARGET_BUILD_ROOT}}/{{TARGET_TECHNICAL_COMPILER}}_fast-debug

{%- if 'check_for_unused_source' in allTasks %}
    [[check_for_unused_source]]
        inherit = None, TARGET, TECHNICAL
        pre-script = """
                     {{'\n'|commandList(LOCAL_BASE_SETUP, LOCAL_TECHNICAL_SETUP, LOCAL_REVEAL_SETUP, "mkdir -p $WORKING_DIR", "cp -rp $SOURCE_DIRECTORY/build/* $WORKING_DIR")}}
                     """
        script = make -C $SOURCE_DIRECTORY/gungho/source unused-check
        post-script = {{deleteDirectory( "$WORKING_DIR" )}}
        [[[directives]]]
{%-   for DIRECTIVE in TARGET_TECHNICAL_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-   endfor %}
{%- endif %}

    # Run locally as they need workstation tools such as Doxygen.
{%- if 'api_documentation' in allTasks %}
    [[api_documentation]]
        inherit = None, LOCAL, TECHNICAL
        pre-script = """
                     {{'\n'|commandList( LOCAL_BASE_SETUP, LOCAL_TECHNICAL_SETUP, LOCAL_REVEAL_SETUP, 'mkdir -p $DESTINATION_DIRECTORY') }}
                     """
        script = make -C $SOURCE_DIRECTORY document-api-gungho
        post-script = """
                      # Future publisher stages need this information
                      echo $CYLC_TASK_LOG_ROOT > $DESTINATION_DIRECTORY/api.doxygen.log.path
                      """
{%- endif %}

{%- if 'uml_documentation' in allTasks %}
    [[uml_documentation]]
      inherit = None, LOCAL, TECHNICAL
        pre-script = """
                     {{'\n'|commandList( LOCAL_BASE_SETUP, LOCAL_TECHNICAL_SETUP, LOCAL_REVEAL_SETUP, 'mkdir -p $DESTINATION_DIRECTORY') }}
                     """
        script = make -C $SOURCE_DIRECTORY document-uml-gungho
{%- endif %}

{%- if 'publish_api_log' in allTasks %}
    [[publish_api_log]]
        inherit = PUBLISH, TECHNICAL, LOCAL
        pre-script = """
{{ensureDestination()}}
                     cp `cat $DESTINATION_DIRECTORY/api.doxygen.log.path`.out $DESTINATION_DIRECTORY/api.doxygen.out
                     cp `cat $DESTINATION_DIRECTORY/api.doxygen.log.path`.err $DESTINATION_DIRECTORY/api.doxygen.err
                     """
        script = rose task-run --app-key=publish --command-key=doxygen
        [[[environment]]]
            LOG_OUT = $DESTINATION_DIRECTORY/api.doxygen.out
            LOG_ERR = $DESTINATION_DIRECTORY/api.doxygen.err
{%- endif %}

{%- if 'publish_api_documentation' in allTasks %}
    [[publish_api_documentation]]
        inherit = PUBLISH, LOCAL, TECHNICAL
        pre-script = """
{{ensureDestination()}}
                     """
        script = rose task-run --app-key=publish --command-key=directory
        [[[environment]]]
            DIRECTORY = $SOURCE_DIRECTORY/documentation/api
{%- endif %}

    # Run locally as they need workstation tools like Inkscape.
{%- if 'design_documentation' in allTasks %}
    [[design_documentation]]
        inherit = None, LOCAL, TECHNICAL
        pre-script = """
                     {{'\n'|commandList( LOCAL_BASE_SETUP, LOCAL_TECHNICAL_SETUP, LOCAL_REVEAL_SETUP) }}
                     """
        script = make -C $SOURCE_DIRECTORY document-latex-gungho
{%- endif %}

{%- if 'publish_design_documentation' in allTasks %}
    [[publish_design_documentation]]
        inherit = PUBLISH, LOCAL, TECHNICAL
        pre-script = """
{{ensureDestination()}}
                     """
        script = rose task-run --app-key=publish --command-key=tar-file
        [[[environment]]]
            FILE = $SOURCE_DIRECTORY/documentation/design-documents.tar
            DESTINATION = {{publish_destination}}/design
{%- endif %}

##############################################################################

{%- for compiler in compiler_setup.keys() -%}
{%-   for build in 'fast-debug', 'full-debug' %}
{%-     set label = compiler | lower + '_' + build | lower %}
{%-     set family = label | upper %}
    [[{{family}}]]
        [[[environment]]]
            SOURCE_DIRECTORY      = $SOURCE_ROOT/{{label}}
            DESTINATION_DIRECTORY = $OUTPUT_ROOT/{{label}}
            COMPILER              = {{compiler}}
            {#- We can't define WORKING_DIR here as it may contain    #}
            {#- target specific variables not existing on the local machine #}

    # Export must be performed locally as it needs access to any working copy
    # involved. Such a working copy may well be on a local disc.
    #
{%- if 'export_for_' + label in allTasks %}
    [[export_for_{{label}}]]
        inherit = {{family}}, LOCAL
        script = """
                 mkdir -p `dirname $SOURCE_DIRECTORY`
                 svn export {{ SOURCE_LFRIC }} $SOURCE_DIRECTORY
                 HOST={{TARGET_HOST}}
                 RELATIVE_SOURCE_DIRECTORY=`echo $SOURCE_DIRECTORY | sed "s|$HOME/||"`
                 ssh $HOST mkdir -p $RELATIVE_SOURCE_DIRECTORY
                 rsync -avz $SOURCE_DIRECTORY/ $HOST:$RELATIVE_SOURCE_DIRECTORY/
                 """
{%- endif %}

{%- if 'compile_with_' + label in allTasks %}
    [[compile_with_{{label}}]]
        inherit = {{family}}, TARGET
        pre-script = """
                     {{'\n'|commandList(TARGET_BASE_SETUP,
                                        compiler_setup[compiler],
                                        TARGET_BUILD_SETUP,
                                        TARGET_REVEAL_SETUP,
                                        deleteDirectory("$WORKING_DIR"))}}
                     """
        script      = rose task-run --app-key=compile
        post-script = """
                      {{deleteDirectory("$WORKING_DIR")}}
                      # Future publisher stages need this information
                      echo $CYLC_TASK_LOG_ROOT > $DESTINATION_DIRECTORY/lfric.gungho.{{compiler}}.log.path
                      """
        [[[environment]]]
            WORKING_DIR          = {{TARGET_BUILD_ROOT}}/{{label}}
            TARGET               = build-gungho
	    MESH_TARGET          = build-mesh_tools
            PROFILE              = {{build}}
            OPTIMISATION_PROFILE = {{TARGET_OPT}}
{% if UM_PHYSICS is defined %}
	    UM_PHYSICS           = {{UM_PHYSICS}}
{% endif %}
        [[[directives]]]
{%-   for DIRECTIVE in TARGET_BUILD_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-   endfor %}
{%- endif %}

{%- if 'publish_' + label + '_compile' in allTasks %}
    [[publish_{{label}}_compile]]
        inherit = PUBLISH, {{family}}, LOCAL
        pre-script = """
{{ensureDestination()}}
                     mkdir -p $DESTINATION_DIRECTORY
                     RELATIVE_DESTINATION_DIRECTORY=`echo $DESTINATION_DIRECTORY | sed "s|$HOME/||"`
                     scp {{TARGET_HOST}}:$RELATIVE_DESTINATION_DIRECTORY/lfric.gungho.{{compiler}}.log.path .
                     scp {{TARGET_HOST}}:`cat lfric.gungho.{{compiler}}.log.path`.out $DESTINATION_DIRECTORY/lfric.gungho.{{compiler}}.out
                     scp {{TARGET_HOST}}:`cat lfric.gungho.{{compiler}}.log.path`.err $DESTINATION_DIRECTORY/lfric.gungho.{{compiler}}.err
                     """
        script = rose task-run --app-key=publish --command-key=compile
        [[[environment]]]
            CONTEXT  = {{build}}
            COMPILER = {{compiler}}
            LOG_OUT  = $DESTINATION_DIRECTORY/lfric.gungho.{{compiler}}.out
            LOG_ERR  = $DESTINATION_DIRECTORY/lfric.gungho.{{compiler}}.err
{%- endif %}

{%-     if 'run_canned_test_' + label in allTasks %}
    [[run_canned_test_{{label}}]]
        inherit = {{family}}, TARGET
        pre-script = """
                     {{'\n'|commandList(TARGET_BASE_SETUP, compiler_setup[compiler], TARGET_RUN_SETUP, TARGET_REVEAL_SETUP)}}
                     """
        script = rose task-run --app-key=canned_test --command-key={{TARGET_RUN_METHOD}}
        [[[environment]]]
            SOURCE_DIRECTORY = $SOURCE_ROOT/{{label}}
        [[[environment]]]
            OMP_NUM_THREADS=1
        [[[directives]]]
{%-       for DIRECTIVE in TARGET_RUN_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-       endfor %}
{%-     endif %}

{%-     for configuration in science_configurations %} {# science configurations #}
{%-       if configuration in resolution_choices %}
{%-           set resolution_options=resolution_choices[configuration] %}
{%-       else  %}
{%-           set resolution_options=[''] %}
{%-       endif %}
{%-       set configuration_label = configuration|lower + '_' + label %}
{%-       for resolution in resolution_options %} {# science resolutions #}
{%-         set resname = resolution if resolution is string else (resolution[0] if resolution|length>1 else '') %}
{%-         set dt_vals = [''] if (resolution is string or (resolution|length<2)) else resolution[1:] %}
{%-         for dt in dt_vals %} {# resolutions timestep values #}
{%-           set configuration_label_res = configuration_label + ('' if resname=='' else '_') + resname + ('' if dt=='' else '_dt-') ~ (dt|replace('.','p')) %}
{%-        if 'run_' + configuration_label_res in allTasks %}
{% if configuration_label in scheduledTasksDict.keys() %}
   {%- set command_key = TARGET_NORMAL_RUN_METHOD if 'directives' in scheduledTasksDict[configuration_label].keys() else TARGET_RUN_METHOD%}
{% else  %}
   {%- set command_key = TARGET_RUN_METHOD%}
{% endif %}
    [[run_{{configuration_label_res}}]]
        inherit = {{family}}, TARGET
        pre-script = """
                     {{'\n'|commandList(TARGET_BASE_SETUP, compiler_setup[compiler], TARGET_RUN_SETUP, TARGET_REVEAL_SETUP)}}
                     """

{# If the mpi is configured by the suite, then we will use the setcores optional configuration, so let's check that here #}
{% set mpi_parts = '' %}
{% if configuration_label in scheduledTasksDict.keys() %}
{%   if 'directives' in scheduledTasksDict[configuration_label].keys() %}
{%     set directiveKey = resname if resname in scheduledTasksDict[configuration_label]['directives'].keys() else 'default'%}
{%     set directiveDict = scheduledTasksDict[configuration_label]['directives'][directiveKey] %}
{%     set mpi_parts = directiveDict['mpi_parts'] %}
{%   endif %}
{% endif %}

        script = rose task-run --app-key=gungho --command-key={{command_key}} --opt-conf-key={{configuration}} --opt-conf-key='({{'empty' if resname=='' else resname}})' --opt-conf-key='({{'empty' if dt=='' else 'setdt'}})' --opt-conf-key='({{'empty' if mpi_parts=='' else 'setcores_x'}})' 
        post-script = """
                      mkdir -p $DESTINATION_DIRECTORY/{{configuration}}
                      cp dynamo-checksums.txt $DESTINATION_DIRECTORY/{{configuration}}/{{compiler}}.checksums
                      mkdir -p $DESTINATION_DIRECTORY/{{configuration}}/results
                      cp $CYLC_TASK_WORK_DIR/diagDynamo*.m $DESTINATION_DIRECTORY/{{configuration}}/results/
                      # Future publisher stages need this information
                      echo $CYLC_TASK_LOG_ROOT > $DESTINATION_DIRECTORY/{{configuration}}/lfric.gungho.{{compiler}}.log.path
                      """
        [[[environment]]]
{# If the mpi is configured by the suite, then we will use the setcores optional configuration, so let's check that here #}
{% if configuration_label in scheduledTasksDict.keys() %} {# configuration_label in scheduledTasksDict #}
{{    scheduledTasksDict[configuration_label] | dictToAssign }}
{# If the directives are configured by the suite, then we will expand those in the environment #}
{%    if 'directives' in scheduledTasksDict[configuration_label].keys() %}
{%       set directiveKey = resname if resname in scheduledTasksDict[configuration_label]['directives'].keys() else 'default'%}
{%       set directiveDict = scheduledTasksDict[configuration_label]['directives'][directiveKey] %}
{{          directiveDict | dictToAssign() }}
{%    endif %}

{# If we have nrun dependent on resolution / timestep then we need to set that in the environment too#}
{%    if 'nrun' in scheduledTasksDict[configuration_label].keys() %}
{%       if scheduledTasksDict[configuration_label]['nrun'] is not number %}
{%          set nrunKey = resname if dt=='' else (resname, dt) %}
{%          set nrunKey = nrunKey if nrunKey in scheduledTasksDict[configuration_label]['nrun'].keys() else 'default' %}
            nrun = {{scheduledTasksDict[configuration_label]['nrun'][nrunKey] }}
{%       endif %}
{%    endif %}
{%  endif %}{# configuration_label in scheduledTasksDict #}
            DT            = {{dt}}
	    CRUN_LENGTH   = $(echo ${crun:-1})
            OMP_NUM_THREADS=$(echo ${threads:-1})
            MPI_PARTS     = $(echo ${mpi_parts:-})  # We leave this empty if we want the default value from the .conf file
            RESTART_NTS   = $(echo ${nrun:-1})
            RESTART_NO    = $(echo $[$CYLC_TASK_CYCLE_POINT -1])
            RESTART       = $(if [ $CYLC_TASK_CYCLE_POINT == $CYLC_SUITE_INITIAL_CYCLE_POINT ] && [ $CYLC_TASK_TRY_NUMBER -eq 1 ]; then echo ""; else echo "true"; fi)
            RESTART_START = $(echo $[$RESTART_NO*$RESTART_NTS + 1])
            RESTART_STOP  = $(echo $[$RESTART_NO*$RESTART_NTS + $RESTART_NTS])
            RESTART_READ  = $(if [[ $RESTART ]]; then echo ".true."; else echo ".false."; fi) 
            RESTART_WRITE = $(if [ $CRUN_LENGTH -gt $CYLC_TASK_CYCLE_POINT ]; then echo ".true."; else echo ".false."; fi) 

        [[[directives]]]
{# 
#If the directives are configured by the suite, then we will expand these in the directives.  This may also require a different batcher
# e.g if setting directives requires a parallel queue, rather than the default shared queue. 
#}
{%        set run_batcher = TARGET_RUN_BATCHER_DIRECTIVES %}
{% if configuration_label in scheduledTasksDict.keys() %}{# configuration_label in scheduledTasksDict #}
{%     if 'directives' in scheduledTasksDict[configuration_label].keys() %}
{%       set directiveKey = resname if resname in scheduledTasksDict[configuration_label]['directives'].keys() else 'default'%}
{%        set directiveDict = scheduledTasksDict[configuration_label]['directives'][directiveKey] %}
{%        set mpi_parts = directiveDict['mpi_parts'] %}
{%        set wallclock = directiveDict['wallclock'] %}
{%        set threads = directiveDict['threads'] %}
{%        set run_batcher = TARGET_PARAM_RUN_BATCHER_DIRECTIVES| directiveModifier(mpi_parts*threads, wallclock) %}
{%     endif  %}
{% endif  %}
{%-         for DIRECTIVE in run_batcher %}
            {{DIRECTIVE }}
{%-         endfor %}
{%-       endif %} {# configuration_label in scheduledTasksDict #}

{%-       if 'publish_' + configuration_label_res in allTasks %}
    [[publish_{{configuration_label_res}}]]
        inherit = PUBLISH, {{family}}, LOCAL
        pre-script = """
{{ensureDestination()}}
                     mkdir -p $DESTINATION_DIRECTORY
                     RELATIVE_DESTINATION_DIRECTORY=`echo $DESTINATION_DIRECTORY | sed "s|$HOME/||"`
                     scp {{TARGET_HOST}}:$RELATIVE_DESTINATION_DIRECTORY/{{configuration}}/lfric.gungho.{{compiler}}.log.path lfric.gungho.{{configuration}}.{{compiler}}.log.path
                     scp {{TARGET_HOST}}:`cat lfric.gungho.{{configuration}}.{{compiler}}.log.path`.out $DESTINATION_DIRECTORY/lfric.gungho.{{configuration}}.{{compiler}}.out
                     scp {{TARGET_HOST}}:`cat lfric.gungho.{{configuration}}.{{compiler}}.log.path`.err $DESTINATION_DIRECTORY/lfric.gungho.{{configuration}}.{{compiler}}.err
                     """
        script = rose task-run --app-key=publish --command-key=run
        [[[environment]]]
            CONTEXT       = {{build}}
            CONFIGURATION = {{configuration}}
            COMPILER      = {{compiler}}
            LOG_OUT       = $DESTINATION_DIRECTORY/lfric.gungho.{{configuration}}.{{compiler}}.out
            LOG_ERR       = $DESTINATION_DIRECTORY/lfric.gungho.{{configuration}}.{{compiler}}.err
{%-       endif %}

{%-       if 'plot_' + configuration_label_res in allTasks %}
{%-         set plot_label = configuration %}
    [[plot_{{configuration_label_res}}]]
        inherit = PUBLISH, {{family}}, TARGET
        pre-script = """
 {{ensureDestination()}}
                     mkdir -p $PLOT_DIR
                     # remove old plots before running new ones
                     rm -rf $PLOT_DIR/*.png
                     """
        script = rose task-run --app-key=plot
        [[[environment]]]
             NODAL_DATA_DIR = $DESTINATION_DIRECTORY/{{configuration}}/results
             PLOT_DIR = $DESTINATION_DIRECTORY/{{configuration}}/plots
             PLOT_CONFIG = {{plot_config[plot_label]}}
{%-       endif %}

{%-       if 'publish_' + configuration_label_res + '_plots' in allTasks %}
    [[publish_{{configuration_label_res}}_plots]]
        inherit = PUBLISH, {{family}}, LOCAL
        script = """
                 mkdir -p $DESTINATION/model_output/{{configuration_label_res}}/plots
                 RELATIVE_DESTINATION_DIRECTORY=`echo $DESTINATION_DIRECTORY | sed "s|$HOME/||"`
                 scp -r {{TARGET_HOST}}:$RELATIVE_DESTINATION_DIRECTORY/{{configuration}}/plots $DESTINATION/model_output/{{configuration_label_res}}
                 """
{%-       endif %}

{%-       if 'check_' + configuration_label_res in allTasks %}
    [[check_{{configuration_label_res}}]]
        inherit = {{family}}, TARGET
        script = rose task-run --app-key=check_gungho
        [[[environment]]]
            TARGET_OPT = {{TARGET_OPT}}
            CONFIG = {{configuration}}
        [[[directives]]]
{%-         for DIRECTIVE in TARGET_TECHNICAL_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-         endfor %}
{%-       endif %}

{# These terminate the for loops started way back up there somewhere, as indicated by the comments #}
{%-     endfor %}{# resolutions timestep values #}
{%-     endfor %}{# science resolutions #}
{%-     endfor %}{# science configurations #}

{%-     for configuration in miniapp_configurations %}
{%-       set configuration_label = configuration|lower + '_' + label %}
{%-       if 'run_' + label + '_' + configuration in allTasks %}
    [[run_{{label}}_{{configuration}}]]
        inherit = {{family}}, TARGET
        pre-script = """
                     {{'\n'|commandList(TARGET_BASE_SETUP, compiler_setup[compiler], TARGET_RUN_SETUP, TARGET_REVEAL_SETUP)}}
                     """
        script = rose task-run --app-key={{configuration}} --command-key={{TARGET_RUN_METHOD}}
        post-script = """
                      cp {{configuration}}-checksums.txt $DESTINATION_DIRECTORY/{{configuration}}.{{compiler}}.checksums
                      mkdir -p $DESTINATION_DIRECTORY/{{configuration}}/results
                      touch $CYLC_TASK_WORK_DIR/tmp.m
                      cp $CYLC_TASK_WORK_DIR/*.m $DESTINATION_DIRECTORY/{{configuration}}/results/
                      """
        [[[environment]]]
            OMP_NUM_THREADS=1
        [[[directives]]]
{%-         for DIRECTIVE in TARGET_RUN_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-         endfor %}
{%-       endif %}

{%-     if 'check_' + label + '_' + configuration in allTasks %}
    [[check_{{label}}_{{configuration}}]]
        inherit = {{family}}, TARGET
        script = rose task-run --app-key='check_'{{configuration}}
        [[[environment]]]
            TARGET_OPT = {{TARGET_OPT}}
            CONFIG = {{configuration}}
{%-       endif %}

{%-       if 'plot_' + configuration_label in allTasks %}
{%-         set plot_label = configuration %}
    [[plot_{{configuration_label}}]]
        inherit = PUBLISH, {{family}}, TARGET
        pre-script = """
 {{ensureDestination()}}
                     mkdir -p $PLOT_DIR
                     # remove old plots before running new ones
                     test -w $PLOT_DIR && rm -rf $PLOT_DIR/*.png || ( echo Unable to delete "$PLOT_DIR/*.png", not writable; false )
                     """
        script = rose task-run --app-key=plot
        [[[environment]]]
             NODAL_DATA_DIR = $DESTINATION_DIRECTORY/{{configuration}}/results
             PLOT_DIR = $DESTINATION_DIRECTORY/{{configuration}}/plots
             PLOT_CONFIG = {{plot_config[plot_label]}}
{%-       endif %}

{%-       if 'publish_' + configuration_label + '_plots' in allTasks %}
    [[publish_{{configuration_label}}_plots]]
        inherit = PUBLISH, {{family}}, LOCAL
        script = """
                 mkdir -p $DESTINATION/model_output/{{configuration_label}}/plots
                 RELATIVE_DESTINATION_DIRECTORY=`echo $DESTINATION_DIRECTORY | sed "s|$HOME/||"`
                 scp -r {{TARGET_HOST}}:$RELATIVE_DESTINATION_DIRECTORY/{{configuration}}/plots $DESTINATION/model_output/{{configuration_label}}
                 """
{%-       endif %}

{%-     endfor %}{# miniapp configurations #}

########################################################################################

{%-     if 'unit_test_with_' + label in allTasks %}
    [[unit_test_with_{{label}}]]
        inherit = {{family}}, TARGET
        pre-script = """
                     {{'\n'|commandList(TARGET_BASE_SETUP, compiler_setup[compiler], TARGET_BUILD_SETUP, TARGET_REVEAL_SETUP)}}
                     """
        script = make -C $SOURCE_DIRECTORY unit-test-gungho
        post-script = """
                      {{deleteDirectory('$WORKING_DIR')}}
                      """
        [[[environment]]]
            WORKING_DIR = {{TARGET_BUILD_ROOT}}/{{label}}
        [[[directives]]]
{%-       for DIRECTIVE in TARGET_BUILD_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-       endfor %}
{%-     endif %}

{%-     for mesh in mesh_types %}
{%-       if 'generate_mesh_' + mesh + '_' + label in allTasks %}
    [[generate_mesh_{{mesh}}_{{label}}]]
        inherit = {{family}}, TARGET
        pre-script = """
                     {{'\n'|commandList(TARGET_BASE_SETUP, compiler_setup[compiler], TARGET_BUILD_SETUP, TARGET_REVEAL_SETUP)}}
                     """
        script = "rose task-run --app-key=mesh --opt-conf-key={{mesh}}"
        [[[environment]]]
            OUTPUT_FILE = $DESTINATION_DIRECTORY/{{mesh}}.nc
        [[[directives]]]
{%-         for DIRECTIVE in TARGET_RUN_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-         endfor %}
{%-       endif %}

{%-       if 'check_mesh_' + mesh + '_' + label in allTasks %}
    [[check_mesh_{{mesh}}_{{label}}]]
        inherit = {{family}}, TARGET
        pre-script = """
                     {{'\n'|commandList(TARGET_BASE_SETUP, compiler_setup[compiler], TARGET_REVEAL_SETUP)}}
                     """
        script = rose task-run --app-key=check_{{mesh}}
        [[[environment]]]
            MESH_FILE = $DESTINATION_DIRECTORY/{{mesh}}.nc
        [[[directives]]]
{%-         for DIRECTIVE in TARGET_TECHNICAL_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-         endfor %}
{%-       endif %}
{%-   endfor %}
{%-   endfor %}
{%-   endfor %}

{##########################################################################}
{###########                 Mesh Generation                    ###########}
{##########################################################################}
{% if do_meshes %}
{%-   for compiler in compiler_setup.keys() %}
{%-   for build in 'fast-debug', 'full-debug' %}
{%-     set label = (compiler + '_' + build) %}
{%-     set family = label|upper %}
    [[GENERATE_MESHES_{{family}}]]
        inherit= None, {{family}}, TARGET
        pre-script = """
                     mkdir -p $DESTINATION_DIRECTORY/meshes
                     {{'\n'|commandList(TARGET_BASE_SETUP, compiler_setup[compiler], TARGET_BUILD_SETUP, TARGET_REVEAL_SETUP)}}
                     """
        [[[directives]]]
{%-         for DIRECTIVE in TARGET_RUN_BATCHER_DIRECTIVES %}
            {{DIRECTIVE}}
{%-         endfor %}
{%-  for mesh_name in mesh_names %}

    [[generate_mesh_{{mesh_name}}_{{label}}]]
        inherit = GENERATE_MESHES_{{family}}
        script = "rose task-run --app-key=mesh --opt-conf-key={{mesh_name}}"
        [[[environment]]]
            OUTPUT_FILE = $DESTINATION_DIRECTORY/meshes/mesh_{{mesh_name}}.nc

{%-   endfor %}
{%-   endfor %}
{%-   endfor %}
{%-  endif %}
